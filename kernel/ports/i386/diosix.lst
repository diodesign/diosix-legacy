
kernel:     file format elf32-i386


Disassembly of section .text:

c0400000 <MultiBootHeader>:
c0400000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
c0400006:	00 00                	add    %al,(%eax)
c0400008:	fb                   	sti    
c0400009:	4f                   	dec    %edi
c040000a:	52                   	push   %edx
c040000b:	e4 b9                	in     $0xb9,%al

c040000c <_loader>:
c040000c:	b9 00 00 41 00       	mov    $0x410000,%ecx
c0400011:	0f 22 d9             	mov    %ecx,%cr3
c0400014:	0f 20 e1             	mov    %cr4,%ecx
c0400017:	81 c9 10 00 00 00    	or     $0x10,%ecx
c040001d:	0f 22 e1             	mov    %ecx,%cr4
c0400020:	0f 20 c1             	mov    %cr0,%ecx
c0400023:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c0400029:	0f 22 c1             	mov    %ecx,%cr0
c040002c:	8d 0d 34 00 40 c0    	lea    0xc0400034,%ecx
c0400032:	ff e1                	jmp    *%ecx

c0400034 <StartInHigherHalf>:
c0400034:	0f 01 15 38 10 41 c0 	lgdtl  0xc0411038
c040003b:	66 b8 10 00          	mov    $0x10,%ax
c040003f:	8e d8                	mov    %eax,%ds
c0400041:	8e c0                	mov    %eax,%es
c0400043:	8e d0                	mov    %eax,%ss
c0400045:	8e e0                	mov    %eax,%fs
c0400047:	8e e8                	mov    %eax,%gs
c0400049:	ea 50 00 40 c0 18 00 	ljmp   $0x18,$0xc0400050

c0400050 <FixupStack>:
c0400050:	bc bc 38 41 c0       	mov    $0xc04138bc,%esp
c0400055:	50                   	push   %eax
c0400056:	53                   	push   %ebx
c0400057:	e8 60 c7 00 00       	call   c040c7bc <_main>
c040005c:	eb fe                	jmp    c040005c <FixupStack+0xc>
c040005e:	90                   	nop
c040005f:	90                   	nop

c0400060 <x86_start_ap>:
c0400060:	fa                   	cli    
c0400061:	66 b8 00 10          	mov    $0x1000,%ax
c0400065:	08 00                	or     %al,(%eax)
c0400067:	67 0f 01 10          	addr16 lgdtl (%bx,%si)
c040006b:	0f 20 c0             	mov    %cr0,%eax
c040006e:	66 0d 01 00          	or     $0x1,%ax
c0400072:	00 00                	add    %al,(%eax)
c0400074:	0f 22 c0             	mov    %eax,%cr0
c0400077:	66 ea 1f 00 08 00    	ljmpw  $0x8,$0x1f
c040007d:	18 00                	sbb    %al,(%eax)

c040007f <APEnterPMode>:
c040007f:	b9 00 30 08 00       	mov    $0x83000,%ecx
c0400084:	c7 01 83 00 00 00    	movl   $0x83,(%ecx)
c040008a:	0f 22 d9             	mov    %ecx,%cr3
c040008d:	0f 20 e1             	mov    %cr4,%ecx
c0400090:	81 c9 10 00 00 00    	or     $0x10,%ecx
c0400096:	0f 22 e1             	mov    %ecx,%cr4
c0400099:	0f 20 c1             	mov    %cr0,%ecx
c040009c:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c04000a2:	0f 22 c1             	mov    %ecx,%cr0
c04000a5:	8d 0d ad 00 40 c0    	lea    0xc04000ad,%ecx
c04000ab:	ff e1                	jmp    *%ecx

c04000ad <APMoveToHigherHalf>:
c04000ad:	b8 38 10 41 c0       	mov    $0xc0411038,%eax
c04000b2:	0f 01 10             	lgdtl  (%eax)
c04000b5:	66 b8 10 00          	mov    $0x10,%ax
c04000b9:	8e d8                	mov    %eax,%ds
c04000bb:	8e c0                	mov    %eax,%es
c04000bd:	8e d0                	mov    %eax,%ss
c04000bf:	8e e0                	mov    %eax,%fs
c04000c1:	8e e8                	mov    %eax,%gs
c04000c3:	ea ca 00 40 c0 18 00 	ljmp   $0x18,$0xc04000ca

c04000ca <APFixupStack>:
c04000ca:	8b 25 3e 10 41 c0    	mov    0xc041103e,%esp
c04000d0:	e8 6b be 00 00       	call   c040bf40 <_mp_catch_ap>
c04000d5:	eb fe                	jmp    c04000d5 <APFixupStack+0xb>

c04000d7 <isr0>:
c04000d7:	fa                   	cli    
c04000d8:	6a 00                	push   $0x0
c04000da:	6a 00                	push   $0x0
c04000dc:	e9 0a 03 00 00       	jmp    c04003eb <int_enter_knl>

c04000e1 <isr1>:
c04000e1:	fa                   	cli    
c04000e2:	6a 00                	push   $0x0
c04000e4:	6a 01                	push   $0x1
c04000e6:	e9 00 03 00 00       	jmp    c04003eb <int_enter_knl>

c04000eb <isr2>:
c04000eb:	fa                   	cli    
c04000ec:	6a 00                	push   $0x0
c04000ee:	6a 02                	push   $0x2
c04000f0:	e9 f6 02 00 00       	jmp    c04003eb <int_enter_knl>

c04000f5 <isr3>:
c04000f5:	fa                   	cli    
c04000f6:	6a 00                	push   $0x0
c04000f8:	6a 03                	push   $0x3
c04000fa:	e9 ec 02 00 00       	jmp    c04003eb <int_enter_knl>

c04000ff <isr4>:
c04000ff:	fa                   	cli    
c0400100:	6a 00                	push   $0x0
c0400102:	6a 04                	push   $0x4
c0400104:	e9 e2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400109 <isr5>:
c0400109:	fa                   	cli    
c040010a:	6a 00                	push   $0x0
c040010c:	6a 05                	push   $0x5
c040010e:	e9 d8 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400113 <isr6>:
c0400113:	fa                   	cli    
c0400114:	6a 00                	push   $0x0
c0400116:	6a 06                	push   $0x6
c0400118:	e9 ce 02 00 00       	jmp    c04003eb <int_enter_knl>

c040011d <isr7>:
c040011d:	fa                   	cli    
c040011e:	6a 00                	push   $0x0
c0400120:	6a 07                	push   $0x7
c0400122:	e9 c4 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400127 <isr8>:
c0400127:	fa                   	cli    
c0400128:	6a 08                	push   $0x8
c040012a:	e9 bc 02 00 00       	jmp    c04003eb <int_enter_knl>

c040012f <isr9>:
c040012f:	fa                   	cli    
c0400130:	6a 00                	push   $0x0
c0400132:	6a 09                	push   $0x9
c0400134:	e9 b2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400139 <isr10>:
c0400139:	fa                   	cli    
c040013a:	6a 0a                	push   $0xa
c040013c:	e9 aa 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400141 <isr11>:
c0400141:	fa                   	cli    
c0400142:	6a 0b                	push   $0xb
c0400144:	e9 a2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400149 <isr12>:
c0400149:	fa                   	cli    
c040014a:	6a 0c                	push   $0xc
c040014c:	e9 9a 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400151 <isr13>:
c0400151:	fa                   	cli    
c0400152:	6a 0d                	push   $0xd
c0400154:	e9 92 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400159 <isr14>:
c0400159:	fa                   	cli    
c040015a:	6a 0e                	push   $0xe
c040015c:	e9 8a 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400161 <isr15>:
c0400161:	fa                   	cli    
c0400162:	6a 00                	push   $0x0
c0400164:	6a 0f                	push   $0xf
c0400166:	e9 80 02 00 00       	jmp    c04003eb <int_enter_knl>

c040016b <isr16>:
c040016b:	fa                   	cli    
c040016c:	6a 00                	push   $0x0
c040016e:	6a 10                	push   $0x10
c0400170:	e9 76 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400175 <isr17>:
c0400175:	fa                   	cli    
c0400176:	6a 00                	push   $0x0
c0400178:	6a 11                	push   $0x11
c040017a:	e9 6c 02 00 00       	jmp    c04003eb <int_enter_knl>

c040017f <isr18>:
c040017f:	fa                   	cli    
c0400180:	6a 00                	push   $0x0
c0400182:	6a 12                	push   $0x12
c0400184:	e9 62 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400189 <isr19>:
c0400189:	fa                   	cli    
c040018a:	6a 00                	push   $0x0
c040018c:	6a 13                	push   $0x13
c040018e:	e9 58 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400193 <isr20>:
c0400193:	fa                   	cli    
c0400194:	6a 00                	push   $0x0
c0400196:	6a 14                	push   $0x14
c0400198:	e9 4e 02 00 00       	jmp    c04003eb <int_enter_knl>

c040019d <isr21>:
c040019d:	fa                   	cli    
c040019e:	6a 00                	push   $0x0
c04001a0:	6a 15                	push   $0x15
c04001a2:	e9 44 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001a7 <isr22>:
c04001a7:	fa                   	cli    
c04001a8:	6a 00                	push   $0x0
c04001aa:	6a 16                	push   $0x16
c04001ac:	e9 3a 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001b1 <isr23>:
c04001b1:	fa                   	cli    
c04001b2:	6a 00                	push   $0x0
c04001b4:	6a 17                	push   $0x17
c04001b6:	e9 30 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001bb <isr24>:
c04001bb:	fa                   	cli    
c04001bc:	6a 00                	push   $0x0
c04001be:	6a 18                	push   $0x18
c04001c0:	e9 26 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001c5 <isr25>:
c04001c5:	fa                   	cli    
c04001c6:	6a 00                	push   $0x0
c04001c8:	6a 19                	push   $0x19
c04001ca:	e9 1c 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001cf <isr26>:
c04001cf:	fa                   	cli    
c04001d0:	6a 00                	push   $0x0
c04001d2:	6a 1a                	push   $0x1a
c04001d4:	e9 12 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001d9 <isr27>:
c04001d9:	fa                   	cli    
c04001da:	6a 00                	push   $0x0
c04001dc:	6a 1b                	push   $0x1b
c04001de:	e9 08 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001e3 <isr28>:
c04001e3:	fa                   	cli    
c04001e4:	6a 00                	push   $0x0
c04001e6:	6a 1c                	push   $0x1c
c04001e8:	e9 fe 01 00 00       	jmp    c04003eb <int_enter_knl>

c04001ed <isr29>:
c04001ed:	fa                   	cli    
c04001ee:	6a 00                	push   $0x0
c04001f0:	6a 1d                	push   $0x1d
c04001f2:	e9 f4 01 00 00       	jmp    c04003eb <int_enter_knl>

c04001f7 <isr30>:
c04001f7:	fa                   	cli    
c04001f8:	6a 00                	push   $0x0
c04001fa:	6a 1e                	push   $0x1e
c04001fc:	e9 ea 01 00 00       	jmp    c04003eb <int_enter_knl>

c0400201 <isr31>:
c0400201:	fa                   	cli    
c0400202:	6a 00                	push   $0x0
c0400204:	6a 1f                	push   $0x1f
c0400206:	e9 e0 01 00 00       	jmp    c04003eb <int_enter_knl>

c040020b <irq0>:
c040020b:	fa                   	cli    
c040020c:	6a 00                	push   $0x0
c040020e:	6a 20                	push   $0x20
c0400210:	e9 fd 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400215 <irq1>:
c0400215:	fa                   	cli    
c0400216:	6a 00                	push   $0x0
c0400218:	6a 21                	push   $0x21
c040021a:	e9 f3 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040021f <irq2>:
c040021f:	fa                   	cli    
c0400220:	6a 00                	push   $0x0
c0400222:	6a 22                	push   $0x22
c0400224:	e9 e9 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400229 <irq3>:
c0400229:	fa                   	cli    
c040022a:	6a 00                	push   $0x0
c040022c:	6a 23                	push   $0x23
c040022e:	e9 df 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400233 <irq4>:
c0400233:	fa                   	cli    
c0400234:	6a 00                	push   $0x0
c0400236:	6a 24                	push   $0x24
c0400238:	e9 d5 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040023d <irq5>:
c040023d:	fa                   	cli    
c040023e:	6a 00                	push   $0x0
c0400240:	6a 25                	push   $0x25
c0400242:	e9 cb 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400247 <irq6>:
c0400247:	fa                   	cli    
c0400248:	6a 00                	push   $0x0
c040024a:	6a 26                	push   $0x26
c040024c:	e9 c1 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400251 <irq7>:
c0400251:	fa                   	cli    
c0400252:	6a 00                	push   $0x0
c0400254:	6a 27                	push   $0x27
c0400256:	e9 b7 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040025b <irq8>:
c040025b:	fa                   	cli    
c040025c:	6a 00                	push   $0x0
c040025e:	6a 28                	push   $0x28
c0400260:	e9 ad 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400265 <irq9>:
c0400265:	fa                   	cli    
c0400266:	6a 00                	push   $0x0
c0400268:	6a 29                	push   $0x29
c040026a:	e9 a3 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040026f <irq10>:
c040026f:	fa                   	cli    
c0400270:	6a 00                	push   $0x0
c0400272:	6a 2a                	push   $0x2a
c0400274:	e9 99 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400279 <irq11>:
c0400279:	fa                   	cli    
c040027a:	6a 00                	push   $0x0
c040027c:	6a 2b                	push   $0x2b
c040027e:	e9 8f 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400283 <irq12>:
c0400283:	fa                   	cli    
c0400284:	6a 00                	push   $0x0
c0400286:	6a 2c                	push   $0x2c
c0400288:	e9 85 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040028d <irq13>:
c040028d:	fa                   	cli    
c040028e:	6a 00                	push   $0x0
c0400290:	6a 2d                	push   $0x2d
c0400292:	e9 7b 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400297 <irq14>:
c0400297:	fa                   	cli    
c0400298:	6a 00                	push   $0x0
c040029a:	6a 2e                	push   $0x2e
c040029c:	e9 71 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002a1 <irq15>:
c04002a1:	fa                   	cli    
c04002a2:	6a 00                	push   $0x0
c04002a4:	6a 2f                	push   $0x2f
c04002a6:	e9 67 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002ab <irq16>:
c04002ab:	fa                   	cli    
c04002ac:	6a 00                	push   $0x0
c04002ae:	6a 30                	push   $0x30
c04002b0:	e9 5d 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002b5 <irq17>:
c04002b5:	fa                   	cli    
c04002b6:	6a 00                	push   $0x0
c04002b8:	6a 31                	push   $0x31
c04002ba:	e9 53 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002bf <irq18>:
c04002bf:	fa                   	cli    
c04002c0:	6a 00                	push   $0x0
c04002c2:	6a 32                	push   $0x32
c04002c4:	e9 49 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002c9 <irq19>:
c04002c9:	fa                   	cli    
c04002ca:	6a 00                	push   $0x0
c04002cc:	6a 33                	push   $0x33
c04002ce:	e9 3f 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002d3 <irq20>:
c04002d3:	fa                   	cli    
c04002d4:	6a 00                	push   $0x0
c04002d6:	6a 3f                	push   $0x3f
c04002d8:	e9 35 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002dd <irq21>:
c04002dd:	fa                   	cli    
c04002de:	6a 00                	push   $0x0
c04002e0:	6a 35                	push   $0x35
c04002e2:	e9 2b 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002e7 <irq22>:
c04002e7:	fa                   	cli    
c04002e8:	6a 00                	push   $0x0
c04002ea:	6a 36                	push   $0x36
c04002ec:	e9 21 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002f1 <irq23>:
c04002f1:	fa                   	cli    
c04002f2:	6a 00                	push   $0x0
c04002f4:	6a 40                	push   $0x40
c04002f6:	e9 17 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002fb <irq24>:
c04002fb:	fa                   	cli    
c04002fc:	6a 00                	push   $0x0
c04002fe:	6a 41                	push   $0x41
c0400300:	e9 0d 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400305 <irq25>:
c0400305:	fa                   	cli    
c0400306:	6a 00                	push   $0x0
c0400308:	6a 42                	push   $0x42
c040030a:	e9 03 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040030f <irq26>:
c040030f:	fa                   	cli    
c0400310:	6a 00                	push   $0x0
c0400312:	6a 43                	push   $0x43
c0400314:	e9 f9 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400319 <irq27>:
c0400319:	fa                   	cli    
c040031a:	6a 00                	push   $0x0
c040031c:	6a 44                	push   $0x44
c040031e:	e9 ef 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400323 <irq28>:
c0400323:	fa                   	cli    
c0400324:	6a 00                	push   $0x0
c0400326:	6a 45                	push   $0x45
c0400328:	e9 e5 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040032d <irq29>:
c040032d:	fa                   	cli    
c040032e:	6a 00                	push   $0x0
c0400330:	6a 46                	push   $0x46
c0400332:	e9 db 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400337 <irq30>:
c0400337:	fa                   	cli    
c0400338:	6a 00                	push   $0x0
c040033a:	6a 47                	push   $0x47
c040033c:	e9 d1 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400341 <irq31>:
c0400341:	fa                   	cli    
c0400342:	6a 00                	push   $0x0
c0400344:	6a 48                	push   $0x48
c0400346:	e9 c7 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040034b <irq32>:
c040034b:	fa                   	cli    
c040034c:	6a 00                	push   $0x0
c040034e:	6a 49                	push   $0x49
c0400350:	e9 bd 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400355 <irq33>:
c0400355:	fa                   	cli    
c0400356:	6a 00                	push   $0x0
c0400358:	6a 4a                	push   $0x4a
c040035a:	e9 b3 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040035f <irq34>:
c040035f:	fa                   	cli    
c0400360:	6a 00                	push   $0x0
c0400362:	6a 4b                	push   $0x4b
c0400364:	e9 a9 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400369 <irq35>:
c0400369:	fa                   	cli    
c040036a:	6a 00                	push   $0x0
c040036c:	6a 4c                	push   $0x4c
c040036e:	e9 9f 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400373 <irq36>:
c0400373:	fa                   	cli    
c0400374:	6a 00                	push   $0x0
c0400376:	6a 4d                	push   $0x4d
c0400378:	e9 95 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040037d <irq37>:
c040037d:	fa                   	cli    
c040037e:	6a 00                	push   $0x0
c0400380:	6a 4e                	push   $0x4e
c0400382:	e9 8b 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400387 <irq38>:
c0400387:	fa                   	cli    
c0400388:	6a 00                	push   $0x0
c040038a:	6a 4f                	push   $0x4f
c040038c:	e9 81 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400391 <irq39>:
c0400391:	fa                   	cli    
c0400392:	6a 00                	push   $0x0
c0400394:	6a 50                	push   $0x50
c0400396:	e9 77 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040039b <irq40>:
c040039b:	fa                   	cli    
c040039c:	6a 00                	push   $0x0
c040039e:	6a 51                	push   $0x51
c04003a0:	e9 6d 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003a5 <irq41>:
c04003a5:	fa                   	cli    
c04003a6:	6a 00                	push   $0x0
c04003a8:	6a 52                	push   $0x52
c04003aa:	e9 63 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003af <irq42>:
c04003af:	fa                   	cli    
c04003b0:	6a 00                	push   $0x0
c04003b2:	6a 53                	push   $0x53
c04003b4:	e9 59 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003b9 <irq43>:
c04003b9:	fa                   	cli    
c04003ba:	6a 00                	push   $0x0
c04003bc:	6a 54                	push   $0x54
c04003be:	e9 4f 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003c3 <irq44>:
c04003c3:	fa                   	cli    
c04003c4:	6a 00                	push   $0x0
c04003c6:	6a 55                	push   $0x55
c04003c8:	e9 45 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003cd <irq45>:
c04003cd:	fa                   	cli    
c04003ce:	6a 00                	push   $0x0
c04003d0:	6a 56                	push   $0x56
c04003d2:	e9 3b 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003d7 <irq46>:
c04003d7:	fa                   	cli    
c04003d8:	6a 00                	push   $0x0
c04003da:	6a 57                	push   $0x57
c04003dc:	e9 31 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003e1 <isr144>:
c04003e1:	fa                   	cli    
c04003e2:	6a 00                	push   $0x0
c04003e4:	6a 90                	push   $0xffffff90
c04003e6:	e9 00 00 00 00       	jmp    c04003eb <int_enter_knl>

c04003eb <int_enter_knl>:
c04003eb:	60                   	pusha  
c04003ec:	8c d8                	mov    %ds,%eax
c04003ee:	50                   	push   %eax
c04003ef:	66 b8 10 00          	mov    $0x10,%ax
c04003f3:	8e d8                	mov    %eax,%ds
c04003f5:	8e c0                	mov    %eax,%es
c04003f7:	8e e0                	mov    %eax,%fs
c04003f9:	8e e8                	mov    %eax,%gs
c04003fb:	e8 e2 13 00 00       	call   c04017e2 <int_handler>
c0400400:	58                   	pop    %eax
c0400401:	8e d8                	mov    %eax,%ds
c0400403:	8e c0                	mov    %eax,%es
c0400405:	8e e0                	mov    %eax,%fs
c0400407:	8e e8                	mov    %eax,%gs
c0400409:	61                   	popa   
c040040a:	81 c4 08 00 00 00    	add    $0x8,%esp
c0400410:	fb                   	sti    
c0400411:	cf                   	iret   

c0400412 <irq_enter_knl>:
c0400412:	60                   	pusha  
c0400413:	8c d8                	mov    %ds,%eax
c0400415:	50                   	push   %eax
c0400416:	66 b8 10 00          	mov    $0x10,%ax
c040041a:	8e d8                	mov    %eax,%ds
c040041c:	8e c0                	mov    %eax,%es
c040041e:	8e e0                	mov    %eax,%fs
c0400420:	8e e8                	mov    %eax,%gs
c0400422:	e8 75 11 00 00       	call   c040159c <irq_handler>
c0400427:	58                   	pop    %eax
c0400428:	8e d8                	mov    %eax,%ds
c040042a:	8e c0                	mov    %eax,%es
c040042c:	8e e0                	mov    %eax,%fs
c040042e:	8e e8                	mov    %eax,%gs
c0400430:	61                   	popa   
c0400431:	81 c4 08 00 00 00    	add    $0x8,%esp
c0400437:	fb                   	sti    
c0400438:	cf                   	iret   

c0400439 <x86_load_idtr>:
c0400439:	8b 44 24 04          	mov    0x4(%esp),%eax
c040043d:	0f 01 18             	lidtl  (%eax)
c0400440:	c3                   	ret    

c0400441 <x86_load_tss>:
c0400441:	66 b8 33 00          	mov    $0x33,%ax
c0400445:	0f 00 d8             	ltr    %ax
c0400448:	c3                   	ret    

c0400449 <x86_load_gdtr>:
c0400449:	8b 44 24 04          	mov    0x4(%esp),%eax
c040044d:	0f 01 10             	lgdtl  (%eax)
c0400450:	c3                   	ret    

c0400451 <x86_test_and_set>:
c0400451:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400455:	8b 54 24 08          	mov    0x8(%esp),%edx
c0400459:	f0 87 02             	lock xchg %eax,(%edx)
c040045c:	c3                   	ret    
c040045d:	00 00                	add    %al,(%eax)
	...

c0400460 <lock_spin>:

/* lock_spin
   Block until we've acquired the lock */
#ifndef UNIPROC
void lock_spin(volatile unsigned int *spinlock)
{		
c0400460:	83 ec 0c             	sub    $0xc,%esp
	/* x86_test_and_set(1, ptr) will return 0 if we have the lock, or 1
		if someone else has it */
	while(x86_test_and_set(1, spinlock))
c0400463:	eb 02                	jmp    c0400467 <lock_spin+0x7>
		/* hint to newer processors that this is a spin-wait loop or
		   NOP for older processors */
		__asm__ __volatile__("pause");
c0400465:	f3 90                	pause  
#ifndef UNIPROC
void lock_spin(volatile unsigned int *spinlock)
{		
	/* x86_test_and_set(1, ptr) will return 0 if we have the lock, or 1
		if someone else has it */
	while(x86_test_and_set(1, spinlock))
c0400467:	83 ec 08             	sub    $0x8,%esp
c040046a:	ff 74 24 18          	pushl  0x18(%esp)
c040046e:	6a 01                	push   $0x1
c0400470:	e8 dc ff ff ff       	call   c0400451 <x86_test_and_set>
c0400475:	83 c4 10             	add    $0x10,%esp
c0400478:	85 c0                	test   %eax,%eax
c040047a:	75 e9                	jne    c0400465 <lock_spin+0x5>
		/* hint to newer processors that this is a spin-wait loop or
		   NOP for older processors */
		__asm__ __volatile__("pause");

	/* lock acquired, continue.. */
}
c040047c:	83 c4 0c             	add    $0xc,%esp
c040047f:	c3                   	ret    

c0400480 <unlock_spin>:
   Release a lock */
#ifndef UNIPROC
void unlock_spin(volatile unsigned int *spinlock)
{
	/* just slap a zero in it to unlock */
	*spinlock = 0;
c0400480:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400484:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c040048a:	c3                   	ret    

c040048b <lock_gate>:
				  to mark a gate as defunct, causing other threads to fail if
              they try to access it
	<= success or a failure code
*/
kresult lock_gate(rw_gate *gate, unsigned int flags)
{
c040048b:	83 ec 2c             	sub    $0x2c,%esp
	kresult err = success;
c040048e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0400495:	00 

#ifdef LOCK_TIME_CHECK
	unsigned long long ticks = x86_read_cyclecount();
c0400496:	e8 f6 02 00 00       	call   c0400791 <x86_read_cyclecount>
c040049b:	89 44 24 10          	mov    %eax,0x10(%esp)
c040049f:	89 54 24 14          	mov    %edx,0x14(%esp)
#ifdef LOCK_DEBUG
	dprintf(DEBUG_COL_LOCK "[lock:%i] -> lock_gate(%p, %x) on cpu %i\n" DEBUG_COL_OFF, CPU_ID, gate, flags, CPU_ID);
#endif
		
	/* sanity checks */
	if(!gate) return e_failure;
c04004a3:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04004a8:	75 0a                	jne    c04004b4 <lock_gate+0x29>
c04004aa:	b8 01 00 00 00       	mov    $0x1,%eax
c04004af:	e9 f0 01 00 00       	jmp    c04006a4 <lock_gate+0x219>
	if(!cpu_table) return success; /* only one processor running */
c04004b4:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04004b9:	85 c0                	test   %eax,%eax
c04004bb:	75 0b                	jne    c04004c8 <lock_gate+0x3d>
c04004bd:	b8 00 00 00 00       	mov    $0x0,%eax
c04004c2:	e9 dd 01 00 00       	jmp    c04006a4 <lock_gate+0x219>
			debug_stacktrace();
			err = e_failure;
			goto exit_lock_gate;
		}
#endif
	}
c04004c7:	90                   	nop
	if(!gate) return e_failure;
	if(!cpu_table) return success; /* only one processor running */
	
	while(1)
	{
		lock_spin(&(gate->spinlock));
c04004c8:	8b 44 24 30          	mov    0x30(%esp),%eax
c04004cc:	83 ec 0c             	sub    $0xc,%esp
c04004cf:	50                   	push   %eax
c04004d0:	e8 8b ff ff ff       	call   c0400460 <lock_spin>
c04004d5:	83 c4 10             	add    $0x10,%esp
		
		/* we're in - is the gate claimed? */
		if(gate->owner)
c04004d8:	8b 44 24 30          	mov    0x30(%esp),%eax
c04004dc:	8b 40 04             	mov    0x4(%eax),%eax
c04004df:	85 c0                	test   %eax,%eax
c04004e1:	0f 84 c1 00 00 00    	je     c04005a8 <lock_gate+0x11d>
		{
			/* it's in use - but is it another thread? */
			if(gate->owner != (unsigned int)cpu_table[CPU_ID].current)
c04004e7:	8b 44 24 30          	mov    0x30(%esp),%eax
c04004eb:	8b 50 04             	mov    0x4(%eax),%edx
c04004ee:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c04004f4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04004f9:	3c 01                	cmp    $0x1,%al
c04004fb:	76 0f                	jbe    c040050c <lock_gate+0x81>
c04004fd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400502:	8b 00                	mov    (%eax),%eax
c0400504:	c1 e8 18             	shr    $0x18,%eax
c0400507:	c1 e0 06             	shl    $0x6,%eax
c040050a:	eb 0b                	jmp    c0400517 <lock_gate+0x8c>
c040050c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400511:	0f b6 c0             	movzbl %al,%eax
c0400514:	c1 e0 06             	shl    $0x6,%eax
c0400517:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040051a:	8b 40 04             	mov    0x4(%eax),%eax
c040051d:	39 c2                	cmp    %eax,%edx
c040051f:	74 71                	je     c0400592 <lock_gate+0x107>
			{
				/* another thread has it :( perform checks */
				
				/* this lock is defunct? */
				if(gate->flags & LOCK_SELFDESTRUCT)
c0400521:	8b 44 24 30          	mov    0x30(%esp),%eax
c0400525:	8b 40 08             	mov    0x8(%eax),%eax
c0400528:	83 e0 02             	and    $0x2,%eax
c040052b:	85 c0                	test   %eax,%eax
c040052d:	74 0d                	je     c040053c <lock_gate+0xb1>
				{
					err = e_failure;
c040052f:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0400536:	00 
					goto exit_lock_gate;
c0400537:	e9 54 01 00 00       	jmp    c0400690 <lock_gate+0x205>
				}
				
				/* if we're not trying to write and the owner isn't
					writing, then it's safe to progress */
				if(!(flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITE))
c040053c:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400540:	83 e0 01             	and    $0x1,%eax
c0400543:	85 c0                	test   %eax,%eax
c0400545:	75 12                	jne    c0400559 <lock_gate+0xce>
c0400547:	8b 44 24 30          	mov    0x30(%esp),%eax
c040054b:	8b 40 08             	mov    0x8(%eax),%eax
c040054e:	83 e0 01             	and    $0x1,%eax
c0400551:	85 c0                	test   %eax,%eax
c0400553:	0f 84 36 01 00 00    	je     c040068f <lock_gate+0x204>
			gate->flags = flags;
			gate->refcount = 1; /* first in */
			goto exit_lock_gate;
		}
		
		unlock_spin(&(gate->spinlock));
c0400559:	8b 44 24 30          	mov    0x30(%esp),%eax
c040055d:	83 ec 0c             	sub    $0xc,%esp
c0400560:	50                   	push   %eax
c0400561:	e8 1a ff ff ff       	call   c0400480 <unlock_spin>
c0400566:	83 c4 10             	add    $0x10,%esp
		
		/* small window of opportunity for the other thread to
		   release the gate :-/ */
		/* hint to newer processors that this is a spin-wait loop or
		 NOP for older processors */
		__asm__ __volatile__("pause");
c0400569:	f3 90                	pause  
		
#ifdef LOCK_TIME_CHECK
		if((x86_read_cyclecount() - ticks) > LOCK_TIMEOUT)
c040056b:	e8 21 02 00 00       	call   c0400791 <x86_read_cyclecount>
c0400570:	2b 44 24 10          	sub    0x10(%esp),%eax
c0400574:	1b 54 24 14          	sbb    0x14(%esp),%edx
c0400578:	83 fa 00             	cmp    $0x0,%edx
c040057b:	77 7e                	ja     c04005fb <lock_gate+0x170>
c040057d:	83 fa 00             	cmp    $0x0,%edx
c0400580:	0f 82 41 ff ff ff    	jb     c04004c7 <lock_gate+0x3c>
c0400586:	3d 00 ca 9a 3b       	cmp    $0x3b9aca00,%eax
c040058b:	77 6e                	ja     c04005fb <lock_gate+0x170>
			debug_stacktrace();
			err = e_failure;
			goto exit_lock_gate;
		}
#endif
	}
c040058d:	e9 36 ff ff ff       	jmp    c04004c8 <lock_gate+0x3d>
				
			}
			else
			{
				/* if the gate's owned by this thread, then carry on */
				gate->refcount++; /* keep track of the number of times we're entering */
c0400592:	8b 44 24 30          	mov    0x30(%esp),%eax
c0400596:	8b 40 0c             	mov    0xc(%eax),%eax
c0400599:	8d 50 01             	lea    0x1(%eax),%edx
c040059c:	8b 44 24 30          	mov    0x30(%esp),%eax
c04005a0:	89 50 0c             	mov    %edx,0xc(%eax)
				goto exit_lock_gate;
c04005a3:	e9 e8 00 00 00       	jmp    c0400690 <lock_gate+0x205>
			}
		}
		else
		{
			/* no one owns this gate, so make our mark */
			gate->owner = (unsigned int)cpu_table[CPU_ID].current;
c04005a8:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04005ae:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04005b3:	3c 01                	cmp    $0x1,%al
c04005b5:	76 0f                	jbe    c04005c6 <lock_gate+0x13b>
c04005b7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04005bc:	8b 00                	mov    (%eax),%eax
c04005be:	c1 e8 18             	shr    $0x18,%eax
c04005c1:	c1 e0 06             	shl    $0x6,%eax
c04005c4:	eb 0b                	jmp    c04005d1 <lock_gate+0x146>
c04005c6:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04005cb:	0f b6 c0             	movzbl %al,%eax
c04005ce:	c1 e0 06             	shl    $0x6,%eax
c04005d1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04005d4:	8b 40 04             	mov    0x4(%eax),%eax
c04005d7:	89 c2                	mov    %eax,%edx
c04005d9:	8b 44 24 30          	mov    0x30(%esp),%eax
c04005dd:	89 50 04             	mov    %edx,0x4(%eax)
			gate->flags = flags;
c04005e0:	8b 44 24 30          	mov    0x30(%esp),%eax
c04005e4:	8b 54 24 34          	mov    0x34(%esp),%edx
c04005e8:	89 50 08             	mov    %edx,0x8(%eax)
			gate->refcount = 1; /* first in */
c04005eb:	8b 44 24 30          	mov    0x30(%esp),%eax
c04005ef:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
			goto exit_lock_gate;
c04005f6:	e9 95 00 00 00       	jmp    c0400690 <lock_gate+0x205>
		__asm__ __volatile__("pause");
		
#ifdef LOCK_TIME_CHECK
		if((x86_read_cyclecount() - ticks) > LOCK_TIMEOUT)
		{
			dprintf(DEBUG_COL_LOCK "[lock:%i] OMGWTF waited too long for gate %p to become available (flags %x)\n"
c04005fb:	8b 44 24 30          	mov    0x30(%esp),%eax
c04005ff:	8b 50 04             	mov    0x4(%eax),%edx
					  "         lock is owned by %p", CPU_ID, gate, flags, gate->owner);
c0400602:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		__asm__ __volatile__("pause");
		
#ifdef LOCK_TIME_CHECK
		if((x86_read_cyclecount() - ticks) > LOCK_TIMEOUT)
		{
			dprintf(DEBUG_COL_LOCK "[lock:%i] OMGWTF waited too long for gate %p to become available (flags %x)\n"
c0400607:	3c 01                	cmp    $0x1,%al
c0400609:	76 0c                	jbe    c0400617 <lock_gate+0x18c>
					  "         lock is owned by %p", CPU_ID, gate, flags, gate->owner);
c040060b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400610:	8b 00                	mov    (%eax),%eax
		__asm__ __volatile__("pause");
		
#ifdef LOCK_TIME_CHECK
		if((x86_read_cyclecount() - ticks) > LOCK_TIMEOUT)
		{
			dprintf(DEBUG_COL_LOCK "[lock:%i] OMGWTF waited too long for gate %p to become available (flags %x)\n"
c0400612:	c1 e8 18             	shr    $0x18,%eax
c0400615:	eb 08                	jmp    c040061f <lock_gate+0x194>
c0400617:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040061c:	0f b6 c0             	movzbl %al,%eax
c040061f:	83 ec 0c             	sub    $0xc,%esp
c0400622:	52                   	push   %edx
c0400623:	ff 74 24 44          	pushl  0x44(%esp)
c0400627:	ff 74 24 44          	pushl  0x44(%esp)
c040062b:	50                   	push   %eax
c040062c:	68 30 d8 40 c0       	push   $0xc040d830
c0400631:	e8 20 ce 00 00       	call   c040d456 <debug_printf>
c0400636:	83 c4 20             	add    $0x20,%esp
					  "         lock is owned by %p", CPU_ID, gate, flags, gate->owner);
			if(gate->owner)
c0400639:	8b 44 24 30          	mov    0x30(%esp),%eax
c040063d:	8b 40 04             	mov    0x4(%eax),%eax
c0400640:	85 c0                	test   %eax,%eax
c0400642:	74 2c                	je     c0400670 <lock_gate+0x1e5>
			{
				thread *t = (thread *)(gate->owner);
c0400644:	8b 44 24 30          	mov    0x30(%esp),%eax
c0400648:	8b 40 04             	mov    0x4(%eax),%eax
c040064b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
				dprintf(" (thread %i process %i)", t->tid, t->proc->pid);
c040064f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0400653:	8b 00                	mov    (%eax),%eax
c0400655:	8b 10                	mov    (%eax),%edx
c0400657:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040065b:	8b 40 04             	mov    0x4(%eax),%eax
c040065e:	83 ec 04             	sub    $0x4,%esp
c0400661:	52                   	push   %edx
c0400662:	50                   	push   %eax
c0400663:	68 99 d8 40 c0       	push   $0xc040d899
c0400668:	e8 e9 cd 00 00       	call   c040d456 <debug_printf>
c040066d:	83 c4 10             	add    $0x10,%esp
			}
			dprintf(DEBUG_COL_OFF "\n");
c0400670:	83 ec 0c             	sub    $0xc,%esp
c0400673:	68 b1 d8 40 c0       	push   $0xc040d8b1
c0400678:	e8 d9 cd 00 00       	call   c040d456 <debug_printf>
c040067d:	83 c4 10             	add    $0x10,%esp
			debug_stacktrace();
c0400680:	e8 ee c6 00 00       	call   c040cd73 <debug_stacktrace>
			err = e_failure;
c0400685:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c040068c:	00 
			goto exit_lock_gate;
c040068d:	eb 01                	jmp    c0400690 <lock_gate+0x205>
				}
				
				/* if we're not trying to write and the owner isn't
					writing, then it's safe to progress */
				if(!(flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITE))
					goto exit_lock_gate;
c040068f:	90                   	nop
#endif
	}

exit_lock_gate:
	/* release the gate so others can inspect it */
	unlock_spin(&(gate->spinlock));
c0400690:	8b 44 24 30          	mov    0x30(%esp),%eax
c0400694:	83 ec 0c             	sub    $0xc,%esp
c0400697:	50                   	push   %eax
c0400698:	e8 e3 fd ff ff       	call   c0400480 <unlock_spin>
c040069d:	83 c4 10             	add    $0x10,%esp
	
#ifdef LOCK_DEBUG
	dprintf(DEBUG_COL_LOCK "[lock:%i] locked %p with %x on cpu %i\n" DEBUG_COL_OFF, CPU_ID, gate, flags, 0);
#endif
	
	return err;
c04006a0:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c04006a4:	83 c4 2c             	add    $0x2c,%esp
c04006a7:	c3                   	ret    

c04006a8 <unlock_gate>:
              to mark a gate as defunct, causing other threads to fail if
				  they try to access it
   <= success or a failure code
 */
kresult unlock_gate(rw_gate *gate, unsigned int flags)
{	
c04006a8:	83 ec 0c             	sub    $0xc,%esp
#ifdef LOCK_DEBUG
	dprintf(DEBUG_COL_LOCK "[lock:%i] unlock_gate(%p, %x) on cpu %i\n" DEBUG_COL_OFF, CPU_ID, gate, flags, 0);
#endif
	
	/* sanity checks */
	if(!gate) return e_failure;
c04006ab:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c04006b0:	75 0a                	jne    c04006bc <unlock_gate+0x14>
c04006b2:	b8 01 00 00 00       	mov    $0x1,%eax
c04006b7:	e9 a9 00 00 00       	jmp    c0400765 <unlock_gate+0xbd>
	if(!cpu_table) return success; /* only one processor running */	
c04006bc:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04006c1:	85 c0                	test   %eax,%eax
c04006c3:	75 0a                	jne    c04006cf <unlock_gate+0x27>
c04006c5:	b8 00 00 00 00       	mov    $0x0,%eax
c04006ca:	e9 96 00 00 00       	jmp    c0400765 <unlock_gate+0xbd>
	
	lock_spin(&(gate->spinlock));
c04006cf:	8b 44 24 10          	mov    0x10(%esp),%eax
c04006d3:	83 ec 0c             	sub    $0xc,%esp
c04006d6:	50                   	push   %eax
c04006d7:	e8 84 fd ff ff       	call   c0400460 <lock_spin>
c04006dc:	83 c4 10             	add    $0x10,%esp
	
	/* if this is our gate then unset details */
	if(gate->owner == (unsigned int)cpu_table[CPU_ID].current)
c04006df:	8b 44 24 10          	mov    0x10(%esp),%eax
c04006e3:	8b 50 04             	mov    0x4(%eax),%edx
c04006e6:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c04006ec:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04006f1:	3c 01                	cmp    $0x1,%al
c04006f3:	76 0f                	jbe    c0400704 <unlock_gate+0x5c>
c04006f5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04006fa:	8b 00                	mov    (%eax),%eax
c04006fc:	c1 e8 18             	shr    $0x18,%eax
c04006ff:	c1 e0 06             	shl    $0x6,%eax
c0400702:	eb 0b                	jmp    c040070f <unlock_gate+0x67>
c0400704:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400709:	0f b6 c0             	movzbl %al,%eax
c040070c:	c1 e0 06             	shl    $0x6,%eax
c040070f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0400712:	8b 40 04             	mov    0x4(%eax),%eax
c0400715:	39 c2                	cmp    %eax,%edx
c0400717:	75 37                	jne    c0400750 <unlock_gate+0xa8>
	{
		/* decrement thread entry count and release the gate if the
		   owner has completely left, keeping the self-destruct lock
		   in place if required */
		gate->refcount--;
c0400719:	8b 44 24 10          	mov    0x10(%esp),%eax
c040071d:	8b 40 0c             	mov    0xc(%eax),%eax
c0400720:	8d 50 ff             	lea    -0x1(%eax),%edx
c0400723:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400727:	89 50 0c             	mov    %edx,0xc(%eax)
		if(gate->refcount == 0)
c040072a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040072e:	8b 40 0c             	mov    0xc(%eax),%eax
c0400731:	85 c0                	test   %eax,%eax
c0400733:	75 1b                	jne    c0400750 <unlock_gate+0xa8>
		{
			gate->owner = 0;
c0400735:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400739:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			gate->flags = flags & LOCK_SELFDESTRUCT;
c0400740:	8b 44 24 14          	mov    0x14(%esp),%eax
c0400744:	89 c2                	mov    %eax,%edx
c0400746:	83 e2 02             	and    $0x2,%edx
c0400749:	8b 44 24 10          	mov    0x10(%esp),%eax
c040074d:	89 50 08             	mov    %edx,0x8(%eax)
		}
	}

	/* release the gate so others can inspect it */
	unlock_spin(&(gate->spinlock));
c0400750:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400754:	83 ec 0c             	sub    $0xc,%esp
c0400757:	50                   	push   %eax
c0400758:	e8 23 fd ff ff       	call   c0400480 <unlock_spin>
c040075d:	83 c4 10             	add    $0x10,%esp

#ifdef LOCK_DEBUG
	dprintf(DEBUG_COL_LOCK "[lock:%i] <- unlocked %p with %x on cpu %i\n" DEBUG_COL_OFF, CPU_ID, gate, flags, 0);
#endif
	
	return success;
c0400760:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0400765:	83 c4 0c             	add    $0xc,%esp
c0400768:	c3                   	ret    

c0400769 <x86_inportb>:
   Read from an IO port
   => port = port number to read
   <= data recieved
*/
unsigned x86_inportb(unsigned short port)
{
c0400769:	83 ec 14             	sub    $0x14,%esp
c040076c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0400770:	66 89 04 24          	mov    %ax,(%esp)
   unsigned char ret_val;

   __asm__ __volatile__("inb %1,%0"
c0400774:	8b 04 24             	mov    (%esp),%eax
c0400777:	89 c2                	mov    %eax,%edx
c0400779:	ec                   	in     (%dx),%al
c040077a:	88 44 24 13          	mov    %al,0x13(%esp)
                        : "=a"(ret_val)
                        : "d"(port));
   return ret_val;
c040077e:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
}
c0400783:	83 c4 14             	add    $0x14,%esp
c0400786:	c3                   	ret    

c0400787 <x86_outportb>:
   => port = port number to access
      val = value to write
*/
void x86_outportb(unsigned port, unsigned val)
{
   __asm__ __volatile__("outb %b0,%w1"
c0400787:	8b 44 24 08          	mov    0x8(%esp),%eax
c040078b:	8b 54 24 04          	mov    0x4(%esp),%edx
c040078f:	ee                   	out    %al,(%dx)
                        :
                        : "a"(val), "d"(port));
}
c0400790:	c3                   	ret    

c0400791 <x86_read_cyclecount>:
// ------------------- performance monitoring support ----------------------
/* x86_read_cyclecount
   <= returns the CPU's current cycle counter value
*/
unsigned long long x86_read_cyclecount(void)
{
c0400791:	57                   	push   %edi
c0400792:	56                   	push   %esi
c0400793:	53                   	push   %ebx
c0400794:	83 ec 10             	sub    $0x10,%esp
	unsigned int high, low;
	
	__asm__ __volatile__("rdtsc"
c0400797:	0f 31                	rdtsc  
c0400799:	89 44 24 0c          	mov    %eax,0xc(%esp)
c040079d:	89 54 24 08          	mov    %edx,0x8(%esp)
								: "=a"(low), "=d"(high));
	
	return ((unsigned long long)low) | (((unsigned long long)high) << 32);
c04007a1:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c04007a5:	bb 00 00 00 00       	mov    $0x0,%ebx
c04007aa:	8b 44 24 08          	mov    0x8(%esp),%eax
c04007ae:	ba 00 00 00 00       	mov    $0x0,%edx
c04007b3:	89 c2                	mov    %eax,%edx
c04007b5:	b8 00 00 00 00       	mov    $0x0,%eax
c04007ba:	89 ce                	mov    %ecx,%esi
c04007bc:	09 c6                	or     %eax,%esi
c04007be:	89 df                	mov    %ebx,%edi
c04007c0:	09 d7                	or     %edx,%edi
c04007c2:	89 f0                	mov    %esi,%eax
c04007c4:	89 fa                	mov    %edi,%edx
}
c04007c6:	83 c4 10             	add    $0x10,%esp
c04007c9:	5b                   	pop    %ebx
c04007ca:	5e                   	pop    %esi
c04007cb:	5f                   	pop    %edi
c04007cc:	c3                   	ret    

c04007cd <x86_cmos_write>:
	Update a byte in the BIOS NVRAM
   => addr = byte number to change
      vlue = new value to write into the CMOS byte
*/
void x86_cmos_write(unsigned char addr, unsigned char value)
{
c04007cd:	83 ec 08             	sub    $0x8,%esp
c04007d0:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04007d4:	8b 44 24 10          	mov    0x10(%esp),%eax
c04007d8:	88 54 24 04          	mov    %dl,0x4(%esp)
c04007dc:	88 04 24             	mov    %al,(%esp)
	x86_outportb(X86_CMOS_ADDR_PORT, addr);
c04007df:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c04007e4:	50                   	push   %eax
c04007e5:	6a 70                	push   $0x70
c04007e7:	e8 9b ff ff ff       	call   c0400787 <x86_outportb>
c04007ec:	83 c4 08             	add    $0x8,%esp
	x86_outportb(X86_CMOS_DATA_PORT, value);	
c04007ef:	0f b6 04 24          	movzbl (%esp),%eax
c04007f3:	50                   	push   %eax
c04007f4:	6a 71                	push   $0x71
c04007f6:	e8 8c ff ff ff       	call   c0400787 <x86_outportb>
c04007fb:	83 c4 08             	add    $0x8,%esp
}
c04007fe:	83 c4 08             	add    $0x8,%esp
c0400801:	c3                   	ret    

c0400802 <x86_timer_init>:

// ------------------------ multitasking support ---------------------------
/* x86_timer_init
   Program the onboard timer to fire freq-times-a-second, or 0 to disable */
void x86_timer_init(unsigned char freq)
{
c0400802:	83 ec 14             	sub    $0x14,%esp
c0400805:	8b 44 24 18          	mov    0x18(%esp),%eax
c0400809:	88 04 24             	mov    %al,(%esp)
	unsigned char lo, hi;
	unsigned int div;
	
	if(!freq)
c040080c:	80 3c 24 00          	cmpb   $0x0,(%esp)
c0400810:	75 0e                	jne    c0400820 <x86_timer_init+0x1e>
	{
		/* disable the timer by parking it in interrupt on 
		   terminal count mode. the chip will wait for a
		   value to be loaded into the data register, 
		   which it won't be */
		x86_outportb(0x43, 1 << 4);
c0400812:	6a 10                	push   $0x10
c0400814:	6a 43                	push   $0x43
c0400816:	e8 6c ff ff ff       	call   c0400787 <x86_outportb>
c040081b:	83 c4 08             	add    $0x8,%esp
		return;
c040081e:	eb 51                	jmp    c0400871 <x86_timer_init+0x6f>
	}
	
	/* calculate the divisor - see http://wiki.osdev.org/Programmable_Interval_Timer
		for more details */
	div = 1193180 / freq;
c0400820:	0f b6 14 24          	movzbl (%esp),%edx
c0400824:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0400829:	89 d1                	mov    %edx,%ecx
c040082b:	99                   	cltd   
c040082c:	f7 f9                	idiv   %ecx
c040082e:	89 44 24 10          	mov    %eax,0x10(%esp)
	
   /* Send byte to command port - generate a square wave pulse
	   interrupt at a set rate (mode 3) on channel 0 (wired to IRQ0) */
   x86_outportb(0x43, 0x36);
c0400832:	6a 36                	push   $0x36
c0400834:	6a 43                	push   $0x43
c0400836:	e8 4c ff ff ff       	call   c0400787 <x86_outportb>
c040083b:	83 c4 08             	add    $0x8,%esp
	
   /* divisor has to be sent byte-wise, lo then hi */
   lo = (unsigned char)(div & 0xff);
c040083e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400842:	88 44 24 0e          	mov    %al,0xe(%esp)
   hi = (unsigned char)((div >> 8) & 0xff);
c0400846:	8b 44 24 10          	mov    0x10(%esp),%eax
c040084a:	c1 e8 08             	shr    $0x8,%eax
c040084d:	88 44 24 0f          	mov    %al,0xf(%esp)
	
   /* send the frequency divisor to channel 0 data port */
   x86_outportb(0x40, lo);
c0400851:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
c0400856:	50                   	push   %eax
c0400857:	6a 40                	push   $0x40
c0400859:	e8 29 ff ff ff       	call   c0400787 <x86_outportb>
c040085e:	83 c4 08             	add    $0x8,%esp
   x86_outportb(0x40, hi);
c0400861:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0400866:	50                   	push   %eax
c0400867:	6a 40                	push   $0x40
c0400869:	e8 19 ff ff ff       	call   c0400787 <x86_outportb>
c040086e:	83 c4 08             	add    $0x8,%esp
}
c0400871:	83 c4 14             	add    $0x14,%esp
c0400874:	c3                   	ret    

c0400875 <x86_load_cr3>:
   Reload the page directory base register with a new physical address
   => ptr = value to move into cr3
*/
void x86_load_cr3(void *ptr)
{
   __asm__ __volatile__("movl %%eax, %%cr3"
c0400875:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400879:	0f 22 d8             	mov    %eax,%cr3
                        :
                        : "a"(ptr));
}
c040087c:	c3                   	ret    

c040087d <x86_read_cr2>:

/* x86_read_cr2
 <= return the contents of CR2 (faulting address reg)
 */
unsigned int x86_read_cr2(void)
{
c040087d:	83 ec 10             	sub    $0x10,%esp
	unsigned int ret_val;
   __asm__ __volatile__("movl %%cr2, %%eax"
c0400880:	0f 20 d0             	mov    %cr2,%eax
c0400883:	89 44 24 0c          	mov    %eax,0xc(%esp)
                        : "=a" (ret_val));
	return ret_val;
c0400887:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040088b:	83 c4 10             	add    $0x10,%esp
c040088e:	c3                   	ret    

c040088f <x86_proc_preinit>:

/* x86_proc_preinit
 Perform any port-specific pre-initialisation before we start the operating system.
 Assuming microkernel virtual memory model is now active */
void x86_proc_preinit(void)
{
c040088f:	53                   	push   %ebx
c0400890:	83 ec 08             	sub    $0x8,%esp
	/* grab a copy of the GDT pointers for the boot cpu */
	cpu_table[CPU_ID].gdtptr.size = ((unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT) - 1;
c0400893:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0400899:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040089e:	3c 01                	cmp    $0x1,%al
c04008a0:	76 0f                	jbe    c04008b1 <x86_proc_preinit+0x22>
c04008a2:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04008a7:	8b 00                	mov    (%eax),%eax
c04008a9:	c1 e8 18             	shr    $0x18,%eax
c04008ac:	c1 e0 06             	shl    $0x6,%eax
c04008af:	eb 0b                	jmp    c04008bc <x86_proc_preinit+0x2d>
c04008b1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04008b6:	0f b6 c0             	movzbl %al,%eax
c04008b9:	c1 e0 06             	shl    $0x6,%eax
c04008bc:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c04008bf:	b8 38 10 41 c0       	mov    $0xc0411038,%eax
c04008c4:	8d 50 ff             	lea    -0x1(%eax),%edx
c04008c7:	b8 00 10 41 c0       	mov    $0xc0411000,%eax
c04008cc:	89 d3                	mov    %edx,%ebx
c04008ce:	66 29 c3             	sub    %ax,%bx
c04008d1:	89 d8                	mov    %ebx,%eax
c04008d3:	66 89 41 34          	mov    %ax,0x34(%ecx)
	cpu_table[CPU_ID].gdtptr.ptr = (unsigned int)&KernelGDT;
c04008d7:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04008dd:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04008e2:	3c 01                	cmp    $0x1,%al
c04008e4:	76 0f                	jbe    c04008f5 <x86_proc_preinit+0x66>
c04008e6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04008eb:	8b 00                	mov    (%eax),%eax
c04008ed:	c1 e8 18             	shr    $0x18,%eax
c04008f0:	c1 e0 06             	shl    $0x6,%eax
c04008f3:	eb 0b                	jmp    c0400900 <x86_proc_preinit+0x71>
c04008f5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04008fa:	0f b6 c0             	movzbl %al,%eax
c04008fd:	c1 e0 06             	shl    $0x6,%eax
c0400900:	01 c2                	add    %eax,%edx
c0400902:	b8 00 10 41 c0       	mov    $0xc0411000,%eax
c0400907:	89 42 36             	mov    %eax,0x36(%edx)
	cpu_table[CPU_ID].tssentry = (gdt_entry *)&TSS_Selector;
c040090a:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0400910:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0400915:	3c 01                	cmp    $0x1,%al
c0400917:	76 0f                	jbe    c0400928 <x86_proc_preinit+0x99>
c0400919:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040091e:	8b 00                	mov    (%eax),%eax
c0400920:	c1 e8 18             	shr    $0x18,%eax
c0400923:	c1 e0 06             	shl    $0x6,%eax
c0400926:	eb 0b                	jmp    c0400933 <x86_proc_preinit+0xa4>
c0400928:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040092d:	0f b6 c0             	movzbl %al,%eax
c0400930:	c1 e0 06             	shl    $0x6,%eax
c0400933:	01 c2                	add    %eax,%edx
c0400935:	b8 30 10 41 c0       	mov    $0xc0411030,%eax
c040093a:	89 42 3c             	mov    %eax,0x3c(%edx)
	
	dprintf(PORT_BANNER "\n[x86] i386 port initialised\n");
c040093d:	83 ec 0c             	sub    $0xc,%esp
c0400940:	68 b4 d8 40 c0       	push   $0xc040d8b4
c0400945:	e8 0c cb 00 00       	call   c040d456 <debug_printf>
c040094a:	83 c4 10             	add    $0x10,%esp
}
c040094d:	83 c4 08             	add    $0x8,%esp
c0400950:	5b                   	pop    %ebx
c0400951:	c3                   	ret    

c0400952 <x86_thread_switch>:
   => now = running thread to stop, or NULL for no thread
      next = thread to reload
      regs = pointer to kernel stack
*/
void x86_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
c0400952:	55                   	push   %ebp
c0400953:	57                   	push   %edi
c0400954:	56                   	push   %esi
c0400955:	53                   	push   %ebx
c0400956:	83 ec 6c             	sub    $0x6c,%esp
	tss_descr *new_tss = (tss_descr *)&(next->tss);
c0400959:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c0400960:	83 c0 38             	add    $0x38,%eax
c0400963:	89 44 24 5c          	mov    %eax,0x5c(%esp)

#ifdef X86_DEBUG	
	dprintf("[x86:%i] switching thread %p for %p (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400967:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040096b:	8b 70 04             	mov    0x4(%eax),%esi
c040096e:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c0400972:	8b 58 08             	mov    0x8(%eax),%ebx
c0400975:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c0400979:	8b 48 4c             	mov    0x4c(%eax),%ecx
c040097c:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c0400980:	8b 50 50             	mov    0x50(%eax),%edx
			  CPU_ID, now, next, regs, new_tss->ss, new_tss->cs, new_tss->ss0, new_tss->esp0);
c0400983:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
void x86_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
	tss_descr *new_tss = (tss_descr *)&(next->tss);

#ifdef X86_DEBUG	
	dprintf("[x86:%i] switching thread %p for %p (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400988:	3c 01                	cmp    $0x1,%al
c040098a:	76 0c                	jbe    c0400998 <x86_thread_switch+0x46>
			  CPU_ID, now, next, regs, new_tss->ss, new_tss->cs, new_tss->ss0, new_tss->esp0);
c040098c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400991:	8b 00                	mov    (%eax),%eax
void x86_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
	tss_descr *new_tss = (tss_descr *)&(next->tss);

#ifdef X86_DEBUG	
	dprintf("[x86:%i] switching thread %p for %p (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400993:	c1 e8 18             	shr    $0x18,%eax
c0400996:	eb 08                	jmp    c04009a0 <x86_thread_switch+0x4e>
c0400998:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040099d:	0f b6 c0             	movzbl %al,%eax
c04009a0:	83 ec 0c             	sub    $0xc,%esp
c04009a3:	56                   	push   %esi
c04009a4:	53                   	push   %ebx
c04009a5:	51                   	push   %ecx
c04009a6:	52                   	push   %edx
c04009a7:	ff b4 24 a4 00 00 00 	pushl  0xa4(%esp)
c04009ae:	ff b4 24 a4 00 00 00 	pushl  0xa4(%esp)
c04009b5:	ff b4 24 a4 00 00 00 	pushl  0xa4(%esp)
c04009bc:	50                   	push   %eax
c04009bd:	68 38 da 40 c0       	push   $0xc040da38
c04009c2:	e8 8f ca 00 00       	call   c040d456 <debug_printf>
c04009c7:	83 c4 30             	add    $0x30,%esp
			  CPU_ID, now, next, regs, new_tss->ss, new_tss->cs, new_tss->ss0, new_tss->esp0);
	dprintf("[x86:%i] PRE-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c04009ca:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c04009d1:	8b 68 3c             	mov    0x3c(%eax),%ebp
c04009d4:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c04009db:	8b 40 38             	mov    0x38(%eax),%eax
c04009de:	89 04 24             	mov    %eax,(%esp)
c04009e1:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c04009e8:	8b 40 34             	mov    0x34(%eax),%eax
c04009eb:	89 44 24 04          	mov    %eax,0x4(%esp)
c04009ef:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c04009f6:	8b 40 30             	mov    0x30(%eax),%eax
c04009f9:	89 44 24 08          	mov    %eax,0x8(%esp)
c04009fd:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a04:	8b 40 2c             	mov    0x2c(%eax),%eax
c0400a07:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0400a0b:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a12:	8b 40 28             	mov    0x28(%eax),%eax
c0400a15:	89 44 24 10          	mov    %eax,0x10(%esp)
c0400a19:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a20:	8b 40 24             	mov    0x24(%eax),%eax
c0400a23:	89 44 24 14          	mov    %eax,0x14(%esp)
c0400a27:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a2e:	8b 40 20             	mov    0x20(%eax),%eax
c0400a31:	89 44 24 18          	mov    %eax,0x18(%esp)
c0400a35:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a3c:	8b 40 1c             	mov    0x1c(%eax),%eax
c0400a3f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0400a43:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a4a:	8b 40 18             	mov    0x18(%eax),%eax
c0400a4d:	89 44 24 20          	mov    %eax,0x20(%esp)
c0400a51:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a58:	8b 40 14             	mov    0x14(%eax),%eax
c0400a5b:	89 44 24 24          	mov    %eax,0x24(%esp)
c0400a5f:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a66:	8b 78 10             	mov    0x10(%eax),%edi
c0400a69:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a70:	8b 70 0c             	mov    0xc(%eax),%esi
c0400a73:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a7a:	8b 58 08             	mov    0x8(%eax),%ebx
c0400a7d:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a84:	8b 48 04             	mov    0x4(%eax),%ecx
c0400a87:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400a8e:	8b 10                	mov    (%eax),%edx
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400a90:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	tss_descr *new_tss = (tss_descr *)&(next->tss);

#ifdef X86_DEBUG	
	dprintf("[x86:%i] switching thread %p for %p (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
			  CPU_ID, now, next, regs, new_tss->ss, new_tss->cs, new_tss->ss0, new_tss->esp0);
	dprintf("[x86:%i] PRE-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400a95:	3c 01                	cmp    $0x1,%al
c0400a97:	76 0c                	jbe    c0400aa5 <x86_thread_switch+0x153>
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400a99:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400a9e:	8b 00                	mov    (%eax),%eax
	tss_descr *new_tss = (tss_descr *)&(next->tss);

#ifdef X86_DEBUG	
	dprintf("[x86:%i] switching thread %p for %p (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
			  CPU_ID, now, next, regs, new_tss->ss, new_tss->cs, new_tss->ss0, new_tss->esp0);
	dprintf("[x86:%i] PRE-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400aa0:	c1 e8 18             	shr    $0x18,%eax
c0400aa3:	eb 08                	jmp    c0400aad <x86_thread_switch+0x15b>
c0400aa5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400aaa:	0f b6 c0             	movzbl %al,%eax
c0400aad:	83 ec 08             	sub    $0x8,%esp
c0400ab0:	55                   	push   %ebp
c0400ab1:	ff 74 24 0c          	pushl  0xc(%esp)
c0400ab5:	ff 74 24 14          	pushl  0x14(%esp)
c0400ab9:	ff 74 24 1c          	pushl  0x1c(%esp)
c0400abd:	ff 74 24 24          	pushl  0x24(%esp)
c0400ac1:	ff 74 24 2c          	pushl  0x2c(%esp)
c0400ac5:	ff 74 24 34          	pushl  0x34(%esp)
c0400ac9:	ff 74 24 3c          	pushl  0x3c(%esp)
c0400acd:	ff 74 24 44          	pushl  0x44(%esp)
c0400ad1:	ff 74 24 4c          	pushl  0x4c(%esp)
c0400ad5:	ff 74 24 54          	pushl  0x54(%esp)
c0400ad9:	57                   	push   %edi
c0400ada:	56                   	push   %esi
c0400adb:	53                   	push   %ebx
c0400adc:	51                   	push   %ecx
c0400add:	52                   	push   %edx
c0400ade:	50                   	push   %eax
c0400adf:	68 88 da 40 c0       	push   $0xc040da88
c0400ae4:	e8 6d c9 00 00       	call   c040d456 <debug_printf>
c0400ae9:	83 c4 50             	add    $0x50,%esp
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
#endif
	
	/* preserve state of the thread */
	vmm_memcpy(&(now->regs), regs, sizeof(int_registers_block));
c0400aec:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0400af3:	05 a0 00 00 00       	add    $0xa0,%eax
c0400af8:	83 ec 04             	sub    $0x4,%esp
c0400afb:	6a 40                	push   $0x40
c0400afd:	ff b4 24 90 00 00 00 	pushl  0x90(%esp)
c0400b04:	50                   	push   %eax
c0400b05:	e8 19 62 00 00       	call   c0406d23 <vmm_memcpy>
c0400b0a:	83 c4 10             	add    $0x10,%esp
	
	/* load state for new thread */
	vmm_memcpy(regs, &(next->regs), sizeof(int_registers_block));
c0400b0d:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c0400b14:	05 a0 00 00 00       	add    $0xa0,%eax
c0400b19:	83 ec 04             	sub    $0x4,%esp
c0400b1c:	6a 40                	push   $0x40
c0400b1e:	50                   	push   %eax
c0400b1f:	ff b4 24 94 00 00 00 	pushl  0x94(%esp)
c0400b26:	e8 f8 61 00 00       	call   c0406d23 <vmm_memcpy>
c0400b2b:	83 c4 10             	add    $0x10,%esp
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] POST-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400b2e:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b35:	8b 68 3c             	mov    0x3c(%eax),%ebp
c0400b38:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b3f:	8b 40 38             	mov    0x38(%eax),%eax
c0400b42:	89 44 24 28          	mov    %eax,0x28(%esp)
c0400b46:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b4d:	8b 40 34             	mov    0x34(%eax),%eax
c0400b50:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0400b54:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b5b:	8b 40 30             	mov    0x30(%eax),%eax
c0400b5e:	89 44 24 30          	mov    %eax,0x30(%esp)
c0400b62:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b69:	8b 40 2c             	mov    0x2c(%eax),%eax
c0400b6c:	89 44 24 34          	mov    %eax,0x34(%esp)
c0400b70:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b77:	8b 40 28             	mov    0x28(%eax),%eax
c0400b7a:	89 44 24 38          	mov    %eax,0x38(%esp)
c0400b7e:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b85:	8b 40 24             	mov    0x24(%eax),%eax
c0400b88:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0400b8c:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400b93:	8b 40 20             	mov    0x20(%eax),%eax
c0400b96:	89 44 24 40          	mov    %eax,0x40(%esp)
c0400b9a:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400ba1:	8b 40 1c             	mov    0x1c(%eax),%eax
c0400ba4:	89 44 24 44          	mov    %eax,0x44(%esp)
c0400ba8:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400baf:	8b 40 18             	mov    0x18(%eax),%eax
c0400bb2:	89 44 24 48          	mov    %eax,0x48(%esp)
c0400bb6:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400bbd:	8b 40 14             	mov    0x14(%eax),%eax
c0400bc0:	89 44 24 4c          	mov    %eax,0x4c(%esp)
c0400bc4:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400bcb:	8b 78 10             	mov    0x10(%eax),%edi
c0400bce:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400bd5:	8b 70 0c             	mov    0xc(%eax),%esi
c0400bd8:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400bdf:	8b 58 08             	mov    0x8(%eax),%ebx
c0400be2:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400be9:	8b 48 04             	mov    0x4(%eax),%ecx
c0400bec:	8b 84 24 88 00 00 00 	mov    0x88(%esp),%eax
c0400bf3:	8b 10                	mov    (%eax),%edx
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400bf5:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	/* load state for new thread */
	vmm_memcpy(regs, &(next->regs), sizeof(int_registers_block));
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] POST-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400bfa:	3c 01                	cmp    $0x1,%al
c0400bfc:	76 0c                	jbe    c0400c0a <x86_thread_switch+0x2b8>
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400bfe:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400c03:	8b 00                	mov    (%eax),%eax
	
	/* load state for new thread */
	vmm_memcpy(regs, &(next->regs), sizeof(int_registers_block));
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] POST-SWAP: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400c05:	c1 e8 18             	shr    $0x18,%eax
c0400c08:	eb 08                	jmp    c0400c12 <x86_thread_switch+0x2c0>
c0400c0a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400c0f:	0f b6 c0             	movzbl %al,%eax
c0400c12:	83 ec 08             	sub    $0x8,%esp
c0400c15:	55                   	push   %ebp
c0400c16:	ff 74 24 34          	pushl  0x34(%esp)
c0400c1a:	ff 74 24 3c          	pushl  0x3c(%esp)
c0400c1e:	ff 74 24 44          	pushl  0x44(%esp)
c0400c22:	ff 74 24 4c          	pushl  0x4c(%esp)
c0400c26:	ff 74 24 54          	pushl  0x54(%esp)
c0400c2a:	ff 74 24 5c          	pushl  0x5c(%esp)
c0400c2e:	ff 74 24 64          	pushl  0x64(%esp)
c0400c32:	ff 74 24 6c          	pushl  0x6c(%esp)
c0400c36:	ff 74 24 74          	pushl  0x74(%esp)
c0400c3a:	ff 74 24 7c          	pushl  0x7c(%esp)
c0400c3e:	57                   	push   %edi
c0400c3f:	56                   	push   %esi
c0400c40:	53                   	push   %ebx
c0400c41:	51                   	push   %ecx
c0400c42:	52                   	push   %edx
c0400c43:	50                   	push   %eax
c0400c44:	68 20 db 40 c0       	push   $0xc040db20
c0400c49:	e8 08 c8 00 00       	call   c040d456 <debug_printf>
c0400c4e:	83 c4 50             	add    $0x50,%esp
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
#endif
	
	/* reload page directory if we're switching to a new address space */
	if(now->proc->pgdir != next->proc->pgdir)
c0400c51:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0400c58:	8b 00                	mov    (%eax),%eax
c0400c5a:	8b 50 20             	mov    0x20(%eax),%edx
c0400c5d:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c0400c64:	8b 00                	mov    (%eax),%eax
c0400c66:	8b 40 20             	mov    0x20(%eax),%eax
c0400c69:	39 c2                	cmp    %eax,%edx
c0400c6b:	74 1d                	je     c0400c8a <x86_thread_switch+0x338>
		x86_load_cr3(KERNEL_LOG2PHYS(next->proc->pgdir));
c0400c6d:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c0400c74:	8b 00                	mov    (%eax),%eax
c0400c76:	8b 40 20             	mov    0x20(%eax),%eax
c0400c79:	05 00 00 00 40       	add    $0x40000000,%eax
c0400c7e:	83 ec 0c             	sub    $0xc,%esp
c0400c81:	50                   	push   %eax
c0400c82:	e8 ee fb ff ff       	call   c0400875 <x86_load_cr3>
c0400c87:	83 c4 10             	add    $0x10,%esp
	
	/* inform the CPU that things have changed */	
	new_tss->esp0 = next->kstackbase;
c0400c8a:	8b 84 24 84 00 00 00 	mov    0x84(%esp),%eax
c0400c91:	8b 50 30             	mov    0x30(%eax),%edx
c0400c94:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c0400c98:	89 50 04             	mov    %edx,0x4(%eax)
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, new_tss);
c0400c9b:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0400ca1:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0400ca6:	3c 01                	cmp    $0x1,%al
c0400ca8:	76 0f                	jbe    c0400cb9 <x86_thread_switch+0x367>
c0400caa:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400caf:	8b 00                	mov    (%eax),%eax
c0400cb1:	c1 e8 18             	shr    $0x18,%eax
c0400cb4:	c1 e0 06             	shl    $0x6,%eax
c0400cb7:	eb 0b                	jmp    c0400cc4 <x86_thread_switch+0x372>
c0400cb9:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400cbe:	0f b6 c0             	movzbl %al,%eax
c0400cc1:	c1 e0 06             	shl    $0x6,%eax
c0400cc4:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400cc7:	8b 40 3c             	mov    0x3c(%eax),%eax
c0400cca:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c0400cd0:	8a 15 f0 38 41 c0    	mov    0xc04138f0,%dl
c0400cd6:	80 fa 01             	cmp    $0x1,%dl
c0400cd9:	76 0f                	jbe    c0400cea <x86_thread_switch+0x398>
c0400cdb:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c0400ce0:	8b 12                	mov    (%edx),%edx
c0400ce2:	c1 ea 18             	shr    $0x18,%edx
c0400ce5:	c1 e2 06             	shl    $0x6,%edx
c0400ce8:	eb 0c                	jmp    c0400cf6 <x86_thread_switch+0x3a4>
c0400cea:	8a 15 f1 38 41 c0    	mov    0xc04138f1,%dl
c0400cf0:	0f b6 d2             	movzbl %dl,%edx
c0400cf3:	c1 e2 06             	shl    $0x6,%edx
c0400cf6:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c0400cf9:	83 c2 34             	add    $0x34,%edx
c0400cfc:	83 ec 04             	sub    $0x4,%esp
c0400cff:	ff 74 24 60          	pushl  0x60(%esp)
c0400d03:	50                   	push   %eax
c0400d04:	52                   	push   %edx
c0400d05:	e8 1b 05 00 00       	call   c0401225 <x86_change_tss>
c0400d0a:	83 c4 10             	add    $0x10,%esp
}
c0400d0d:	83 c4 6c             	add    $0x6c,%esp
c0400d10:	5b                   	pop    %ebx
c0400d11:	5e                   	pop    %esi
c0400d12:	5f                   	pop    %edi
c0400d13:	5d                   	pop    %ebp
c0400d14:	c3                   	ret    

c0400d15 <x86_init_tss>:

/* x86_init_tss
   Configure a thread's TSS for the first (and only) time */
void x86_init_tss(thread *toinit)
{
c0400d15:	83 ec 10             	sub    $0x10,%esp
	tss_descr *tss = (tss_descr *)&(toinit->tss);
c0400d18:	8b 44 24 14          	mov    0x14(%esp),%eax
c0400d1c:	83 c0 38             	add    $0x38,%eax
c0400d1f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* initialise the correct registers */
	/* kernel data seg is 0x10, code seg is 0x18, ORd 0x3 for ring-3 access */
	tss->ss  = tss->ds = tss->es = tss->fs = tss->gs = 0x10 | 0x03;
c0400d23:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d27:	c7 40 5c 13 00 00 00 	movl   $0x13,0x5c(%eax)
c0400d2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d32:	8b 50 5c             	mov    0x5c(%eax),%edx
c0400d35:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d39:	89 50 58             	mov    %edx,0x58(%eax)
c0400d3c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d40:	8b 50 58             	mov    0x58(%eax),%edx
c0400d43:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d47:	89 50 48             	mov    %edx,0x48(%eax)
c0400d4a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d4e:	8b 50 48             	mov    0x48(%eax),%edx
c0400d51:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d55:	89 50 54             	mov    %edx,0x54(%eax)
c0400d58:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d5c:	8b 50 54             	mov    0x54(%eax),%edx
c0400d5f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d63:	89 50 50             	mov    %edx,0x50(%eax)
	tss->cs  = 0x18 | 0x03;
c0400d66:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d6a:	c7 40 4c 1b 00 00 00 	movl   $0x1b,0x4c(%eax)
	tss->ss0 = 0x10; /* kernel stack seg (aka data seg) for the IRQ handler */
c0400d71:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d75:	c7 40 08 10 00 00 00 	movl   $0x10,0x8(%eax)
	tss->esp0 = toinit->kstackbase;
c0400d7c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0400d80:	8b 50 30             	mov    0x30(%eax),%edx
c0400d83:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d87:	89 50 04             	mov    %edx,0x4(%eax)
}
c0400d8a:	83 c4 10             	add    $0x10,%esp
c0400d8d:	c3                   	ret    

c0400d8e <x86_warm_kickstart>:

/* x86_warm_kickstart
   Jumpstart the processor with its top queued thread that's already been put into usermode */
void x86_warm_kickstart(void)
{
c0400d8e:	55                   	push   %ebp
c0400d8f:	57                   	push   %edi
c0400d90:	56                   	push   %esi
c0400d91:	53                   	push   %ebx
c0400d92:	83 ec 4c             	sub    $0x4c,%esp
	thread *next = cpu_table[CPU_ID].queue_head;
c0400d95:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0400d9b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0400da0:	3c 01                	cmp    $0x1,%al
c0400da2:	76 0f                	jbe    c0400db3 <x86_warm_kickstart+0x25>
c0400da4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400da9:	8b 00                	mov    (%eax),%eax
c0400dab:	c1 e8 18             	shr    $0x18,%eax
c0400dae:	c1 e0 06             	shl    $0x6,%eax
c0400db1:	eb 0b                	jmp    c0400dbe <x86_warm_kickstart+0x30>
c0400db3:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400db8:	0f b6 c0             	movzbl %al,%eax
c0400dbb:	c1 e0 06             	shl    $0x6,%eax
c0400dbe:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400dc1:	8b 40 18             	mov    0x18(%eax),%eax
c0400dc4:	89 44 24 34          	mov    %eax,0x34(%esp)
	int_registers_block *regs = &(next->regs);
c0400dc8:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400dcc:	05 a0 00 00 00       	add    $0xa0,%eax
c0400dd1:	89 44 24 38          	mov    %eax,0x38(%esp)
	tss_descr *next_tss = (tss_descr *)&(next->tss);
c0400dd5:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400dd9:	83 c0 38             	add    $0x38,%eax
c0400ddc:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400de0:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0400de4:	8b 40 04             	mov    0x4(%eax),%eax
c0400de7:	89 44 24 04          	mov    %eax,0x4(%esp)
c0400deb:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0400def:	8b 68 08             	mov    0x8(%eax),%ebp
c0400df2:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0400df6:	8b 78 4c             	mov    0x4c(%eax),%edi
c0400df9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0400dfd:	8b 70 50             	mov    0x50(%eax),%esi
c0400e00:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400e04:	8b 18                	mov    (%eax),%ebx
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
c0400e06:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400e0a:	8b 00                	mov    (%eax),%eax
	thread *next = cpu_table[CPU_ID].queue_head;
	int_registers_block *regs = &(next->regs);
	tss_descr *next_tss = (tss_descr *)&(next->tss);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400e0c:	8b 08                	mov    (%eax),%ecx
c0400e0e:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400e12:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
c0400e15:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	thread *next = cpu_table[CPU_ID].queue_head;
	int_registers_block *regs = &(next->regs);
	tss_descr *next_tss = (tss_descr *)&(next->tss);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400e1a:	3c 01                	cmp    $0x1,%al
c0400e1c:	76 0c                	jbe    c0400e2a <x86_warm_kickstart+0x9c>
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
c0400e1e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400e23:	8b 00                	mov    (%eax),%eax
	thread *next = cpu_table[CPU_ID].queue_head;
	int_registers_block *regs = &(next->regs);
	tss_descr *next_tss = (tss_descr *)&(next->tss);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
c0400e25:	c1 e8 18             	shr    $0x18,%eax
c0400e28:	eb 08                	jmp    c0400e32 <x86_warm_kickstart+0xa4>
c0400e2a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400e2f:	0f b6 c0             	movzbl %al,%eax
c0400e32:	83 ec 04             	sub    $0x4,%esp
c0400e35:	ff 74 24 08          	pushl  0x8(%esp)
c0400e39:	55                   	push   %ebp
c0400e3a:	57                   	push   %edi
c0400e3b:	56                   	push   %esi
c0400e3c:	ff 74 24 4c          	pushl  0x4c(%esp)
c0400e40:	53                   	push   %ebx
c0400e41:	51                   	push   %ecx
c0400e42:	ff 74 24 54          	pushl  0x54(%esp)
c0400e46:	52                   	push   %edx
c0400e47:	50                   	push   %eax
c0400e48:	68 b8 db 40 c0       	push   $0xc040dbb8
c0400e4d:	e8 04 c6 00 00       	call   c040d456 <debug_printf>
c0400e52:	83 c4 30             	add    $0x30,%esp
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
			  next_tss->ss, next_tss->cs, next_tss->ss0, next_tss->esp0);
	dprintf("[x86:%i] warm context: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400e55:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e59:	8b 68 3c             	mov    0x3c(%eax),%ebp
c0400e5c:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e60:	8b 40 38             	mov    0x38(%eax),%eax
c0400e63:	89 44 24 08          	mov    %eax,0x8(%esp)
c0400e67:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e6b:	8b 40 34             	mov    0x34(%eax),%eax
c0400e6e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0400e72:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e76:	8b 40 30             	mov    0x30(%eax),%eax
c0400e79:	89 44 24 10          	mov    %eax,0x10(%esp)
c0400e7d:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e81:	8b 40 2c             	mov    0x2c(%eax),%eax
c0400e84:	89 44 24 14          	mov    %eax,0x14(%esp)
c0400e88:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e8c:	8b 40 28             	mov    0x28(%eax),%eax
c0400e8f:	89 44 24 18          	mov    %eax,0x18(%esp)
c0400e93:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400e97:	8b 40 24             	mov    0x24(%eax),%eax
c0400e9a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0400e9e:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ea2:	8b 40 20             	mov    0x20(%eax),%eax
c0400ea5:	89 44 24 20          	mov    %eax,0x20(%esp)
c0400ea9:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ead:	8b 40 1c             	mov    0x1c(%eax),%eax
c0400eb0:	89 44 24 24          	mov    %eax,0x24(%esp)
c0400eb4:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400eb8:	8b 40 18             	mov    0x18(%eax),%eax
c0400ebb:	89 44 24 28          	mov    %eax,0x28(%esp)
c0400ebf:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ec3:	8b 40 14             	mov    0x14(%eax),%eax
c0400ec6:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0400eca:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ece:	8b 78 10             	mov    0x10(%eax),%edi
c0400ed1:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ed5:	8b 70 0c             	mov    0xc(%eax),%esi
c0400ed8:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400edc:	8b 58 08             	mov    0x8(%eax),%ebx
c0400edf:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400ee3:	8b 48 04             	mov    0x4(%eax),%ecx
c0400ee6:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400eea:	8b 10                	mov    (%eax),%edx
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400eec:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
			  next_tss->ss, next_tss->cs, next_tss->ss0, next_tss->esp0);
	dprintf("[x86:%i] warm context: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400ef1:	3c 01                	cmp    $0x1,%al
c0400ef3:	76 0c                	jbe    c0400f01 <x86_warm_kickstart+0x173>
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
c0400ef5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400efa:	8b 00                	mov    (%eax),%eax
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] resuming warm thread %i (%p) of process %i (%p) (regs %p) (ds/ss %x cs %x ss0 %x esp0 %x)\n",
			  CPU_ID, next->tid, next, next->proc->pid, next->proc, regs,
			  next_tss->ss, next_tss->cs, next_tss->ss0, next_tss->esp0);
	dprintf("[x86:%i] warm context: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
c0400efc:	c1 e8 18             	shr    $0x18,%eax
c0400eff:	eb 08                	jmp    c0400f09 <x86_warm_kickstart+0x17b>
c0400f01:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400f06:	0f b6 c0             	movzbl %al,%eax
c0400f09:	83 ec 08             	sub    $0x8,%esp
c0400f0c:	55                   	push   %ebp
c0400f0d:	ff 74 24 14          	pushl  0x14(%esp)
c0400f11:	ff 74 24 1c          	pushl  0x1c(%esp)
c0400f15:	ff 74 24 24          	pushl  0x24(%esp)
c0400f19:	ff 74 24 2c          	pushl  0x2c(%esp)
c0400f1d:	ff 74 24 34          	pushl  0x34(%esp)
c0400f21:	ff 74 24 3c          	pushl  0x3c(%esp)
c0400f25:	ff 74 24 44          	pushl  0x44(%esp)
c0400f29:	ff 74 24 4c          	pushl  0x4c(%esp)
c0400f2d:	ff 74 24 54          	pushl  0x54(%esp)
c0400f31:	ff 74 24 5c          	pushl  0x5c(%esp)
c0400f35:	57                   	push   %edi
c0400f36:	56                   	push   %esi
c0400f37:	53                   	push   %ebx
c0400f38:	51                   	push   %ecx
c0400f39:	52                   	push   %edx
c0400f3a:	50                   	push   %eax
c0400f3b:	68 1c dc 40 c0       	push   $0xc040dc1c
c0400f40:	e8 11 c5 00 00       	call   c040d456 <debug_printf>
c0400f45:	83 c4 50             	add    $0x50,%esp
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
#endif

	/* load page directory */
	x86_load_cr3(KERNEL_LOG2PHYS(next->proc->pgdir));
c0400f48:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400f4c:	8b 00                	mov    (%eax),%eax
c0400f4e:	8b 40 20             	mov    0x20(%eax),%eax
c0400f51:	05 00 00 00 40       	add    $0x40000000,%eax
c0400f56:	83 ec 0c             	sub    $0xc,%esp
c0400f59:	50                   	push   %eax
c0400f5a:	e8 16 f9 ff ff       	call   c0400875 <x86_load_cr3>
c0400f5f:	83 c4 10             	add    $0x10,%esp
	
	/* inform the CPU that things have changed */	
	next_tss->esp0 = next->kstackbase;
c0400f62:	8b 44 24 34          	mov    0x34(%esp),%eax
c0400f66:	8b 50 30             	mov    0x30(%eax),%edx
c0400f69:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0400f6d:	89 50 04             	mov    %edx,0x4(%eax)
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, next_tss);
c0400f70:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0400f76:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0400f7b:	3c 01                	cmp    $0x1,%al
c0400f7d:	76 0f                	jbe    c0400f8e <x86_warm_kickstart+0x200>
c0400f7f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400f84:	8b 00                	mov    (%eax),%eax
c0400f86:	c1 e8 18             	shr    $0x18,%eax
c0400f89:	c1 e0 06             	shl    $0x6,%eax
c0400f8c:	eb 0b                	jmp    c0400f99 <x86_warm_kickstart+0x20b>
c0400f8e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0400f93:	0f b6 c0             	movzbl %al,%eax
c0400f96:	c1 e0 06             	shl    $0x6,%eax
c0400f99:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400f9c:	8b 40 3c             	mov    0x3c(%eax),%eax
c0400f9f:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c0400fa5:	8a 15 f0 38 41 c0    	mov    0xc04138f0,%dl
c0400fab:	80 fa 01             	cmp    $0x1,%dl
c0400fae:	76 0f                	jbe    c0400fbf <x86_warm_kickstart+0x231>
c0400fb0:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c0400fb5:	8b 12                	mov    (%edx),%edx
c0400fb7:	c1 ea 18             	shr    $0x18,%edx
c0400fba:	c1 e2 06             	shl    $0x6,%edx
c0400fbd:	eb 0c                	jmp    c0400fcb <x86_warm_kickstart+0x23d>
c0400fbf:	8a 15 f1 38 41 c0    	mov    0xc04138f1,%dl
c0400fc5:	0f b6 d2             	movzbl %dl,%edx
c0400fc8:	c1 e2 06             	shl    $0x6,%edx
c0400fcb:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c0400fce:	83 c2 34             	add    $0x34,%edx
c0400fd1:	83 ec 04             	sub    $0x4,%esp
c0400fd4:	ff 74 24 40          	pushl  0x40(%esp)
c0400fd8:	50                   	push   %eax
c0400fd9:	52                   	push   %edx
c0400fda:	e8 46 02 00 00       	call   c0401225 <x86_change_tss>
c0400fdf:	83 c4 10             	add    $0x10,%esp

	/* now return to the usermode thread - all the registers are stacked up in the 
	   thread's reg block - see int_handler in locore.s for this return code */
	__asm__ __volatile__
c0400fe2:	8b 44 24 38          	mov    0x38(%esp),%eax
c0400fe6:	89 c4                	mov    %eax,%esp
c0400fe8:	58                   	pop    %eax
c0400fe9:	8e d8                	mov    %eax,%ds
c0400feb:	8e c0                	mov    %eax,%es
c0400fed:	8e e0                	mov    %eax,%fs
c0400fef:	8e e8                	mov    %eax,%gs
c0400ff1:	61                   	popa   
c0400ff2:	83 c4 08             	add    $0x8,%esp
c0400ff5:	fb                   	sti    
c0400ff6:	cf                   	iret   
	  addl $8, %%esp; \
	  sti; \
	  iret;" : : "a" (regs));
	
	/* shouldn't reach here.. */
}
c0400ff7:	83 c4 4c             	add    $0x4c,%esp
c0400ffa:	5b                   	pop    %ebx
c0400ffb:	5e                   	pop    %esi
c0400ffc:	5f                   	pop    %edi
c0400ffd:	5d                   	pop    %ebp
c0400ffe:	c3                   	ret    

c0400fff <x86_kickstart>:

/* x86_kickstart
   Jumpstart the processor by executing the top queued thread in usermode  */
void x86_kickstart(void)
{
c0400fff:	55                   	push   %ebp
c0401000:	57                   	push   %edi
c0401001:	56                   	push   %esi
c0401002:	53                   	push   %ebx
c0401003:	83 ec 1c             	sub    $0x1c,%esp
	thread *torun = cpu_table[CPU_ID].queue_head;
c0401006:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040100c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401011:	3c 01                	cmp    $0x1,%al
c0401013:	76 0f                	jbe    c0401024 <x86_kickstart+0x25>
c0401015:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040101a:	8b 00                	mov    (%eax),%eax
c040101c:	c1 e8 18             	shr    $0x18,%eax
c040101f:	c1 e0 06             	shl    $0x6,%eax
c0401022:	eb 0b                	jmp    c040102f <x86_kickstart+0x30>
c0401024:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401029:	0f b6 c0             	movzbl %al,%eax
c040102c:	c1 e0 06             	shl    $0x6,%eax
c040102f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401032:	8b 40 18             	mov    0x18(%eax),%eax
c0401035:	89 04 24             	mov    %eax,(%esp)
	process *proc;
	tss_descr *tss;
	unsigned int usresp;
	
	if(!torun)
c0401038:	83 3c 24 00          	cmpl   $0x0,(%esp)
c040103c:	75 33                	jne    c0401071 <x86_kickstart+0x72>
	{
		dprintf("[x86:%i] OMGWTF: cannot find a thread to kickstart.\n", CPU_ID);
c040103e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401043:	3c 01                	cmp    $0x1,%al
c0401045:	76 0c                	jbe    c0401053 <x86_kickstart+0x54>
c0401047:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040104c:	8b 00                	mov    (%eax),%eax
c040104e:	c1 e8 18             	shr    $0x18,%eax
c0401051:	eb 08                	jmp    c040105b <x86_kickstart+0x5c>
c0401053:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401058:	0f b6 c0             	movzbl %al,%eax
c040105b:	83 ec 08             	sub    $0x8,%esp
c040105e:	50                   	push   %eax
c040105f:	68 b8 dc 40 c0       	push   $0xc040dcb8
c0401064:	e8 ed c3 00 00       	call   c040d456 <debug_printf>
c0401069:	83 c4 10             	add    $0x10,%esp
		return;
c040106c:	e9 ac 01 00 00       	jmp    c040121d <x86_kickstart+0x21e>
	}
	
	/* has this thread already entered usermode? */
	if(torun->flags & THREAD_INUSERMODE)
c0401071:	8b 04 24             	mov    (%esp),%eax
c0401074:	8a 40 0c             	mov    0xc(%eax),%al
c0401077:	0f b6 c0             	movzbl %al,%eax
c040107a:	83 e0 01             	and    $0x1,%eax
c040107d:	84 c0                	test   %al,%al
c040107f:	74 0a                	je     c040108b <x86_kickstart+0x8c>
	{
		x86_warm_kickstart();
c0401081:	e8 08 fd ff ff       	call   c0400d8e <x86_warm_kickstart>
		return;
c0401086:	e9 92 01 00 00       	jmp    c040121d <x86_kickstart+0x21e>
	}
	
	tss = (tss_descr *)&(torun->tss);
c040108b:	8b 04 24             	mov    (%esp),%eax
c040108e:	83 c0 38             	add    $0x38,%eax
c0401091:	89 44 24 08          	mov    %eax,0x8(%esp)
	proc = torun->proc;
c0401095:	8b 04 24             	mov    (%esp),%eax
c0401098:	8b 00                	mov    (%eax),%eax
c040109a:	89 44 24 04          	mov    %eax,0x4(%esp)
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] kickstarting cold thread %i (%p) of process %i (%p) stackbase %x kstackbase %x tss %x at EIP %x\n",
c040109e:	8b 44 24 04          	mov    0x4(%esp),%eax
c04010a2:	8b 78 44             	mov    0x44(%eax),%edi
c04010a5:	8b 04 24             	mov    (%esp),%eax
c04010a8:	8d 68 38             	lea    0x38(%eax),%ebp
c04010ab:	8b 04 24             	mov    (%esp),%eax
c04010ae:	8b 70 30             	mov    0x30(%eax),%esi
c04010b1:	8b 04 24             	mov    (%esp),%eax
c04010b4:	8b 58 2c             	mov    0x2c(%eax),%ebx
c04010b7:	8b 44 24 04          	mov    0x4(%esp),%eax
c04010bb:	8b 08                	mov    (%eax),%ecx
c04010bd:	8b 04 24             	mov    (%esp),%eax
c04010c0:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, torun->tid, torun, proc->pid, proc, torun->stackbase, torun->kstackbase, &(torun->tss), proc->entry);
c04010c3:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	tss = (tss_descr *)&(torun->tss);
	proc = torun->proc;
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] kickstarting cold thread %i (%p) of process %i (%p) stackbase %x kstackbase %x tss %x at EIP %x\n",
c04010c8:	3c 01                	cmp    $0x1,%al
c04010ca:	76 0c                	jbe    c04010d8 <x86_kickstart+0xd9>
			  CPU_ID, torun->tid, torun, proc->pid, proc, torun->stackbase, torun->kstackbase, &(torun->tss), proc->entry);
c04010cc:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04010d1:	8b 00                	mov    (%eax),%eax
	
	tss = (tss_descr *)&(torun->tss);
	proc = torun->proc;
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] kickstarting cold thread %i (%p) of process %i (%p) stackbase %x kstackbase %x tss %x at EIP %x\n",
c04010d3:	c1 e8 18             	shr    $0x18,%eax
c04010d6:	eb 08                	jmp    c04010e0 <x86_kickstart+0xe1>
c04010d8:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04010dd:	0f b6 c0             	movzbl %al,%eax
c04010e0:	83 ec 08             	sub    $0x8,%esp
c04010e3:	57                   	push   %edi
c04010e4:	55                   	push   %ebp
c04010e5:	56                   	push   %esi
c04010e6:	53                   	push   %ebx
c04010e7:	ff 74 24 1c          	pushl  0x1c(%esp)
c04010eb:	51                   	push   %ecx
c04010ec:	ff 74 24 20          	pushl  0x20(%esp)
c04010f0:	52                   	push   %edx
c04010f1:	50                   	push   %eax
c04010f2:	68 f0 dc 40 c0       	push   $0xc040dcf0
c04010f7:	e8 5a c3 00 00       	call   c040d456 <debug_printf>
c04010fc:	83 c4 30             	add    $0x30,%esp
			  CPU_ID, torun->tid, torun, proc->pid, proc, torun->stackbase, torun->kstackbase, &(torun->tss), proc->entry);
#endif
	
	/* get page tables loaded, TSS initialised and GDT updated */
	x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c04010ff:	8b 44 24 04          	mov    0x4(%esp),%eax
c0401103:	8b 40 20             	mov    0x20(%eax),%eax
c0401106:	05 00 00 00 40       	add    $0x40000000,%eax
c040110b:	83 ec 0c             	sub    $0xc,%esp
c040110e:	50                   	push   %eax
c040110f:	e8 61 f7 ff ff       	call   c0400875 <x86_load_cr3>
c0401114:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(torun);
c0401117:	83 ec 0c             	sub    $0xc,%esp
c040111a:	ff 74 24 0c          	pushl  0xc(%esp)
c040111e:	e8 f2 fb ff ff       	call   c0400d15 <x86_init_tss>
c0401123:	83 c4 10             	add    $0x10,%esp
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, tss);
c0401126:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040112c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401131:	3c 01                	cmp    $0x1,%al
c0401133:	76 0f                	jbe    c0401144 <x86_kickstart+0x145>
c0401135:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040113a:	8b 00                	mov    (%eax),%eax
c040113c:	c1 e8 18             	shr    $0x18,%eax
c040113f:	c1 e0 06             	shl    $0x6,%eax
c0401142:	eb 0b                	jmp    c040114f <x86_kickstart+0x150>
c0401144:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401149:	0f b6 c0             	movzbl %al,%eax
c040114c:	c1 e0 06             	shl    $0x6,%eax
c040114f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401152:	8b 40 3c             	mov    0x3c(%eax),%eax
c0401155:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c040115b:	8a 15 f0 38 41 c0    	mov    0xc04138f0,%dl
c0401161:	80 fa 01             	cmp    $0x1,%dl
c0401164:	76 0f                	jbe    c0401175 <x86_kickstart+0x176>
c0401166:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c040116b:	8b 12                	mov    (%edx),%edx
c040116d:	c1 ea 18             	shr    $0x18,%edx
c0401170:	c1 e2 06             	shl    $0x6,%edx
c0401173:	eb 0c                	jmp    c0401181 <x86_kickstart+0x182>
c0401175:	8a 15 f1 38 41 c0    	mov    0xc04138f1,%dl
c040117b:	0f b6 d2             	movzbl %dl,%edx
c040117e:	c1 e2 06             	shl    $0x6,%edx
c0401181:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c0401184:	83 c2 34             	add    $0x34,%edx
c0401187:	83 ec 04             	sub    $0x4,%esp
c040118a:	ff 74 24 0c          	pushl  0xc(%esp)
c040118e:	50                   	push   %eax
c040118f:	52                   	push   %edx
c0401190:	e8 90 00 00 00       	call   c0401225 <x86_change_tss>
c0401195:	83 c4 10             	add    $0x10,%esp
	
	/* keep the scheduler happy */
	torun->state = running;
c0401198:	8b 04 24             	mov    (%esp),%eax
c040119b:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	torun->timeslice = SCHED_TIMESLICE;
c04011a2:	8b 04 24             	mov    (%esp),%eax
c04011a5:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	cpu_table[CPU_ID].current = torun;
c04011a9:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04011af:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04011b4:	3c 01                	cmp    $0x1,%al
c04011b6:	76 0f                	jbe    c04011c7 <x86_kickstart+0x1c8>
c04011b8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04011bd:	8b 00                	mov    (%eax),%eax
c04011bf:	c1 e8 18             	shr    $0x18,%eax
c04011c2:	c1 e0 06             	shl    $0x6,%eax
c04011c5:	eb 0b                	jmp    c04011d2 <x86_kickstart+0x1d3>
c04011c7:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04011cc:	0f b6 c0             	movzbl %al,%eax
c04011cf:	c1 e0 06             	shl    $0x6,%eax
c04011d2:	01 c2                	add    %eax,%edx
c04011d4:	8b 04 24             	mov    (%esp),%eax
c04011d7:	89 42 04             	mov    %eax,0x4(%edx)
	torun->flags = THREAD_INUSERMODE; /* well, we're about to be.. */
c04011da:	8b 04 24             	mov    (%esp),%eax
c04011dd:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	
	/* assume we're going to kickstart an i386-elf, so prepare the stack pointer appropriately.
	   the page holding the stack will have been zero'd, so we just move the ptr down a few words
	   to keep the C-front end of the kick-started program from accessing stack that's not there */
	usresp = torun->stackbase - (4 * (sizeof(unsigned int)));
c04011e1:	8b 04 24             	mov    (%esp),%eax
c04011e4:	8b 40 2c             	mov    0x2c(%eax),%eax
c04011e7:	83 e8 10             	sub    $0x10,%eax
c04011ea:	89 44 24 0c          	mov    %eax,0xc(%esp)
	  or $0x200, %%eax; \
	  pushl %%eax; \
	  pushl $0x2B; \
	  movl %1, %%eax; \
	  pushl %%eax; \
	  iret;" : : "b" (usresp), "c" (proc->entry));
c04011ee:	8b 44 24 04          	mov    0x4(%esp),%eax
c04011f2:	8b 50 44             	mov    0x44(%eax),%edx
	
	/* x86 voodoo to switch to user mode and enable interrupts (eflags OR 0x200 in the code) */
	/* segment number 0x23 = 0x20 | 0x3 = user data seg 0x20 with ring3 bits set
	                  0x2B = 0x28 | 0x3 = user code seg 0x28 with ring3 bits set */
	/* also: pass new stack pointer and jump to the thread's entry point */
	__asm__ __volatile__
c04011f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04011f9:	89 c3                	mov    %eax,%ebx
c04011fb:	89 d1                	mov    %edx,%ecx
c04011fd:	b8 23 00 00 00       	mov    $0x23,%eax
c0401202:	8e d8                	mov    %eax,%ds
c0401204:	8e c0                	mov    %eax,%es
c0401206:	8e e0                	mov    %eax,%fs
c0401208:	8e e8                	mov    %eax,%gs
c040120a:	89 d8                	mov    %ebx,%eax
c040120c:	6a 23                	push   $0x23
c040120e:	50                   	push   %eax
c040120f:	9c                   	pushf  
c0401210:	58                   	pop    %eax
c0401211:	0d 00 02 00 00       	or     $0x200,%eax
c0401216:	50                   	push   %eax
c0401217:	6a 2b                	push   $0x2b
c0401219:	89 c8                	mov    %ecx,%eax
c040121b:	50                   	push   %eax
c040121c:	cf                   	iret   
	  movl %1, %%eax; \
	  pushl %%eax; \
	  iret;" : : "b" (usresp), "c" (proc->entry));
	
	/* execution shouldn't really return to here */
}
c040121d:	83 c4 1c             	add    $0x1c,%esp
c0401220:	5b                   	pop    %ebx
c0401221:	5e                   	pop    %esi
c0401222:	5f                   	pop    %edi
c0401223:	5d                   	pop    %ebp
c0401224:	c3                   	ret    

c0401225 <x86_change_tss>:

/* x86_change_tss
	Update the given tss and point to it from the given gdt entry */
void x86_change_tss(gdtptr_descr *cpugdt, gdt_entry *gdt, tss_descr *tss)
{
c0401225:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int base = (unsigned int)tss;
c0401228:	8b 44 24 28          	mov    0x28(%esp),%eax
c040122c:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int limit = sizeof(tss_descr);
c0401230:	c7 44 24 0c 68 00 00 	movl   $0x68,0xc(%esp)
c0401237:	00 
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] changing TSS: gdtptr %p (gdt base %x size %i bytes) entry %p tss %p\n",
			  CPU_ID, cpugdt, cpugdt->ptr, cpugdt->size, gdt, tss);
c0401238:	8b 44 24 20          	mov    0x20(%esp),%eax
c040123c:	66 8b 00             	mov    (%eax),%ax
{
	unsigned int base = (unsigned int)tss;
	unsigned int limit = sizeof(tss_descr);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] changing TSS: gdtptr %p (gdt base %x size %i bytes) entry %p tss %p\n",
c040123f:	0f b7 c8             	movzwl %ax,%ecx
c0401242:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401246:	8b 50 02             	mov    0x2(%eax),%edx
			  CPU_ID, cpugdt, cpugdt->ptr, cpugdt->size, gdt, tss);
c0401249:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
{
	unsigned int base = (unsigned int)tss;
	unsigned int limit = sizeof(tss_descr);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] changing TSS: gdtptr %p (gdt base %x size %i bytes) entry %p tss %p\n",
c040124e:	3c 01                	cmp    $0x1,%al
c0401250:	76 0c                	jbe    c040125e <x86_change_tss+0x39>
			  CPU_ID, cpugdt, cpugdt->ptr, cpugdt->size, gdt, tss);
c0401252:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401257:	8b 00                	mov    (%eax),%eax
{
	unsigned int base = (unsigned int)tss;
	unsigned int limit = sizeof(tss_descr);
	
#ifdef X86_DEBUG
	dprintf("[x86:%i] changing TSS: gdtptr %p (gdt base %x size %i bytes) entry %p tss %p\n",
c0401259:	c1 e8 18             	shr    $0x18,%eax
c040125c:	eb 08                	jmp    c0401266 <x86_change_tss+0x41>
c040125e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401263:	0f b6 c0             	movzbl %al,%eax
c0401266:	83 ec 04             	sub    $0x4,%esp
c0401269:	ff 74 24 2c          	pushl  0x2c(%esp)
c040126d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0401271:	51                   	push   %ecx
c0401272:	52                   	push   %edx
c0401273:	ff 74 24 34          	pushl  0x34(%esp)
c0401277:	50                   	push   %eax
c0401278:	68 5c dd 40 c0       	push   $0xc040dd5c
c040127d:	e8 d4 c1 00 00       	call   c040d456 <debug_printf>
c0401282:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, cpugdt, cpugdt->ptr, cpugdt->size, gdt, tss);
#endif
	
	gdt->base_low    = (base & 0xFFFF);
c0401285:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401289:	8b 54 24 24          	mov    0x24(%esp),%edx
c040128d:	66 89 42 02          	mov    %ax,0x2(%edx)
   gdt->base_middle = (base >> 16) & 0xFF;
c0401291:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401295:	c1 e8 10             	shr    $0x10,%eax
c0401298:	88 c2                	mov    %al,%dl
c040129a:	8b 44 24 24          	mov    0x24(%esp),%eax
c040129e:	88 50 04             	mov    %dl,0x4(%eax)
   gdt->base_high   = (base >> 24) & 0xFF;
c04012a1:	8b 44 24 08          	mov    0x8(%esp),%eax
c04012a5:	c1 e8 18             	shr    $0x18,%eax
c04012a8:	88 c2                	mov    %al,%dl
c04012aa:	8b 44 24 24          	mov    0x24(%esp),%eax
c04012ae:	88 50 07             	mov    %dl,0x7(%eax)
   gdt->limit_low   = (limit & 0xFFFF);
c04012b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04012b5:	8b 54 24 24          	mov    0x24(%esp),%edx
c04012b9:	66 89 02             	mov    %ax,(%edx)
   gdt->granularity = ((limit >> 16) & 0x0F) | 0x40; /* 32bit mode */
c04012bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04012c0:	c1 e8 10             	shr    $0x10,%eax
c04012c3:	83 e0 0f             	and    $0xf,%eax
c04012c6:	88 c2                	mov    %al,%dl
c04012c8:	83 ca 40             	or     $0x40,%edx
c04012cb:	8b 44 24 24          	mov    0x24(%esp),%eax
c04012cf:	88 50 06             	mov    %dl,0x6(%eax)
   gdt->access      = 0x89; /* flags: present, executable, accessed */
c04012d2:	8b 44 24 24          	mov    0x24(%esp),%eax
c04012d6:	c6 40 05 89          	movb   $0x89,0x5(%eax)

	/* inform the cpu of changes */
	x86_load_gdtr((unsigned int)cpugdt);
c04012da:	8b 44 24 20          	mov    0x20(%esp),%eax
c04012de:	83 ec 0c             	sub    $0xc,%esp
c04012e1:	50                   	push   %eax
c04012e2:	e8 62 f1 ff ff       	call   c0400449 <x86_load_gdtr>
c04012e7:	83 c4 10             	add    $0x10,%esp
	x86_load_tss();
c04012ea:	e8 52 f1 ff ff       	call   c0400441 <x86_load_tss>
}
c04012ef:	83 c4 1c             	add    $0x1c,%esp
c04012f2:	c3                   	ret    

c04012f3 <x86_pic_remap>:
	=> offset1 = vector offset for master PIC
					 vectors on the master become offset1 to offset1 + 7
	=> offset2 = same for slave PIC: offset2 to offset2 + 7
*/
void x86_pic_remap(unsigned int offset1, unsigned int offset2)
{
c04012f3:	83 ec 10             	sub    $0x10,%esp
	unsigned char a1, a2;
	
	/* save the masks */
	a1 = x86_inportb(PIC1_DATA);
c04012f6:	6a 21                	push   $0x21
c04012f8:	e8 6c f4 ff ff       	call   c0400769 <x86_inportb>
c04012fd:	83 c4 04             	add    $0x4,%esp
c0401300:	88 44 24 0e          	mov    %al,0xe(%esp)
	a2 = x86_inportb(PIC2_DATA);
c0401304:	68 a1 00 00 00       	push   $0xa1
c0401309:	e8 5b f4 ff ff       	call   c0400769 <x86_inportb>
c040130e:	83 c4 04             	add    $0x4,%esp
c0401311:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	/* reinitialise the chipset */
	x86_outportb(PIC1_COMMAND, ICW1_INIT+ICW1_ICW4);
c0401315:	6a 11                	push   $0x11
c0401317:	6a 20                	push   $0x20
c0401319:	e8 69 f4 ff ff       	call   c0400787 <x86_outportb>
c040131e:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_COMMAND, ICW1_INIT+ICW1_ICW4);
c0401321:	6a 11                	push   $0x11
c0401323:	68 a0 00 00 00       	push   $0xa0
c0401328:	e8 5a f4 ff ff       	call   c0400787 <x86_outportb>
c040132d:	83 c4 08             	add    $0x8,%esp
	/* send the new offsets */
	x86_outportb(PIC1_DATA, offset1);
c0401330:	ff 74 24 14          	pushl  0x14(%esp)
c0401334:	6a 21                	push   $0x21
c0401336:	e8 4c f4 ff ff       	call   c0400787 <x86_outportb>
c040133b:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, offset2);
c040133e:	ff 74 24 18          	pushl  0x18(%esp)
c0401342:	68 a1 00 00 00       	push   $0xa1
c0401347:	e8 3b f4 ff ff       	call   c0400787 <x86_outportb>
c040134c:	83 c4 08             	add    $0x8,%esp
	/* complete the reinitialisation sequence */
	x86_outportb(PIC1_DATA, 4);
c040134f:	6a 04                	push   $0x4
c0401351:	6a 21                	push   $0x21
c0401353:	e8 2f f4 ff ff       	call   c0400787 <x86_outportb>
c0401358:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, 2);
c040135b:	6a 02                	push   $0x2
c040135d:	68 a1 00 00 00       	push   $0xa1
c0401362:	e8 20 f4 ff ff       	call   c0400787 <x86_outportb>
c0401367:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC1_DATA, ICW4_8086);
c040136a:	6a 01                	push   $0x1
c040136c:	6a 21                	push   $0x21
c040136e:	e8 14 f4 ff ff       	call   c0400787 <x86_outportb>
c0401373:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, ICW4_8086);
c0401376:	6a 01                	push   $0x1
c0401378:	68 a1 00 00 00       	push   $0xa1
c040137d:	e8 05 f4 ff ff       	call   c0400787 <x86_outportb>
c0401382:	83 c4 08             	add    $0x8,%esp
	
	/* restore saved masks */
	x86_outportb(PIC1_DATA, a1);
c0401385:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
c040138a:	50                   	push   %eax
c040138b:	6a 21                	push   $0x21
c040138d:	e8 f5 f3 ff ff       	call   c0400787 <x86_outportb>
c0401392:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, a2);
c0401395:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c040139a:	50                   	push   %eax
c040139b:	68 a1 00 00 00       	push   $0xa1
c04013a0:	e8 e2 f3 ff ff       	call   c0400787 <x86_outportb>
c04013a5:	83 c4 08             	add    $0x8,%esp
}
c04013a8:	83 c4 10             	add    $0x10,%esp
c04013ab:	c3                   	ret    

c04013ac <x86_pic_reset>:
   Send an end-of-interrupt/reset signal to a PIC
	=> pic = 1 for master
            2 for slave
*/
void x86_pic_reset(unsigned char pic)
{
c04013ac:	83 ec 04             	sub    $0x4,%esp
c04013af:	8b 44 24 08          	mov    0x8(%esp),%eax
c04013b3:	88 04 24             	mov    %al,(%esp)
	if(pic == 1)
c04013b6:	80 3c 24 01          	cmpb   $0x1,(%esp)
c04013ba:	75 0e                	jne    c04013ca <x86_pic_reset+0x1e>
		x86_outportb(PIC1_COMMAND, 0x20);
c04013bc:	6a 20                	push   $0x20
c04013be:	6a 20                	push   $0x20
c04013c0:	e8 c2 f3 ff ff       	call   c0400787 <x86_outportb>
c04013c5:	83 c4 08             	add    $0x8,%esp
c04013c8:	eb 0f                	jmp    c04013d9 <x86_pic_reset+0x2d>
	else
		x86_outportb(PIC2_COMMAND, 0x20);
c04013ca:	6a 20                	push   $0x20
c04013cc:	68 a0 00 00 00       	push   $0xa0
c04013d1:	e8 b1 f3 ff ff       	call   c0400787 <x86_outportb>
c04013d6:	83 c4 08             	add    $0x8,%esp
}
c04013d9:	83 c4 04             	add    $0x4,%esp
c04013dc:	c3                   	ret    

c04013dd <x86_enable_interrupts>:
 These functions enable and disable interrupt handling.
 Pending interrupts remain pending while handling is
 disabled */
void x86_enable_interrupts(void)
{
	__asm__ __volatile__("sti");
c04013dd:	fb                   	sti    
}
c04013de:	c3                   	ret    

c04013df <x86_disable_interrupts>:
void x86_disable_interrupts(void)
{
	__asm__ __volatile__("cli");
c04013df:	fa                   	cli    
}
c04013e0:	c3                   	ret    

c04013e1 <lowlevel_thread_switch>:


/* generic veneers */
void lowlevel_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
c04013e1:	53                   	push   %ebx
c04013e2:	83 ec 18             	sub    $0x18,%esp
#ifdef LOCK_SANITY_CHECK
	/* thread+owner process locks should be released prior to switching tasks to avoid deadlocks */
	lock_spin(&(now->lock.spinlock));
c04013e5:	8b 44 24 20          	mov    0x20(%esp),%eax
c04013e9:	83 c0 1c             	add    $0x1c,%eax
c04013ec:	83 ec 0c             	sub    $0xc,%esp
c04013ef:	50                   	push   %eax
c04013f0:	e8 6b f0 ff ff       	call   c0400460 <lock_spin>
c04013f5:	83 c4 10             	add    $0x10,%esp
	if(now->lock.owner)
c04013f8:	8b 44 24 20          	mov    0x20(%esp),%eax
c04013fc:	8b 40 20             	mov    0x20(%eax),%eax
c04013ff:	85 c0                	test   %eax,%eax
c0401401:	0f 84 8a 00 00 00    	je     c0401491 <lowlevel_thread_switch+0xb0>
	{
		thread *o = (thread *)(now->lock.owner);
c0401407:	8b 44 24 20          	mov    0x20(%esp),%eax
c040140b:	8b 40 20             	mov    0x20(%eax),%eax
c040140e:	89 44 24 08          	mov    %eax,0x8(%esp)
		dprintf("[x86:%i] switching from thread %p (tid %i pid %i) with lock %p still engaged!\n",
c0401412:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401416:	8d 58 1c             	lea    0x1c(%eax),%ebx
				  CPU_ID, now, now->tid, now->proc->pid, &(now->lock));
c0401419:	8b 44 24 20          	mov    0x20(%esp),%eax
c040141d:	8b 00                	mov    (%eax),%eax
	/* thread+owner process locks should be released prior to switching tasks to avoid deadlocks */
	lock_spin(&(now->lock.spinlock));
	if(now->lock.owner)
	{
		thread *o = (thread *)(now->lock.owner);
		dprintf("[x86:%i] switching from thread %p (tid %i pid %i) with lock %p still engaged!\n",
c040141f:	8b 08                	mov    (%eax),%ecx
c0401421:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401425:	8b 50 04             	mov    0x4(%eax),%edx
				  CPU_ID, now, now->tid, now->proc->pid, &(now->lock));
c0401428:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* thread+owner process locks should be released prior to switching tasks to avoid deadlocks */
	lock_spin(&(now->lock.spinlock));
	if(now->lock.owner)
	{
		thread *o = (thread *)(now->lock.owner);
		dprintf("[x86:%i] switching from thread %p (tid %i pid %i) with lock %p still engaged!\n",
c040142d:	3c 01                	cmp    $0x1,%al
c040142f:	76 0c                	jbe    c040143d <lowlevel_thread_switch+0x5c>
				  CPU_ID, now, now->tid, now->proc->pid, &(now->lock));
c0401431:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401436:	8b 00                	mov    (%eax),%eax
	/* thread+owner process locks should be released prior to switching tasks to avoid deadlocks */
	lock_spin(&(now->lock.spinlock));
	if(now->lock.owner)
	{
		thread *o = (thread *)(now->lock.owner);
		dprintf("[x86:%i] switching from thread %p (tid %i pid %i) with lock %p still engaged!\n",
c0401438:	c1 e8 18             	shr    $0x18,%eax
c040143b:	eb 08                	jmp    c0401445 <lowlevel_thread_switch+0x64>
c040143d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401442:	0f b6 c0             	movzbl %al,%eax
c0401445:	83 ec 08             	sub    $0x8,%esp
c0401448:	53                   	push   %ebx
c0401449:	51                   	push   %ecx
c040144a:	52                   	push   %edx
c040144b:	ff 74 24 34          	pushl  0x34(%esp)
c040144f:	50                   	push   %eax
c0401450:	68 ac dd 40 c0       	push   $0xc040ddac
c0401455:	e8 fc bf 00 00       	call   c040d456 <debug_printf>
c040145a:	83 c4 20             	add    $0x20,%esp
				  CPU_ID, now, now->tid, now->proc->pid, &(now->lock));
		dprintf("        lock owner is %p (tid %i pid %i)\n", o, o->tid, o->proc->pid);
c040145d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401461:	8b 00                	mov    (%eax),%eax
c0401463:	8b 10                	mov    (%eax),%edx
c0401465:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401469:	8b 40 04             	mov    0x4(%eax),%eax
c040146c:	52                   	push   %edx
c040146d:	50                   	push   %eax
c040146e:	ff 74 24 10          	pushl  0x10(%esp)
c0401472:	68 fc dd 40 c0       	push   $0xc040ddfc
c0401477:	e8 da bf 00 00       	call   c040d456 <debug_printf>
c040147c:	83 c4 10             	add    $0x10,%esp
		dprintf(" *** halting.\n");
c040147f:	83 ec 0c             	sub    $0xc,%esp
c0401482:	68 26 de 40 c0       	push   $0xc040de26
c0401487:	e8 ca bf 00 00       	call   c040d456 <debug_printf>
c040148c:	83 c4 10             	add    $0x10,%esp
		while(1);
c040148f:	eb fe                	jmp    c040148f <lowlevel_thread_switch+0xae>
	}
	unlock_spin(&(now->lock.spinlock));
c0401491:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401495:	83 c0 1c             	add    $0x1c,%eax
c0401498:	83 ec 0c             	sub    $0xc,%esp
c040149b:	50                   	push   %eax
c040149c:	e8 df ef ff ff       	call   c0400480 <unlock_spin>
c04014a1:	83 c4 10             	add    $0x10,%esp
	
	lock_spin(&(now->proc->lock.spinlock));
c04014a4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014a8:	8b 00                	mov    (%eax),%eax
c04014aa:	83 c0 10             	add    $0x10,%eax
c04014ad:	83 ec 0c             	sub    $0xc,%esp
c04014b0:	50                   	push   %eax
c04014b1:	e8 aa ef ff ff       	call   c0400460 <lock_spin>
c04014b6:	83 c4 10             	add    $0x10,%esp
	if(now->proc->lock.owner)
c04014b9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014bd:	8b 00                	mov    (%eax),%eax
c04014bf:	8b 40 14             	mov    0x14(%eax),%eax
c04014c2:	85 c0                	test   %eax,%eax
c04014c4:	0f 84 89 00 00 00    	je     c0401553 <lowlevel_thread_switch+0x172>
	{
		thread *o = (thread *)(now->proc->lock.owner);
c04014ca:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014ce:	8b 00                	mov    (%eax),%eax
c04014d0:	8b 40 14             	mov    0x14(%eax),%eax
c04014d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
		dprintf("[x86:%i] switching from process %p (pid %i) with lock %p still engaged!\n",
				  CPU_ID, now->proc, now->proc->pid, &(now->proc->lock));
c04014d7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014db:	8b 00                	mov    (%eax),%eax
	
	lock_spin(&(now->proc->lock.spinlock));
	if(now->proc->lock.owner)
	{
		thread *o = (thread *)(now->proc->lock.owner);
		dprintf("[x86:%i] switching from process %p (pid %i) with lock %p still engaged!\n",
c04014dd:	8d 58 10             	lea    0x10(%eax),%ebx
				  CPU_ID, now->proc, now->proc->pid, &(now->proc->lock));
c04014e0:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014e4:	8b 00                	mov    (%eax),%eax
	
	lock_spin(&(now->proc->lock.spinlock));
	if(now->proc->lock.owner)
	{
		thread *o = (thread *)(now->proc->lock.owner);
		dprintf("[x86:%i] switching from process %p (pid %i) with lock %p still engaged!\n",
c04014e6:	8b 08                	mov    (%eax),%ecx
c04014e8:	8b 44 24 20          	mov    0x20(%esp),%eax
c04014ec:	8b 10                	mov    (%eax),%edx
				  CPU_ID, now->proc, now->proc->pid, &(now->proc->lock));
c04014ee:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	lock_spin(&(now->proc->lock.spinlock));
	if(now->proc->lock.owner)
	{
		thread *o = (thread *)(now->proc->lock.owner);
		dprintf("[x86:%i] switching from process %p (pid %i) with lock %p still engaged!\n",
c04014f3:	3c 01                	cmp    $0x1,%al
c04014f5:	76 0c                	jbe    c0401503 <lowlevel_thread_switch+0x122>
				  CPU_ID, now->proc, now->proc->pid, &(now->proc->lock));
c04014f7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04014fc:	8b 00                	mov    (%eax),%eax
	
	lock_spin(&(now->proc->lock.spinlock));
	if(now->proc->lock.owner)
	{
		thread *o = (thread *)(now->proc->lock.owner);
		dprintf("[x86:%i] switching from process %p (pid %i) with lock %p still engaged!\n",
c04014fe:	c1 e8 18             	shr    $0x18,%eax
c0401501:	eb 08                	jmp    c040150b <lowlevel_thread_switch+0x12a>
c0401503:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401508:	0f b6 c0             	movzbl %al,%eax
c040150b:	83 ec 0c             	sub    $0xc,%esp
c040150e:	53                   	push   %ebx
c040150f:	51                   	push   %ecx
c0401510:	52                   	push   %edx
c0401511:	50                   	push   %eax
c0401512:	68 38 de 40 c0       	push   $0xc040de38
c0401517:	e8 3a bf 00 00       	call   c040d456 <debug_printf>
c040151c:	83 c4 20             	add    $0x20,%esp
				  CPU_ID, now->proc, now->proc->pid, &(now->proc->lock));
		dprintf("        lock owner is %p (tid %i pid %i)\n", o, o->tid, o->proc->pid);
c040151f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401523:	8b 00                	mov    (%eax),%eax
c0401525:	8b 10                	mov    (%eax),%edx
c0401527:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040152b:	8b 40 04             	mov    0x4(%eax),%eax
c040152e:	52                   	push   %edx
c040152f:	50                   	push   %eax
c0401530:	ff 74 24 14          	pushl  0x14(%esp)
c0401534:	68 fc dd 40 c0       	push   $0xc040ddfc
c0401539:	e8 18 bf 00 00       	call   c040d456 <debug_printf>
c040153e:	83 c4 10             	add    $0x10,%esp
		dprintf(" *** halting.\n");
c0401541:	83 ec 0c             	sub    $0xc,%esp
c0401544:	68 26 de 40 c0       	push   $0xc040de26
c0401549:	e8 08 bf 00 00       	call   c040d456 <debug_printf>
c040154e:	83 c4 10             	add    $0x10,%esp
		while(1);
c0401551:	eb fe                	jmp    c0401551 <lowlevel_thread_switch+0x170>
	}
	unlock_spin(&(now->proc->lock.spinlock));
c0401553:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401557:	8b 00                	mov    (%eax),%eax
c0401559:	83 c0 10             	add    $0x10,%eax
c040155c:	83 ec 0c             	sub    $0xc,%esp
c040155f:	50                   	push   %eax
c0401560:	e8 1b ef ff ff       	call   c0400480 <unlock_spin>
c0401565:	83 c4 10             	add    $0x10,%esp
#endif
	
	x86_thread_switch(now, next, regs);
c0401568:	83 ec 04             	sub    $0x4,%esp
c040156b:	ff 74 24 2c          	pushl  0x2c(%esp)
c040156f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0401573:	ff 74 24 2c          	pushl  0x2c(%esp)
c0401577:	e8 d6 f3 ff ff       	call   c0400952 <x86_thread_switch>
c040157c:	83 c4 10             	add    $0x10,%esp
}
c040157f:	83 c4 18             	add    $0x18,%esp
c0401582:	5b                   	pop    %ebx
c0401583:	c3                   	ret    

c0401584 <lowlevel_proc_preinit>:

void lowlevel_proc_preinit(void)
{
c0401584:	83 ec 0c             	sub    $0xc,%esp
	x86_proc_preinit();
c0401587:	e8 03 f3 ff ff       	call   c040088f <x86_proc_preinit>
}
c040158c:	83 c4 0c             	add    $0xc,%esp
c040158f:	c3                   	ret    

c0401590 <lowlevel_kickstart>:

void lowlevel_kickstart(void)
{
c0401590:	83 ec 0c             	sub    $0xc,%esp
	x86_kickstart();
c0401593:	e8 67 fa ff ff       	call   c0400fff <x86_kickstart>
}
c0401598:	83 c4 0c             	add    $0xc,%esp
c040159b:	c3                   	ret    

c040159c <irq_handler>:
/* irq_handler
 Master interrupt handler -- investigate and delegate
 => r = pointer to stacked registers
 */
void irq_handler(int_registers_block regs)
{	
c040159c:	83 ec 0c             	sub    $0xc,%esp
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
#endif
	
	/* make sure we only consider the low byte */
	regs.intnum &= 0xff;
c040159f:	8b 44 24 34          	mov    0x34(%esp),%eax
c04015a3:	25 ff 00 00 00       	and    $0xff,%eax
c04015a8:	89 44 24 34          	mov    %eax,0x34(%esp)

	switch(regs.intnum)
c04015ac:	8b 44 24 34          	mov    0x34(%esp),%eax
c04015b0:	83 e8 20             	sub    $0x20,%eax
c04015b3:	83 f8 20             	cmp    $0x20,%eax
c04015b6:	0f 87 2d 01 00 00    	ja     c04016e9 <irq_handler+0x14d>
c04015bc:	8b 04 85 70 df 40 c0 	mov    -0x3fbf2090(,%eax,4),%eax
c04015c3:	ff e0                	jmp    *%eax
	{
		case IRQ_IOAPIC_TIMER: /* IOAPIC IRQ 0 - timer */
			int_apic_write(LAPIC_EOI, 0); /* clear the LAPIC's interrupt */
c04015c5:	83 ec 08             	sub    $0x8,%esp
c04015c8:	6a 00                	push   $0x0
c04015ca:	68 b0 00 e0 fe       	push   $0xfee000b0
c04015cf:	e8 a6 11 00 00       	call   c040277a <int_apic_write>
c04015d4:	83 c4 10             	add    $0x10,%esp
 		case IRQ_TIMER: /* PIC IRQ 0 - timer */
			if(int_preflight_timer_flag)
c04015d7:	a0 bc 38 41 c0       	mov    0xc04138bc,%al
c04015dc:	84 c0                	test   %al,%al
c04015de:	74 44                	je     c0401624 <irq_handler+0x88>
			{
				/* we're performing pre-flight checks during boot up.
				   make a note of the LAPIC's countdown timer's current
				   count and reload */
				int_preflight_timer_lap[int_preflight_timer_pass] = (*LAPIC_TIMERNOW) / 4;
c04015e0:	a0 bd 38 41 c0       	mov    0xc04138bd,%al
c04015e5:	0f b6 c0             	movzbl %al,%eax
c04015e8:	ba 90 03 e0 fe       	mov    $0xfee00390,%edx
c04015ed:	8b 12                	mov    (%edx),%edx
c04015ef:	c1 ea 02             	shr    $0x2,%edx
c04015f2:	89 14 85 60 18 41 c0 	mov    %edx,-0x3fbee7a0(,%eax,4)
				if(int_preflight_timer_pass < 4) int_preflight_timer_pass++;
c04015f9:	a0 bd 38 41 c0       	mov    0xc04138bd,%al
c04015fe:	3c 03                	cmp    $0x3,%al
c0401600:	77 0b                	ja     c040160d <irq_handler+0x71>
c0401602:	a0 bd 38 41 c0       	mov    0xc04138bd,%al
c0401607:	40                   	inc    %eax
c0401608:	a2 bd 38 41 c0       	mov    %al,0xc04138bd
				int_apic_write(LAPIC_TIMERINIT, 0xffffffff);
c040160d:	83 ec 08             	sub    $0x8,%esp
c0401610:	6a ff                	push   $0xffffffff
c0401612:	68 80 03 e0 fe       	push   $0xfee00380
c0401617:	e8 5e 11 00 00       	call   c040277a <int_apic_write>
c040161c:	83 c4 10             	add    $0x10,%esp
			}
			else
				sched_tick(&regs); /* will call sched_pick() if needed */
			goto irq_handler_oldpic_eoi;
c040161f:	e9 64 01 00 00       	jmp    c0401788 <irq_handler+0x1ec>
				int_preflight_timer_lap[int_preflight_timer_pass] = (*LAPIC_TIMERNOW) / 4;
				if(int_preflight_timer_pass < 4) int_preflight_timer_pass++;
				int_apic_write(LAPIC_TIMERINIT, 0xffffffff);
			}
			else
				sched_tick(&regs); /* will call sched_pick() if needed */
c0401624:	83 ec 0c             	sub    $0xc,%esp
c0401627:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c040162b:	50                   	push   %eax
c040162c:	e8 d6 3a 00 00       	call   c0405107 <sched_tick>
c0401631:	83 c4 10             	add    $0x10,%esp
			goto irq_handler_oldpic_eoi;
c0401634:	e9 4f 01 00 00       	jmp    c0401788 <irq_handler+0x1ec>
			break;

		case IRQ_APIC_SPURIOUS:	
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] APIC spurious interrupt\n" DEBUG_COL_OFF, CPU_ID, regs.intnum);
c0401639:	8b 54 24 34          	mov    0x34(%esp),%edx
c040163d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401642:	3c 01                	cmp    $0x1,%al
c0401644:	76 0c                	jbe    c0401652 <irq_handler+0xb6>
c0401646:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040164b:	8b 00                	mov    (%eax),%eax
c040164d:	c1 e8 18             	shr    $0x18,%eax
c0401650:	eb 08                	jmp    c040165a <irq_handler+0xbe>
c0401652:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401657:	0f b6 c0             	movzbl %al,%eax
c040165a:	83 ec 04             	sub    $0x4,%esp
c040165d:	52                   	push   %edx
c040165e:	50                   	push   %eax
c040165f:	68 84 de 40 c0       	push   $0xc040de84
c0401664:	e8 ed bd 00 00       	call   c040d456 <debug_printf>
c0401669:	83 c4 10             	add    $0x10,%esp
#endif
			return; /* no EOI required */
c040166c:	e9 6d 01 00 00       	jmp    c04017de <irq_handler+0x242>
			
		case IRQ_APIC_TIMER:
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] APIC timer interrupt\n" DEBUG_COL_OFF, CPU_ID);
c0401671:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401676:	3c 01                	cmp    $0x1,%al
c0401678:	76 0c                	jbe    c0401686 <irq_handler+0xea>
c040167a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040167f:	8b 00                	mov    (%eax),%eax
c0401681:	c1 e8 18             	shr    $0x18,%eax
c0401684:	eb 08                	jmp    c040168e <irq_handler+0xf2>
c0401686:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040168b:	0f b6 c0             	movzbl %al,%eax
c040168e:	83 ec 08             	sub    $0x8,%esp
c0401691:	50                   	push   %eax
c0401692:	68 a8 de 40 c0       	push   $0xc040dea8
c0401697:	e8 ba bd 00 00       	call   c040d456 <debug_printf>
c040169c:	83 c4 10             	add    $0x10,%esp
#endif
			sched_tick(&regs); /* will call sched_pick() if needed */
c040169f:	83 ec 0c             	sub    $0xc,%esp
c04016a2:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c04016a6:	50                   	push   %eax
c04016a7:	e8 5b 3a 00 00       	call   c0405107 <sched_tick>
c04016ac:	83 c4 10             	add    $0x10,%esp
			goto irq_handler_apic_eoi;
c04016af:	e9 8c 00 00 00       	jmp    c0401740 <irq_handler+0x1a4>
		case IRQ_APIC_LINT1:
		case IRQ_APIC_PCINT:
		case IRQ_APIC_THERMAL:
		case IRQ_APIC_ERROR:
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] APIC interrupt: %x\n" DEBUG_COL_OFF, CPU_ID, regs.intnum);
c04016b4:	8b 54 24 34          	mov    0x34(%esp),%edx
c04016b8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04016bd:	3c 01                	cmp    $0x1,%al
c04016bf:	76 0c                	jbe    c04016cd <irq_handler+0x131>
c04016c1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04016c6:	8b 00                	mov    (%eax),%eax
c04016c8:	c1 e8 18             	shr    $0x18,%eax
c04016cb:	eb 08                	jmp    c04016d5 <irq_handler+0x139>
c04016cd:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04016d2:	0f b6 c0             	movzbl %al,%eax
c04016d5:	83 ec 04             	sub    $0x4,%esp
c04016d8:	52                   	push   %edx
c04016d9:	50                   	push   %eax
c04016da:	68 c7 de 40 c0       	push   $0xc040dec7
c04016df:	e8 72 bd 00 00       	call   c040d456 <debug_printf>
c04016e4:	83 c4 10             	add    $0x10,%esp
#endif
			goto irq_handler_apic_eoi;
c04016e7:	eb 57                	jmp    c0401740 <irq_handler+0x1a4>
			
		default:
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] unhandled interrupt %x received!\n" DEBUG_COL_OFF,
c04016e9:	8b 54 24 34          	mov    0x34(%esp),%edx
					  CPU_ID, regs.intnum);
c04016ed:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
#endif
			goto irq_handler_apic_eoi;
			
		default:
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] unhandled interrupt %x received!\n" DEBUG_COL_OFF,
c04016f2:	3c 01                	cmp    $0x1,%al
c04016f4:	76 0c                	jbe    c0401702 <irq_handler+0x166>
					  CPU_ID, regs.intnum);
c04016f6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04016fb:	8b 00                	mov    (%eax),%eax
#endif
			goto irq_handler_apic_eoi;
			
		default:
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] unhandled interrupt %x received!\n" DEBUG_COL_OFF,
c04016fd:	c1 e8 18             	shr    $0x18,%eax
c0401700:	eb 08                	jmp    c040170a <irq_handler+0x16e>
c0401702:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401707:	0f b6 c0             	movzbl %al,%eax
c040170a:	83 ec 04             	sub    $0x4,%esp
c040170d:	52                   	push   %edx
c040170e:	50                   	push   %eax
c040170f:	68 e4 de 40 c0       	push   $0xc040dee4
c0401714:	e8 3d bd 00 00       	call   c040d456 <debug_printf>
c0401719:	83 c4 10             	add    $0x10,%esp
					  CPU_ID, regs.intnum);
#endif
			/* there might be a thread of a higher-priority waiting to be run - so prod the
			   scheduler to switch to another thread if we're going to be switching back to
			   usermode */
			if(regs.eip < KERNEL_SPACE_BASE) sched_pick(&regs);
c040171c:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0401720:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0401725:	77 10                	ja     c0401737 <irq_handler+0x19b>
c0401727:	83 ec 0c             	sub    $0xc,%esp
c040172a:	8d 44 24 1c          	lea    0x1c(%esp),%eax
c040172e:	50                   	push   %eax
c040172f:	e8 c5 3b 00 00       	call   c04052f9 <sched_pick>
c0401734:	83 c4 10             	add    $0x10,%esp
			/* make sure we run the right EOI */
			if(regs.intnum < IRQ_APIC_FIRST) goto irq_handler_oldpic_eoi;
c0401737:	8b 44 24 34          	mov    0x34(%esp),%eax
c040173b:	83 f8 2f             	cmp    $0x2f,%eax
c040173e:	76 47                	jbe    c0401787 <irq_handler+0x1eb>
	}
	
irq_handler_apic_eoi:
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] acknowledging APIC interrupt (%x)\n" DEBUG_COL_OFF, CPU_ID, regs.intnum);
c0401740:	8b 54 24 34          	mov    0x34(%esp),%edx
c0401744:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401749:	3c 01                	cmp    $0x1,%al
c040174b:	76 0c                	jbe    c0401759 <irq_handler+0x1bd>
c040174d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401752:	8b 00                	mov    (%eax),%eax
c0401754:	c1 e8 18             	shr    $0x18,%eax
c0401757:	eb 08                	jmp    c0401761 <irq_handler+0x1c5>
c0401759:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040175e:	0f b6 c0             	movzbl %al,%eax
c0401761:	83 ec 04             	sub    $0x4,%esp
c0401764:	52                   	push   %edx
c0401765:	50                   	push   %eax
c0401766:	68 10 df 40 c0       	push   $0xc040df10
c040176b:	e8 e6 bc 00 00       	call   c040d456 <debug_printf>
c0401770:	83 c4 10             	add    $0x10,%esp
#endif
	int_apic_write(LAPIC_EOI, 0); /* clear the interrupt */
c0401773:	83 ec 08             	sub    $0x8,%esp
c0401776:	6a 00                	push   $0x0
c0401778:	68 b0 00 e0 fe       	push   $0xfee000b0
c040177d:	e8 f8 0f 00 00       	call   c040277a <int_apic_write>
c0401782:	83 c4 10             	add    $0x10,%esp

#ifdef PERFORMANCE_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] hardware interrupt %x took about %i cycles to process\n" DEBUG_COL_OFF, CPU_ID, regs.intnum,
			  (unsigned int)(x86_read_cyclecount() - debug_cycles));
#endif
	return;
c0401785:	eb 57                	jmp    c04017de <irq_handler+0x242>
			/* there might be a thread of a higher-priority waiting to be run - so prod the
			   scheduler to switch to another thread if we're going to be switching back to
			   usermode */
			if(regs.eip < KERNEL_SPACE_BASE) sched_pick(&regs);
			/* make sure we run the right EOI */
			if(regs.intnum < IRQ_APIC_FIRST) goto irq_handler_oldpic_eoi;
c0401787:	90                   	nop
#endif
	return;
	
irq_handler_oldpic_eoi:
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] acknowledging old-world interrupt (%x)\n" DEBUG_COL_OFF, CPU_ID, regs.intnum);
c0401788:	8b 54 24 34          	mov    0x34(%esp),%edx
c040178c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401791:	3c 01                	cmp    $0x1,%al
c0401793:	76 0c                	jbe    c04017a1 <irq_handler+0x205>
c0401795:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040179a:	8b 00                	mov    (%eax),%eax
c040179c:	c1 e8 18             	shr    $0x18,%eax
c040179f:	eb 08                	jmp    c04017a9 <irq_handler+0x20d>
c04017a1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04017a6:	0f b6 c0             	movzbl %al,%eax
c04017a9:	83 ec 04             	sub    $0x4,%esp
c04017ac:	52                   	push   %edx
c04017ad:	50                   	push   %eax
c04017ae:	68 3c df 40 c0       	push   $0xc040df3c
c04017b3:	e8 9e bc 00 00       	call   c040d456 <debug_printf>
c04017b8:	83 c4 10             	add    $0x10,%esp
#endif
	/* send an end-of-interrupt signal to the PICs */
	if(regs.intnum >= 40)
c04017bb:	8b 44 24 34          	mov    0x34(%esp),%eax
c04017bf:	83 f8 27             	cmp    $0x27,%eax
c04017c2:	76 0d                	jbe    c04017d1 <irq_handler+0x235>
		x86_pic_reset(2); /* reset the slave if necessary */
c04017c4:	83 ec 0c             	sub    $0xc,%esp
c04017c7:	6a 02                	push   $0x2
c04017c9:	e8 de fb ff ff       	call   c04013ac <x86_pic_reset>
c04017ce:	83 c4 10             	add    $0x10,%esp
	x86_pic_reset(1); /* as well as the master */
c04017d1:	83 ec 0c             	sub    $0xc,%esp
c04017d4:	6a 01                	push   $0x1
c04017d6:	e8 d1 fb ff ff       	call   c04013ac <x86_pic_reset>
c04017db:	83 c4 10             	add    $0x10,%esp

#ifdef PERFORMANCE_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] hardware interrupt %x took about %i cycles to process\n" DEBUG_COL_OFF, CPU_ID, regs.intnum,
			  (unsigned int)(x86_read_cyclecount() - debug_cycles));
#endif
}
c04017de:	83 c4 0c             	add    $0xc,%esp
c04017e1:	c3                   	ret    

c04017e2 <int_handler>:
/* int_handler
	Master exception handler -- investigate and delegate
	=> regs = pointer to stacked registers
*/
void int_handler(int_registers_block regs)
{
c04017e2:	55                   	push   %ebp
c04017e3:	57                   	push   %edi
c04017e4:	56                   	push   %esi
c04017e5:	53                   	push   %ebx
c04017e6:	83 ec 7c             	sub    $0x7c,%esp
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
#endif

#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] IN: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c04017e9:	8b 94 24 cc 00 00 00 	mov    0xcc(%esp),%edx
c04017f0:	8b 9c 24 c8 00 00 00 	mov    0xc8(%esp),%ebx
c04017f7:	8b bc 24 c4 00 00 00 	mov    0xc4(%esp),%edi
c04017fe:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
c0401805:	89 44 24 08          	mov    %eax,0x8(%esp)
c0401809:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
c0401810:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0401814:	8b 84 24 b8 00 00 00 	mov    0xb8(%esp),%eax
c040181b:	89 44 24 10          	mov    %eax,0x10(%esp)
c040181f:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
c0401826:	89 44 24 14          	mov    %eax,0x14(%esp)
c040182a:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
c0401831:	89 44 24 18          	mov    %eax,0x18(%esp)
c0401835:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
c040183c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0401840:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
c0401847:	89 44 24 20          	mov    %eax,0x20(%esp)
c040184b:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
c0401852:	89 44 24 24          	mov    %eax,0x24(%esp)
c0401856:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
c040185d:	89 44 24 28          	mov    %eax,0x28(%esp)
c0401861:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
c0401868:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c040186c:	8b ac 24 98 00 00 00 	mov    0x98(%esp),%ebp
c0401873:	8b b4 24 94 00 00 00 	mov    0x94(%esp),%esi
c040187a:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
			  CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
c0401881:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
#endif

#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] IN: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c0401886:	3c 01                	cmp    $0x1,%al
c0401888:	76 0c                	jbe    c0401896 <int_handler+0xb4>
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
			  CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
c040188a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040188f:	8b 00                	mov    (%eax),%eax
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
#endif

#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] IN: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c0401891:	c1 e8 18             	shr    $0x18,%eax
c0401894:	eb 08                	jmp    c040189e <int_handler+0xbc>
c0401896:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040189b:	0f b6 c0             	movzbl %al,%eax
c040189e:	83 ec 08             	sub    $0x8,%esp
c04018a1:	52                   	push   %edx
c04018a2:	53                   	push   %ebx
c04018a3:	57                   	push   %edi
c04018a4:	ff 74 24 1c          	pushl  0x1c(%esp)
c04018a8:	ff 74 24 24          	pushl  0x24(%esp)
c04018ac:	ff 74 24 2c          	pushl  0x2c(%esp)
c04018b0:	ff 74 24 34          	pushl  0x34(%esp)
c04018b4:	ff 74 24 3c          	pushl  0x3c(%esp)
c04018b8:	ff 74 24 44          	pushl  0x44(%esp)
c04018bc:	ff 74 24 4c          	pushl  0x4c(%esp)
c04018c0:	ff 74 24 54          	pushl  0x54(%esp)
c04018c4:	ff 74 24 5c          	pushl  0x5c(%esp)
c04018c8:	ff 74 24 64          	pushl  0x64(%esp)
c04018cc:	55                   	push   %ebp
c04018cd:	56                   	push   %esi
c04018ce:	51                   	push   %ecx
c04018cf:	50                   	push   %eax
c04018d0:	68 f4 df 40 c0       	push   $0xc040dff4
c04018d5:	e8 7c bb 00 00       	call   c040d456 <debug_printf>
c04018da:	83 c4 50             	add    $0x50,%esp
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
			  CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
			  regs.intnum, regs.errcode, regs.eip, regs.cs, regs.eflags, regs.useresp, regs.ss);
#endif
	
	regs.intnum &= 0xff; /* just interested in the byte */
c04018dd:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
c04018e4:	25 ff 00 00 00       	and    $0xff,%eax
c04018e9:	89 84 24 b4 00 00 00 	mov    %eax,0xb4(%esp)
	
	switch(regs.intnum)
c04018f0:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
c04018f7:	83 f8 0d             	cmp    $0xd,%eax
c04018fa:	0f 84 e7 00 00 00    	je     c04019e7 <int_handler+0x205>
c0401900:	83 f8 0d             	cmp    $0xd,%eax
c0401903:	77 0a                	ja     c040190f <int_handler+0x12d>
c0401905:	83 f8 08             	cmp    $0x8,%eax
c0401908:	74 1e                	je     c0401928 <int_handler+0x146>
c040190a:	e9 0d 06 00 00       	jmp    c0401f1c <int_handler+0x73a>
c040190f:	83 f8 0e             	cmp    $0xe,%eax
c0401912:	0f 84 5c 03 00 00    	je     c0401c74 <int_handler+0x492>
c0401918:	3d 90 00 00 00       	cmp    $0x90,%eax
c040191d:	0f 84 67 04 00 00    	je     c0401d8a <int_handler+0x5a8>
c0401923:	e9 f4 05 00 00       	jmp    c0401f1c <int_handler+0x73a>
	{
		/* cpu exceptions */
		case INT_DOUBLEF: /* DOUBLE FAULT */
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] DOUBLE FAULT: code %i (%x)\n" DEBUG_COL_OFF,
c0401928:	8b 84 24 b8 00 00 00 	mov    0xb8(%esp),%eax
c040192f:	0f b7 c8             	movzwl %ax,%ecx
c0401932:	8b 94 24 b8 00 00 00 	mov    0xb8(%esp),%edx
					  CPU_ID, regs.errcode, regs.errcode & ((1 << 16) - 1));
c0401939:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	switch(regs.intnum)
	{
		/* cpu exceptions */
		case INT_DOUBLEF: /* DOUBLE FAULT */
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] DOUBLE FAULT: code %i (%x)\n" DEBUG_COL_OFF,
c040193e:	3c 01                	cmp    $0x1,%al
c0401940:	76 0c                	jbe    c040194e <int_handler+0x16c>
					  CPU_ID, regs.errcode, regs.errcode & ((1 << 16) - 1));
c0401942:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401947:	8b 00                	mov    (%eax),%eax
	switch(regs.intnum)
	{
		/* cpu exceptions */
		case INT_DOUBLEF: /* DOUBLE FAULT */
#ifdef INT_DEBUG
			dprintf(DEBUG_COL_INT "[int:%i] DOUBLE FAULT: code %i (%x)\n" DEBUG_COL_OFF,
c0401949:	c1 e8 18             	shr    $0x18,%eax
c040194c:	eb 08                	jmp    c0401956 <int_handler+0x174>
c040194e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401953:	0f b6 c0             	movzbl %al,%eax
c0401956:	51                   	push   %ecx
c0401957:	52                   	push   %edx
c0401958:	50                   	push   %eax
c0401959:	68 84 e0 40 c0       	push   $0xc040e084
c040195e:	e8 f3 ba 00 00       	call   c040d456 <debug_printf>
c0401963:	83 c4 10             	add    $0x10,%esp
					  CPU_ID, regs.errcode, regs.errcode & ((1 << 16) - 1));
#endif
			proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c0401966:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040196c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401971:	3c 01                	cmp    $0x1,%al
c0401973:	76 0f                	jbe    c0401984 <int_handler+0x1a2>
c0401975:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040197a:	8b 00                	mov    (%eax),%eax
c040197c:	c1 e8 18             	shr    $0x18,%eax
c040197f:	c1 e0 06             	shl    $0x6,%eax
c0401982:	eb 0b                	jmp    c040198f <int_handler+0x1ad>
c0401984:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401989:	0f b6 c0             	movzbl %al,%eax
c040198c:	c1 e0 06             	shl    $0x6,%eax
c040198f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401992:	8b 40 04             	mov    0x4(%eax),%eax
c0401995:	8b 10                	mov    (%eax),%edx
c0401997:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c040199d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04019a2:	3c 01                	cmp    $0x1,%al
c04019a4:	76 0f                	jbe    c04019b5 <int_handler+0x1d3>
c04019a6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04019ab:	8b 00                	mov    (%eax),%eax
c04019ad:	c1 e8 18             	shr    $0x18,%eax
c04019b0:	c1 e0 06             	shl    $0x6,%eax
c04019b3:	eb 0b                	jmp    c04019c0 <int_handler+0x1de>
c04019b5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04019ba:	0f b6 c0             	movzbl %al,%eax
c04019bd:	c1 e0 06             	shl    $0x6,%eax
c04019c0:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04019c3:	8b 40 04             	mov    0x4(%eax),%eax
c04019c6:	8b 00                	mov    (%eax),%eax
c04019c8:	8b 00                	mov    (%eax),%eax
c04019ca:	83 ec 08             	sub    $0x8,%esp
c04019cd:	52                   	push   %edx
c04019ce:	50                   	push   %eax
c04019cf:	e8 03 9f 00 00       	call   c040b8d7 <proc_kill>
c04019d4:	83 c4 10             	add    $0x10,%esp
			regs.eip = 0; /* force a sched_pick() call */
c04019d7:	c7 84 24 bc 00 00 00 	movl   $0x0,0xbc(%esp)
c04019de:	00 00 00 00 
			break;
c04019e2:	e9 79 05 00 00       	jmp    c0401f60 <int_handler+0x77e>
			
		case INT_GPF: /* GENERAL PROTECTION FAULT */
			if(regs.eip > KERNEL_SPACE_BASE)
c04019e7:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
c04019ee:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c04019f3:	0f 86 cf 00 00 00    	jbe    c0401ac8 <int_handler+0x2e6>
			{
				dprintf(DEBUG_COL_INT "[int:%i] GPF: code %i (0x%x) eip %x\n" DEBUG_COL_OFF
c04019f9:	8b 94 24 cc 00 00 00 	mov    0xcc(%esp),%edx
c0401a00:	8b 9c 24 c8 00 00 00 	mov    0xc8(%esp),%ebx
c0401a07:	8b bc 24 c4 00 00 00 	mov    0xc4(%esp),%edi
c0401a0e:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
c0401a15:	89 44 24 30          	mov    %eax,0x30(%esp)
c0401a19:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
c0401a20:	89 44 24 34          	mov    %eax,0x34(%esp)
c0401a24:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
c0401a2b:	89 44 24 38          	mov    %eax,0x38(%esp)
c0401a2f:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
c0401a36:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0401a3a:	8b 84 24 94 00 00 00 	mov    0x94(%esp),%eax
c0401a41:	89 44 24 40          	mov    %eax,0x40(%esp)
c0401a45:	8b 84 24 90 00 00 00 	mov    0x90(%esp),%eax
c0401a4c:	89 44 24 44          	mov    %eax,0x44(%esp)
c0401a50:	8b ac 24 bc 00 00 00 	mov    0xbc(%esp),%ebp
c0401a57:	8b b4 24 b8 00 00 00 	mov    0xb8(%esp),%esi
c0401a5e:	8b 8c 24 b8 00 00 00 	mov    0xb8(%esp),%ecx
						  "      ds %x edi %x ebp %x esp %x\n" DEBUG_COL_OFF
						  "      eax %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
						  CPU_ID, regs.errcode, regs.errcode, regs.eip,
c0401a65:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
			break;
			
		case INT_GPF: /* GENERAL PROTECTION FAULT */
			if(regs.eip > KERNEL_SPACE_BASE)
			{
				dprintf(DEBUG_COL_INT "[int:%i] GPF: code %i (0x%x) eip %x\n" DEBUG_COL_OFF
c0401a6a:	3c 01                	cmp    $0x1,%al
c0401a6c:	76 0c                	jbe    c0401a7a <int_handler+0x298>
						  "      ds %x edi %x ebp %x esp %x\n" DEBUG_COL_OFF
						  "      eax %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
						  CPU_ID, regs.errcode, regs.errcode, regs.eip,
c0401a6e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401a73:	8b 00                	mov    (%eax),%eax
			break;
			
		case INT_GPF: /* GENERAL PROTECTION FAULT */
			if(regs.eip > KERNEL_SPACE_BASE)
			{
				dprintf(DEBUG_COL_INT "[int:%i] GPF: code %i (0x%x) eip %x\n" DEBUG_COL_OFF
c0401a75:	c1 e8 18             	shr    $0x18,%eax
c0401a78:	eb 08                	jmp    c0401a82 <int_handler+0x2a0>
c0401a7a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401a7f:	0f b6 c0             	movzbl %al,%eax
c0401a82:	83 ec 08             	sub    $0x8,%esp
c0401a85:	52                   	push   %edx
c0401a86:	53                   	push   %ebx
c0401a87:	57                   	push   %edi
c0401a88:	ff 74 24 44          	pushl  0x44(%esp)
c0401a8c:	ff 74 24 4c          	pushl  0x4c(%esp)
c0401a90:	ff 74 24 54          	pushl  0x54(%esp)
c0401a94:	ff 74 24 5c          	pushl  0x5c(%esp)
c0401a98:	ff 74 24 64          	pushl  0x64(%esp)
c0401a9c:	ff 74 24 6c          	pushl  0x6c(%esp)
c0401aa0:	55                   	push   %ebp
c0401aa1:	56                   	push   %esi
c0401aa2:	51                   	push   %ecx
c0401aa3:	50                   	push   %eax
c0401aa4:	68 ac e0 40 c0       	push   $0xc040e0ac
c0401aa9:	e8 a8 b9 00 00       	call   c040d456 <debug_printf>
c0401aae:	83 c4 40             	add    $0x40,%esp
						  "      ds %x edi %x ebp %x esp %x\n" DEBUG_COL_OFF
						  "      eax %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
						  CPU_ID, regs.errcode, regs.errcode, regs.eip,
						  regs.ds, regs.edi, regs.ebp, regs.esp,
						  regs.eax, regs.cs, regs.eflags, regs.useresp, regs.ss);
				debug_stacktrace();
c0401ab1:	e8 bd b2 00 00       	call   c040cd73 <debug_stacktrace>
				dprintf("*** panic: unhandled serious fault in the kernel. halting.\n" DEBUG_COL_OFF);
c0401ab6:	83 ec 0c             	sub    $0xc,%esp
c0401ab9:	68 20 e1 40 c0       	push   $0xc040e120
c0401abe:	e8 93 b9 00 00       	call   c040d456 <debug_printf>
c0401ac3:	83 c4 10             	add    $0x10,%esp
				while(1);
c0401ac6:	eb fe                	jmp    c0401ac6 <int_handler+0x2e4>
			else
			{
				/* if this process was already trying to handle a GPF then kill it.
				   the kernel's signal code in msg.c will clear this bit when the
				   thread next */
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGBUS))
c0401ac8:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401ace:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401ad3:	3c 01                	cmp    $0x1,%al
c0401ad5:	76 0f                	jbe    c0401ae6 <int_handler+0x304>
c0401ad7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401adc:	8b 00                	mov    (%eax),%eax
c0401ade:	c1 e8 18             	shr    $0x18,%eax
c0401ae1:	c1 e0 06             	shl    $0x6,%eax
c0401ae4:	eb 0b                	jmp    c0401af1 <int_handler+0x30f>
c0401ae6:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401aeb:	0f b6 c0             	movzbl %al,%eax
c0401aee:	c1 e0 06             	shl    $0x6,%eax
c0401af1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401af4:	8b 40 04             	mov    0x4(%eax),%eax
c0401af7:	8b 00                	mov    (%eax),%eax
c0401af9:	8b 40 58             	mov    0x58(%eax),%eax
c0401afc:	25 00 04 00 00       	and    $0x400,%eax
c0401b01:	85 c0                	test   %eax,%eax
c0401b03:	74 76                	je     c0401b7b <int_handler+0x399>
					proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c0401b05:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401b0b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401b10:	3c 01                	cmp    $0x1,%al
c0401b12:	76 0f                	jbe    c0401b23 <int_handler+0x341>
c0401b14:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401b19:	8b 00                	mov    (%eax),%eax
c0401b1b:	c1 e8 18             	shr    $0x18,%eax
c0401b1e:	c1 e0 06             	shl    $0x6,%eax
c0401b21:	eb 0b                	jmp    c0401b2e <int_handler+0x34c>
c0401b23:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401b28:	0f b6 c0             	movzbl %al,%eax
c0401b2b:	c1 e0 06             	shl    $0x6,%eax
c0401b2e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401b31:	8b 40 04             	mov    0x4(%eax),%eax
c0401b34:	8b 10                	mov    (%eax),%edx
c0401b36:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c0401b3c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401b41:	3c 01                	cmp    $0x1,%al
c0401b43:	76 0f                	jbe    c0401b54 <int_handler+0x372>
c0401b45:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401b4a:	8b 00                	mov    (%eax),%eax
c0401b4c:	c1 e8 18             	shr    $0x18,%eax
c0401b4f:	c1 e0 06             	shl    $0x6,%eax
c0401b52:	eb 0b                	jmp    c0401b5f <int_handler+0x37d>
c0401b54:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401b59:	0f b6 c0             	movzbl %al,%eax
c0401b5c:	c1 e0 06             	shl    $0x6,%eax
c0401b5f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0401b62:	8b 40 04             	mov    0x4(%eax),%eax
c0401b65:	8b 00                	mov    (%eax),%eax
c0401b67:	8b 00                	mov    (%eax),%eax
c0401b69:	83 ec 08             	sub    $0x8,%esp
c0401b6c:	52                   	push   %edx
c0401b6d:	50                   	push   %eax
c0401b6e:	e8 64 9d 00 00       	call   c040b8d7 <proc_kill>
c0401b73:	83 c4 10             	add    $0x10,%esp
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				}
			}
			break;
c0401b76:	e9 e5 03 00 00       	jmp    c0401f60 <int_handler+0x77e>
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGBUS))
					proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				else
				{
					/* mark this process as attempting to handle the fault */
					cpu_table[CPU_ID].current->proc->signalsinprogress |= (1 << SIGBUS);
c0401b7b:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401b81:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401b86:	3c 01                	cmp    $0x1,%al
c0401b88:	76 0f                	jbe    c0401b99 <int_handler+0x3b7>
c0401b8a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401b8f:	8b 00                	mov    (%eax),%eax
c0401b91:	c1 e8 18             	shr    $0x18,%eax
c0401b94:	c1 e0 06             	shl    $0x6,%eax
c0401b97:	eb 0b                	jmp    c0401ba4 <int_handler+0x3c2>
c0401b99:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401b9e:	0f b6 c0             	movzbl %al,%eax
c0401ba1:	c1 e0 06             	shl    $0x6,%eax
c0401ba4:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401ba7:	8b 40 04             	mov    0x4(%eax),%eax
c0401baa:	8b 00                	mov    (%eax),%eax
c0401bac:	8b 50 58             	mov    0x58(%eax),%edx
c0401baf:	80 ce 04             	or     $0x4,%dh
c0401bb2:	89 50 58             	mov    %edx,0x58(%eax)
					
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
c0401bb5:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401bbb:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401bc0:	3c 01                	cmp    $0x1,%al
c0401bc2:	76 0f                	jbe    c0401bd3 <int_handler+0x3f1>
c0401bc4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401bc9:	8b 00                	mov    (%eax),%eax
c0401bcb:	c1 e8 18             	shr    $0x18,%eax
c0401bce:	c1 e0 06             	shl    $0x6,%eax
c0401bd1:	eb 0b                	jmp    c0401bde <int_handler+0x3fc>
c0401bd3:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401bd8:	0f b6 c0             	movzbl %al,%eax
c0401bdb:	c1 e0 06             	shl    $0x6,%eax
c0401bde:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401be1:	8b 40 04             	mov    0x4(%eax),%eax
c0401be4:	8b 00                	mov    (%eax),%eax
c0401be6:	83 ec 04             	sub    $0x4,%esp
c0401be9:	6a 00                	push   $0x0
c0401beb:	6a 0a                	push   $0xa
c0401bed:	50                   	push   %eax
c0401bee:	e8 b5 25 00 00       	call   c04041a8 <msg_send_signal>
c0401bf3:	83 c4 10             	add    $0x10,%esp
c0401bf6:	85 c0                	test   %eax,%eax
c0401bf8:	0f 84 5b 03 00 00    	je     c0401f59 <int_handler+0x777>
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c0401bfe:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401c04:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401c09:	3c 01                	cmp    $0x1,%al
c0401c0b:	76 0f                	jbe    c0401c1c <int_handler+0x43a>
c0401c0d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401c12:	8b 00                	mov    (%eax),%eax
c0401c14:	c1 e8 18             	shr    $0x18,%eax
c0401c17:	c1 e0 06             	shl    $0x6,%eax
c0401c1a:	eb 0b                	jmp    c0401c27 <int_handler+0x445>
c0401c1c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401c21:	0f b6 c0             	movzbl %al,%eax
c0401c24:	c1 e0 06             	shl    $0x6,%eax
c0401c27:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401c2a:	8b 40 04             	mov    0x4(%eax),%eax
c0401c2d:	8b 10                	mov    (%eax),%edx
c0401c2f:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c0401c35:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401c3a:	3c 01                	cmp    $0x1,%al
c0401c3c:	76 0f                	jbe    c0401c4d <int_handler+0x46b>
c0401c3e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401c43:	8b 00                	mov    (%eax),%eax
c0401c45:	c1 e8 18             	shr    $0x18,%eax
c0401c48:	c1 e0 06             	shl    $0x6,%eax
c0401c4b:	eb 0b                	jmp    c0401c58 <int_handler+0x476>
c0401c4d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401c52:	0f b6 c0             	movzbl %al,%eax
c0401c55:	c1 e0 06             	shl    $0x6,%eax
c0401c58:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0401c5b:	8b 40 04             	mov    0x4(%eax),%eax
c0401c5e:	8b 00                	mov    (%eax),%eax
c0401c60:	8b 00                	mov    (%eax),%eax
c0401c62:	83 ec 08             	sub    $0x8,%esp
c0401c65:	52                   	push   %edx
c0401c66:	50                   	push   %eax
c0401c67:	e8 6b 9c 00 00       	call   c040b8d7 <proc_kill>
c0401c6c:	83 c4 10             	add    $0x10,%esp
				}
			}
			break;
c0401c6f:	e9 ec 02 00 00       	jmp    c0401f60 <int_handler+0x77e>
			
		case INT_PF: /* PAGE FAULT */
			if(pg_fault(&regs))
c0401c74:	83 ec 0c             	sub    $0xc,%esp
c0401c77:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401c7e:	50                   	push   %eax
c0401c7f:	e8 cc 79 00 00       	call   c0409650 <pg_fault>
c0401c84:	83 c4 10             	add    $0x10,%esp
c0401c87:	85 c0                	test   %eax,%eax
c0401c89:	0f 84 cd 02 00 00    	je     c0401f5c <int_handler+0x77a>
			/* something went wrong, so default action is to kill
			   the process - pg_fault() doesn't return if the kernel
			   hits an unhandled page fault */
			{
				/* kill the process if it in the middle of trying to fix-up a page fault */
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGSEGV))
c0401c8f:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401c95:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401c9a:	3c 01                	cmp    $0x1,%al
c0401c9c:	76 0f                	jbe    c0401cad <int_handler+0x4cb>
c0401c9e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401ca3:	8b 00                	mov    (%eax),%eax
c0401ca5:	c1 e8 18             	shr    $0x18,%eax
c0401ca8:	c1 e0 06             	shl    $0x6,%eax
c0401cab:	eb 0b                	jmp    c0401cb8 <int_handler+0x4d6>
c0401cad:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401cb2:	0f b6 c0             	movzbl %al,%eax
c0401cb5:	c1 e0 06             	shl    $0x6,%eax
c0401cb8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401cbb:	8b 40 04             	mov    0x4(%eax),%eax
c0401cbe:	8b 00                	mov    (%eax),%eax
c0401cc0:	8b 40 58             	mov    0x58(%eax),%eax
c0401cc3:	25 00 08 00 00       	and    $0x800,%eax
c0401cc8:	85 c0                	test   %eax,%eax
c0401cca:	74 18                	je     c0401ce4 <int_handler+0x502>
					syscall_do_exit(&regs);
c0401ccc:	83 ec 0c             	sub    $0xc,%esp
c0401ccf:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401cd6:	50                   	push   %eax
c0401cd7:	e8 b8 15 00 00       	call   c0403294 <syscall_do_exit>
c0401cdc:	83 c4 10             	add    $0x10,%esp
						regs.eax = POSIX_GENERIC_FAILURE;
						syscall_do_exit(&regs);
					}
				}
			}
			break;
c0401cdf:	e9 7c 02 00 00       	jmp    c0401f60 <int_handler+0x77e>
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGSEGV))
					syscall_do_exit(&regs);
				else
				{
					/* mark this process as attempting to handle the fault */
					cpu_table[CPU_ID].current->proc->signalsinprogress |= (1 << SIGSEGV);			
c0401ce4:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401cea:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401cef:	3c 01                	cmp    $0x1,%al
c0401cf1:	76 0f                	jbe    c0401d02 <int_handler+0x520>
c0401cf3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401cf8:	8b 00                	mov    (%eax),%eax
c0401cfa:	c1 e8 18             	shr    $0x18,%eax
c0401cfd:	c1 e0 06             	shl    $0x6,%eax
c0401d00:	eb 0b                	jmp    c0401d0d <int_handler+0x52b>
c0401d02:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401d07:	0f b6 c0             	movzbl %al,%eax
c0401d0a:	c1 e0 06             	shl    $0x6,%eax
c0401d0d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401d10:	8b 40 04             	mov    0x4(%eax),%eax
c0401d13:	8b 00                	mov    (%eax),%eax
c0401d15:	8b 50 58             	mov    0x58(%eax),%edx
c0401d18:	80 ce 08             	or     $0x8,%dh
c0401d1b:	89 50 58             	mov    %edx,0x58(%eax)
	
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGSEGV, 0))
c0401d1e:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401d24:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401d29:	3c 01                	cmp    $0x1,%al
c0401d2b:	76 0f                	jbe    c0401d3c <int_handler+0x55a>
c0401d2d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401d32:	8b 00                	mov    (%eax),%eax
c0401d34:	c1 e8 18             	shr    $0x18,%eax
c0401d37:	c1 e0 06             	shl    $0x6,%eax
c0401d3a:	eb 0b                	jmp    c0401d47 <int_handler+0x565>
c0401d3c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401d41:	0f b6 c0             	movzbl %al,%eax
c0401d44:	c1 e0 06             	shl    $0x6,%eax
c0401d47:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401d4a:	8b 40 04             	mov    0x4(%eax),%eax
c0401d4d:	8b 00                	mov    (%eax),%eax
c0401d4f:	83 ec 04             	sub    $0x4,%esp
c0401d52:	6a 00                	push   $0x0
c0401d54:	6a 0b                	push   $0xb
c0401d56:	50                   	push   %eax
c0401d57:	e8 4c 24 00 00       	call   c04041a8 <msg_send_signal>
c0401d5c:	83 c4 10             	add    $0x10,%esp
c0401d5f:	85 c0                	test   %eax,%eax
c0401d61:	0f 84 f8 01 00 00    	je     c0401f5f <int_handler+0x77d>
					{
						/* something went wrong, so shoot to kill */
						regs.eax = POSIX_GENERIC_FAILURE;
c0401d67:	c7 84 24 b0 00 00 00 	movl   $0xffffffff,0xb0(%esp)
c0401d6e:	ff ff ff ff 
						syscall_do_exit(&regs);
c0401d72:	83 ec 0c             	sub    $0xc,%esp
c0401d75:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401d7c:	50                   	push   %eax
c0401d7d:	e8 12 15 00 00       	call   c0403294 <syscall_do_exit>
c0401d82:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			break;
c0401d85:	e9 d6 01 00 00       	jmp    c0401f60 <int_handler+0x77e>

		case INT_KERNEL_SWI: /* KERNEL SYSTEM CALL */
			/* kernel swi number in edx, params in eax-ecx */
			switch(regs.edx)
c0401d8a:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
c0401d91:	83 f8 08             	cmp    $0x8,%eax
c0401d94:	0f 87 e1 00 00 00    	ja     c0401e7b <int_handler+0x699>
c0401d9a:	8b 04 85 54 e2 40 c0 	mov    -0x3fbf1dac(,%eax,4),%eax
c0401da1:	ff e0                	jmp    *%eax
			{
				case SYSCALL_EXIT:
					syscall_do_exit(&regs);
c0401da3:	83 ec 0c             	sub    $0xc,%esp
c0401da6:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401dad:	50                   	push   %eax
c0401dae:	e8 e1 14 00 00       	call   c0403294 <syscall_do_exit>
c0401db3:	83 c4 10             	add    $0x10,%esp
					break;
c0401db6:	e9 5f 01 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_FORK:
					syscall_do_fork(&regs);
c0401dbb:	83 ec 0c             	sub    $0xc,%esp
c0401dbe:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401dc5:	50                   	push   %eax
c0401dc6:	e8 1d 16 00 00       	call   c04033e8 <syscall_do_fork>
c0401dcb:	83 c4 10             	add    $0x10,%esp
					break;
c0401dce:	e9 47 01 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_KILL:
					syscall_do_kill(&regs);
c0401dd3:	83 ec 0c             	sub    $0xc,%esp
c0401dd6:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401ddd:	50                   	push   %eax
c0401dde:	e8 0f 18 00 00       	call   c04035f2 <syscall_do_kill>
c0401de3:	83 c4 10             	add    $0x10,%esp
					break;
c0401de6:	e9 2f 01 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_YIELD:
					syscall_do_yield(&regs);
c0401deb:	83 ec 0c             	sub    $0xc,%esp
c0401dee:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401df5:	50                   	push   %eax
c0401df6:	e8 80 19 00 00       	call   c040377b <syscall_do_yield>
c0401dfb:	83 c4 10             	add    $0x10,%esp
					break; /* we will poke the scheduler below */
c0401dfe:	e9 17 01 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_THREAD_EXIT:
					syscall_do_thread_exit(&regs);
c0401e03:	83 ec 0c             	sub    $0xc,%esp
c0401e06:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401e0d:	50                   	push   %eax
c0401e0e:	e8 ca 1a 00 00       	call   c04038dd <syscall_do_thread_exit>
c0401e13:	83 c4 10             	add    $0x10,%esp
					break;
c0401e16:	e9 ff 00 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_THREAD_FORK:
					syscall_do_thread_fork(&regs);
c0401e1b:	83 ec 0c             	sub    $0xc,%esp
c0401e1e:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401e25:	50                   	push   %eax
c0401e26:	e8 8a 1c 00 00       	call   c0403ab5 <syscall_do_thread_fork>
c0401e2b:	83 c4 10             	add    $0x10,%esp
					break;
c0401e2e:	e9 e7 00 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_THREAD_KILL:
					syscall_do_thread_kill(&regs);
c0401e33:	83 ec 0c             	sub    $0xc,%esp
c0401e36:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401e3d:	50                   	push   %eax
c0401e3e:	e8 bb 1e 00 00       	call   c0403cfe <syscall_do_thread_kill>
c0401e43:	83 c4 10             	add    $0x10,%esp
					break;
c0401e46:	e9 cf 00 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_MSG_SEND:
					syscall_do_msg_send(&regs);
c0401e4b:	83 ec 0c             	sub    $0xc,%esp
c0401e4e:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401e55:	50                   	push   %eax
c0401e56:	e8 a9 20 00 00       	call   c0403f04 <syscall_do_msg_send>
c0401e5b:	83 c4 10             	add    $0x10,%esp
					break;
c0401e5e:	e9 b7 00 00 00       	jmp    c0401f1a <int_handler+0x738>
					
				case SYSCALL_MSG_RECV:
					syscall_do_msg_recv(&regs);
c0401e63:	83 ec 0c             	sub    $0xc,%esp
c0401e66:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401e6d:	50                   	push   %eax
c0401e6e:	e8 e2 21 00 00       	call   c0404055 <syscall_do_msg_recv>
c0401e73:	83 c4 10             	add    $0x10,%esp
					break;
c0401e76:	e9 9f 00 00 00       	jmp    c0401f1a <int_handler+0x738>
		
#ifdef INT_DEBUG
				default:
					dprintf(DEBUG_COL_INT "[int:%i] unknown syscall %x by thread %i in process %i\n" DEBUG_COL_OFF, CPU_ID, regs.edx,
							  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->pid);
c0401e7b:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401e81:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401e86:	3c 01                	cmp    $0x1,%al
c0401e88:	76 0f                	jbe    c0401e99 <int_handler+0x6b7>
c0401e8a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401e8f:	8b 00                	mov    (%eax),%eax
c0401e91:	c1 e8 18             	shr    $0x18,%eax
c0401e94:	c1 e0 06             	shl    $0x6,%eax
c0401e97:	eb 0b                	jmp    c0401ea4 <int_handler+0x6c2>
c0401e99:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401e9e:	0f b6 c0             	movzbl %al,%eax
c0401ea1:	c1 e0 06             	shl    $0x6,%eax
c0401ea4:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401ea7:	8b 40 04             	mov    0x4(%eax),%eax
c0401eaa:	8b 00                	mov    (%eax),%eax
					syscall_do_msg_recv(&regs);
					break;
		
#ifdef INT_DEBUG
				default:
					dprintf(DEBUG_COL_INT "[int:%i] unknown syscall %x by thread %i in process %i\n" DEBUG_COL_OFF, CPU_ID, regs.edx,
c0401eac:	8b 18                	mov    (%eax),%ebx
							  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->pid);
c0401eae:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0401eb4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401eb9:	3c 01                	cmp    $0x1,%al
c0401ebb:	76 0f                	jbe    c0401ecc <int_handler+0x6ea>
c0401ebd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401ec2:	8b 00                	mov    (%eax),%eax
c0401ec4:	c1 e8 18             	shr    $0x18,%eax
c0401ec7:	c1 e0 06             	shl    $0x6,%eax
c0401eca:	eb 0b                	jmp    c0401ed7 <int_handler+0x6f5>
c0401ecc:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401ed1:	0f b6 c0             	movzbl %al,%eax
c0401ed4:	c1 e0 06             	shl    $0x6,%eax
c0401ed7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401eda:	8b 40 04             	mov    0x4(%eax),%eax
					syscall_do_msg_recv(&regs);
					break;
		
#ifdef INT_DEBUG
				default:
					dprintf(DEBUG_COL_INT "[int:%i] unknown syscall %x by thread %i in process %i\n" DEBUG_COL_OFF, CPU_ID, regs.edx,
c0401edd:	8b 48 04             	mov    0x4(%eax),%ecx
c0401ee0:	8b 94 24 a8 00 00 00 	mov    0xa8(%esp),%edx
c0401ee7:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0401eec:	3c 01                	cmp    $0x1,%al
c0401eee:	76 0c                	jbe    c0401efc <int_handler+0x71a>
c0401ef0:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401ef5:	8b 00                	mov    (%eax),%eax
c0401ef7:	c1 e8 18             	shr    $0x18,%eax
c0401efa:	eb 08                	jmp    c0401f04 <int_handler+0x722>
c0401efc:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401f01:	0f b6 c0             	movzbl %al,%eax
c0401f04:	83 ec 0c             	sub    $0xc,%esp
c0401f07:	53                   	push   %ebx
c0401f08:	51                   	push   %ecx
c0401f09:	52                   	push   %edx
c0401f0a:	50                   	push   %eax
c0401f0b:	68 5c e1 40 c0       	push   $0xc040e15c
c0401f10:	e8 41 b5 00 00       	call   c040d456 <debug_printf>
c0401f15:	83 c4 20             	add    $0x20,%esp
							  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->pid);
					break;
#endif
			}
			break;
c0401f18:	eb 46                	jmp    c0401f60 <int_handler+0x77e>
c0401f1a:	eb 44                	jmp    c0401f60 <int_handler+0x77e>
		
#ifdef INT_DEBUG
		default:
			dprintf(DEBUG_COL_INT "[int:%i] unhandled exception %x/%x received!\n" DEBUG_COL_OFF,
c0401f1c:	8b 8c 24 b8 00 00 00 	mov    0xb8(%esp),%ecx
c0401f23:	8b 94 24 b4 00 00 00 	mov    0xb4(%esp),%edx
					  CPU_ID, regs.intnum, regs.errcode);
c0401f2a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
			}
			break;
		
#ifdef INT_DEBUG
		default:
			dprintf(DEBUG_COL_INT "[int:%i] unhandled exception %x/%x received!\n" DEBUG_COL_OFF,
c0401f2f:	3c 01                	cmp    $0x1,%al
c0401f31:	76 0c                	jbe    c0401f3f <int_handler+0x75d>
					  CPU_ID, regs.intnum, regs.errcode);
c0401f33:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401f38:	8b 00                	mov    (%eax),%eax
			}
			break;
		
#ifdef INT_DEBUG
		default:
			dprintf(DEBUG_COL_INT "[int:%i] unhandled exception %x/%x received!\n" DEBUG_COL_OFF,
c0401f3a:	c1 e8 18             	shr    $0x18,%eax
c0401f3d:	eb 08                	jmp    c0401f47 <int_handler+0x765>
c0401f3f:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0401f44:	0f b6 c0             	movzbl %al,%eax
c0401f47:	51                   	push   %ecx
c0401f48:	52                   	push   %edx
c0401f49:	50                   	push   %eax
c0401f4a:	68 94 e1 40 c0       	push   $0xc040e194
c0401f4f:	e8 02 b5 00 00       	call   c040d456 <debug_printf>
c0401f54:	83 c4 10             	add    $0x10,%esp
c0401f57:	eb 07                	jmp    c0401f60 <int_handler+0x77e>
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				}
			}
			break;
c0401f59:	90                   	nop
c0401f5a:	eb 04                	jmp    c0401f60 <int_handler+0x77e>
						regs.eax = POSIX_GENERIC_FAILURE;
						syscall_do_exit(&regs);
					}
				}
			}
			break;
c0401f5c:	90                   	nop
c0401f5d:	eb 01                	jmp    c0401f60 <int_handler+0x77e>
c0401f5f:	90                   	nop
		
	/* there might be a thread of a higher-priority waiting to be run or the current process
	   may not exist - so prod the scheduler to switch to another thread if need be -
	   but only if we're returning to usermode, ie: don't try to switch out if we just
		handled a kernel->kernel exception */
	if(regs.eip < KERNEL_SPACE_BASE)
c0401f60:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
c0401f67:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0401f6c:	77 13                	ja     c0401f81 <int_handler+0x79f>
		sched_pick(&regs);
c0401f6e:	83 ec 0c             	sub    $0xc,%esp
c0401f71:	8d 84 24 9c 00 00 00 	lea    0x9c(%esp),%eax
c0401f78:	50                   	push   %eax
c0401f79:	e8 7b 33 00 00       	call   c04052f9 <sched_pick>
c0401f7e:	83 c4 10             	add    $0x10,%esp
	
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] OUT: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c0401f81:	8b 94 24 cc 00 00 00 	mov    0xcc(%esp),%edx
c0401f88:	8b 9c 24 c8 00 00 00 	mov    0xc8(%esp),%ebx
c0401f8f:	8b bc 24 c4 00 00 00 	mov    0xc4(%esp),%edi
c0401f96:	8b 84 24 c0 00 00 00 	mov    0xc0(%esp),%eax
c0401f9d:	89 44 24 48          	mov    %eax,0x48(%esp)
c0401fa1:	8b 84 24 bc 00 00 00 	mov    0xbc(%esp),%eax
c0401fa8:	89 44 24 4c          	mov    %eax,0x4c(%esp)
c0401fac:	8b 84 24 b8 00 00 00 	mov    0xb8(%esp),%eax
c0401fb3:	89 44 24 50          	mov    %eax,0x50(%esp)
c0401fb7:	8b 84 24 b4 00 00 00 	mov    0xb4(%esp),%eax
c0401fbe:	89 44 24 54          	mov    %eax,0x54(%esp)
c0401fc2:	8b 84 24 b0 00 00 00 	mov    0xb0(%esp),%eax
c0401fc9:	89 44 24 58          	mov    %eax,0x58(%esp)
c0401fcd:	8b 84 24 ac 00 00 00 	mov    0xac(%esp),%eax
c0401fd4:	89 44 24 5c          	mov    %eax,0x5c(%esp)
c0401fd8:	8b 84 24 a8 00 00 00 	mov    0xa8(%esp),%eax
c0401fdf:	89 44 24 60          	mov    %eax,0x60(%esp)
c0401fe3:	8b 84 24 a4 00 00 00 	mov    0xa4(%esp),%eax
c0401fea:	89 44 24 64          	mov    %eax,0x64(%esp)
c0401fee:	8b 84 24 a0 00 00 00 	mov    0xa0(%esp),%eax
c0401ff5:	89 44 24 68          	mov    %eax,0x68(%esp)
c0401ff9:	8b 84 24 9c 00 00 00 	mov    0x9c(%esp),%eax
c0402000:	89 44 24 6c          	mov    %eax,0x6c(%esp)
c0402004:	8b ac 24 98 00 00 00 	mov    0x98(%esp),%ebp
c040200b:	8b b4 24 94 00 00 00 	mov    0x94(%esp),%esi
c0402012:	8b 8c 24 90 00 00 00 	mov    0x90(%esp),%ecx
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
			  CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
c0402019:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		handled a kernel->kernel exception */
	if(regs.eip < KERNEL_SPACE_BASE)
		sched_pick(&regs);
	
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] OUT: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c040201e:	3c 01                	cmp    $0x1,%al
c0402020:	76 0c                	jbe    c040202e <int_handler+0x84c>
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n" DEBUG_COL_OFF,
			  CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
c0402022:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402027:	8b 00                	mov    (%eax),%eax
		handled a kernel->kernel exception */
	if(regs.eip < KERNEL_SPACE_BASE)
		sched_pick(&regs);
	
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] OUT: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n" DEBUG_COL_OFF
c0402029:	c1 e8 18             	shr    $0x18,%eax
c040202c:	eb 08                	jmp    c0402036 <int_handler+0x854>
c040202e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402033:	0f b6 c0             	movzbl %al,%eax
c0402036:	83 ec 08             	sub    $0x8,%esp
c0402039:	52                   	push   %edx
c040203a:	53                   	push   %ebx
c040203b:	57                   	push   %edi
c040203c:	ff 74 24 5c          	pushl  0x5c(%esp)
c0402040:	ff 74 24 64          	pushl  0x64(%esp)
c0402044:	ff 74 24 6c          	pushl  0x6c(%esp)
c0402048:	ff 74 24 74          	pushl  0x74(%esp)
c040204c:	ff 74 24 7c          	pushl  0x7c(%esp)
c0402050:	ff b4 24 84 00 00 00 	pushl  0x84(%esp)
c0402057:	ff b4 24 8c 00 00 00 	pushl  0x8c(%esp)
c040205e:	ff b4 24 94 00 00 00 	pushl  0x94(%esp)
c0402065:	ff b4 24 9c 00 00 00 	pushl  0x9c(%esp)
c040206c:	ff b4 24 a4 00 00 00 	pushl  0xa4(%esp)
c0402073:	55                   	push   %ebp
c0402074:	56                   	push   %esi
c0402075:	51                   	push   %ecx
c0402076:	50                   	push   %eax
c0402077:	68 c4 e1 40 c0       	push   $0xc040e1c4
c040207c:	e8 d5 b3 00 00       	call   c040d456 <debug_printf>
c0402081:	83 c4 50             	add    $0x50,%esp
	
#ifdef PERFORMANCE_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] software interrupt %x took about %i cycles to process\n" DEBUG_COL_OFF, CPU_ID, regs.intnum,
			  (unsigned int)(x86_read_cyclecount() - debug_cycles));
#endif
}
c0402084:	83 c4 7c             	add    $0x7c,%esp
c0402087:	5b                   	pop    %ebx
c0402088:	5e                   	pop    %esi
c0402089:	5f                   	pop    %edi
c040208a:	5d                   	pop    %ebp
c040208b:	c3                   	ret    

c040208c <int_reload_idtr>:
/* ---------------------------------------------------------------------------------------- */

/* int_reload_idtr
   Reload the idtr */
void int_reload_idtr(void)
{
c040208c:	83 ec 0c             	sub    $0xc,%esp
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] loading idtr with %p (%x %x)\n" DEBUG_COL_OFF,
			  CPU_ID, &int_table_ptr, int_table_ptr.base, int_table_ptr.limit);
c040208f:	66 a1 70 18 41 c0    	mov    0xc0411870,%ax
/* int_reload_idtr
   Reload the idtr */
void int_reload_idtr(void)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] loading idtr with %p (%x %x)\n" DEBUG_COL_OFF,
c0402095:	0f b7 c8             	movzwl %ax,%ecx
c0402098:	8b 15 72 18 41 c0    	mov    0xc0411872,%edx
			  CPU_ID, &int_table_ptr, int_table_ptr.base, int_table_ptr.limit);
c040209e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
/* int_reload_idtr
   Reload the idtr */
void int_reload_idtr(void)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] loading idtr with %p (%x %x)\n" DEBUG_COL_OFF,
c04020a3:	3c 01                	cmp    $0x1,%al
c04020a5:	76 0c                	jbe    c04020b3 <int_reload_idtr+0x27>
			  CPU_ID, &int_table_ptr, int_table_ptr.base, int_table_ptr.limit);
c04020a7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04020ac:	8b 00                	mov    (%eax),%eax
/* int_reload_idtr
   Reload the idtr */
void int_reload_idtr(void)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] loading idtr with %p (%x %x)\n" DEBUG_COL_OFF,
c04020ae:	c1 e8 18             	shr    $0x18,%eax
c04020b1:	eb 08                	jmp    c04020bb <int_reload_idtr+0x2f>
c04020b3:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04020b8:	0f b6 c0             	movzbl %al,%eax
c04020bb:	83 ec 0c             	sub    $0xc,%esp
c04020be:	51                   	push   %ecx
c04020bf:	52                   	push   %edx
c04020c0:	68 70 18 41 c0       	push   $0xc0411870
c04020c5:	50                   	push   %eax
c04020c6:	68 78 e2 40 c0       	push   $0xc040e278
c04020cb:	e8 86 b3 00 00       	call   c040d456 <debug_printf>
c04020d0:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, &int_table_ptr, int_table_ptr.base, int_table_ptr.limit);
#endif	
	
	x86_load_idtr((unsigned int *)&int_table_ptr); /* in start.s */
c04020d3:	b8 70 18 41 c0       	mov    $0xc0411870,%eax
c04020d8:	83 ec 0c             	sub    $0xc,%esp
c04020db:	50                   	push   %eax
c04020dc:	e8 58 e3 ff ff       	call   c0400439 <x86_load_idtr>
c04020e1:	83 c4 10             	add    $0x10,%esp
}
c04020e4:	83 c4 0c             	add    $0xc,%esp
c04020e7:	c3                   	ret    

c04020e8 <int_set_gate>:
      segment = kernel segment selector for routine
      flags   = handler descriptor flags
      flush   = set to non-zero to force a reload of the cpu idt reg
*/
void int_set_gate(unsigned char intnum, unsigned int base, unsigned short segment, unsigned char flags, unsigned char flush)
{
c04020e8:	53                   	push   %ebx
c04020e9:	83 ec 18             	sub    $0x18,%esp
c04020ec:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c04020f0:	8b 44 24 28          	mov    0x28(%esp),%eax
c04020f4:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
c04020f8:	8b 54 24 30          	mov    0x30(%esp),%edx
c04020fc:	88 5c 24 0c          	mov    %bl,0xc(%esp)
c0402100:	66 89 44 24 08       	mov    %ax,0x8(%esp)
c0402105:	88 4c 24 04          	mov    %cl,0x4(%esp)
c0402109:	88 14 24             	mov    %dl,(%esp)
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] setting gate: #%i = %x:%x\n" DEBUG_COL_OFF, CPU_ID, intnum, segment, base);
c040210c:	0f b7 4c 24 08       	movzwl 0x8(%esp),%ecx
c0402111:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0402116:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040211b:	3c 01                	cmp    $0x1,%al
c040211d:	76 0c                	jbe    c040212b <int_set_gate+0x43>
c040211f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402124:	8b 00                	mov    (%eax),%eax
c0402126:	c1 e8 18             	shr    $0x18,%eax
c0402129:	eb 08                	jmp    c0402133 <int_set_gate+0x4b>
c040212b:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402130:	0f b6 c0             	movzbl %al,%eax
c0402133:	83 ec 0c             	sub    $0xc,%esp
c0402136:	ff 74 24 30          	pushl  0x30(%esp)
c040213a:	51                   	push   %ecx
c040213b:	52                   	push   %edx
c040213c:	50                   	push   %eax
c040213d:	68 a0 e2 40 c0       	push   $0xc040e2a0
c0402142:	e8 0f b3 00 00       	call   c040d456 <debug_printf>
c0402147:	83 c4 20             	add    $0x20,%esp
#endif
	
	int_idt_table[intnum].base_lo  = base & 0xFFFF;
c040214a:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040214f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402153:	66 89 04 d5 60 10 41 	mov    %ax,-0x3fbeefa0(,%edx,8)
c040215a:	c0 
   int_idt_table[intnum].base_hi  = (base >> 16) & 0xFFFF;
c040215b:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0402160:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402164:	c1 e8 10             	shr    $0x10,%eax
c0402167:	66 89 04 d5 66 10 41 	mov    %ax,-0x3fbeef9a(,%edx,8)
c040216e:	c0 
   int_idt_table[intnum].segment = segment;
c040216f:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0402174:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402178:	66 89 04 d5 62 10 41 	mov    %ax,-0x3fbeef9e(,%edx,8)
c040217f:	c0 
   int_idt_table[intnum].always0  = 0; /* mandatory zero */
c0402180:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0402185:	c6 04 c5 64 10 41 c0 	movb   $0x0,-0x3fbeef9c(,%eax,8)
c040218c:	00 
   int_idt_table[intnum].flags    = flags;
c040218d:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0402192:	8a 54 24 04          	mov    0x4(%esp),%dl
c0402196:	88 14 c5 65 10 41 c0 	mov    %dl,-0x3fbeef9b(,%eax,8)
	
	if(flush)
c040219d:	80 3c 24 00          	cmpb   $0x0,(%esp)
c04021a1:	74 05                	je     c04021a8 <int_set_gate+0xc0>
		int_reload_idtr();
c04021a3:	e8 e4 fe ff ff       	call   c040208c <int_reload_idtr>
}
c04021a8:	83 c4 18             	add    $0x18,%esp
c04021ab:	5b                   	pop    %ebx
c04021ac:	c3                   	ret    

c04021ad <int_initialise_common>:

/* initialise the common entries in the int table for uni and multiproc systems */
void int_initialise_common(void)
{
c04021ad:	83 ec 0c             	sub    $0xc,%esp
	dprintf(DEBUG_COL_INT "[int:%i] initialising common exception and syscall handlers... \n" DEBUG_COL_OFF, CPU_ID);
c04021b0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04021b5:	3c 01                	cmp    $0x1,%al
c04021b7:	76 0c                	jbe    c04021c5 <int_initialise_common+0x18>
c04021b9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04021be:	8b 00                	mov    (%eax),%eax
c04021c0:	c1 e8 18             	shr    $0x18,%eax
c04021c3:	eb 08                	jmp    c04021cd <int_initialise_common+0x20>
c04021c5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04021ca:	0f b6 c0             	movzbl %al,%eax
c04021cd:	83 ec 08             	sub    $0x8,%esp
c04021d0:	50                   	push   %eax
c04021d1:	68 c4 e2 40 c0       	push   $0xc040e2c4
c04021d6:	e8 7b b2 00 00       	call   c040d456 <debug_printf>
c04021db:	83 c4 10             	add    $0x10,%esp
	
	/* initialise table pointer and idt table */
	int_table_ptr.limit = (sizeof(int_idt_descr) * 256) - 1;
c04021de:	66 c7 05 70 18 41 c0 	movw   $0x7ff,0xc0411870
c04021e5:	ff 07 
	int_table_ptr.base  = (unsigned int)&int_idt_table;
c04021e7:	b8 60 10 41 c0       	mov    $0xc0411060,%eax
c04021ec:	a3 72 18 41 c0       	mov    %eax,0xc0411872
	vmm_memset(&int_idt_table, 0, (sizeof(int_idt_descr) * 256));
c04021f1:	83 ec 04             	sub    $0x4,%esp
c04021f4:	68 00 08 00 00       	push   $0x800
c04021f9:	6a 00                	push   $0x0
c04021fb:	68 60 10 41 c0       	push   $0xc0411060
c0402200:	e8 e1 4a 00 00       	call   c0406ce6 <vmm_memset>
c0402205:	83 c4 10             	add    $0x10,%esp
		
	/* laboriously setup the basic exception handlers
	   kernel code segment is the 4th entry in the GDT,
	   hence (4 - 1) * (sizeof GDT entry) = 3 * 8 = 24 = 0x18
	   flags of 0x83 = int gate, 32bit wide, present */
	int_set_gate(0,  (unsigned int)isr0,  0x18, 0x8E, 0);
c0402208:	b8 d7 00 40 c0       	mov    $0xc04000d7,%eax
c040220d:	83 ec 0c             	sub    $0xc,%esp
c0402210:	6a 00                	push   $0x0
c0402212:	68 8e 00 00 00       	push   $0x8e
c0402217:	6a 18                	push   $0x18
c0402219:	50                   	push   %eax
c040221a:	6a 00                	push   $0x0
c040221c:	e8 c7 fe ff ff       	call   c04020e8 <int_set_gate>
c0402221:	83 c4 20             	add    $0x20,%esp
	int_set_gate(1,  (unsigned int)isr1,  0x18, 0x8E, 0);
c0402224:	b8 e1 00 40 c0       	mov    $0xc04000e1,%eax
c0402229:	83 ec 0c             	sub    $0xc,%esp
c040222c:	6a 00                	push   $0x0
c040222e:	68 8e 00 00 00       	push   $0x8e
c0402233:	6a 18                	push   $0x18
c0402235:	50                   	push   %eax
c0402236:	6a 01                	push   $0x1
c0402238:	e8 ab fe ff ff       	call   c04020e8 <int_set_gate>
c040223d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(2,  (unsigned int)isr2,  0x18, 0x8E, 0);
c0402240:	b8 eb 00 40 c0       	mov    $0xc04000eb,%eax
c0402245:	83 ec 0c             	sub    $0xc,%esp
c0402248:	6a 00                	push   $0x0
c040224a:	68 8e 00 00 00       	push   $0x8e
c040224f:	6a 18                	push   $0x18
c0402251:	50                   	push   %eax
c0402252:	6a 02                	push   $0x2
c0402254:	e8 8f fe ff ff       	call   c04020e8 <int_set_gate>
c0402259:	83 c4 20             	add    $0x20,%esp
	int_set_gate(3,  (unsigned int)isr3,  0x18, 0x8E, 0);
c040225c:	b8 f5 00 40 c0       	mov    $0xc04000f5,%eax
c0402261:	83 ec 0c             	sub    $0xc,%esp
c0402264:	6a 00                	push   $0x0
c0402266:	68 8e 00 00 00       	push   $0x8e
c040226b:	6a 18                	push   $0x18
c040226d:	50                   	push   %eax
c040226e:	6a 03                	push   $0x3
c0402270:	e8 73 fe ff ff       	call   c04020e8 <int_set_gate>
c0402275:	83 c4 20             	add    $0x20,%esp
	int_set_gate(4,  (unsigned int)isr4,  0x18, 0x8E, 0);
c0402278:	b8 ff 00 40 c0       	mov    $0xc04000ff,%eax
c040227d:	83 ec 0c             	sub    $0xc,%esp
c0402280:	6a 00                	push   $0x0
c0402282:	68 8e 00 00 00       	push   $0x8e
c0402287:	6a 18                	push   $0x18
c0402289:	50                   	push   %eax
c040228a:	6a 04                	push   $0x4
c040228c:	e8 57 fe ff ff       	call   c04020e8 <int_set_gate>
c0402291:	83 c4 20             	add    $0x20,%esp
	int_set_gate(5,  (unsigned int)isr5,  0x18, 0x8E, 0);
c0402294:	b8 09 01 40 c0       	mov    $0xc0400109,%eax
c0402299:	83 ec 0c             	sub    $0xc,%esp
c040229c:	6a 00                	push   $0x0
c040229e:	68 8e 00 00 00       	push   $0x8e
c04022a3:	6a 18                	push   $0x18
c04022a5:	50                   	push   %eax
c04022a6:	6a 05                	push   $0x5
c04022a8:	e8 3b fe ff ff       	call   c04020e8 <int_set_gate>
c04022ad:	83 c4 20             	add    $0x20,%esp
	int_set_gate(6,  (unsigned int)isr6,  0x18, 0x8E, 0);
c04022b0:	b8 13 01 40 c0       	mov    $0xc0400113,%eax
c04022b5:	83 ec 0c             	sub    $0xc,%esp
c04022b8:	6a 00                	push   $0x0
c04022ba:	68 8e 00 00 00       	push   $0x8e
c04022bf:	6a 18                	push   $0x18
c04022c1:	50                   	push   %eax
c04022c2:	6a 06                	push   $0x6
c04022c4:	e8 1f fe ff ff       	call   c04020e8 <int_set_gate>
c04022c9:	83 c4 20             	add    $0x20,%esp
	int_set_gate(7,  (unsigned int)isr7,  0x18, 0x8E, 0);
c04022cc:	b8 1d 01 40 c0       	mov    $0xc040011d,%eax
c04022d1:	83 ec 0c             	sub    $0xc,%esp
c04022d4:	6a 00                	push   $0x0
c04022d6:	68 8e 00 00 00       	push   $0x8e
c04022db:	6a 18                	push   $0x18
c04022dd:	50                   	push   %eax
c04022de:	6a 07                	push   $0x7
c04022e0:	e8 03 fe ff ff       	call   c04020e8 <int_set_gate>
c04022e5:	83 c4 20             	add    $0x20,%esp
	int_set_gate(8,  (unsigned int)isr8,  0x18, 0x8E, 0);
c04022e8:	b8 27 01 40 c0       	mov    $0xc0400127,%eax
c04022ed:	83 ec 0c             	sub    $0xc,%esp
c04022f0:	6a 00                	push   $0x0
c04022f2:	68 8e 00 00 00       	push   $0x8e
c04022f7:	6a 18                	push   $0x18
c04022f9:	50                   	push   %eax
c04022fa:	6a 08                	push   $0x8
c04022fc:	e8 e7 fd ff ff       	call   c04020e8 <int_set_gate>
c0402301:	83 c4 20             	add    $0x20,%esp
	int_set_gate(9,  (unsigned int)isr9,  0x18, 0x8E, 0);
c0402304:	b8 2f 01 40 c0       	mov    $0xc040012f,%eax
c0402309:	83 ec 0c             	sub    $0xc,%esp
c040230c:	6a 00                	push   $0x0
c040230e:	68 8e 00 00 00       	push   $0x8e
c0402313:	6a 18                	push   $0x18
c0402315:	50                   	push   %eax
c0402316:	6a 09                	push   $0x9
c0402318:	e8 cb fd ff ff       	call   c04020e8 <int_set_gate>
c040231d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(10, (unsigned int)isr10, 0x18, 0x8E, 0);
c0402320:	b8 39 01 40 c0       	mov    $0xc0400139,%eax
c0402325:	83 ec 0c             	sub    $0xc,%esp
c0402328:	6a 00                	push   $0x0
c040232a:	68 8e 00 00 00       	push   $0x8e
c040232f:	6a 18                	push   $0x18
c0402331:	50                   	push   %eax
c0402332:	6a 0a                	push   $0xa
c0402334:	e8 af fd ff ff       	call   c04020e8 <int_set_gate>
c0402339:	83 c4 20             	add    $0x20,%esp
	int_set_gate(11, (unsigned int)isr11, 0x18, 0x8E, 0);
c040233c:	b8 41 01 40 c0       	mov    $0xc0400141,%eax
c0402341:	83 ec 0c             	sub    $0xc,%esp
c0402344:	6a 00                	push   $0x0
c0402346:	68 8e 00 00 00       	push   $0x8e
c040234b:	6a 18                	push   $0x18
c040234d:	50                   	push   %eax
c040234e:	6a 0b                	push   $0xb
c0402350:	e8 93 fd ff ff       	call   c04020e8 <int_set_gate>
c0402355:	83 c4 20             	add    $0x20,%esp
	int_set_gate(12, (unsigned int)isr12, 0x18, 0x8E, 0);
c0402358:	b8 49 01 40 c0       	mov    $0xc0400149,%eax
c040235d:	83 ec 0c             	sub    $0xc,%esp
c0402360:	6a 00                	push   $0x0
c0402362:	68 8e 00 00 00       	push   $0x8e
c0402367:	6a 18                	push   $0x18
c0402369:	50                   	push   %eax
c040236a:	6a 0c                	push   $0xc
c040236c:	e8 77 fd ff ff       	call   c04020e8 <int_set_gate>
c0402371:	83 c4 20             	add    $0x20,%esp
	int_set_gate(13, (unsigned int)isr13, 0x18, 0x8E, 0);
c0402374:	b8 51 01 40 c0       	mov    $0xc0400151,%eax
c0402379:	83 ec 0c             	sub    $0xc,%esp
c040237c:	6a 00                	push   $0x0
c040237e:	68 8e 00 00 00       	push   $0x8e
c0402383:	6a 18                	push   $0x18
c0402385:	50                   	push   %eax
c0402386:	6a 0d                	push   $0xd
c0402388:	e8 5b fd ff ff       	call   c04020e8 <int_set_gate>
c040238d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(14, (unsigned int)isr14, 0x18, 0x8E, 0);
c0402390:	b8 59 01 40 c0       	mov    $0xc0400159,%eax
c0402395:	83 ec 0c             	sub    $0xc,%esp
c0402398:	6a 00                	push   $0x0
c040239a:	68 8e 00 00 00       	push   $0x8e
c040239f:	6a 18                	push   $0x18
c04023a1:	50                   	push   %eax
c04023a2:	6a 0e                	push   $0xe
c04023a4:	e8 3f fd ff ff       	call   c04020e8 <int_set_gate>
c04023a9:	83 c4 20             	add    $0x20,%esp
	int_set_gate(15, (unsigned int)isr15, 0x18, 0x8E, 0);
c04023ac:	b8 61 01 40 c0       	mov    $0xc0400161,%eax
c04023b1:	83 ec 0c             	sub    $0xc,%esp
c04023b4:	6a 00                	push   $0x0
c04023b6:	68 8e 00 00 00       	push   $0x8e
c04023bb:	6a 18                	push   $0x18
c04023bd:	50                   	push   %eax
c04023be:	6a 0f                	push   $0xf
c04023c0:	e8 23 fd ff ff       	call   c04020e8 <int_set_gate>
c04023c5:	83 c4 20             	add    $0x20,%esp
	int_set_gate(16, (unsigned int)isr16, 0x18, 0x8E, 0);
c04023c8:	b8 6b 01 40 c0       	mov    $0xc040016b,%eax
c04023cd:	83 ec 0c             	sub    $0xc,%esp
c04023d0:	6a 00                	push   $0x0
c04023d2:	68 8e 00 00 00       	push   $0x8e
c04023d7:	6a 18                	push   $0x18
c04023d9:	50                   	push   %eax
c04023da:	6a 10                	push   $0x10
c04023dc:	e8 07 fd ff ff       	call   c04020e8 <int_set_gate>
c04023e1:	83 c4 20             	add    $0x20,%esp
	int_set_gate(17, (unsigned int)isr17, 0x18, 0x8E, 0);
c04023e4:	b8 75 01 40 c0       	mov    $0xc0400175,%eax
c04023e9:	83 ec 0c             	sub    $0xc,%esp
c04023ec:	6a 00                	push   $0x0
c04023ee:	68 8e 00 00 00       	push   $0x8e
c04023f3:	6a 18                	push   $0x18
c04023f5:	50                   	push   %eax
c04023f6:	6a 11                	push   $0x11
c04023f8:	e8 eb fc ff ff       	call   c04020e8 <int_set_gate>
c04023fd:	83 c4 20             	add    $0x20,%esp
	int_set_gate(18, (unsigned int)isr18, 0x18, 0x8E, 0);
c0402400:	b8 7f 01 40 c0       	mov    $0xc040017f,%eax
c0402405:	83 ec 0c             	sub    $0xc,%esp
c0402408:	6a 00                	push   $0x0
c040240a:	68 8e 00 00 00       	push   $0x8e
c040240f:	6a 18                	push   $0x18
c0402411:	50                   	push   %eax
c0402412:	6a 12                	push   $0x12
c0402414:	e8 cf fc ff ff       	call   c04020e8 <int_set_gate>
c0402419:	83 c4 20             	add    $0x20,%esp
	int_set_gate(19, (unsigned int)isr19, 0x18, 0x8E, 0);
c040241c:	b8 89 01 40 c0       	mov    $0xc0400189,%eax
c0402421:	83 ec 0c             	sub    $0xc,%esp
c0402424:	6a 00                	push   $0x0
c0402426:	68 8e 00 00 00       	push   $0x8e
c040242b:	6a 18                	push   $0x18
c040242d:	50                   	push   %eax
c040242e:	6a 13                	push   $0x13
c0402430:	e8 b3 fc ff ff       	call   c04020e8 <int_set_gate>
c0402435:	83 c4 20             	add    $0x20,%esp
	int_set_gate(20, (unsigned int)isr20, 0x18, 0x8E, 0);
c0402438:	b8 93 01 40 c0       	mov    $0xc0400193,%eax
c040243d:	83 ec 0c             	sub    $0xc,%esp
c0402440:	6a 00                	push   $0x0
c0402442:	68 8e 00 00 00       	push   $0x8e
c0402447:	6a 18                	push   $0x18
c0402449:	50                   	push   %eax
c040244a:	6a 14                	push   $0x14
c040244c:	e8 97 fc ff ff       	call   c04020e8 <int_set_gate>
c0402451:	83 c4 20             	add    $0x20,%esp
	int_set_gate(21, (unsigned int)isr21, 0x18, 0x8E, 0);
c0402454:	b8 9d 01 40 c0       	mov    $0xc040019d,%eax
c0402459:	83 ec 0c             	sub    $0xc,%esp
c040245c:	6a 00                	push   $0x0
c040245e:	68 8e 00 00 00       	push   $0x8e
c0402463:	6a 18                	push   $0x18
c0402465:	50                   	push   %eax
c0402466:	6a 15                	push   $0x15
c0402468:	e8 7b fc ff ff       	call   c04020e8 <int_set_gate>
c040246d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(22, (unsigned int)isr22, 0x18, 0x8E, 0);
c0402470:	b8 a7 01 40 c0       	mov    $0xc04001a7,%eax
c0402475:	83 ec 0c             	sub    $0xc,%esp
c0402478:	6a 00                	push   $0x0
c040247a:	68 8e 00 00 00       	push   $0x8e
c040247f:	6a 18                	push   $0x18
c0402481:	50                   	push   %eax
c0402482:	6a 16                	push   $0x16
c0402484:	e8 5f fc ff ff       	call   c04020e8 <int_set_gate>
c0402489:	83 c4 20             	add    $0x20,%esp
	int_set_gate(23, (unsigned int)isr23, 0x18, 0x8E, 0);
c040248c:	b8 b1 01 40 c0       	mov    $0xc04001b1,%eax
c0402491:	83 ec 0c             	sub    $0xc,%esp
c0402494:	6a 00                	push   $0x0
c0402496:	68 8e 00 00 00       	push   $0x8e
c040249b:	6a 18                	push   $0x18
c040249d:	50                   	push   %eax
c040249e:	6a 17                	push   $0x17
c04024a0:	e8 43 fc ff ff       	call   c04020e8 <int_set_gate>
c04024a5:	83 c4 20             	add    $0x20,%esp
	int_set_gate(24, (unsigned int)isr24, 0x18, 0x8E, 0);
c04024a8:	b8 bb 01 40 c0       	mov    $0xc04001bb,%eax
c04024ad:	83 ec 0c             	sub    $0xc,%esp
c04024b0:	6a 00                	push   $0x0
c04024b2:	68 8e 00 00 00       	push   $0x8e
c04024b7:	6a 18                	push   $0x18
c04024b9:	50                   	push   %eax
c04024ba:	6a 18                	push   $0x18
c04024bc:	e8 27 fc ff ff       	call   c04020e8 <int_set_gate>
c04024c1:	83 c4 20             	add    $0x20,%esp
	int_set_gate(25, (unsigned int)isr25, 0x18, 0x8E, 0);
c04024c4:	b8 c5 01 40 c0       	mov    $0xc04001c5,%eax
c04024c9:	83 ec 0c             	sub    $0xc,%esp
c04024cc:	6a 00                	push   $0x0
c04024ce:	68 8e 00 00 00       	push   $0x8e
c04024d3:	6a 18                	push   $0x18
c04024d5:	50                   	push   %eax
c04024d6:	6a 19                	push   $0x19
c04024d8:	e8 0b fc ff ff       	call   c04020e8 <int_set_gate>
c04024dd:	83 c4 20             	add    $0x20,%esp
	int_set_gate(26, (unsigned int)isr26, 0x18, 0x8E, 0);
c04024e0:	b8 cf 01 40 c0       	mov    $0xc04001cf,%eax
c04024e5:	83 ec 0c             	sub    $0xc,%esp
c04024e8:	6a 00                	push   $0x0
c04024ea:	68 8e 00 00 00       	push   $0x8e
c04024ef:	6a 18                	push   $0x18
c04024f1:	50                   	push   %eax
c04024f2:	6a 1a                	push   $0x1a
c04024f4:	e8 ef fb ff ff       	call   c04020e8 <int_set_gate>
c04024f9:	83 c4 20             	add    $0x20,%esp
	int_set_gate(27, (unsigned int)isr27, 0x18, 0x8E, 0);
c04024fc:	b8 d9 01 40 c0       	mov    $0xc04001d9,%eax
c0402501:	83 ec 0c             	sub    $0xc,%esp
c0402504:	6a 00                	push   $0x0
c0402506:	68 8e 00 00 00       	push   $0x8e
c040250b:	6a 18                	push   $0x18
c040250d:	50                   	push   %eax
c040250e:	6a 1b                	push   $0x1b
c0402510:	e8 d3 fb ff ff       	call   c04020e8 <int_set_gate>
c0402515:	83 c4 20             	add    $0x20,%esp
	int_set_gate(28, (unsigned int)isr28, 0x18, 0x8E, 0);
c0402518:	b8 e3 01 40 c0       	mov    $0xc04001e3,%eax
c040251d:	83 ec 0c             	sub    $0xc,%esp
c0402520:	6a 00                	push   $0x0
c0402522:	68 8e 00 00 00       	push   $0x8e
c0402527:	6a 18                	push   $0x18
c0402529:	50                   	push   %eax
c040252a:	6a 1c                	push   $0x1c
c040252c:	e8 b7 fb ff ff       	call   c04020e8 <int_set_gate>
c0402531:	83 c4 20             	add    $0x20,%esp
	int_set_gate(29, (unsigned int)isr29, 0x18, 0x8E, 0);
c0402534:	b8 ed 01 40 c0       	mov    $0xc04001ed,%eax
c0402539:	83 ec 0c             	sub    $0xc,%esp
c040253c:	6a 00                	push   $0x0
c040253e:	68 8e 00 00 00       	push   $0x8e
c0402543:	6a 18                	push   $0x18
c0402545:	50                   	push   %eax
c0402546:	6a 1d                	push   $0x1d
c0402548:	e8 9b fb ff ff       	call   c04020e8 <int_set_gate>
c040254d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(30, (unsigned int)isr30, 0x18, 0x8E, 0);
c0402550:	b8 f7 01 40 c0       	mov    $0xc04001f7,%eax
c0402555:	83 ec 0c             	sub    $0xc,%esp
c0402558:	6a 00                	push   $0x0
c040255a:	68 8e 00 00 00       	push   $0x8e
c040255f:	6a 18                	push   $0x18
c0402561:	50                   	push   %eax
c0402562:	6a 1e                	push   $0x1e
c0402564:	e8 7f fb ff ff       	call   c04020e8 <int_set_gate>
c0402569:	83 c4 20             	add    $0x20,%esp
	int_set_gate(31, (unsigned int)isr31, 0x18, 0x8E, 0);
c040256c:	b8 01 02 40 c0       	mov    $0xc0400201,%eax
c0402571:	83 ec 0c             	sub    $0xc,%esp
c0402574:	6a 00                	push   $0x0
c0402576:	68 8e 00 00 00       	push   $0x8e
c040257b:	6a 18                	push   $0x18
c040257d:	50                   	push   %eax
c040257e:	6a 1f                	push   $0x1f
c0402580:	e8 63 fb ff ff       	call   c04020e8 <int_set_gate>
c0402585:	83 c4 20             	add    $0x20,%esp
	
	/* reprogram the basic PICs so that any old-world interrupts
	 get sent to the 16 vectors above the cpu exceptions.
	 Run the PIC vectors from 32 (0x20) to 47 (0x2F) */
	x86_pic_remap(0x20, 0x28);
c0402588:	83 ec 08             	sub    $0x8,%esp
c040258b:	6a 28                	push   $0x28
c040258d:	6a 20                	push   $0x20
c040258f:	e8 5f ed ff ff       	call   c04012f3 <x86_pic_remap>
c0402594:	83 c4 10             	add    $0x10,%esp
	
	/* ..and direct the old-world hardware interrupts at the right vectors */
	int_set_gate(IRQ_TIMER, (unsigned int)irq0,  0x18, 0x8E, 0);
c0402597:	b8 0b 02 40 c0       	mov    $0xc040020b,%eax
c040259c:	83 ec 0c             	sub    $0xc,%esp
c040259f:	6a 00                	push   $0x0
c04025a1:	68 8e 00 00 00       	push   $0x8e
c04025a6:	6a 18                	push   $0x18
c04025a8:	50                   	push   %eax
c04025a9:	6a 20                	push   $0x20
c04025ab:	e8 38 fb ff ff       	call   c04020e8 <int_set_gate>
c04025b0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(33, (unsigned int)irq1,  0x18, 0x8E, 0);
c04025b3:	b8 15 02 40 c0       	mov    $0xc0400215,%eax
c04025b8:	83 ec 0c             	sub    $0xc,%esp
c04025bb:	6a 00                	push   $0x0
c04025bd:	68 8e 00 00 00       	push   $0x8e
c04025c2:	6a 18                	push   $0x18
c04025c4:	50                   	push   %eax
c04025c5:	6a 21                	push   $0x21
c04025c7:	e8 1c fb ff ff       	call   c04020e8 <int_set_gate>
c04025cc:	83 c4 20             	add    $0x20,%esp
	int_set_gate(34, (unsigned int)irq2,  0x18, 0x8E, 0);
c04025cf:	b8 1f 02 40 c0       	mov    $0xc040021f,%eax
c04025d4:	83 ec 0c             	sub    $0xc,%esp
c04025d7:	6a 00                	push   $0x0
c04025d9:	68 8e 00 00 00       	push   $0x8e
c04025de:	6a 18                	push   $0x18
c04025e0:	50                   	push   %eax
c04025e1:	6a 22                	push   $0x22
c04025e3:	e8 00 fb ff ff       	call   c04020e8 <int_set_gate>
c04025e8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(35, (unsigned int)irq3,  0x18, 0x8E, 0);
c04025eb:	b8 29 02 40 c0       	mov    $0xc0400229,%eax
c04025f0:	83 ec 0c             	sub    $0xc,%esp
c04025f3:	6a 00                	push   $0x0
c04025f5:	68 8e 00 00 00       	push   $0x8e
c04025fa:	6a 18                	push   $0x18
c04025fc:	50                   	push   %eax
c04025fd:	6a 23                	push   $0x23
c04025ff:	e8 e4 fa ff ff       	call   c04020e8 <int_set_gate>
c0402604:	83 c4 20             	add    $0x20,%esp
	int_set_gate(36, (unsigned int)irq4,  0x18, 0x8E, 0);
c0402607:	b8 33 02 40 c0       	mov    $0xc0400233,%eax
c040260c:	83 ec 0c             	sub    $0xc,%esp
c040260f:	6a 00                	push   $0x0
c0402611:	68 8e 00 00 00       	push   $0x8e
c0402616:	6a 18                	push   $0x18
c0402618:	50                   	push   %eax
c0402619:	6a 24                	push   $0x24
c040261b:	e8 c8 fa ff ff       	call   c04020e8 <int_set_gate>
c0402620:	83 c4 20             	add    $0x20,%esp
	int_set_gate(37, (unsigned int)irq5,  0x18, 0x8E, 0);
c0402623:	b8 3d 02 40 c0       	mov    $0xc040023d,%eax
c0402628:	83 ec 0c             	sub    $0xc,%esp
c040262b:	6a 00                	push   $0x0
c040262d:	68 8e 00 00 00       	push   $0x8e
c0402632:	6a 18                	push   $0x18
c0402634:	50                   	push   %eax
c0402635:	6a 25                	push   $0x25
c0402637:	e8 ac fa ff ff       	call   c04020e8 <int_set_gate>
c040263c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(38, (unsigned int)irq6,  0x18, 0x8E, 0);
c040263f:	b8 47 02 40 c0       	mov    $0xc0400247,%eax
c0402644:	83 ec 0c             	sub    $0xc,%esp
c0402647:	6a 00                	push   $0x0
c0402649:	68 8e 00 00 00       	push   $0x8e
c040264e:	6a 18                	push   $0x18
c0402650:	50                   	push   %eax
c0402651:	6a 26                	push   $0x26
c0402653:	e8 90 fa ff ff       	call   c04020e8 <int_set_gate>
c0402658:	83 c4 20             	add    $0x20,%esp
	int_set_gate(39, (unsigned int)irq7,  0x18, 0x8E, 0);
c040265b:	b8 51 02 40 c0       	mov    $0xc0400251,%eax
c0402660:	83 ec 0c             	sub    $0xc,%esp
c0402663:	6a 00                	push   $0x0
c0402665:	68 8e 00 00 00       	push   $0x8e
c040266a:	6a 18                	push   $0x18
c040266c:	50                   	push   %eax
c040266d:	6a 27                	push   $0x27
c040266f:	e8 74 fa ff ff       	call   c04020e8 <int_set_gate>
c0402674:	83 c4 20             	add    $0x20,%esp
	int_set_gate(40, (unsigned int)irq8,  0x18, 0x8E, 0);
c0402677:	b8 5b 02 40 c0       	mov    $0xc040025b,%eax
c040267c:	83 ec 0c             	sub    $0xc,%esp
c040267f:	6a 00                	push   $0x0
c0402681:	68 8e 00 00 00       	push   $0x8e
c0402686:	6a 18                	push   $0x18
c0402688:	50                   	push   %eax
c0402689:	6a 28                	push   $0x28
c040268b:	e8 58 fa ff ff       	call   c04020e8 <int_set_gate>
c0402690:	83 c4 20             	add    $0x20,%esp
	int_set_gate(41, (unsigned int)irq9,  0x18, 0x8E, 0);
c0402693:	b8 65 02 40 c0       	mov    $0xc0400265,%eax
c0402698:	83 ec 0c             	sub    $0xc,%esp
c040269b:	6a 00                	push   $0x0
c040269d:	68 8e 00 00 00       	push   $0x8e
c04026a2:	6a 18                	push   $0x18
c04026a4:	50                   	push   %eax
c04026a5:	6a 29                	push   $0x29
c04026a7:	e8 3c fa ff ff       	call   c04020e8 <int_set_gate>
c04026ac:	83 c4 20             	add    $0x20,%esp
	int_set_gate(42, (unsigned int)irq10, 0x18, 0x8E, 0);
c04026af:	b8 6f 02 40 c0       	mov    $0xc040026f,%eax
c04026b4:	83 ec 0c             	sub    $0xc,%esp
c04026b7:	6a 00                	push   $0x0
c04026b9:	68 8e 00 00 00       	push   $0x8e
c04026be:	6a 18                	push   $0x18
c04026c0:	50                   	push   %eax
c04026c1:	6a 2a                	push   $0x2a
c04026c3:	e8 20 fa ff ff       	call   c04020e8 <int_set_gate>
c04026c8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(43, (unsigned int)irq11, 0x18, 0x8E, 0);
c04026cb:	b8 79 02 40 c0       	mov    $0xc0400279,%eax
c04026d0:	83 ec 0c             	sub    $0xc,%esp
c04026d3:	6a 00                	push   $0x0
c04026d5:	68 8e 00 00 00       	push   $0x8e
c04026da:	6a 18                	push   $0x18
c04026dc:	50                   	push   %eax
c04026dd:	6a 2b                	push   $0x2b
c04026df:	e8 04 fa ff ff       	call   c04020e8 <int_set_gate>
c04026e4:	83 c4 20             	add    $0x20,%esp
	int_set_gate(44, (unsigned int)irq12, 0x18, 0x8E, 0);
c04026e7:	b8 83 02 40 c0       	mov    $0xc0400283,%eax
c04026ec:	83 ec 0c             	sub    $0xc,%esp
c04026ef:	6a 00                	push   $0x0
c04026f1:	68 8e 00 00 00       	push   $0x8e
c04026f6:	6a 18                	push   $0x18
c04026f8:	50                   	push   %eax
c04026f9:	6a 2c                	push   $0x2c
c04026fb:	e8 e8 f9 ff ff       	call   c04020e8 <int_set_gate>
c0402700:	83 c4 20             	add    $0x20,%esp
	int_set_gate(45, (unsigned int)irq13, 0x18, 0x8E, 0);
c0402703:	b8 8d 02 40 c0       	mov    $0xc040028d,%eax
c0402708:	83 ec 0c             	sub    $0xc,%esp
c040270b:	6a 00                	push   $0x0
c040270d:	68 8e 00 00 00       	push   $0x8e
c0402712:	6a 18                	push   $0x18
c0402714:	50                   	push   %eax
c0402715:	6a 2d                	push   $0x2d
c0402717:	e8 cc f9 ff ff       	call   c04020e8 <int_set_gate>
c040271c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(46, (unsigned int)irq14, 0x18, 0x8E, 0);
c040271f:	b8 97 02 40 c0       	mov    $0xc0400297,%eax
c0402724:	83 ec 0c             	sub    $0xc,%esp
c0402727:	6a 00                	push   $0x0
c0402729:	68 8e 00 00 00       	push   $0x8e
c040272e:	6a 18                	push   $0x18
c0402730:	50                   	push   %eax
c0402731:	6a 2e                	push   $0x2e
c0402733:	e8 b0 f9 ff ff       	call   c04020e8 <int_set_gate>
c0402738:	83 c4 20             	add    $0x20,%esp
	int_set_gate(47, (unsigned int)irq15, 0x18, 0x8E, 0); 
c040273b:	b8 a1 02 40 c0       	mov    $0xc04002a1,%eax
c0402740:	83 ec 0c             	sub    $0xc,%esp
c0402743:	6a 00                	push   $0x0
c0402745:	68 8e 00 00 00       	push   $0x8e
c040274a:	6a 18                	push   $0x18
c040274c:	50                   	push   %eax
c040274d:	6a 2f                	push   $0x2f
c040274f:	e8 94 f9 ff ff       	call   c04020e8 <int_set_gate>
c0402754:	83 c4 20             	add    $0x20,%esp
		
	/* define the software interrupt vector - starting from 0x90 (144)
	 OR flags with 0x60 to set DPL to ring3, so userland can call them */
	int_set_gate(INT_KERNEL_SWI, (unsigned int)isr144, 0x18, 0x8E | 0x60, 1); /* reload idt */	
c0402757:	b8 e1 03 40 c0       	mov    $0xc04003e1,%eax
c040275c:	83 ec 0c             	sub    $0xc,%esp
c040275f:	6a 01                	push   $0x1
c0402761:	68 ee 00 00 00       	push   $0xee
c0402766:	6a 18                	push   $0x18
c0402768:	50                   	push   %eax
c0402769:	68 90 00 00 00       	push   $0x90
c040276e:	e8 75 f9 ff ff       	call   c04020e8 <int_set_gate>
c0402773:	83 c4 20             	add    $0x20,%esp
}
c0402776:	83 c4 0c             	add    $0xc,%esp
c0402779:	c3                   	ret    

c040277a <int_apic_write>:
      value = 32bit value to write
*/
void int_apic_write(volatile unsigned int volatile *addr, volatile unsigned int value)
{
	/* simple, eh? */
	*addr = value;
c040277a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040277e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0402782:	89 10                	mov    %edx,(%eax)
}
c0402784:	c3                   	ret    

c0402785 <int_apic_icr_ready>:

/* int_apic_icr_ready
   Wait until the local APIC's IPI-pending flag is zero */
void int_apic_icr_ready(void)
{
	while((*LAPIC_ICR_LO) & LAPIC_PENDING) __asm__ __volatile__("pause");
c0402785:	eb 02                	jmp    c0402789 <int_apic_icr_ready+0x4>
c0402787:	f3 90                	pause  
c0402789:	b8 00 03 e0 fe       	mov    $0xfee00300,%eax
c040278e:	8b 00                	mov    (%eax),%eax
c0402790:	25 00 10 00 00       	and    $0x1000,%eax
c0402795:	85 c0                	test   %eax,%eax
c0402797:	75 ee                	jne    c0402787 <int_apic_icr_ready+0x2>
}
c0402799:	c3                   	ret    

c040279a <int_ipi_send_init>:

/* int_ipi_send_init
	Send an INIT IPI to the given processor
*/
void int_ipi_send_init(unsigned int destination)
{
c040279a:	83 ec 0c             	sub    $0xc,%esp
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending INIT IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
			  CPU_ID, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT, destination);
c040279d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	Send an INIT IPI to the given processor
*/
void int_ipi_send_init(unsigned int destination)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending INIT IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
c04027a2:	3c 01                	cmp    $0x1,%al
c04027a4:	76 0c                	jbe    c04027b2 <int_ipi_send_init+0x18>
			  CPU_ID, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT, destination);
c04027a6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04027ab:	8b 00                	mov    (%eax),%eax
	Send an INIT IPI to the given processor
*/
void int_ipi_send_init(unsigned int destination)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending INIT IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
c04027ad:	c1 e8 18             	shr    $0x18,%eax
c04027b0:	eb 08                	jmp    c04027ba <int_ipi_send_init+0x20>
c04027b2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04027b7:	0f b6 c0             	movzbl %al,%eax
c04027ba:	ff 74 24 10          	pushl  0x10(%esp)
c04027be:	68 00 c5 00 00       	push   $0xc500
c04027c3:	50                   	push   %eax
c04027c4:	68 08 e3 40 c0       	push   $0xc040e308
c04027c9:	e8 88 ac 00 00       	call   c040d456 <debug_printf>
c04027ce:	83 c4 10             	add    $0x10,%esp
			  CPU_ID, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT, destination);
#endif

	int_apic_icr_ready(); /* wait for the command reg to be ready */
c04027d1:	e8 af ff ff ff       	call   c0402785 <int_apic_icr_ready>
	
	/* write to HI, then LO to send */
	int_apic_write(LAPIC_ICR_HI, destination << LAPIC_DEST_SHIFT);
c04027d6:	8b 44 24 10          	mov    0x10(%esp),%eax
c04027da:	c1 e0 18             	shl    $0x18,%eax
c04027dd:	83 ec 08             	sub    $0x8,%esp
c04027e0:	50                   	push   %eax
c04027e1:	68 10 03 e0 fe       	push   $0xfee00310
c04027e6:	e8 8f ff ff ff       	call   c040277a <int_apic_write>
c04027eb:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_ICR_LO, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT);
c04027ee:	83 ec 08             	sub    $0x8,%esp
c04027f1:	68 00 c5 00 00       	push   $0xc500
c04027f6:	68 00 03 e0 fe       	push   $0xfee00300
c04027fb:	e8 7a ff ff ff       	call   c040277a <int_apic_write>
c0402800:	83 c4 10             	add    $0x10,%esp
	
	/* don't forget to deassert the INIT */
	int_apic_write(LAPIC_ICR_LO, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ALLINCSEL);
c0402803:	83 ec 08             	sub    $0x8,%esp
c0402806:	68 00 85 08 00       	push   $0x88500
c040280b:	68 00 03 e0 fe       	push   $0xfee00300
c0402810:	e8 65 ff ff ff       	call   c040277a <int_apic_write>
c0402815:	83 c4 10             	add    $0x10,%esp
}
c0402818:	83 c4 0c             	add    $0xc,%esp
c040281b:	c3                   	ret    

c040281c <int_ipi_send_startup>:

/* int_ipi_send_startup
	Send a startup IPI to the given processor using the given vector
*/
void int_ipi_send_startup(unsigned int destination, unsigned char vector)
{
c040281c:	83 ec 1c             	sub    $0x1c,%esp
c040281f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402823:	88 44 24 0c          	mov    %al,0xc(%esp)
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending startup IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
c0402827:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040282c:	89 c2                	mov    %eax,%edx
c040282e:	80 ce 46             	or     $0x46,%dh
			  CPU_ID, vector | LAPIC_TYPE_START | LAPIC_ASSERT, destination);
c0402831:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	Send a startup IPI to the given processor using the given vector
*/
void int_ipi_send_startup(unsigned int destination, unsigned char vector)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending startup IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
c0402836:	3c 01                	cmp    $0x1,%al
c0402838:	76 0c                	jbe    c0402846 <int_ipi_send_startup+0x2a>
			  CPU_ID, vector | LAPIC_TYPE_START | LAPIC_ASSERT, destination);
c040283a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040283f:	8b 00                	mov    (%eax),%eax
	Send a startup IPI to the given processor using the given vector
*/
void int_ipi_send_startup(unsigned int destination, unsigned char vector)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] sending startup IPI (%x) to AP %i..\n" DEBUG_COL_OFF,
c0402841:	c1 e8 18             	shr    $0x18,%eax
c0402844:	eb 08                	jmp    c040284e <int_ipi_send_startup+0x32>
c0402846:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040284b:	0f b6 c0             	movzbl %al,%eax
c040284e:	ff 74 24 20          	pushl  0x20(%esp)
c0402852:	52                   	push   %edx
c0402853:	50                   	push   %eax
c0402854:	68 34 e3 40 c0       	push   $0xc040e334
c0402859:	e8 f8 ab 00 00       	call   c040d456 <debug_printf>
c040285e:	83 c4 10             	add    $0x10,%esp
			  CPU_ID, vector | LAPIC_TYPE_START | LAPIC_ASSERT, destination);
#endif
	
	int_apic_icr_ready(); /* wait for the command reg to be ready */
c0402861:	e8 1f ff ff ff       	call   c0402785 <int_apic_icr_ready>

	/* write to HI, then LO to send */
	int_apic_write(LAPIC_ICR_HI, destination << LAPIC_DEST_SHIFT);
c0402866:	8b 44 24 20          	mov    0x20(%esp),%eax
c040286a:	c1 e0 18             	shl    $0x18,%eax
c040286d:	83 ec 08             	sub    $0x8,%esp
c0402870:	50                   	push   %eax
c0402871:	68 10 03 e0 fe       	push   $0xfee00310
c0402876:	e8 ff fe ff ff       	call   c040277a <int_apic_write>
c040287b:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_ICR_LO, vector | LAPIC_TYPE_START | LAPIC_ASSERT);
c040287e:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0402883:	80 cc 46             	or     $0x46,%ah
c0402886:	83 ec 08             	sub    $0x8,%esp
c0402889:	50                   	push   %eax
c040288a:	68 00 03 e0 fe       	push   $0xfee00300
c040288f:	e8 e6 fe ff ff       	call   c040277a <int_apic_write>
c0402894:	83 c4 10             	add    $0x10,%esp
}
c0402897:	83 c4 1c             	add    $0x1c,%esp
c040289a:	c3                   	ret    

c040289b <int_ioapic_read>:
 => id = system id of IOAPIC to program
    reg = IOAPIC register number to write to
 <= the 32bit word in the selected register
*/
unsigned int int_ioapic_read(unsigned char id, unsigned char reg)
{
c040289b:	83 ec 18             	sub    $0x18,%esp
c040289e:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04028a2:	8b 44 24 20          	mov    0x20(%esp),%eax
c04028a6:	88 54 24 04          	mov    %dl,0x4(%esp)
c04028aa:	88 04 24             	mov    %al,(%esp)
	unsigned int addr_reg = IOAPIC_REG_SELECT + (id * 0x100);
c04028ad:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c04028b2:	05 00 c0 fe 00       	add    $0xfec000,%eax
c04028b7:	c1 e0 08             	shl    $0x8,%eax
c04028ba:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int addr_val = IOAPIC_WINDOW_SELECT + (id * 0x100);
c04028be:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c04028c3:	c1 e0 08             	shl    $0x8,%eax
c04028c6:	2d f0 ff 3f 01       	sub    $0x13ffff0,%eax
c04028cb:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	/* write the target register into the select register */
	*((volatile unsigned int *)(addr_reg)) = reg;
c04028cf:	8b 44 24 10          	mov    0x10(%esp),%eax
c04028d3:	0f b6 14 24          	movzbl (%esp),%edx
c04028d7:	89 10                	mov    %edx,(%eax)
	
	/* ..then read the data */
	return *((volatile unsigned int *)(addr_val));
c04028d9:	8b 44 24 14          	mov    0x14(%esp),%eax
c04028dd:	8b 00                	mov    (%eax),%eax
}
c04028df:	83 c4 18             	add    $0x18,%esp
c04028e2:	c3                   	ret    

c04028e3 <int_ioapic_write>:
      reg = IOAPIC register number to write to
      value = the 32bit word to write in
   <= assumes success
*/
void int_ioapic_write(unsigned char id, unsigned char reg, unsigned int value)
{
c04028e3:	83 ec 18             	sub    $0x18,%esp
c04028e6:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04028ea:	8b 44 24 20          	mov    0x20(%esp),%eax
c04028ee:	88 54 24 04          	mov    %dl,0x4(%esp)
c04028f2:	88 04 24             	mov    %al,(%esp)
	unsigned int addr_reg = IOAPIC_REG_SELECT + (id * 0x100);
c04028f5:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c04028fa:	05 00 c0 fe 00       	add    $0xfec000,%eax
c04028ff:	c1 e0 08             	shl    $0x8,%eax
c0402902:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int addr_val = IOAPIC_WINDOW_SELECT + (id * 0x100);
c0402906:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c040290b:	c1 e0 08             	shl    $0x8,%eax
c040290e:	2d f0 ff 3f 01       	sub    $0x13ffff0,%eax
c0402913:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	/* write the target register into the select register */
	*((volatile unsigned int *)(addr_reg)) = reg;
c0402917:	8b 44 24 10          	mov    0x10(%esp),%eax
c040291b:	0f b6 14 24          	movzbl (%esp),%edx
c040291f:	89 10                	mov    %edx,(%eax)
	
	/* ..then the data */
	*((volatile unsigned int *)(addr_val)) = value;
c0402921:	8b 44 24 14          	mov    0x14(%esp),%eax
c0402925:	8b 54 24 24          	mov    0x24(%esp),%edx
c0402929:	89 10                	mov    %edx,(%eax)
}
c040292b:	83 c4 18             	add    $0x18,%esp
c040292e:	c3                   	ret    

c040292f <int_ioapic_route_set>:
      cpu = system id of CPU to route the interrupt to
      flags = flags to set in the IO redirection table
   <= assumes success
*/
void int_ioapic_route_set(unsigned char id, unsigned char entry, unsigned char cpu, unsigned int flags)
{
c040292f:	53                   	push   %ebx
c0402930:	83 ec 18             	sub    $0x18,%esp
c0402933:	8b 4c 24 20          	mov    0x20(%esp),%ecx
c0402937:	8b 54 24 24          	mov    0x24(%esp),%edx
c040293b:	8b 44 24 28          	mov    0x28(%esp),%eax
c040293f:	88 4c 24 0c          	mov    %cl,0xc(%esp)
c0402943:	88 54 24 08          	mov    %dl,0x8(%esp)
c0402947:	88 44 24 04          	mov    %al,0x4(%esp)
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] routing IOAPIC %i IRQ %i to CPU %i (flags %x)\n",
c040294b:	0f b6 5c 24 04       	movzbl 0x4(%esp),%ebx
c0402950:	0f b6 4c 24 08       	movzbl 0x8(%esp),%ecx
c0402955:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
			  CPU_ID, id, entry, cpu, flags);
c040295a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   <= assumes success
*/
void int_ioapic_route_set(unsigned char id, unsigned char entry, unsigned char cpu, unsigned int flags)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] routing IOAPIC %i IRQ %i to CPU %i (flags %x)\n",
c040295f:	3c 01                	cmp    $0x1,%al
c0402961:	76 0c                	jbe    c040296f <int_ioapic_route_set+0x40>
			  CPU_ID, id, entry, cpu, flags);
c0402963:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402968:	8b 00                	mov    (%eax),%eax
   <= assumes success
*/
void int_ioapic_route_set(unsigned char id, unsigned char entry, unsigned char cpu, unsigned int flags)
{
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] routing IOAPIC %i IRQ %i to CPU %i (flags %x)\n",
c040296a:	c1 e8 18             	shr    $0x18,%eax
c040296d:	eb 08                	jmp    c0402977 <int_ioapic_route_set+0x48>
c040296f:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402974:	0f b6 c0             	movzbl %al,%eax
c0402977:	83 ec 08             	sub    $0x8,%esp
c040297a:	ff 74 24 34          	pushl  0x34(%esp)
c040297e:	53                   	push   %ebx
c040297f:	51                   	push   %ecx
c0402980:	52                   	push   %edx
c0402981:	50                   	push   %eax
c0402982:	68 64 e3 40 c0       	push   $0xc040e364
c0402987:	e8 ca aa 00 00       	call   c040d456 <debug_printf>
c040298c:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, id, entry, cpu, flags);
#endif
	
	/* the chip's IO redirection table is 64 bits wide:
	   the target cpu is in bits 63:56, the flags in bits 16:0 */
	int_ioapic_write(id, IOAPIC_REDIR_BASE + (entry * 2) + 0, flags);
c040298f:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
c0402994:	83 c0 08             	add    $0x8,%eax
c0402997:	d1 e0                	shl    %eax
c0402999:	0f b6 d0             	movzbl %al,%edx
c040299c:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c04029a1:	83 ec 04             	sub    $0x4,%esp
c04029a4:	ff 74 24 30          	pushl  0x30(%esp)
c04029a8:	52                   	push   %edx
c04029a9:	50                   	push   %eax
c04029aa:	e8 34 ff ff ff       	call   c04028e3 <int_ioapic_write>
c04029af:	83 c4 10             	add    $0x10,%esp
	int_ioapic_write(id, IOAPIC_REDIR_BASE + (entry * 2) + 1, cpu << 24);
c04029b2:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c04029b7:	c1 e0 18             	shl    $0x18,%eax
c04029ba:	89 c1                	mov    %eax,%ecx
c04029bc:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
c04029c1:	83 c0 08             	add    $0x8,%eax
c04029c4:	d1 e0                	shl    %eax
c04029c6:	40                   	inc    %eax
c04029c7:	0f b6 d0             	movzbl %al,%edx
c04029ca:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c04029cf:	83 ec 04             	sub    $0x4,%esp
c04029d2:	51                   	push   %ecx
c04029d3:	52                   	push   %edx
c04029d4:	50                   	push   %eax
c04029d5:	e8 09 ff ff ff       	call   c04028e3 <int_ioapic_write>
c04029da:	83 c4 10             	add    $0x10,%esp
}
c04029dd:	83 c4 18             	add    $0x18,%esp
c04029e0:	5b                   	pop    %ebx
c04029e1:	c3                   	ret    

c04029e2 <int_initialise_mproc>:
	Set up a cpu on a multiprocessor system
   => flags = flag up who's calling this function
				  INT_IAMBSP = 1 for the BSP, which will create the int table
*/
void int_initialise_mproc(unsigned char flags)
{		
c04029e2:	83 ec 2c             	sub    $0x2c,%esp
c04029e5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04029e9:	88 44 24 0c          	mov    %al,0xc(%esp)
	/* clear int table and fill it with syscall and cpu exception handlers */
	if(flags & INT_IAMBSP)
c04029ed:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c04029f2:	83 e0 01             	and    $0x1,%eax
c04029f5:	84 c0                	test   %al,%al
c04029f7:	74 05                	je     c04029fe <int_initialise_mproc+0x1c>
		int_initialise_common();
c04029f9:	e8 af f7 ff ff       	call   c04021ad <int_initialise_common>
	
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] programming APIC on cpu %i\n" DEBUG_COL_OFF, CPU_ID, CPU_ID);
c04029fe:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0402a03:	3c 01                	cmp    $0x1,%al
c0402a05:	76 0e                	jbe    c0402a15 <int_initialise_mproc+0x33>
c0402a07:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402a0c:	8b 00                	mov    (%eax),%eax
c0402a0e:	89 c2                	mov    %eax,%edx
c0402a10:	c1 ea 18             	shr    $0x18,%edx
c0402a13:	eb 08                	jmp    c0402a1d <int_initialise_mproc+0x3b>
c0402a15:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402a1a:	0f b6 d0             	movzbl %al,%edx
c0402a1d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0402a22:	3c 01                	cmp    $0x1,%al
c0402a24:	76 0c                	jbe    c0402a32 <int_initialise_mproc+0x50>
c0402a26:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402a2b:	8b 00                	mov    (%eax),%eax
c0402a2d:	c1 e8 18             	shr    $0x18,%eax
c0402a30:	eb 08                	jmp    c0402a3a <int_initialise_mproc+0x58>
c0402a32:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402a37:	0f b6 c0             	movzbl %al,%eax
c0402a3a:	83 ec 04             	sub    $0x4,%esp
c0402a3d:	52                   	push   %edx
c0402a3e:	50                   	push   %eax
c0402a3f:	68 9c e3 40 c0       	push   $0xc040e39c
c0402a44:	e8 0d aa 00 00       	call   c040d456 <debug_printf>
c0402a49:	83 c4 10             	add    $0x10,%esp
#endif
	
	/* install the APIC int handlers */
	int_set_gate(IRQ_APIC_TIMER,    (unsigned int)irq16, 0x18, 0x8E, 0);
c0402a4c:	b8 ab 02 40 c0       	mov    $0xc04002ab,%eax
c0402a51:	83 ec 0c             	sub    $0xc,%esp
c0402a54:	6a 00                	push   $0x0
c0402a56:	68 8e 00 00 00       	push   $0x8e
c0402a5b:	6a 18                	push   $0x18
c0402a5d:	50                   	push   %eax
c0402a5e:	6a 30                	push   $0x30
c0402a60:	e8 83 f6 ff ff       	call   c04020e8 <int_set_gate>
c0402a65:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_LINT0,    (unsigned int)irq17, 0x18, 0x8E, 0);
c0402a68:	b8 b5 02 40 c0       	mov    $0xc04002b5,%eax
c0402a6d:	83 ec 0c             	sub    $0xc,%esp
c0402a70:	6a 00                	push   $0x0
c0402a72:	68 8e 00 00 00       	push   $0x8e
c0402a77:	6a 18                	push   $0x18
c0402a79:	50                   	push   %eax
c0402a7a:	6a 31                	push   $0x31
c0402a7c:	e8 67 f6 ff ff       	call   c04020e8 <int_set_gate>
c0402a81:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_LINT1,    (unsigned int)irq18, 0x18, 0x8E, 0);
c0402a84:	b8 bf 02 40 c0       	mov    $0xc04002bf,%eax
c0402a89:	83 ec 0c             	sub    $0xc,%esp
c0402a8c:	6a 00                	push   $0x0
c0402a8e:	68 8e 00 00 00       	push   $0x8e
c0402a93:	6a 18                	push   $0x18
c0402a95:	50                   	push   %eax
c0402a96:	6a 32                	push   $0x32
c0402a98:	e8 4b f6 ff ff       	call   c04020e8 <int_set_gate>
c0402a9d:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_PCINT,    (unsigned int)irq19, 0x18, 0x8E, 0);
c0402aa0:	b8 c9 02 40 c0       	mov    $0xc04002c9,%eax
c0402aa5:	83 ec 0c             	sub    $0xc,%esp
c0402aa8:	6a 00                	push   $0x0
c0402aaa:	68 8e 00 00 00       	push   $0x8e
c0402aaf:	6a 18                	push   $0x18
c0402ab1:	50                   	push   %eax
c0402ab2:	6a 33                	push   $0x33
c0402ab4:	e8 2f f6 ff ff       	call   c04020e8 <int_set_gate>
c0402ab9:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_SPURIOUS, (unsigned int)irq20, 0x18, 0x8E, 0);
c0402abc:	b8 d3 02 40 c0       	mov    $0xc04002d3,%eax
c0402ac1:	83 ec 0c             	sub    $0xc,%esp
c0402ac4:	6a 00                	push   $0x0
c0402ac6:	68 8e 00 00 00       	push   $0x8e
c0402acb:	6a 18                	push   $0x18
c0402acd:	50                   	push   %eax
c0402ace:	6a 3f                	push   $0x3f
c0402ad0:	e8 13 f6 ff ff       	call   c04020e8 <int_set_gate>
c0402ad5:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_THERMAL,  (unsigned int)irq21, 0x18, 0x8E, 0);
c0402ad8:	b8 dd 02 40 c0       	mov    $0xc04002dd,%eax
c0402add:	83 ec 0c             	sub    $0xc,%esp
c0402ae0:	6a 00                	push   $0x0
c0402ae2:	68 8e 00 00 00       	push   $0x8e
c0402ae7:	6a 18                	push   $0x18
c0402ae9:	50                   	push   %eax
c0402aea:	6a 35                	push   $0x35
c0402aec:	e8 f7 f5 ff ff       	call   c04020e8 <int_set_gate>
c0402af1:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IRQ_APIC_ERROR,    (unsigned int)irq22, 0x18, 0x8E, 1); /* reload idt */
c0402af4:	b8 e7 02 40 c0       	mov    $0xc04002e7,%eax
c0402af9:	83 ec 0c             	sub    $0xc,%esp
c0402afc:	6a 01                	push   $0x1
c0402afe:	68 8e 00 00 00       	push   $0x8e
c0402b03:	6a 18                	push   $0x18
c0402b05:	50                   	push   %eax
c0402b06:	6a 36                	push   $0x36
c0402b08:	e8 db f5 ff ff       	call   c04020e8 <int_set_gate>
c0402b0d:	83 c4 20             	add    $0x20,%esp
	
	/* program the APIC's registers so that interrupts point towards
	   the correct entries in the table of handlers  - start with the 
	   destination and task priority registers before enabling the APIC */
	int_apic_write(LAPIC_DESTID,  0xff000000);
c0402b10:	83 ec 08             	sub    $0x8,%esp
c0402b13:	68 00 00 00 ff       	push   $0xff000000
c0402b18:	68 d0 00 e0 fe       	push   $0xfee000d0
c0402b1d:	e8 58 fc ff ff       	call   c040277a <int_apic_write>
c0402b22:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_DESTFMT, 0xffffffff); /* force into flat SMP mode */
c0402b25:	83 ec 08             	sub    $0x8,%esp
c0402b28:	6a ff                	push   $0xffffffff
c0402b2a:	68 e0 00 e0 fe       	push   $0xfee000e0
c0402b2f:	e8 46 fc ff ff       	call   c040277a <int_apic_write>
c0402b34:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TASKPRI, 0); /* clear the task priority reg so all ints are handled */
c0402b37:	83 ec 08             	sub    $0x8,%esp
c0402b3a:	6a 00                	push   $0x0
c0402b3c:	68 80 00 e0 fe       	push   $0xfee00080
c0402b41:	e8 34 fc ff ff       	call   c040277a <int_apic_write>
c0402b46:	83 c4 10             	add    $0x10,%esp
		
	int_apic_write(LAPIC_SPURIOUS_REG, IRQ_APIC_SPURIOUS | LAPIC_ENABLE);
c0402b49:	83 ec 08             	sub    $0x8,%esp
c0402b4c:	68 3f 01 00 00       	push   $0x13f
c0402b51:	68 f0 00 e0 fe       	push   $0xfee000f0
c0402b56:	e8 1f fc ff ff       	call   c040277a <int_apic_write>
c0402b5b:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_TIMER,    IRQ_APIC_TIMER);
c0402b5e:	83 ec 08             	sub    $0x8,%esp
c0402b61:	6a 30                	push   $0x30
c0402b63:	68 20 03 e0 fe       	push   $0xfee00320
c0402b68:	e8 0d fc ff ff       	call   c040277a <int_apic_write>
c0402b6d:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_LINT0,    IRQ_APIC_LINT0);
c0402b70:	83 ec 08             	sub    $0x8,%esp
c0402b73:	6a 31                	push   $0x31
c0402b75:	68 50 03 e0 fe       	push   $0xfee00350
c0402b7a:	e8 fb fb ff ff       	call   c040277a <int_apic_write>
c0402b7f:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_LINT1,    IRQ_APIC_LINT1 | LAPIC_LVT_NMI);
c0402b82:	83 ec 08             	sub    $0x8,%esp
c0402b85:	68 32 04 00 00       	push   $0x432
c0402b8a:	68 60 03 e0 fe       	push   $0xfee00360
c0402b8f:	e8 e6 fb ff ff       	call   c040277a <int_apic_write>
c0402b94:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_PCOUNTER, IRQ_APIC_PCINT | LAPIC_LVT_MASK);
c0402b97:	83 ec 08             	sub    $0x8,%esp
c0402b9a:	68 33 00 01 00       	push   $0x10033
c0402b9f:	68 40 03 e0 fe       	push   $0xfee00340
c0402ba4:	e8 d1 fb ff ff       	call   c040277a <int_apic_write>
c0402ba9:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_THERMAL,  IRQ_APIC_THERMAL);
c0402bac:	83 ec 08             	sub    $0x8,%esp
c0402baf:	6a 35                	push   $0x35
c0402bb1:	68 30 03 e0 fe       	push   $0xfee00330
c0402bb6:	e8 bf fb ff ff       	call   c040277a <int_apic_write>
c0402bbb:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_LVT_ERROR,    IRQ_APIC_ERROR);
c0402bbe:	83 ec 08             	sub    $0x8,%esp
c0402bc1:	6a 36                	push   $0x36
c0402bc3:	68 70 03 e0 fe       	push   $0xfee00370
c0402bc8:	e8 ad fb ff ff       	call   c040277a <int_apic_write>
c0402bcd:	83 c4 10             	add    $0x10,%esp
	
	/* allow the boot processor to perform one-time system init and pre-flight checks */
	if(flags & INT_IAMBSP)
c0402bd0:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0402bd5:	83 e0 01             	and    $0x1,%eax
c0402bd8:	84 c0                	test   %al,%al
c0402bda:	0f 84 f2 05 00 00    	je     c04031d2 <int_initialise_mproc+0x7f0>
	{
		unsigned int this_cpu = CPU_ID;
c0402be0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0402be5:	3c 01                	cmp    $0x1,%al
c0402be7:	76 0c                	jbe    c0402bf5 <int_initialise_mproc+0x213>
c0402be9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402bee:	8b 00                	mov    (%eax),%eax
c0402bf0:	c1 e8 18             	shr    $0x18,%eax
c0402bf3:	eb 08                	jmp    c0402bfd <int_initialise_mproc+0x21b>
c0402bf5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0402bfa:	0f b6 c0             	movzbl %al,%eax
c0402bfd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		 23h, which receive address and data respectively. To access the IMCR, write a
		 value of 70h to I/O port 22h, which selects the IMCR. Then write the data to
		 I/O port 23h. The power-on default value is zero, which connects the NMI and
		 8259 INTR lines directly to the BSP. Write a value of 1 to route 8259/PIT
		 interrupts via the IOAPIC */
		x86_outportb(0x22, 0x70); /* begin IMCR access */
c0402c01:	83 ec 08             	sub    $0x8,%esp
c0402c04:	6a 70                	push   $0x70
c0402c06:	6a 22                	push   $0x22
c0402c08:	e8 7a db ff ff       	call   c0400787 <x86_outportb>
c0402c0d:	83 c4 10             	add    $0x10,%esp
		x86_outportb(0x23, 1);    /* set bit 1 for SMP mode */
c0402c10:	83 ec 08             	sub    $0x8,%esp
c0402c13:	6a 01                	push   $0x1
c0402c15:	6a 23                	push   $0x23
c0402c17:	e8 6b db ff ff       	call   c0400787 <x86_outportb>
c0402c1c:	83 c4 10             	add    $0x10,%esp
		
		/* point the IOAPIC interrupt lines at specific reserved vectors and route
		   to the boot processor - but mask out all interrupts except the PIT timer line */
		int_set_gate(IOAPIC_VECTOR_BASE + 0, (unsigned int)irq23, 0x18, 0x8E, 0);
c0402c1f:	b8 f1 02 40 c0       	mov    $0xc04002f1,%eax
c0402c24:	83 ec 0c             	sub    $0xc,%esp
c0402c27:	6a 00                	push   $0x0
c0402c29:	68 8e 00 00 00       	push   $0x8e
c0402c2e:	6a 18                	push   $0x18
c0402c30:	50                   	push   %eax
c0402c31:	6a 40                	push   $0x40
c0402c33:	e8 b0 f4 ff ff       	call   c04020e8 <int_set_gate>
c0402c38:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 0, this_cpu, (IOAPIC_VECTOR_BASE + 0)); /* keep PIT timer unmasked */
c0402c3b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402c3f:	0f b6 c0             	movzbl %al,%eax
c0402c42:	6a 40                	push   $0x40
c0402c44:	50                   	push   %eax
c0402c45:	6a 00                	push   $0x0
c0402c47:	6a 00                	push   $0x0
c0402c49:	e8 e1 fc ff ff       	call   c040292f <int_ioapic_route_set>
c0402c4e:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 1, (unsigned int)irq24, 0x18, 0x8E, 0);
c0402c51:	b8 fb 02 40 c0       	mov    $0xc04002fb,%eax
c0402c56:	83 ec 0c             	sub    $0xc,%esp
c0402c59:	6a 00                	push   $0x0
c0402c5b:	68 8e 00 00 00       	push   $0x8e
c0402c60:	6a 18                	push   $0x18
c0402c62:	50                   	push   %eax
c0402c63:	6a 41                	push   $0x41
c0402c65:	e8 7e f4 ff ff       	call   c04020e8 <int_set_gate>
c0402c6a:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 1, this_cpu, (IOAPIC_VECTOR_BASE + 1) | IOAPIC_MASK);
c0402c6d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402c71:	0f b6 c0             	movzbl %al,%eax
c0402c74:	68 41 00 01 00       	push   $0x10041
c0402c79:	50                   	push   %eax
c0402c7a:	6a 01                	push   $0x1
c0402c7c:	6a 00                	push   $0x0
c0402c7e:	e8 ac fc ff ff       	call   c040292f <int_ioapic_route_set>
c0402c83:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 2, (unsigned int)irq25, 0x18, 0x8E, 0);
c0402c86:	b8 05 03 40 c0       	mov    $0xc0400305,%eax
c0402c8b:	83 ec 0c             	sub    $0xc,%esp
c0402c8e:	6a 00                	push   $0x0
c0402c90:	68 8e 00 00 00       	push   $0x8e
c0402c95:	6a 18                	push   $0x18
c0402c97:	50                   	push   %eax
c0402c98:	6a 42                	push   $0x42
c0402c9a:	e8 49 f4 ff ff       	call   c04020e8 <int_set_gate>
c0402c9f:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 2, this_cpu, (IOAPIC_VECTOR_BASE + 2) | IOAPIC_MASK);
c0402ca2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402ca6:	0f b6 c0             	movzbl %al,%eax
c0402ca9:	68 42 00 01 00       	push   $0x10042
c0402cae:	50                   	push   %eax
c0402caf:	6a 02                	push   $0x2
c0402cb1:	6a 00                	push   $0x0
c0402cb3:	e8 77 fc ff ff       	call   c040292f <int_ioapic_route_set>
c0402cb8:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 3, (unsigned int)irq26, 0x18, 0x8E, 0);
c0402cbb:	b8 0f 03 40 c0       	mov    $0xc040030f,%eax
c0402cc0:	83 ec 0c             	sub    $0xc,%esp
c0402cc3:	6a 00                	push   $0x0
c0402cc5:	68 8e 00 00 00       	push   $0x8e
c0402cca:	6a 18                	push   $0x18
c0402ccc:	50                   	push   %eax
c0402ccd:	6a 43                	push   $0x43
c0402ccf:	e8 14 f4 ff ff       	call   c04020e8 <int_set_gate>
c0402cd4:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 3, this_cpu, (IOAPIC_VECTOR_BASE + 3) | IOAPIC_MASK);
c0402cd7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402cdb:	0f b6 c0             	movzbl %al,%eax
c0402cde:	68 43 00 01 00       	push   $0x10043
c0402ce3:	50                   	push   %eax
c0402ce4:	6a 03                	push   $0x3
c0402ce6:	6a 00                	push   $0x0
c0402ce8:	e8 42 fc ff ff       	call   c040292f <int_ioapic_route_set>
c0402ced:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 4, (unsigned int)irq27, 0x18, 0x8E, 0);
c0402cf0:	b8 19 03 40 c0       	mov    $0xc0400319,%eax
c0402cf5:	83 ec 0c             	sub    $0xc,%esp
c0402cf8:	6a 00                	push   $0x0
c0402cfa:	68 8e 00 00 00       	push   $0x8e
c0402cff:	6a 18                	push   $0x18
c0402d01:	50                   	push   %eax
c0402d02:	6a 44                	push   $0x44
c0402d04:	e8 df f3 ff ff       	call   c04020e8 <int_set_gate>
c0402d09:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 4, this_cpu, (IOAPIC_VECTOR_BASE + 4) | IOAPIC_MASK);
c0402d0c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402d10:	0f b6 c0             	movzbl %al,%eax
c0402d13:	68 44 00 01 00       	push   $0x10044
c0402d18:	50                   	push   %eax
c0402d19:	6a 04                	push   $0x4
c0402d1b:	6a 00                	push   $0x0
c0402d1d:	e8 0d fc ff ff       	call   c040292f <int_ioapic_route_set>
c0402d22:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 5, (unsigned int)irq28, 0x18, 0x8E, 0);
c0402d25:	b8 23 03 40 c0       	mov    $0xc0400323,%eax
c0402d2a:	83 ec 0c             	sub    $0xc,%esp
c0402d2d:	6a 00                	push   $0x0
c0402d2f:	68 8e 00 00 00       	push   $0x8e
c0402d34:	6a 18                	push   $0x18
c0402d36:	50                   	push   %eax
c0402d37:	6a 45                	push   $0x45
c0402d39:	e8 aa f3 ff ff       	call   c04020e8 <int_set_gate>
c0402d3e:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 5, this_cpu, (IOAPIC_VECTOR_BASE + 5) | IOAPIC_MASK);
c0402d41:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402d45:	0f b6 c0             	movzbl %al,%eax
c0402d48:	68 45 00 01 00       	push   $0x10045
c0402d4d:	50                   	push   %eax
c0402d4e:	6a 05                	push   $0x5
c0402d50:	6a 00                	push   $0x0
c0402d52:	e8 d8 fb ff ff       	call   c040292f <int_ioapic_route_set>
c0402d57:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 6, (unsigned int)irq29, 0x18, 0x8E, 0);
c0402d5a:	b8 2d 03 40 c0       	mov    $0xc040032d,%eax
c0402d5f:	83 ec 0c             	sub    $0xc,%esp
c0402d62:	6a 00                	push   $0x0
c0402d64:	68 8e 00 00 00       	push   $0x8e
c0402d69:	6a 18                	push   $0x18
c0402d6b:	50                   	push   %eax
c0402d6c:	6a 46                	push   $0x46
c0402d6e:	e8 75 f3 ff ff       	call   c04020e8 <int_set_gate>
c0402d73:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 6, this_cpu, (IOAPIC_VECTOR_BASE + 6) | IOAPIC_MASK);
c0402d76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402d7a:	0f b6 c0             	movzbl %al,%eax
c0402d7d:	68 46 00 01 00       	push   $0x10046
c0402d82:	50                   	push   %eax
c0402d83:	6a 06                	push   $0x6
c0402d85:	6a 00                	push   $0x0
c0402d87:	e8 a3 fb ff ff       	call   c040292f <int_ioapic_route_set>
c0402d8c:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 7, (unsigned int)irq30, 0x18, 0x8E, 0);
c0402d8f:	b8 37 03 40 c0       	mov    $0xc0400337,%eax
c0402d94:	83 ec 0c             	sub    $0xc,%esp
c0402d97:	6a 00                	push   $0x0
c0402d99:	68 8e 00 00 00       	push   $0x8e
c0402d9e:	6a 18                	push   $0x18
c0402da0:	50                   	push   %eax
c0402da1:	6a 47                	push   $0x47
c0402da3:	e8 40 f3 ff ff       	call   c04020e8 <int_set_gate>
c0402da8:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 7, this_cpu, (IOAPIC_VECTOR_BASE + 7) | IOAPIC_MASK);
c0402dab:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402daf:	0f b6 c0             	movzbl %al,%eax
c0402db2:	68 47 00 01 00       	push   $0x10047
c0402db7:	50                   	push   %eax
c0402db8:	6a 07                	push   $0x7
c0402dba:	6a 00                	push   $0x0
c0402dbc:	e8 6e fb ff ff       	call   c040292f <int_ioapic_route_set>
c0402dc1:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 8, (unsigned int)irq31, 0x18, 0x8E, 0);
c0402dc4:	b8 41 03 40 c0       	mov    $0xc0400341,%eax
c0402dc9:	83 ec 0c             	sub    $0xc,%esp
c0402dcc:	6a 00                	push   $0x0
c0402dce:	68 8e 00 00 00       	push   $0x8e
c0402dd3:	6a 18                	push   $0x18
c0402dd5:	50                   	push   %eax
c0402dd6:	6a 48                	push   $0x48
c0402dd8:	e8 0b f3 ff ff       	call   c04020e8 <int_set_gate>
c0402ddd:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 8, this_cpu, (IOAPIC_VECTOR_BASE + 8) | IOAPIC_MASK);
c0402de0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402de4:	0f b6 c0             	movzbl %al,%eax
c0402de7:	68 48 00 01 00       	push   $0x10048
c0402dec:	50                   	push   %eax
c0402ded:	6a 08                	push   $0x8
c0402def:	6a 00                	push   $0x0
c0402df1:	e8 39 fb ff ff       	call   c040292f <int_ioapic_route_set>
c0402df6:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 9, (unsigned int)irq32, 0x18, 0x8E, 0);
c0402df9:	b8 4b 03 40 c0       	mov    $0xc040034b,%eax
c0402dfe:	83 ec 0c             	sub    $0xc,%esp
c0402e01:	6a 00                	push   $0x0
c0402e03:	68 8e 00 00 00       	push   $0x8e
c0402e08:	6a 18                	push   $0x18
c0402e0a:	50                   	push   %eax
c0402e0b:	6a 49                	push   $0x49
c0402e0d:	e8 d6 f2 ff ff       	call   c04020e8 <int_set_gate>
c0402e12:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 9, this_cpu, (IOAPIC_VECTOR_BASE + 9) | IOAPIC_MASK);
c0402e15:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402e19:	0f b6 c0             	movzbl %al,%eax
c0402e1c:	68 49 00 01 00       	push   $0x10049
c0402e21:	50                   	push   %eax
c0402e22:	6a 09                	push   $0x9
c0402e24:	6a 00                	push   $0x0
c0402e26:	e8 04 fb ff ff       	call   c040292f <int_ioapic_route_set>
c0402e2b:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 10, (unsigned int)irq33, 0x18, 0x8E, 0);
c0402e2e:	b8 55 03 40 c0       	mov    $0xc0400355,%eax
c0402e33:	83 ec 0c             	sub    $0xc,%esp
c0402e36:	6a 00                	push   $0x0
c0402e38:	68 8e 00 00 00       	push   $0x8e
c0402e3d:	6a 18                	push   $0x18
c0402e3f:	50                   	push   %eax
c0402e40:	6a 4a                	push   $0x4a
c0402e42:	e8 a1 f2 ff ff       	call   c04020e8 <int_set_gate>
c0402e47:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 10, this_cpu, (IOAPIC_VECTOR_BASE + 10) | IOAPIC_MASK);
c0402e4a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402e4e:	0f b6 c0             	movzbl %al,%eax
c0402e51:	68 4a 00 01 00       	push   $0x1004a
c0402e56:	50                   	push   %eax
c0402e57:	6a 0a                	push   $0xa
c0402e59:	6a 00                	push   $0x0
c0402e5b:	e8 cf fa ff ff       	call   c040292f <int_ioapic_route_set>
c0402e60:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 11, (unsigned int)irq34, 0x18, 0x8E, 0);
c0402e63:	b8 5f 03 40 c0       	mov    $0xc040035f,%eax
c0402e68:	83 ec 0c             	sub    $0xc,%esp
c0402e6b:	6a 00                	push   $0x0
c0402e6d:	68 8e 00 00 00       	push   $0x8e
c0402e72:	6a 18                	push   $0x18
c0402e74:	50                   	push   %eax
c0402e75:	6a 4b                	push   $0x4b
c0402e77:	e8 6c f2 ff ff       	call   c04020e8 <int_set_gate>
c0402e7c:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 11, this_cpu, (IOAPIC_VECTOR_BASE + 11) | IOAPIC_MASK);
c0402e7f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402e83:	0f b6 c0             	movzbl %al,%eax
c0402e86:	68 4b 00 01 00       	push   $0x1004b
c0402e8b:	50                   	push   %eax
c0402e8c:	6a 0b                	push   $0xb
c0402e8e:	6a 00                	push   $0x0
c0402e90:	e8 9a fa ff ff       	call   c040292f <int_ioapic_route_set>
c0402e95:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 12, (unsigned int)irq35, 0x18, 0x8E, 0);
c0402e98:	b8 69 03 40 c0       	mov    $0xc0400369,%eax
c0402e9d:	83 ec 0c             	sub    $0xc,%esp
c0402ea0:	6a 00                	push   $0x0
c0402ea2:	68 8e 00 00 00       	push   $0x8e
c0402ea7:	6a 18                	push   $0x18
c0402ea9:	50                   	push   %eax
c0402eaa:	6a 4c                	push   $0x4c
c0402eac:	e8 37 f2 ff ff       	call   c04020e8 <int_set_gate>
c0402eb1:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 12, this_cpu, (IOAPIC_VECTOR_BASE + 12) | IOAPIC_MASK);
c0402eb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402eb8:	0f b6 c0             	movzbl %al,%eax
c0402ebb:	68 4c 00 01 00       	push   $0x1004c
c0402ec0:	50                   	push   %eax
c0402ec1:	6a 0c                	push   $0xc
c0402ec3:	6a 00                	push   $0x0
c0402ec5:	e8 65 fa ff ff       	call   c040292f <int_ioapic_route_set>
c0402eca:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 13, (unsigned int)irq36, 0x18, 0x8E, 0);
c0402ecd:	b8 73 03 40 c0       	mov    $0xc0400373,%eax
c0402ed2:	83 ec 0c             	sub    $0xc,%esp
c0402ed5:	6a 00                	push   $0x0
c0402ed7:	68 8e 00 00 00       	push   $0x8e
c0402edc:	6a 18                	push   $0x18
c0402ede:	50                   	push   %eax
c0402edf:	6a 4d                	push   $0x4d
c0402ee1:	e8 02 f2 ff ff       	call   c04020e8 <int_set_gate>
c0402ee6:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 13, this_cpu, (IOAPIC_VECTOR_BASE + 13) | IOAPIC_MASK);
c0402ee9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402eed:	0f b6 c0             	movzbl %al,%eax
c0402ef0:	68 4d 00 01 00       	push   $0x1004d
c0402ef5:	50                   	push   %eax
c0402ef6:	6a 0d                	push   $0xd
c0402ef8:	6a 00                	push   $0x0
c0402efa:	e8 30 fa ff ff       	call   c040292f <int_ioapic_route_set>
c0402eff:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 14, (unsigned int)irq37, 0x18, 0x8E, 0);
c0402f02:	b8 7d 03 40 c0       	mov    $0xc040037d,%eax
c0402f07:	83 ec 0c             	sub    $0xc,%esp
c0402f0a:	6a 00                	push   $0x0
c0402f0c:	68 8e 00 00 00       	push   $0x8e
c0402f11:	6a 18                	push   $0x18
c0402f13:	50                   	push   %eax
c0402f14:	6a 4e                	push   $0x4e
c0402f16:	e8 cd f1 ff ff       	call   c04020e8 <int_set_gate>
c0402f1b:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 14, this_cpu, (IOAPIC_VECTOR_BASE + 14) | IOAPIC_MASK);
c0402f1e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402f22:	0f b6 c0             	movzbl %al,%eax
c0402f25:	68 4e 00 01 00       	push   $0x1004e
c0402f2a:	50                   	push   %eax
c0402f2b:	6a 0e                	push   $0xe
c0402f2d:	6a 00                	push   $0x0
c0402f2f:	e8 fb f9 ff ff       	call   c040292f <int_ioapic_route_set>
c0402f34:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 15, (unsigned int)irq38, 0x18, 0x8E, 0);
c0402f37:	b8 87 03 40 c0       	mov    $0xc0400387,%eax
c0402f3c:	83 ec 0c             	sub    $0xc,%esp
c0402f3f:	6a 00                	push   $0x0
c0402f41:	68 8e 00 00 00       	push   $0x8e
c0402f46:	6a 18                	push   $0x18
c0402f48:	50                   	push   %eax
c0402f49:	6a 4f                	push   $0x4f
c0402f4b:	e8 98 f1 ff ff       	call   c04020e8 <int_set_gate>
c0402f50:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 15, this_cpu, (IOAPIC_VECTOR_BASE + 15) | IOAPIC_MASK);
c0402f53:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402f57:	0f b6 c0             	movzbl %al,%eax
c0402f5a:	68 4f 00 01 00       	push   $0x1004f
c0402f5f:	50                   	push   %eax
c0402f60:	6a 0f                	push   $0xf
c0402f62:	6a 00                	push   $0x0
c0402f64:	e8 c6 f9 ff ff       	call   c040292f <int_ioapic_route_set>
c0402f69:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 16, (unsigned int)irq39, 0x18, 0x8E, 0);
c0402f6c:	b8 91 03 40 c0       	mov    $0xc0400391,%eax
c0402f71:	83 ec 0c             	sub    $0xc,%esp
c0402f74:	6a 00                	push   $0x0
c0402f76:	68 8e 00 00 00       	push   $0x8e
c0402f7b:	6a 18                	push   $0x18
c0402f7d:	50                   	push   %eax
c0402f7e:	6a 50                	push   $0x50
c0402f80:	e8 63 f1 ff ff       	call   c04020e8 <int_set_gate>
c0402f85:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 16, this_cpu, (IOAPIC_VECTOR_BASE + 16) | IOAPIC_MASK);
c0402f88:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402f8c:	0f b6 c0             	movzbl %al,%eax
c0402f8f:	68 50 00 01 00       	push   $0x10050
c0402f94:	50                   	push   %eax
c0402f95:	6a 10                	push   $0x10
c0402f97:	6a 00                	push   $0x0
c0402f99:	e8 91 f9 ff ff       	call   c040292f <int_ioapic_route_set>
c0402f9e:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 17, (unsigned int)irq40, 0x18, 0x8E, 0);
c0402fa1:	b8 9b 03 40 c0       	mov    $0xc040039b,%eax
c0402fa6:	83 ec 0c             	sub    $0xc,%esp
c0402fa9:	6a 00                	push   $0x0
c0402fab:	68 8e 00 00 00       	push   $0x8e
c0402fb0:	6a 18                	push   $0x18
c0402fb2:	50                   	push   %eax
c0402fb3:	6a 51                	push   $0x51
c0402fb5:	e8 2e f1 ff ff       	call   c04020e8 <int_set_gate>
c0402fba:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 17, this_cpu, (IOAPIC_VECTOR_BASE + 17) | IOAPIC_MASK);
c0402fbd:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402fc1:	0f b6 c0             	movzbl %al,%eax
c0402fc4:	68 51 00 01 00       	push   $0x10051
c0402fc9:	50                   	push   %eax
c0402fca:	6a 11                	push   $0x11
c0402fcc:	6a 00                	push   $0x0
c0402fce:	e8 5c f9 ff ff       	call   c040292f <int_ioapic_route_set>
c0402fd3:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 18, (unsigned int)irq41, 0x18, 0x8E, 0);
c0402fd6:	b8 a5 03 40 c0       	mov    $0xc04003a5,%eax
c0402fdb:	83 ec 0c             	sub    $0xc,%esp
c0402fde:	6a 00                	push   $0x0
c0402fe0:	68 8e 00 00 00       	push   $0x8e
c0402fe5:	6a 18                	push   $0x18
c0402fe7:	50                   	push   %eax
c0402fe8:	6a 52                	push   $0x52
c0402fea:	e8 f9 f0 ff ff       	call   c04020e8 <int_set_gate>
c0402fef:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 18, this_cpu, (IOAPIC_VECTOR_BASE + 18) | IOAPIC_MASK);
c0402ff2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0402ff6:	0f b6 c0             	movzbl %al,%eax
c0402ff9:	68 52 00 01 00       	push   $0x10052
c0402ffe:	50                   	push   %eax
c0402fff:	6a 12                	push   $0x12
c0403001:	6a 00                	push   $0x0
c0403003:	e8 27 f9 ff ff       	call   c040292f <int_ioapic_route_set>
c0403008:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 19, (unsigned int)irq42, 0x18, 0x8E, 0);
c040300b:	b8 af 03 40 c0       	mov    $0xc04003af,%eax
c0403010:	83 ec 0c             	sub    $0xc,%esp
c0403013:	6a 00                	push   $0x0
c0403015:	68 8e 00 00 00       	push   $0x8e
c040301a:	6a 18                	push   $0x18
c040301c:	50                   	push   %eax
c040301d:	6a 53                	push   $0x53
c040301f:	e8 c4 f0 ff ff       	call   c04020e8 <int_set_gate>
c0403024:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 19, this_cpu, (IOAPIC_VECTOR_BASE + 19) | IOAPIC_MASK);
c0403027:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040302b:	0f b6 c0             	movzbl %al,%eax
c040302e:	68 53 00 01 00       	push   $0x10053
c0403033:	50                   	push   %eax
c0403034:	6a 13                	push   $0x13
c0403036:	6a 00                	push   $0x0
c0403038:	e8 f2 f8 ff ff       	call   c040292f <int_ioapic_route_set>
c040303d:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 20, (unsigned int)irq43, 0x18, 0x8E, 0);
c0403040:	b8 b9 03 40 c0       	mov    $0xc04003b9,%eax
c0403045:	83 ec 0c             	sub    $0xc,%esp
c0403048:	6a 00                	push   $0x0
c040304a:	68 8e 00 00 00       	push   $0x8e
c040304f:	6a 18                	push   $0x18
c0403051:	50                   	push   %eax
c0403052:	6a 54                	push   $0x54
c0403054:	e8 8f f0 ff ff       	call   c04020e8 <int_set_gate>
c0403059:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 20, this_cpu, (IOAPIC_VECTOR_BASE + 20) | IOAPIC_MASK);
c040305c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0403060:	0f b6 c0             	movzbl %al,%eax
c0403063:	68 54 00 01 00       	push   $0x10054
c0403068:	50                   	push   %eax
c0403069:	6a 14                	push   $0x14
c040306b:	6a 00                	push   $0x0
c040306d:	e8 bd f8 ff ff       	call   c040292f <int_ioapic_route_set>
c0403072:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 21, (unsigned int)irq44, 0x18, 0x8E, 0);
c0403075:	b8 c3 03 40 c0       	mov    $0xc04003c3,%eax
c040307a:	83 ec 0c             	sub    $0xc,%esp
c040307d:	6a 00                	push   $0x0
c040307f:	68 8e 00 00 00       	push   $0x8e
c0403084:	6a 18                	push   $0x18
c0403086:	50                   	push   %eax
c0403087:	6a 55                	push   $0x55
c0403089:	e8 5a f0 ff ff       	call   c04020e8 <int_set_gate>
c040308e:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 21, this_cpu, (IOAPIC_VECTOR_BASE + 21) | IOAPIC_MASK);
c0403091:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0403095:	0f b6 c0             	movzbl %al,%eax
c0403098:	68 55 00 01 00       	push   $0x10055
c040309d:	50                   	push   %eax
c040309e:	6a 15                	push   $0x15
c04030a0:	6a 00                	push   $0x0
c04030a2:	e8 88 f8 ff ff       	call   c040292f <int_ioapic_route_set>
c04030a7:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 22, (unsigned int)irq45, 0x18, 0x8E, 0);
c04030aa:	b8 cd 03 40 c0       	mov    $0xc04003cd,%eax
c04030af:	83 ec 0c             	sub    $0xc,%esp
c04030b2:	6a 00                	push   $0x0
c04030b4:	68 8e 00 00 00       	push   $0x8e
c04030b9:	6a 18                	push   $0x18
c04030bb:	50                   	push   %eax
c04030bc:	6a 56                	push   $0x56
c04030be:	e8 25 f0 ff ff       	call   c04020e8 <int_set_gate>
c04030c3:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 22, this_cpu, (IOAPIC_VECTOR_BASE + 22) | IOAPIC_MASK);
c04030c6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04030ca:	0f b6 c0             	movzbl %al,%eax
c04030cd:	68 56 00 01 00       	push   $0x10056
c04030d2:	50                   	push   %eax
c04030d3:	6a 16                	push   $0x16
c04030d5:	6a 00                	push   $0x0
c04030d7:	e8 53 f8 ff ff       	call   c040292f <int_ioapic_route_set>
c04030dc:	83 c4 10             	add    $0x10,%esp
		int_set_gate(IOAPIC_VECTOR_BASE + 23, (unsigned int)irq46, 0x18, 0x8E, 1);
c04030df:	b8 d7 03 40 c0       	mov    $0xc04003d7,%eax
c04030e4:	83 ec 0c             	sub    $0xc,%esp
c04030e7:	6a 01                	push   $0x1
c04030e9:	68 8e 00 00 00       	push   $0x8e
c04030ee:	6a 18                	push   $0x18
c04030f0:	50                   	push   %eax
c04030f1:	6a 57                	push   $0x57
c04030f3:	e8 f0 ef ff ff       	call   c04020e8 <int_set_gate>
c04030f8:	83 c4 20             	add    $0x20,%esp
		int_ioapic_route_set(0, 23, this_cpu, (IOAPIC_VECTOR_BASE + 23) | IOAPIC_MASK);
c04030fb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04030ff:	0f b6 c0             	movzbl %al,%eax
c0403102:	68 57 00 01 00       	push   $0x10057
c0403107:	50                   	push   %eax
c0403108:	6a 17                	push   $0x17
c040310a:	6a 00                	push   $0x0
c040310c:	e8 1e f8 ff ff       	call   c040292f <int_ioapic_route_set>
c0403111:	83 c4 10             	add    $0x10,%esp
		
		/* calculate average CPU bus speed and, thus, the local APIC's timer period */
#ifdef INT_DEBUG
		dprintf(DEBUG_COL_INT "[int:%i] performing APIC pre-flight checks...\n" DEBUG_COL_OFF, CPU_ID);
c0403114:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403119:	3c 01                	cmp    $0x1,%al
c040311b:	76 0c                	jbe    c0403129 <int_initialise_mproc+0x747>
c040311d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403122:	8b 00                	mov    (%eax),%eax
c0403124:	c1 e8 18             	shr    $0x18,%eax
c0403127:	eb 08                	jmp    c0403131 <int_initialise_mproc+0x74f>
c0403129:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040312e:	0f b6 c0             	movzbl %al,%eax
c0403131:	83 ec 08             	sub    $0x8,%esp
c0403134:	50                   	push   %eax
c0403135:	68 c4 e3 40 c0       	push   $0xc040e3c4
c040313a:	e8 17 a3 00 00       	call   c040d456 <debug_printf>
c040313f:	83 c4 10             	add    $0x10,%esp
#endif
		
		int_preflight_timer_flag = 1;
c0403142:	c6 05 bc 38 41 c0 01 	movb   $0x1,0xc04138bc
		
		/* set the old-world timer to fire every at the rate expcted by the scheduler
		   and see how far the CPU's APIC counts down in those periods */
		int_apic_write(LAPIC_TIMERDIV, LAPIC_DIV_128); /* divide down the bus clock by 128 */
c0403149:	83 ec 08             	sub    $0x8,%esp
c040314c:	6a 0a                	push   $0xa
c040314e:	68 e0 03 e0 fe       	push   $0xfee003e0
c0403153:	e8 22 f6 ff ff       	call   c040277a <int_apic_write>
c0403158:	83 c4 10             	add    $0x10,%esp
		x86_timer_init(SCHED_FREQUENCY);
c040315b:	83 ec 0c             	sub    $0xc,%esp
c040315e:	6a 64                	push   $0x64
c0403160:	e8 9d d6 ff ff       	call   c0400802 <x86_timer_init>
c0403165:	83 c4 10             	add    $0x10,%esp
		int_apic_write(LAPIC_TIMERINIT, 0xffffffff);
c0403168:	83 ec 08             	sub    $0x8,%esp
c040316b:	6a ff                	push   $0xffffffff
c040316d:	68 80 03 e0 fe       	push   $0xfee00380
c0403172:	e8 03 f6 ff ff       	call   c040277a <int_apic_write>
c0403177:	83 c4 10             	add    $0x10,%esp
		x86_enable_interrupts();
c040317a:	e8 5e e2 ff ff       	call   c04013dd <x86_enable_interrupts>
		
		/* loop until all done, then cancel interrupts */
		while(int_preflight_timer_pass < 4) __asm__ __volatile__("pause"); 
c040317f:	eb 02                	jmp    c0403183 <int_initialise_mproc+0x7a1>
c0403181:	f3 90                	pause  
c0403183:	a0 bd 38 41 c0       	mov    0xc04138bd,%al
c0403188:	3c 03                	cmp    $0x3,%al
c040318a:	76 f5                	jbe    c0403181 <int_initialise_mproc+0x79f>

		x86_disable_interrupts();
c040318c:	e8 4e e2 ff ff       	call   c04013df <x86_disable_interrupts>
		x86_timer_init(0);
c0403191:	83 ec 0c             	sub    $0xc,%esp
c0403194:	6a 00                	push   $0x0
c0403196:	e8 67 d6 ff ff       	call   c0400802 <x86_timer_init>
c040319b:	83 c4 10             	add    $0x10,%esp

		int_preflight_timer_flag = 0;
c040319e:	c6 05 bc 38 41 c0 00 	movb   $0x0,0xc04138bc
		
		/* calculate the average init value for the apic timer - each value has
		   already been divided by four */
		int_preflight_timer_init = int_preflight_timer_lap[0] + int_preflight_timer_lap[1] +
c04031a5:	8b 15 60 18 41 c0    	mov    0xc0411860,%edx
c04031ab:	a1 64 18 41 c0       	mov    0xc0411864,%eax
c04031b0:	01 c2                	add    %eax,%edx
											int_preflight_timer_lap[2] + int_preflight_timer_lap[3];
c04031b2:	a1 68 18 41 c0       	mov    0xc0411868,%eax
c04031b7:	01 c2                	add    %eax,%edx
c04031b9:	a1 6c 18 41 c0       	mov    0xc041186c,%eax

		int_preflight_timer_flag = 0;
		
		/* calculate the average init value for the apic timer - each value has
		   already been divided by four */
		int_preflight_timer_init = int_preflight_timer_lap[0] + int_preflight_timer_lap[1] +
c04031be:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04031c1:	a3 78 18 41 c0       	mov    %eax,0xc0411878
											int_preflight_timer_lap[2] + int_preflight_timer_lap[3];
		int_preflight_timer_init = 0xffffffff - int_preflight_timer_init;
c04031c6:	a1 78 18 41 c0       	mov    0xc0411878,%eax
c04031cb:	f7 d0                	not    %eax
c04031cd:	a3 78 18 41 c0       	mov    %eax,0xc0411878
	}
	
#ifdef INT_DEBUG
	dprintf(DEBUG_COL_INT "[int:%i] programming APIC timer with reload value of %x\n" DEBUG_COL_OFF, CPU_ID, int_preflight_timer_init);
c04031d2:	8b 15 78 18 41 c0    	mov    0xc0411878,%edx
c04031d8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04031dd:	3c 01                	cmp    $0x1,%al
c04031df:	76 0c                	jbe    c04031ed <int_initialise_mproc+0x80b>
c04031e1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04031e6:	8b 00                	mov    (%eax),%eax
c04031e8:	c1 e8 18             	shr    $0x18,%eax
c04031eb:	eb 08                	jmp    c04031f5 <int_initialise_mproc+0x813>
c04031ed:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04031f2:	0f b6 c0             	movzbl %al,%eax
c04031f5:	83 ec 04             	sub    $0x4,%esp
c04031f8:	52                   	push   %edx
c04031f9:	50                   	push   %eax
c04031fa:	68 f4 e3 40 c0       	push   $0xc040e3f4
c04031ff:	e8 52 a2 00 00       	call   c040d456 <debug_printf>
c0403204:	83 c4 10             	add    $0x10,%esp
#endif
	/* program the apic timer to fire every so many ticks */
	int_apic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER | LAPIC_TIMER_TP);
c0403207:	83 ec 08             	sub    $0x8,%esp
c040320a:	68 30 00 02 00       	push   $0x20030
c040320f:	68 20 03 e0 fe       	push   $0xfee00320
c0403214:	e8 61 f5 ff ff       	call   c040277a <int_apic_write>
c0403219:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040321c:	83 ec 08             	sub    $0x8,%esp
c040321f:	6a 0a                	push   $0xa
c0403221:	68 e0 03 e0 fe       	push   $0xfee003e0
c0403226:	e8 4f f5 ff ff       	call   c040277a <int_apic_write>
c040322b:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERINIT, int_preflight_timer_init);
c040322e:	a1 78 18 41 c0       	mov    0xc0411878,%eax
c0403233:	83 ec 08             	sub    $0x8,%esp
c0403236:	50                   	push   %eax
c0403237:	68 80 03 e0 fe       	push   $0xfee00380
c040323c:	e8 39 f5 ff ff       	call   c040277a <int_apic_write>
c0403241:	83 c4 10             	add    $0x10,%esp
}
c0403244:	83 c4 2c             	add    $0x2c,%esp
c0403247:	c3                   	ret    

c0403248 <int_initialise_uniproc>:
 
/* int_initialise_uniproc
	Set up the machine's sole cpu with exception and
   interrupt handlers and program the timer */
void int_initialise_uniproc(void)
{
c0403248:	83 ec 0c             	sub    $0xc,%esp
	int_initialise_common();
c040324b:	e8 5d ef ff ff       	call   c04021ad <int_initialise_common>

	/* set up a 100Hz ticker for the scheduler  */
	x86_timer_init(SCHED_FREQUENCY);
c0403250:	83 ec 0c             	sub    $0xc,%esp
c0403253:	6a 64                	push   $0x64
c0403255:	e8 a8 d5 ff ff       	call   c0400802 <x86_timer_init>
c040325a:	83 c4 10             	add    $0x10,%esp
	dprintf(DEBUG_COL_INT "[int:%i] uniproc: timer: %iHz\n" DEBUG_COL_OFF, CPU_ID, SCHED_FREQUENCY);
c040325d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403262:	3c 01                	cmp    $0x1,%al
c0403264:	76 0c                	jbe    c0403272 <int_initialise_uniproc+0x2a>
c0403266:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040326b:	8b 00                	mov    (%eax),%eax
c040326d:	c1 e8 18             	shr    $0x18,%eax
c0403270:	eb 08                	jmp    c040327a <int_initialise_uniproc+0x32>
c0403272:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403277:	0f b6 c0             	movzbl %al,%eax
c040327a:	83 ec 04             	sub    $0x4,%esp
c040327d:	6a 64                	push   $0x64
c040327f:	50                   	push   %eax
c0403280:	68 30 e4 40 c0       	push   $0xc040e430
c0403285:	e8 cc a1 00 00       	call   c040d456 <debug_printf>
c040328a:	83 c4 10             	add    $0x10,%esp
}
c040328d:	83 c4 0c             	add    $0xc,%esp
c0403290:	c3                   	ret    
c0403291:	00 00                	add    %al,(%eax)
	...

c0403294 <syscall_do_exit>:

#define SYSCALL_RETURN(a) do { regs->eax = (unsigned int)(a); return; } while(0)

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
c0403294:	53                   	push   %ebx
c0403295:	83 ec 08             	sub    $0x8,%esp
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				  cpu_table[CPU_ID].current->tid);
c0403298:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040329e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04032a3:	3c 01                	cmp    $0x1,%al
c04032a5:	76 0f                	jbe    c04032b6 <syscall_do_exit+0x22>
c04032a7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04032ac:	8b 00                	mov    (%eax),%eax
c04032ae:	c1 e8 18             	shr    $0x18,%eax
c04032b1:	c1 e0 06             	shl    $0x6,%eax
c04032b4:	eb 0b                	jmp    c04032c1 <syscall_do_exit+0x2d>
c04032b6:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04032bb:	0f b6 c0             	movzbl %al,%eax
c04032be:	c1 e0 06             	shl    $0x6,%eax
c04032c1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04032c4:	8b 40 04             	mov    0x4(%eax),%eax

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04032c7:	8b 58 04             	mov    0x4(%eax),%ebx
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04032ca:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04032d0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04032d5:	3c 01                	cmp    $0x1,%al
c04032d7:	76 0f                	jbe    c04032e8 <syscall_do_exit+0x54>
c04032d9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04032de:	8b 00                	mov    (%eax),%eax
c04032e0:	c1 e8 18             	shr    $0x18,%eax
c04032e3:	c1 e0 06             	shl    $0x6,%eax
c04032e6:	eb 0b                	jmp    c04032f3 <syscall_do_exit+0x5f>
c04032e8:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04032ed:	0f b6 c0             	movzbl %al,%eax
c04032f0:	c1 e0 06             	shl    $0x6,%eax
c04032f3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04032f6:	8b 40 04             	mov    0x4(%eax),%eax

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04032f9:	8b 08                	mov    (%eax),%ecx
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04032fb:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403301:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403306:	3c 01                	cmp    $0x1,%al
c0403308:	76 0f                	jbe    c0403319 <syscall_do_exit+0x85>
c040330a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040330f:	8b 00                	mov    (%eax),%eax
c0403311:	c1 e8 18             	shr    $0x18,%eax
c0403314:	c1 e0 06             	shl    $0x6,%eax
c0403317:	eb 0b                	jmp    c0403324 <syscall_do_exit+0x90>
c0403319:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040331e:	0f b6 c0             	movzbl %al,%eax
c0403321:	c1 e0 06             	shl    $0x6,%eax
c0403324:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403327:	8b 40 04             	mov    0x4(%eax),%eax
c040332a:	8b 00                	mov    (%eax),%eax

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040332c:	8b 10                	mov    (%eax),%edx
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040332e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403333:	3c 01                	cmp    $0x1,%al
c0403335:	76 0c                	jbe    c0403343 <syscall_do_exit+0xaf>
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403337:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040333c:	8b 00                	mov    (%eax),%eax

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040333e:	c1 e8 18             	shr    $0x18,%eax
c0403341:	eb 08                	jmp    c040334b <syscall_do_exit+0xb7>
c0403343:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403348:	0f b6 c0             	movzbl %al,%eax
c040334b:	83 ec 0c             	sub    $0xc,%esp
c040334e:	53                   	push   %ebx
c040334f:	51                   	push   %ecx
c0403350:	52                   	push   %edx
c0403351:	50                   	push   %eax
c0403352:	68 50 e4 40 c0       	push   $0xc040e450
c0403357:	e8 fa a0 00 00       	call   c040d456 <debug_printf>
c040335c:	83 c4 20             	add    $0x20,%esp
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				  cpu_table[CPU_ID].current->tid);
#endif

	/* request to be killed by the system executive */
	msg_send_signal(proc_sys_executive, SIGXPROCEXIT, cpu_table[CPU_ID].current->proc->pid);
c040335f:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403365:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040336a:	3c 01                	cmp    $0x1,%al
c040336c:	76 0f                	jbe    c040337d <syscall_do_exit+0xe9>
c040336e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403373:	8b 00                	mov    (%eax),%eax
c0403375:	c1 e8 18             	shr    $0x18,%eax
c0403378:	c1 e0 06             	shl    $0x6,%eax
c040337b:	eb 0b                	jmp    c0403388 <syscall_do_exit+0xf4>
c040337d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403382:	0f b6 c0             	movzbl %al,%eax
c0403385:	c1 e0 06             	shl    $0x6,%eax
c0403388:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040338b:	8b 40 04             	mov    0x4(%eax),%eax
c040338e:	8b 00                	mov    (%eax),%eax
c0403390:	8b 10                	mov    (%eax),%edx
c0403392:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c0403397:	83 ec 04             	sub    $0x4,%esp
c040339a:	52                   	push   %edx
c040339b:	6a 22                	push   $0x22
c040339d:	50                   	push   %eax
c040339e:	e8 05 0e 00 00       	call   c04041a8 <msg_send_signal>
c04033a3:	83 c4 10             	add    $0x10,%esp

	/* remove from the run queue and mark as dying */
	sched_remove(cpu_table[CPU_ID].current, dead);
c04033a6:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04033ac:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04033b1:	3c 01                	cmp    $0x1,%al
c04033b3:	76 0f                	jbe    c04033c4 <syscall_do_exit+0x130>
c04033b5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04033ba:	8b 00                	mov    (%eax),%eax
c04033bc:	c1 e8 18             	shr    $0x18,%eax
c04033bf:	c1 e0 06             	shl    $0x6,%eax
c04033c2:	eb 0b                	jmp    c04033cf <syscall_do_exit+0x13b>
c04033c4:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04033c9:	0f b6 c0             	movzbl %al,%eax
c04033cc:	c1 e0 06             	shl    $0x6,%eax
c04033cf:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04033d2:	8b 40 04             	mov    0x4(%eax),%eax
c04033d5:	83 ec 08             	sub    $0x8,%esp
c04033d8:	6a 06                	push   $0x6
c04033da:	50                   	push   %eax
c04033db:	e8 61 26 00 00       	call   c0405a41 <sched_remove>
c04033e0:	83 c4 10             	add    $0x10,%esp
}
c04033e3:	83 c4 08             	add    $0x8,%esp
c04033e6:	5b                   	pop    %ebx
c04033e7:	c3                   	ret    

c04033e8 <syscall_do_fork>:

/* syscall: fork - duplicate the currently running process as per:
	http://www.opengroup.org/onlinepubs/009695399/functions/fork.html
   <= eax = -1 for failure, 0 for the child or the new child's PID for the parent */
void syscall_do_fork(int_registers_block *regs)
{
c04033e8:	53                   	push   %ebx
c04033e9:	83 ec 18             	sub    $0x18,%esp
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);
c04033ec:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04033f2:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04033f7:	3c 01                	cmp    $0x1,%al
c04033f9:	76 0f                	jbe    c040340a <syscall_do_fork+0x22>
c04033fb:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403400:	8b 00                	mov    (%eax),%eax
c0403402:	c1 e8 18             	shr    $0x18,%eax
c0403405:	c1 e0 06             	shl    $0x6,%eax
c0403408:	eb 0b                	jmp    c0403415 <syscall_do_fork+0x2d>
c040340a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040340f:	0f b6 c0             	movzbl %al,%eax
c0403412:	c1 e0 06             	shl    $0x6,%eax
c0403415:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403418:	8b 40 04             	mov    0x4(%eax),%eax
void syscall_do_fork(int_registers_block *regs)
{
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040341b:	8b 58 04             	mov    0x4(%eax),%ebx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040341e:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403424:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403429:	3c 01                	cmp    $0x1,%al
c040342b:	76 0f                	jbe    c040343c <syscall_do_fork+0x54>
c040342d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403432:	8b 00                	mov    (%eax),%eax
c0403434:	c1 e8 18             	shr    $0x18,%eax
c0403437:	c1 e0 06             	shl    $0x6,%eax
c040343a:	eb 0b                	jmp    c0403447 <syscall_do_fork+0x5f>
c040343c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403441:	0f b6 c0             	movzbl %al,%eax
c0403444:	c1 e0 06             	shl    $0x6,%eax
c0403447:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040344a:	8b 40 04             	mov    0x4(%eax),%eax
void syscall_do_fork(int_registers_block *regs)
{
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040344d:	8b 08                	mov    (%eax),%ecx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040344f:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403455:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040345a:	3c 01                	cmp    $0x1,%al
c040345c:	76 0f                	jbe    c040346d <syscall_do_fork+0x85>
c040345e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403463:	8b 00                	mov    (%eax),%eax
c0403465:	c1 e8 18             	shr    $0x18,%eax
c0403468:	c1 e0 06             	shl    $0x6,%eax
c040346b:	eb 0b                	jmp    c0403478 <syscall_do_fork+0x90>
c040346d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403472:	0f b6 c0             	movzbl %al,%eax
c0403475:	c1 e0 06             	shl    $0x6,%eax
c0403478:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040347b:	8b 40 04             	mov    0x4(%eax),%eax
c040347e:	8b 00                	mov    (%eax),%eax
void syscall_do_fork(int_registers_block *regs)
{
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403480:	8b 10                	mov    (%eax),%edx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403482:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
void syscall_do_fork(int_registers_block *regs)
{
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403487:	3c 01                	cmp    $0x1,%al
c0403489:	76 0c                	jbe    c0403497 <syscall_do_fork+0xaf>
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040348b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403490:	8b 00                	mov    (%eax),%eax
void syscall_do_fork(int_registers_block *regs)
{
	process *new;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403492:	c1 e8 18             	shr    $0x18,%eax
c0403495:	eb 08                	jmp    c040349f <syscall_do_fork+0xb7>
c0403497:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040349c:	0f b6 c0             	movzbl %al,%eax
c040349f:	83 ec 0c             	sub    $0xc,%esp
c04034a2:	53                   	push   %ebx
c04034a3:	51                   	push   %ecx
c04034a4:	52                   	push   %edx
c04034a5:	50                   	push   %eax
c04034a6:	68 90 e4 40 c0       	push   $0xc040e490
c04034ab:	e8 a6 9f 00 00       	call   c040d456 <debug_printf>
c04034b0:	83 c4 20             	add    $0x20,%esp
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);
#endif
	
	new = proc_new(cpu_table[CPU_ID].current->proc, cpu_table[CPU_ID].current);
c04034b3:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04034b9:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04034be:	3c 01                	cmp    $0x1,%al
c04034c0:	76 0f                	jbe    c04034d1 <syscall_do_fork+0xe9>
c04034c2:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04034c7:	8b 00                	mov    (%eax),%eax
c04034c9:	c1 e8 18             	shr    $0x18,%eax
c04034cc:	c1 e0 06             	shl    $0x6,%eax
c04034cf:	eb 0b                	jmp    c04034dc <syscall_do_fork+0xf4>
c04034d1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04034d6:	0f b6 c0             	movzbl %al,%eax
c04034d9:	c1 e0 06             	shl    $0x6,%eax
c04034dc:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04034df:	8b 50 04             	mov    0x4(%eax),%edx
c04034e2:	8b 0d e4 38 41 c0    	mov    0xc04138e4,%ecx
c04034e8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04034ed:	3c 01                	cmp    $0x1,%al
c04034ef:	76 0f                	jbe    c0403500 <syscall_do_fork+0x118>
c04034f1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04034f6:	8b 00                	mov    (%eax),%eax
c04034f8:	c1 e8 18             	shr    $0x18,%eax
c04034fb:	c1 e0 06             	shl    $0x6,%eax
c04034fe:	eb 0b                	jmp    c040350b <syscall_do_fork+0x123>
c0403500:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403505:	0f b6 c0             	movzbl %al,%eax
c0403508:	c1 e0 06             	shl    $0x6,%eax
c040350b:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040350e:	8b 40 04             	mov    0x4(%eax),%eax
c0403511:	8b 00                	mov    (%eax),%eax
c0403513:	83 ec 08             	sub    $0x8,%esp
c0403516:	52                   	push   %edx
c0403517:	50                   	push   %eax
c0403518:	e8 fa 7f 00 00       	call   c040b517 <proc_new>
c040351d:	83 c4 10             	add    $0x10,%esp
c0403520:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	/* return the right info */
	if(!new) SYSCALL_RETURN(POSIX_GENERIC_FAILURE); /* POSIX_GENERIC_FAILURE == -1 */
c0403524:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0403529:	75 10                	jne    c040353b <syscall_do_fork+0x153>
c040352b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040352f:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0403536:	e9 b2 00 00 00       	jmp    c04035ed <syscall_do_fork+0x205>

	thread *tnew;

	tnew = thread_find_thread(new, cpu_table[CPU_ID].current->tid);
c040353b:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403541:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403546:	3c 01                	cmp    $0x1,%al
c0403548:	76 0f                	jbe    c0403559 <syscall_do_fork+0x171>
c040354a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040354f:	8b 00                	mov    (%eax),%eax
c0403551:	c1 e8 18             	shr    $0x18,%eax
c0403554:	c1 e0 06             	shl    $0x6,%eax
c0403557:	eb 0b                	jmp    c0403564 <syscall_do_fork+0x17c>
c0403559:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040355e:	0f b6 c0             	movzbl %al,%eax
c0403561:	c1 e0 06             	shl    $0x6,%eax
c0403564:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403567:	8b 40 04             	mov    0x4(%eax),%eax
c040356a:	8b 40 04             	mov    0x4(%eax),%eax
c040356d:	83 ec 08             	sub    $0x8,%esp
c0403570:	50                   	push   %eax
c0403571:	ff 74 24 14          	pushl  0x14(%esp)
c0403575:	e8 ce 70 00 00       	call   c040a648 <thread_find_thread>
c040357a:	83 c4 10             	add    $0x10,%esp
c040357d:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* don't forget to init the tss for the new thread in the new process and duplicate the 
	   state of the current thread */
	vmm_memcpy(&(tnew->regs), regs, sizeof(int_registers_block));
c0403581:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403585:	05 a0 00 00 00       	add    $0xa0,%eax
c040358a:	83 ec 04             	sub    $0x4,%esp
c040358d:	6a 40                	push   $0x40
c040358f:	ff 74 24 28          	pushl  0x28(%esp)
c0403593:	50                   	push   %eax
c0403594:	e8 8a 37 00 00       	call   c0406d23 <vmm_memcpy>
c0403599:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(tnew);
c040359c:	83 ec 0c             	sub    $0xc,%esp
c040359f:	ff 74 24 18          	pushl  0x18(%esp)
c04035a3:	e8 6d d7 ff ff       	call   c0400d15 <x86_init_tss>
c04035a8:	83 c4 10             	add    $0x10,%esp
	
	/* zero eax on the new thread and set the child PID in eax for the parent */
	tnew->regs.eax = 0;
c04035ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04035af:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
c04035b6:	00 00 00 
	regs->eax = new->pid;
c04035b9:	8b 44 24 08          	mov    0x8(%esp),%eax
c04035bd:	8b 10                	mov    (%eax),%edx
c04035bf:	8b 44 24 20          	mov    0x20(%esp),%eax
c04035c3:	89 50 20             	mov    %edx,0x20(%eax)
	
	/* run the new thread */
	sched_add(tnew->proc->cpu, tnew->priority, tnew);
c04035c6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04035ca:	8a 40 0e             	mov    0xe(%eax),%al
c04035cd:	0f b6 d0             	movzbl %al,%edx
c04035d0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04035d4:	8b 00                	mov    (%eax),%eax
c04035d6:	8a 40 0c             	mov    0xc(%eax),%al
c04035d9:	0f b6 c0             	movzbl %al,%eax
c04035dc:	83 ec 04             	sub    $0x4,%esp
c04035df:	ff 74 24 10          	pushl  0x10(%esp)
c04035e3:	52                   	push   %edx
c04035e4:	50                   	push   %eax
c04035e5:	e8 35 22 00 00       	call   c040581f <sched_add>
c04035ea:	83 c4 10             	add    $0x10,%esp
}
c04035ed:	83 c4 18             	add    $0x18,%esp
c04035f0:	5b                   	pop    %ebx
c04035f1:	c3                   	ret    

c04035f2 <syscall_do_kill>:
	to terminate itself, it should ask the executive or its parent via syscall:exit
	=> eax = PID for the process to kill
	<= eax = 0 for success or -1 for a failure
*/
void syscall_do_kill(int_registers_block *regs)
{
c04035f2:	56                   	push   %esi
c04035f3:	53                   	push   %ebx
c04035f4:	83 ec 14             	sub    $0x14,%esp
	unsigned int victim = regs->eax;
c04035f7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04035fb:	8b 40 20             	mov    0x20(%eax),%eax
c04035fe:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
c0403602:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403608:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040360d:	3c 01                	cmp    $0x1,%al
c040360f:	76 0f                	jbe    c0403620 <syscall_do_kill+0x2e>
c0403611:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403616:	8b 00                	mov    (%eax),%eax
c0403618:	c1 e8 18             	shr    $0x18,%eax
c040361b:	c1 e0 06             	shl    $0x6,%eax
c040361e:	eb 0b                	jmp    c040362b <syscall_do_kill+0x39>
c0403620:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403625:	0f b6 c0             	movzbl %al,%eax
c0403628:	c1 e0 06             	shl    $0x6,%eax
c040362b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040362e:	8b 40 04             	mov    0x4(%eax),%eax
void syscall_do_kill(int_registers_block *regs)
{
	unsigned int victim = regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403631:	8b 70 04             	mov    0x4(%eax),%esi
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403634:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040363a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040363f:	3c 01                	cmp    $0x1,%al
c0403641:	76 0f                	jbe    c0403652 <syscall_do_kill+0x60>
c0403643:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403648:	8b 00                	mov    (%eax),%eax
c040364a:	c1 e8 18             	shr    $0x18,%eax
c040364d:	c1 e0 06             	shl    $0x6,%eax
c0403650:	eb 0b                	jmp    c040365d <syscall_do_kill+0x6b>
c0403652:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403657:	0f b6 c0             	movzbl %al,%eax
c040365a:	c1 e0 06             	shl    $0x6,%eax
c040365d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403660:	8b 40 04             	mov    0x4(%eax),%eax
void syscall_do_kill(int_registers_block *regs)
{
	unsigned int victim = regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403663:	8b 18                	mov    (%eax),%ebx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403665:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040366b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403670:	3c 01                	cmp    $0x1,%al
c0403672:	76 0f                	jbe    c0403683 <syscall_do_kill+0x91>
c0403674:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403679:	8b 00                	mov    (%eax),%eax
c040367b:	c1 e8 18             	shr    $0x18,%eax
c040367e:	c1 e0 06             	shl    $0x6,%eax
c0403681:	eb 0b                	jmp    c040368e <syscall_do_kill+0x9c>
c0403683:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403688:	0f b6 c0             	movzbl %al,%eax
c040368b:	c1 e0 06             	shl    $0x6,%eax
c040368e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403691:	8b 40 04             	mov    0x4(%eax),%eax
c0403694:	8b 00                	mov    (%eax),%eax
void syscall_do_kill(int_registers_block *regs)
{
	unsigned int victim = regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403696:	8b 08                	mov    (%eax),%ecx
c0403698:	8b 44 24 20          	mov    0x20(%esp),%eax
c040369c:	8b 50 20             	mov    0x20(%eax),%edx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040369f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
void syscall_do_kill(int_registers_block *regs)
{
	unsigned int victim = regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04036a4:	3c 01                	cmp    $0x1,%al
c04036a6:	76 0c                	jbe    c04036b4 <syscall_do_kill+0xc2>
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04036a8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04036ad:	8b 00                	mov    (%eax),%eax
void syscall_do_kill(int_registers_block *regs)
{
	unsigned int victim = regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04036af:	c1 e8 18             	shr    $0x18,%eax
c04036b2:	eb 08                	jmp    c04036bc <syscall_do_kill+0xca>
c04036b4:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04036b9:	0f b6 c0             	movzbl %al,%eax
c04036bc:	83 ec 08             	sub    $0x8,%esp
c04036bf:	56                   	push   %esi
c04036c0:	53                   	push   %ebx
c04036c1:	51                   	push   %ecx
c04036c2:	52                   	push   %edx
c04036c3:	50                   	push   %eax
c04036c4:	68 d0 e4 40 c0       	push   $0xc040e4d0
c04036c9:	e8 88 9d 00 00       	call   c040d456 <debug_printf>
c04036ce:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
#endif
	
	regs->eax = proc_kill(victim, cpu_table[CPU_ID].current->proc);
c04036d1:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04036d7:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04036dc:	3c 01                	cmp    $0x1,%al
c04036de:	76 0f                	jbe    c04036ef <syscall_do_kill+0xfd>
c04036e0:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04036e5:	8b 00                	mov    (%eax),%eax
c04036e7:	c1 e8 18             	shr    $0x18,%eax
c04036ea:	c1 e0 06             	shl    $0x6,%eax
c04036ed:	eb 0b                	jmp    c04036fa <syscall_do_kill+0x108>
c04036ef:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04036f4:	0f b6 c0             	movzbl %al,%eax
c04036f7:	c1 e0 06             	shl    $0x6,%eax
c04036fa:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04036fd:	8b 40 04             	mov    0x4(%eax),%eax
c0403700:	8b 00                	mov    (%eax),%eax
c0403702:	83 ec 08             	sub    $0x8,%esp
c0403705:	50                   	push   %eax
c0403706:	ff 74 24 18          	pushl  0x18(%esp)
c040370a:	e8 c8 81 00 00       	call   c040b8d7 <proc_kill>
c040370f:	83 c4 10             	add    $0x10,%esp
c0403712:	8b 54 24 20          	mov    0x20(%esp),%edx
c0403716:	89 42 20             	mov    %eax,0x20(%edx)
	
	if(!(regs->eax) && cpu_table[CPU_ID].current->proc != proc_sys_executive)
c0403719:	8b 44 24 20          	mov    0x20(%esp),%eax
c040371d:	8b 40 20             	mov    0x20(%eax),%eax
c0403720:	85 c0                	test   %eax,%eax
c0403722:	75 51                	jne    c0403775 <syscall_do_kill+0x183>
c0403724:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040372a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040372f:	3c 01                	cmp    $0x1,%al
c0403731:	76 0f                	jbe    c0403742 <syscall_do_kill+0x150>
c0403733:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403738:	8b 00                	mov    (%eax),%eax
c040373a:	c1 e8 18             	shr    $0x18,%eax
c040373d:	c1 e0 06             	shl    $0x6,%eax
c0403740:	eb 0b                	jmp    c040374d <syscall_do_kill+0x15b>
c0403742:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403747:	0f b6 c0             	movzbl %al,%eax
c040374a:	c1 e0 06             	shl    $0x6,%eax
c040374d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403750:	8b 40 04             	mov    0x4(%eax),%eax
c0403753:	8b 10                	mov    (%eax),%edx
c0403755:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c040375a:	39 c2                	cmp    %eax,%edx
c040375c:	74 17                	je     c0403775 <syscall_do_kill+0x183>
		/* inform the system executive that a process has been killed */
		msg_send_signal(proc_sys_executive, SIGXPROCKILLED, victim);
c040375e:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c0403763:	83 ec 04             	sub    $0x4,%esp
c0403766:	ff 74 24 10          	pushl  0x10(%esp)
c040376a:	6a 20                	push   $0x20
c040376c:	50                   	push   %eax
c040376d:	e8 36 0a 00 00       	call   c04041a8 <msg_send_signal>
c0403772:	83 c4 10             	add    $0x10,%esp
}
c0403775:	83 c4 14             	add    $0x14,%esp
c0403778:	5b                   	pop    %ebx
c0403779:	5e                   	pop    %esi
c040377a:	c3                   	ret    

c040377b <syscall_do_yield>:
   NOTE: this syscall should really be called thread_yield :-/
	=> no parameters required
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
c040377b:	53                   	push   %ebx
c040377c:	83 ec 08             	sub    $0x8,%esp
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);
c040377f:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403785:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040378a:	3c 01                	cmp    $0x1,%al
c040378c:	76 0f                	jbe    c040379d <syscall_do_yield+0x22>
c040378e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403793:	8b 00                	mov    (%eax),%eax
c0403795:	c1 e8 18             	shr    $0x18,%eax
c0403798:	c1 e0 06             	shl    $0x6,%eax
c040379b:	eb 0b                	jmp    c04037a8 <syscall_do_yield+0x2d>
c040379d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04037a2:	0f b6 c0             	movzbl %al,%eax
c04037a5:	c1 e0 06             	shl    $0x6,%eax
c04037a8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04037ab:	8b 40 04             	mov    0x4(%eax),%eax
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04037ae:	8b 58 04             	mov    0x4(%eax),%ebx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04037b1:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04037b7:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04037bc:	3c 01                	cmp    $0x1,%al
c04037be:	76 0f                	jbe    c04037cf <syscall_do_yield+0x54>
c04037c0:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04037c5:	8b 00                	mov    (%eax),%eax
c04037c7:	c1 e8 18             	shr    $0x18,%eax
c04037ca:	c1 e0 06             	shl    $0x6,%eax
c04037cd:	eb 0b                	jmp    c04037da <syscall_do_yield+0x5f>
c04037cf:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04037d4:	0f b6 c0             	movzbl %al,%eax
c04037d7:	c1 e0 06             	shl    $0x6,%eax
c04037da:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04037dd:	8b 40 04             	mov    0x4(%eax),%eax
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04037e0:	8b 08                	mov    (%eax),%ecx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04037e2:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04037e8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04037ed:	3c 01                	cmp    $0x1,%al
c04037ef:	76 0f                	jbe    c0403800 <syscall_do_yield+0x85>
c04037f1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04037f6:	8b 00                	mov    (%eax),%eax
c04037f8:	c1 e8 18             	shr    $0x18,%eax
c04037fb:	c1 e0 06             	shl    $0x6,%eax
c04037fe:	eb 0b                	jmp    c040380b <syscall_do_yield+0x90>
c0403800:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403805:	0f b6 c0             	movzbl %al,%eax
c0403808:	c1 e0 06             	shl    $0x6,%eax
c040380b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040380e:	8b 40 04             	mov    0x4(%eax),%eax
c0403811:	8b 00                	mov    (%eax),%eax
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403813:	8b 10                	mov    (%eax),%edx
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403815:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040381a:	3c 01                	cmp    $0x1,%al
c040381c:	76 0c                	jbe    c040382a <syscall_do_yield+0xaf>
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040381e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403823:	8b 00                	mov    (%eax),%eax
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403825:	c1 e8 18             	shr    $0x18,%eax
c0403828:	eb 08                	jmp    c0403832 <syscall_do_yield+0xb7>
c040382a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040382f:	0f b6 c0             	movzbl %al,%eax
c0403832:	83 ec 0c             	sub    $0xc,%esp
c0403835:	53                   	push   %ebx
c0403836:	51                   	push   %ecx
c0403837:	52                   	push   %edx
c0403838:	50                   	push   %eax
c0403839:	68 14 e5 40 c0       	push   $0xc040e514
c040383e:	e8 13 9c 00 00       	call   c040d456 <debug_printf>
c0403843:	83 c4 20             	add    $0x20,%esp
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);
#endif

	sched_move_to_end(CPU_ID, cpu_table[CPU_ID].current->priority, cpu_table[CPU_ID].current);
c0403846:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040384c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403851:	3c 01                	cmp    $0x1,%al
c0403853:	76 0f                	jbe    c0403864 <syscall_do_yield+0xe9>
c0403855:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040385a:	8b 00                	mov    (%eax),%eax
c040385c:	c1 e8 18             	shr    $0x18,%eax
c040385f:	c1 e0 06             	shl    $0x6,%eax
c0403862:	eb 0b                	jmp    c040386f <syscall_do_yield+0xf4>
c0403864:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403869:	0f b6 c0             	movzbl %al,%eax
c040386c:	c1 e0 06             	shl    $0x6,%eax
c040386f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403872:	8b 48 04             	mov    0x4(%eax),%ecx
c0403875:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040387b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403880:	3c 01                	cmp    $0x1,%al
c0403882:	76 0f                	jbe    c0403893 <syscall_do_yield+0x118>
c0403884:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403889:	8b 00                	mov    (%eax),%eax
c040388b:	c1 e8 18             	shr    $0x18,%eax
c040388e:	c1 e0 06             	shl    $0x6,%eax
c0403891:	eb 0b                	jmp    c040389e <syscall_do_yield+0x123>
c0403893:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403898:	0f b6 c0             	movzbl %al,%eax
c040389b:	c1 e0 06             	shl    $0x6,%eax
c040389e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04038a1:	8b 40 04             	mov    0x4(%eax),%eax
c04038a4:	8a 40 0e             	mov    0xe(%eax),%al
c04038a7:	0f b6 d0             	movzbl %al,%edx
c04038aa:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04038af:	3c 01                	cmp    $0x1,%al
c04038b1:	76 0f                	jbe    c04038c2 <syscall_do_yield+0x147>
c04038b3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04038b8:	8b 00                	mov    (%eax),%eax
c04038ba:	c1 e8 18             	shr    $0x18,%eax
c04038bd:	0f b6 c0             	movzbl %al,%eax
c04038c0:	eb 08                	jmp    c04038ca <syscall_do_yield+0x14f>
c04038c2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04038c7:	0f b6 c0             	movzbl %al,%eax
c04038ca:	83 ec 04             	sub    $0x4,%esp
c04038cd:	51                   	push   %ecx
c04038ce:	52                   	push   %edx
c04038cf:	50                   	push   %eax
c04038d0:	e8 30 1d 00 00       	call   c0405605 <sched_move_to_end>
c04038d5:	83 c4 10             	add    $0x10,%esp

	/* the syscall dispatch will call sched_pick() for us */
}
c04038d8:	83 c4 08             	add    $0x8,%esp
c04038db:	5b                   	pop    %ebx
c04038dc:	c3                   	ret    

c04038dd <syscall_do_thread_exit>:

/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
c04038dd:	56                   	push   %esi
c04038de:	53                   	push   %ebx
c04038df:	83 ec 04             	sub    $0x4,%esp
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->thread_count);
c04038e2:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04038e8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04038ed:	3c 01                	cmp    $0x1,%al
c04038ef:	76 0f                	jbe    c0403900 <syscall_do_thread_exit+0x23>
c04038f1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04038f6:	8b 00                	mov    (%eax),%eax
c04038f8:	c1 e8 18             	shr    $0x18,%eax
c04038fb:	c1 e0 06             	shl    $0x6,%eax
c04038fe:	eb 0b                	jmp    c040390b <syscall_do_thread_exit+0x2e>
c0403900:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403905:	0f b6 c0             	movzbl %al,%eax
c0403908:	c1 e0 06             	shl    $0x6,%eax
c040390b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040390e:	8b 40 04             	mov    0x4(%eax),%eax
c0403911:	8b 00                	mov    (%eax),%eax
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c0403913:	8b 70 3c             	mov    0x3c(%eax),%esi
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->thread_count);
c0403916:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040391c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403921:	3c 01                	cmp    $0x1,%al
c0403923:	76 0f                	jbe    c0403934 <syscall_do_thread_exit+0x57>
c0403925:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040392a:	8b 00                	mov    (%eax),%eax
c040392c:	c1 e8 18             	shr    $0x18,%eax
c040392f:	c1 e0 06             	shl    $0x6,%eax
c0403932:	eb 0b                	jmp    c040393f <syscall_do_thread_exit+0x62>
c0403934:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403939:	0f b6 c0             	movzbl %al,%eax
c040393c:	c1 e0 06             	shl    $0x6,%eax
c040393f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403942:	8b 40 04             	mov    0x4(%eax),%eax
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c0403945:	8b 58 04             	mov    0x4(%eax),%ebx
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403948:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040394e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403953:	3c 01                	cmp    $0x1,%al
c0403955:	76 0f                	jbe    c0403966 <syscall_do_thread_exit+0x89>
c0403957:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040395c:	8b 00                	mov    (%eax),%eax
c040395e:	c1 e8 18             	shr    $0x18,%eax
c0403961:	c1 e0 06             	shl    $0x6,%eax
c0403964:	eb 0b                	jmp    c0403971 <syscall_do_thread_exit+0x94>
c0403966:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040396b:	0f b6 c0             	movzbl %al,%eax
c040396e:	c1 e0 06             	shl    $0x6,%eax
c0403971:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403974:	8b 40 04             	mov    0x4(%eax),%eax
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c0403977:	8b 08                	mov    (%eax),%ecx
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403979:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040397f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403984:	3c 01                	cmp    $0x1,%al
c0403986:	76 0f                	jbe    c0403997 <syscall_do_thread_exit+0xba>
c0403988:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040398d:	8b 00                	mov    (%eax),%eax
c040398f:	c1 e8 18             	shr    $0x18,%eax
c0403992:	c1 e0 06             	shl    $0x6,%eax
c0403995:	eb 0b                	jmp    c04039a2 <syscall_do_thread_exit+0xc5>
c0403997:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040399c:	0f b6 c0             	movzbl %al,%eax
c040399f:	c1 e0 06             	shl    $0x6,%eax
c04039a2:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04039a5:	8b 40 04             	mov    0x4(%eax),%eax
c04039a8:	8b 00                	mov    (%eax),%eax
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c04039aa:	8b 10                	mov    (%eax),%edx
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04039ac:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c04039b1:	3c 01                	cmp    $0x1,%al
c04039b3:	76 0c                	jbe    c04039c1 <syscall_do_thread_exit+0xe4>
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04039b5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04039ba:	8b 00                	mov    (%eax),%eax
/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n" DEBUG_COL_OFF,
c04039bc:	c1 e8 18             	shr    $0x18,%eax
c04039bf:	eb 08                	jmp    c04039c9 <syscall_do_thread_exit+0xec>
c04039c1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04039c6:	0f b6 c0             	movzbl %al,%eax
c04039c9:	83 ec 08             	sub    $0x8,%esp
c04039cc:	56                   	push   %esi
c04039cd:	53                   	push   %ebx
c04039ce:	51                   	push   %ecx
c04039cf:	52                   	push   %edx
c04039d0:	50                   	push   %eax
c04039d1:	68 54 e5 40 c0       	push   $0xc040e554
c04039d6:	e8 7b 9a 00 00       	call   c040d456 <debug_printf>
c04039db:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->thread_count);
#endif
	
	/* check to see if this process has only one thread */
	if(cpu_table[CPU_ID].current->proc->thread_count < 2)
c04039de:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04039e4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04039e9:	3c 01                	cmp    $0x1,%al
c04039eb:	76 0f                	jbe    c04039fc <syscall_do_thread_exit+0x11f>
c04039ed:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04039f2:	8b 00                	mov    (%eax),%eax
c04039f4:	c1 e8 18             	shr    $0x18,%eax
c04039f7:	c1 e0 06             	shl    $0x6,%eax
c04039fa:	eb 0b                	jmp    c0403a07 <syscall_do_thread_exit+0x12a>
c04039fc:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403a01:	0f b6 c0             	movzbl %al,%eax
c0403a04:	c1 e0 06             	shl    $0x6,%eax
c0403a07:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403a0a:	8b 40 04             	mov    0x4(%eax),%eax
c0403a0d:	8b 00                	mov    (%eax),%eax
c0403a0f:	8b 40 3c             	mov    0x3c(%eax),%eax
c0403a12:	83 f8 01             	cmp    $0x1,%eax
c0403a15:	77 14                	ja     c0403a2b <syscall_do_thread_exit+0x14e>
	{
		syscall_do_exit(regs);
c0403a17:	83 ec 0c             	sub    $0xc,%esp
c0403a1a:	ff 74 24 1c          	pushl  0x1c(%esp)
c0403a1e:	e8 71 f8 ff ff       	call   c0403294 <syscall_do_exit>
c0403a23:	83 c4 10             	add    $0x10,%esp
		return;
c0403a26:	e9 84 00 00 00       	jmp    c0403aaf <syscall_do_thread_exit+0x1d2>
	}
	
	/* request to be killed by the system executive */
	msg_send_signal(proc_sys_executive, SIGXTHREADEXIT, cpu_table[CPU_ID].current->proc->pid);
c0403a2b:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403a31:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403a36:	3c 01                	cmp    $0x1,%al
c0403a38:	76 0f                	jbe    c0403a49 <syscall_do_thread_exit+0x16c>
c0403a3a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403a3f:	8b 00                	mov    (%eax),%eax
c0403a41:	c1 e8 18             	shr    $0x18,%eax
c0403a44:	c1 e0 06             	shl    $0x6,%eax
c0403a47:	eb 0b                	jmp    c0403a54 <syscall_do_thread_exit+0x177>
c0403a49:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403a4e:	0f b6 c0             	movzbl %al,%eax
c0403a51:	c1 e0 06             	shl    $0x6,%eax
c0403a54:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403a57:	8b 40 04             	mov    0x4(%eax),%eax
c0403a5a:	8b 00                	mov    (%eax),%eax
c0403a5c:	8b 10                	mov    (%eax),%edx
c0403a5e:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c0403a63:	83 ec 04             	sub    $0x4,%esp
c0403a66:	52                   	push   %edx
c0403a67:	6a 24                	push   $0x24
c0403a69:	50                   	push   %eax
c0403a6a:	e8 39 07 00 00       	call   c04041a8 <msg_send_signal>
c0403a6f:	83 c4 10             	add    $0x10,%esp
	
	/* remove from the run queue and mark as dying */
	sched_remove(cpu_table[CPU_ID].current, dead);	
c0403a72:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403a78:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403a7d:	3c 01                	cmp    $0x1,%al
c0403a7f:	76 0f                	jbe    c0403a90 <syscall_do_thread_exit+0x1b3>
c0403a81:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403a86:	8b 00                	mov    (%eax),%eax
c0403a88:	c1 e8 18             	shr    $0x18,%eax
c0403a8b:	c1 e0 06             	shl    $0x6,%eax
c0403a8e:	eb 0b                	jmp    c0403a9b <syscall_do_thread_exit+0x1be>
c0403a90:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403a95:	0f b6 c0             	movzbl %al,%eax
c0403a98:	c1 e0 06             	shl    $0x6,%eax
c0403a9b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403a9e:	8b 40 04             	mov    0x4(%eax),%eax
c0403aa1:	83 ec 08             	sub    $0x8,%esp
c0403aa4:	6a 06                	push   $0x6
c0403aa6:	50                   	push   %eax
c0403aa7:	e8 95 1f 00 00       	call   c0405a41 <sched_remove>
c0403aac:	83 c4 10             	add    $0x10,%esp
}
c0403aaf:	83 c4 04             	add    $0x4,%esp
c0403ab2:	5b                   	pop    %ebx
c0403ab3:	5e                   	pop    %esi
c0403ab4:	c3                   	ret    

c0403ab5 <syscall_do_thread_fork>:

/* syscall: thread_fork - duplicate the current thread inside the currently-running
	process, much like a process fork()
   <= eax = -1 for failure, 0 for the new thread or the new thread's TID for the caller */
void syscall_do_thread_fork(int_registers_block *regs)
{
c0403ab5:	57                   	push   %edi
c0403ab6:	56                   	push   %esi
c0403ab7:	53                   	push   %ebx
c0403ab8:	83 ec 10             	sub    $0x10,%esp
	thread *new, *current = cpu_table[CPU_ID].current;
c0403abb:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403ac1:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403ac6:	3c 01                	cmp    $0x1,%al
c0403ac8:	76 0f                	jbe    c0403ad9 <syscall_do_thread_fork+0x24>
c0403aca:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403acf:	8b 00                	mov    (%eax),%eax
c0403ad1:	c1 e8 18             	shr    $0x18,%eax
c0403ad4:	c1 e0 06             	shl    $0x6,%eax
c0403ad7:	eb 0b                	jmp    c0403ae4 <syscall_do_thread_fork+0x2f>
c0403ad9:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403ade:	0f b6 c0             	movzbl %al,%eax
c0403ae1:	c1 e0 06             	shl    $0x6,%eax
c0403ae4:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403ae7:	8b 40 04             	mov    0x4(%eax),%eax
c0403aea:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_FORK called by process %i (%p) (thread %i usresp %x)\n" DEBUG_COL_OFF,
c0403aee:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403af2:	8b 70 38             	mov    0x38(%eax),%esi
c0403af5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403af9:	8b 58 04             	mov    0x4(%eax),%ebx
c0403afc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403b00:	8b 08                	mov    (%eax),%ecx
			  CPU_ID, current->proc->pid, current->proc, current->tid, regs->useresp);
c0403b02:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403b06:	8b 00                	mov    (%eax),%eax
void syscall_do_thread_fork(int_registers_block *regs)
{
	thread *new, *current = cpu_table[CPU_ID].current;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_FORK called by process %i (%p) (thread %i usresp %x)\n" DEBUG_COL_OFF,
c0403b08:	8b 10                	mov    (%eax),%edx
			  CPU_ID, current->proc->pid, current->proc, current->tid, regs->useresp);
c0403b0a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
void syscall_do_thread_fork(int_registers_block *regs)
{
	thread *new, *current = cpu_table[CPU_ID].current;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_FORK called by process %i (%p) (thread %i usresp %x)\n" DEBUG_COL_OFF,
c0403b0f:	3c 01                	cmp    $0x1,%al
c0403b11:	76 0c                	jbe    c0403b1f <syscall_do_thread_fork+0x6a>
			  CPU_ID, current->proc->pid, current->proc, current->tid, regs->useresp);
c0403b13:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403b18:	8b 00                	mov    (%eax),%eax
void syscall_do_thread_fork(int_registers_block *regs)
{
	thread *new, *current = cpu_table[CPU_ID].current;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_FORK called by process %i (%p) (thread %i usresp %x)\n" DEBUG_COL_OFF,
c0403b1a:	c1 e8 18             	shr    $0x18,%eax
c0403b1d:	eb 08                	jmp    c0403b27 <syscall_do_thread_fork+0x72>
c0403b1f:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403b24:	0f b6 c0             	movzbl %al,%eax
c0403b27:	83 ec 08             	sub    $0x8,%esp
c0403b2a:	56                   	push   %esi
c0403b2b:	53                   	push   %ebx
c0403b2c:	51                   	push   %ecx
c0403b2d:	52                   	push   %edx
c0403b2e:	50                   	push   %eax
c0403b2f:	68 a4 e5 40 c0       	push   $0xc040e5a4
c0403b34:	e8 1d 99 00 00       	call   c040d456 <debug_printf>
c0403b39:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, current->proc->pid, current->proc, current->tid, regs->useresp);
#endif	

	/* create new thread and mark it as ready to run in usermode */
	new = thread_new(current->proc);
c0403b3c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403b40:	8b 00                	mov    (%eax),%eax
c0403b42:	83 ec 0c             	sub    $0xc,%esp
c0403b45:	50                   	push   %eax
c0403b46:	e8 ca 6f 00 00       	call   c040ab15 <thread_new>
c0403b4b:	83 c4 10             	add    $0x10,%esp
c0403b4e:	89 44 24 08          	mov    %eax,0x8(%esp)
	if(!new) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0403b52:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0403b57:	75 10                	jne    c0403b69 <syscall_do_thread_fork+0xb4>
c0403b59:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403b5d:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0403b64:	e9 8e 01 00 00       	jmp    c0403cf7 <syscall_do_thread_fork+0x242>
	new->flags |= THREAD_INUSERMODE;
c0403b69:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403b6d:	8a 40 0c             	mov    0xc(%eax),%al
c0403b70:	88 c2                	mov    %al,%dl
c0403b72:	83 ca 01             	or     $0x1,%edx
c0403b75:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403b79:	88 50 0c             	mov    %dl,0xc(%eax)
	
	/* copy the state of the caller thread into the state of the new thread */
	vmm_memcpy(&(new->regs), regs, sizeof(int_registers_block));
c0403b7c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403b80:	05 a0 00 00 00       	add    $0xa0,%eax
c0403b85:	83 ec 04             	sub    $0x4,%esp
c0403b88:	6a 40                	push   $0x40
c0403b8a:	ff 74 24 28          	pushl  0x28(%esp)
c0403b8e:	50                   	push   %eax
c0403b8f:	e8 8f 31 00 00       	call   c0406d23 <vmm_memcpy>
c0403b94:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(new);
c0403b97:	83 ec 0c             	sub    $0xc,%esp
c0403b9a:	ff 74 24 14          	pushl  0x14(%esp)
c0403b9e:	e8 72 d1 ff ff       	call   c0400d15 <x86_init_tss>
c0403ba3:	83 c4 10             	add    $0x10,%esp

	/* fix up the stack pointer and duplicate the stack  - only fix up the
		ebp if it looks like an active frame pointer, ugh :( */
	new->regs.useresp = new->stackbase - (current->stackbase - regs->useresp);
c0403ba6:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403baa:	8b 50 2c             	mov    0x2c(%eax),%edx
c0403bad:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403bb1:	8b 48 38             	mov    0x38(%eax),%ecx
c0403bb4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403bb8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0403bbb:	89 cb                	mov    %ecx,%ebx
c0403bbd:	29 c3                	sub    %eax,%ebx
c0403bbf:	89 d8                	mov    %ebx,%eax
c0403bc1:	01 c2                	add    %eax,%edx
c0403bc3:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403bc7:	89 90 d8 00 00 00    	mov    %edx,0xd8(%eax)
	
	if((regs->ebp <= new->stackbase) &&
c0403bcd:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403bd1:	8b 50 0c             	mov    0xc(%eax),%edx
c0403bd4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403bd8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0403bdb:	39 c2                	cmp    %eax,%edx
c0403bdd:	77 3e                	ja     c0403c1d <syscall_do_thread_fork+0x168>
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
c0403bdf:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403be3:	8b 50 0c             	mov    0xc(%eax),%edx
c0403be6:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403bea:	8b 40 2c             	mov    0x2c(%eax),%eax
c0403bed:	2d 00 40 00 00       	sub    $0x4000,%eax

	/* fix up the stack pointer and duplicate the stack  - only fix up the
		ebp if it looks like an active frame pointer, ugh :( */
	new->regs.useresp = new->stackbase - (current->stackbase - regs->useresp);
	
	if((regs->ebp <= new->stackbase) &&
c0403bf2:	39 c2                	cmp    %eax,%edx
c0403bf4:	76 27                	jbe    c0403c1d <syscall_do_thread_fork+0x168>
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
		new->regs.ebp = new->stackbase - (current->stackbase - regs->ebp);
c0403bf6:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403bfa:	8b 50 2c             	mov    0x2c(%eax),%edx
c0403bfd:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403c01:	8b 48 0c             	mov    0xc(%eax),%ecx
c0403c04:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403c08:	8b 40 2c             	mov    0x2c(%eax),%eax
c0403c0b:	89 cb                	mov    %ecx,%ebx
c0403c0d:	29 c3                	sub    %eax,%ebx
c0403c0f:	89 d8                	mov    %ebx,%eax
c0403c11:	01 c2                	add    %eax,%edx
c0403c13:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403c17:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] cloning stack: target esp %x source esp %x (%i bytes) (target stackbase %x source stackbase %x)\n" DEBUG_COL_OFF,
c0403c1d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403c21:	8b 70 2c             	mov    0x2c(%eax),%esi
c0403c24:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403c28:	8b 58 2c             	mov    0x2c(%eax),%ebx
c0403c2b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403c2f:	8b 50 2c             	mov    0x2c(%eax),%edx
c0403c32:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403c36:	8b 40 38             	mov    0x38(%eax),%eax
c0403c39:	89 d7                	mov    %edx,%edi
c0403c3b:	29 c7                	sub    %eax,%edi
c0403c3d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403c41:	8b 48 38             	mov    0x38(%eax),%ecx
c0403c44:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403c48:	8b 90 d8 00 00 00    	mov    0xd8(%eax),%edx
			  CPU_ID, new->regs.useresp, regs->useresp, current->stackbase - regs->useresp, new->stackbase, current->stackbase);
c0403c4e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	if((regs->ebp <= new->stackbase) &&
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
		new->regs.ebp = new->stackbase - (current->stackbase - regs->ebp);

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] cloning stack: target esp %x source esp %x (%i bytes) (target stackbase %x source stackbase %x)\n" DEBUG_COL_OFF,
c0403c53:	3c 01                	cmp    $0x1,%al
c0403c55:	76 0c                	jbe    c0403c63 <syscall_do_thread_fork+0x1ae>
			  CPU_ID, new->regs.useresp, regs->useresp, current->stackbase - regs->useresp, new->stackbase, current->stackbase);
c0403c57:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403c5c:	8b 00                	mov    (%eax),%eax
	if((regs->ebp <= new->stackbase) &&
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
		new->regs.ebp = new->stackbase - (current->stackbase - regs->ebp);

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] cloning stack: target esp %x source esp %x (%i bytes) (target stackbase %x source stackbase %x)\n" DEBUG_COL_OFF,
c0403c5e:	c1 e8 18             	shr    $0x18,%eax
c0403c61:	eb 08                	jmp    c0403c6b <syscall_do_thread_fork+0x1b6>
c0403c63:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403c68:	0f b6 c0             	movzbl %al,%eax
c0403c6b:	83 ec 04             	sub    $0x4,%esp
c0403c6e:	56                   	push   %esi
c0403c6f:	53                   	push   %ebx
c0403c70:	57                   	push   %edi
c0403c71:	51                   	push   %ecx
c0403c72:	52                   	push   %edx
c0403c73:	50                   	push   %eax
c0403c74:	68 f4 e5 40 c0       	push   $0xc040e5f4
c0403c79:	e8 d8 97 00 00       	call   c040d456 <debug_printf>
c0403c7e:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, new->regs.useresp, regs->useresp, current->stackbase - regs->useresp, new->stackbase, current->stackbase);
#endif
	
	vmm_memcpy((void *)(new->regs.useresp), (void *)(regs->useresp), current->stackbase - regs->useresp);
c0403c81:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403c85:	8b 50 2c             	mov    0x2c(%eax),%edx
c0403c88:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403c8c:	8b 40 38             	mov    0x38(%eax),%eax
c0403c8f:	89 d1                	mov    %edx,%ecx
c0403c91:	29 c1                	sub    %eax,%ecx
c0403c93:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403c97:	8b 40 38             	mov    0x38(%eax),%eax
c0403c9a:	89 c2                	mov    %eax,%edx
c0403c9c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ca0:	8b 80 d8 00 00 00    	mov    0xd8(%eax),%eax
c0403ca6:	83 ec 04             	sub    $0x4,%esp
c0403ca9:	51                   	push   %ecx
c0403caa:	52                   	push   %edx
c0403cab:	50                   	push   %eax
c0403cac:	e8 72 30 00 00       	call   c0406d23 <vmm_memcpy>
c0403cb1:	83 c4 10             	add    $0x10,%esp
	
	/* zero eax on the new thread and set the child PID in eax for the parent */
	new->regs.eax = 0;
c0403cb4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403cb8:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
c0403cbf:	00 00 00 
	regs->eax = new->tid;
c0403cc2:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403cc6:	8b 50 04             	mov    0x4(%eax),%edx
c0403cc9:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403ccd:	89 50 20             	mov    %edx,0x20(%eax)
	
	/* run the new thred */
	sched_add(new->proc->cpu, new->priority, new);	
c0403cd0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403cd4:	8a 40 0e             	mov    0xe(%eax),%al
c0403cd7:	0f b6 d0             	movzbl %al,%edx
c0403cda:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403cde:	8b 00                	mov    (%eax),%eax
c0403ce0:	8a 40 0c             	mov    0xc(%eax),%al
c0403ce3:	0f b6 c0             	movzbl %al,%eax
c0403ce6:	83 ec 04             	sub    $0x4,%esp
c0403ce9:	ff 74 24 0c          	pushl  0xc(%esp)
c0403ced:	52                   	push   %edx
c0403cee:	50                   	push   %eax
c0403cef:	e8 2b 1b 00 00       	call   c040581f <sched_add>
c0403cf4:	83 c4 10             	add    $0x10,%esp
}
c0403cf7:	83 c4 10             	add    $0x10,%esp
c0403cfa:	5b                   	pop    %ebx
c0403cfb:	5e                   	pop    %esi
c0403cfc:	5f                   	pop    %edi
c0403cfd:	c3                   	ret    

c0403cfe <syscall_do_thread_kill>:
   itself, it should ask the executive via syscall:thread_exit
	=> eax = TID for the thread to kill
	<= eax = 0 for success or -1 for a failure
*/
void syscall_do_thread_kill(int_registers_block *regs)
{
c0403cfe:	56                   	push   %esi
c0403cff:	53                   	push   %ebx
c0403d00:	83 ec 14             	sub    $0x14,%esp
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
c0403d03:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403d09:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403d0e:	3c 01                	cmp    $0x1,%al
c0403d10:	76 0f                	jbe    c0403d21 <syscall_do_thread_kill+0x23>
c0403d12:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403d17:	8b 00                	mov    (%eax),%eax
c0403d19:	c1 e8 18             	shr    $0x18,%eax
c0403d1c:	c1 e0 06             	shl    $0x6,%eax
c0403d1f:	eb 0b                	jmp    c0403d2c <syscall_do_thread_kill+0x2e>
c0403d21:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403d26:	0f b6 c0             	movzbl %al,%eax
c0403d29:	c1 e0 06             	shl    $0x6,%eax
c0403d2c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403d2f:	8b 40 04             	mov    0x4(%eax),%eax
c0403d32:	8b 00                	mov    (%eax),%eax
c0403d34:	89 44 24 08          	mov    %eax,0x8(%esp)
	thread *victim = thread_find_thread(owner, regs->eax);
c0403d38:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403d3c:	8b 40 20             	mov    0x20(%eax),%eax
c0403d3f:	83 ec 08             	sub    $0x8,%esp
c0403d42:	50                   	push   %eax
c0403d43:	ff 74 24 14          	pushl  0x14(%esp)
c0403d47:	e8 fc 68 00 00       	call   c040a648 <thread_find_thread>
c0403d4c:	83 c4 10             	add    $0x10,%esp
c0403d4f:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
c0403d53:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403d59:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403d5e:	3c 01                	cmp    $0x1,%al
c0403d60:	76 0f                	jbe    c0403d71 <syscall_do_thread_kill+0x73>
c0403d62:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403d67:	8b 00                	mov    (%eax),%eax
c0403d69:	c1 e8 18             	shr    $0x18,%eax
c0403d6c:	c1 e0 06             	shl    $0x6,%eax
c0403d6f:	eb 0b                	jmp    c0403d7c <syscall_do_thread_kill+0x7e>
c0403d71:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403d76:	0f b6 c0             	movzbl %al,%eax
c0403d79:	c1 e0 06             	shl    $0x6,%eax
c0403d7c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403d7f:	8b 40 04             	mov    0x4(%eax),%eax
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
	thread *victim = thread_find_thread(owner, regs->eax);
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403d82:	8b 70 04             	mov    0x4(%eax),%esi
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403d85:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403d8b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403d90:	3c 01                	cmp    $0x1,%al
c0403d92:	76 0f                	jbe    c0403da3 <syscall_do_thread_kill+0xa5>
c0403d94:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403d99:	8b 00                	mov    (%eax),%eax
c0403d9b:	c1 e8 18             	shr    $0x18,%eax
c0403d9e:	c1 e0 06             	shl    $0x6,%eax
c0403da1:	eb 0b                	jmp    c0403dae <syscall_do_thread_kill+0xb0>
c0403da3:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403da8:	0f b6 c0             	movzbl %al,%eax
c0403dab:	c1 e0 06             	shl    $0x6,%eax
c0403dae:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403db1:	8b 40 04             	mov    0x4(%eax),%eax
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
	thread *victim = thread_find_thread(owner, regs->eax);
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403db4:	8b 18                	mov    (%eax),%ebx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403db6:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403dbc:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403dc1:	3c 01                	cmp    $0x1,%al
c0403dc3:	76 0f                	jbe    c0403dd4 <syscall_do_thread_kill+0xd6>
c0403dc5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403dca:	8b 00                	mov    (%eax),%eax
c0403dcc:	c1 e8 18             	shr    $0x18,%eax
c0403dcf:	c1 e0 06             	shl    $0x6,%eax
c0403dd2:	eb 0b                	jmp    c0403ddf <syscall_do_thread_kill+0xe1>
c0403dd4:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403dd9:	0f b6 c0             	movzbl %al,%eax
c0403ddc:	c1 e0 06             	shl    $0x6,%eax
c0403ddf:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403de2:	8b 40 04             	mov    0x4(%eax),%eax
c0403de5:	8b 00                	mov    (%eax),%eax
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
	thread *victim = thread_find_thread(owner, regs->eax);
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403de7:	8b 08                	mov    (%eax),%ecx
c0403de9:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403ded:	8b 50 20             	mov    0x20(%eax),%edx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403df0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
	thread *victim = thread_find_thread(owner, regs->eax);
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403df5:	3c 01                	cmp    $0x1,%al
c0403df7:	76 0c                	jbe    c0403e05 <syscall_do_thread_kill+0x107>
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403df9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403dfe:	8b 00                	mov    (%eax),%eax
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
	thread *victim = thread_find_thread(owner, regs->eax);
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403e00:	c1 e8 18             	shr    $0x18,%eax
c0403e03:	eb 08                	jmp    c0403e0d <syscall_do_thread_kill+0x10f>
c0403e05:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403e0a:	0f b6 c0             	movzbl %al,%eax
c0403e0d:	83 ec 08             	sub    $0x8,%esp
c0403e10:	56                   	push   %esi
c0403e11:	53                   	push   %ebx
c0403e12:	51                   	push   %ecx
c0403e13:	52                   	push   %edx
c0403e14:	50                   	push   %eax
c0403e15:	68 60 e6 40 c0       	push   $0xc040e660
c0403e1a:	e8 37 96 00 00       	call   c040d456 <debug_printf>
c0403e1f:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
#endif
	
	/* bail out if we can't find the given thread or we're trying to kill ourselves */
	if(!victim || (victim == cpu_table[CPU_ID].current)) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0403e22:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0403e27:	74 35                	je     c0403e5e <syscall_do_thread_kill+0x160>
c0403e29:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403e2f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403e34:	3c 01                	cmp    $0x1,%al
c0403e36:	76 0f                	jbe    c0403e47 <syscall_do_thread_kill+0x149>
c0403e38:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403e3d:	8b 00                	mov    (%eax),%eax
c0403e3f:	c1 e8 18             	shr    $0x18,%eax
c0403e42:	c1 e0 06             	shl    $0x6,%eax
c0403e45:	eb 0b                	jmp    c0403e52 <syscall_do_thread_kill+0x154>
c0403e47:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403e4c:	0f b6 c0             	movzbl %al,%eax
c0403e4f:	c1 e0 06             	shl    $0x6,%eax
c0403e52:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403e55:	8b 40 04             	mov    0x4(%eax),%eax
c0403e58:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0403e5c:	75 10                	jne    c0403e6e <syscall_do_thread_kill+0x170>
c0403e5e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e62:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0403e69:	e9 90 00 00 00       	jmp    c0403efe <syscall_do_thread_kill+0x200>
	
	/* remove the thread */
	err = thread_kill(owner, victim);
c0403e6e:	83 ec 08             	sub    $0x8,%esp
c0403e71:	ff 74 24 14          	pushl  0x14(%esp)
c0403e75:	ff 74 24 14          	pushl  0x14(%esp)
c0403e79:	e8 d6 6f 00 00       	call   c040ae54 <thread_kill>
c0403e7e:	83 c4 10             	add    $0x10,%esp
c0403e81:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(err) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0403e85:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0403e8a:	74 0d                	je     c0403e99 <syscall_do_thread_kill+0x19b>
c0403e8c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e90:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0403e97:	eb 65                	jmp    c0403efe <syscall_do_thread_kill+0x200>

	/* stop this thread from running and mark it as dying for the sysexec to clear up */
	sched_remove(victim, dead);
c0403e99:	83 ec 08             	sub    $0x8,%esp
c0403e9c:	6a 06                	push   $0x6
c0403e9e:	ff 74 24 18          	pushl  0x18(%esp)
c0403ea2:	e8 9a 1b 00 00       	call   c0405a41 <sched_remove>
c0403ea7:	83 c4 10             	add    $0x10,%esp
	
	if(cpu_table[CPU_ID].current->proc != proc_sys_executive)
c0403eaa:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403eb0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403eb5:	3c 01                	cmp    $0x1,%al
c0403eb7:	76 0f                	jbe    c0403ec8 <syscall_do_thread_kill+0x1ca>
c0403eb9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403ebe:	8b 00                	mov    (%eax),%eax
c0403ec0:	c1 e8 18             	shr    $0x18,%eax
c0403ec3:	c1 e0 06             	shl    $0x6,%eax
c0403ec6:	eb 0b                	jmp    c0403ed3 <syscall_do_thread_kill+0x1d5>
c0403ec8:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403ecd:	0f b6 c0             	movzbl %al,%eax
c0403ed0:	c1 e0 06             	shl    $0x6,%eax
c0403ed3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403ed6:	8b 40 04             	mov    0x4(%eax),%eax
c0403ed9:	8b 10                	mov    (%eax),%edx
c0403edb:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c0403ee0:	39 c2                	cmp    %eax,%edx
c0403ee2:	74 1a                	je     c0403efe <syscall_do_thread_kill+0x200>
		/* inform the system executive that a thread has been killed */
		msg_send_signal(proc_sys_executive, SIGXTHREADKILLED, owner->pid);
c0403ee4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ee8:	8b 10                	mov    (%eax),%edx
c0403eea:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c0403eef:	83 ec 04             	sub    $0x4,%esp
c0403ef2:	52                   	push   %edx
c0403ef3:	6a 23                	push   $0x23
c0403ef5:	50                   	push   %eax
c0403ef6:	e8 ad 02 00 00       	call   c04041a8 <msg_send_signal>
c0403efb:	83 c4 10             	add    $0x10,%esp
}
c0403efe:	83 c4 14             	add    $0x14,%esp
c0403f01:	5b                   	pop    %ebx
c0403f02:	5e                   	pop    %esi
c0403f03:	c3                   	ret    

c0403f04 <syscall_do_msg_send>:
/* syscall:msg_send - send a message to a process and block until a reply is received
	=> eax = pointer to message description block
   <= eax = 0 for success or a diosix-specific error code
*/
void syscall_do_msg_send(int_registers_block *regs)
{
c0403f04:	56                   	push   %esi
c0403f05:	53                   	push   %ebx
c0403f06:	83 ec 14             	sub    $0x14,%esp
	thread *current = cpu_table[CPU_ID].current;
c0403f09:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403f0f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403f14:	3c 01                	cmp    $0x1,%al
c0403f16:	76 0f                	jbe    c0403f27 <syscall_do_msg_send+0x23>
c0403f18:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403f1d:	8b 00                	mov    (%eax),%eax
c0403f1f:	c1 e8 18             	shr    $0x18,%eax
c0403f22:	c1 e0 06             	shl    $0x6,%eax
c0403f25:	eb 0b                	jmp    c0403f32 <syscall_do_msg_send+0x2e>
c0403f27:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403f2c:	0f b6 c0             	movzbl %al,%eax
c0403f2f:	c1 e0 06             	shl    $0x6,%eax
c0403f32:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403f35:	8b 40 04             	mov    0x4(%eax),%eax
c0403f38:	89 44 24 08          	mov    %eax,0x8(%esp)
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
c0403f3c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403f40:	8b 40 20             	mov    0x20(%eax),%eax
c0403f43:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);
c0403f47:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403f4d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403f52:	3c 01                	cmp    $0x1,%al
c0403f54:	76 0f                	jbe    c0403f65 <syscall_do_msg_send+0x61>
c0403f56:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403f5b:	8b 00                	mov    (%eax),%eax
c0403f5d:	c1 e8 18             	shr    $0x18,%eax
c0403f60:	c1 e0 06             	shl    $0x6,%eax
c0403f63:	eb 0b                	jmp    c0403f70 <syscall_do_msg_send+0x6c>
c0403f65:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403f6a:	0f b6 c0             	movzbl %al,%eax
c0403f6d:	c1 e0 06             	shl    $0x6,%eax
c0403f70:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403f73:	8b 40 04             	mov    0x4(%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403f76:	8b 70 04             	mov    0x4(%eax),%esi
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403f79:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403f7f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403f84:	3c 01                	cmp    $0x1,%al
c0403f86:	76 0f                	jbe    c0403f97 <syscall_do_msg_send+0x93>
c0403f88:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403f8d:	8b 00                	mov    (%eax),%eax
c0403f8f:	c1 e8 18             	shr    $0x18,%eax
c0403f92:	c1 e0 06             	shl    $0x6,%eax
c0403f95:	eb 0b                	jmp    c0403fa2 <syscall_do_msg_send+0x9e>
c0403f97:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403f9c:	0f b6 c0             	movzbl %al,%eax
c0403f9f:	c1 e0 06             	shl    $0x6,%eax
c0403fa2:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403fa5:	8b 40 04             	mov    0x4(%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403fa8:	8b 18                	mov    (%eax),%ebx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403faa:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0403fb0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0403fb5:	3c 01                	cmp    $0x1,%al
c0403fb7:	76 0f                	jbe    c0403fc8 <syscall_do_msg_send+0xc4>
c0403fb9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403fbe:	8b 00                	mov    (%eax),%eax
c0403fc0:	c1 e8 18             	shr    $0x18,%eax
c0403fc3:	c1 e0 06             	shl    $0x6,%eax
c0403fc6:	eb 0b                	jmp    c0403fd3 <syscall_do_msg_send+0xcf>
c0403fc8:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403fcd:	0f b6 c0             	movzbl %al,%eax
c0403fd0:	c1 e0 06             	shl    $0x6,%eax
c0403fd3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403fd6:	8b 40 04             	mov    0x4(%eax),%eax
c0403fd9:	8b 00                	mov    (%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403fdb:	8b 08                	mov    (%eax),%ecx
c0403fdd:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403fe1:	8b 50 20             	mov    0x20(%eax),%edx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403fe4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403fe9:	3c 01                	cmp    $0x1,%al
c0403feb:	76 0c                	jbe    c0403ff9 <syscall_do_msg_send+0xf5>
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0403fed:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403ff2:	8b 00                	mov    (%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
	
#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0403ff4:	c1 e8 18             	shr    $0x18,%eax
c0403ff7:	eb 08                	jmp    c0404001 <syscall_do_msg_send+0xfd>
c0403ff9:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0403ffe:	0f b6 c0             	movzbl %al,%eax
c0404001:	83 ec 08             	sub    $0x8,%esp
c0404004:	56                   	push   %esi
c0404005:	53                   	push   %ebx
c0404006:	51                   	push   %ecx
c0404007:	52                   	push   %edx
c0404008:	50                   	push   %eax
c0404009:	68 a8 e6 40 c0       	push   $0xc040e6a8
c040400e:	e8 43 94 00 00       	call   c040d456 <debug_printf>
c0404013:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);
#endif

	/* sanitise the input data while we're here */
	if(!msg || ((unsigned int)msg >= KERNEL_SPACE_BASE)) SYSCALL_RETURN(e_bad_address);
c0404016:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040401b:	74 0b                	je     c0404028 <syscall_do_msg_send+0x124>
c040401d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404021:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0404026:	76 0d                	jbe    c0404035 <syscall_do_msg_send+0x131>
c0404028:	8b 44 24 20          	mov    0x20(%esp),%eax
c040402c:	c7 40 20 11 00 00 00 	movl   $0x11,0x20(%eax)
c0404033:	eb 1a                	jmp    c040404f <syscall_do_msg_send+0x14b>
	
	/* do the actual sending */
	regs->eax = msg_send(current, msg);
c0404035:	83 ec 08             	sub    $0x8,%esp
c0404038:	ff 74 24 14          	pushl  0x14(%esp)
c040403c:	ff 74 24 14          	pushl  0x14(%esp)
c0404040:	e8 4c 05 00 00       	call   c0404591 <msg_send>
c0404045:	83 c4 10             	add    $0x10,%esp
c0404048:	8b 54 24 20          	mov    0x20(%esp),%edx
c040404c:	89 42 20             	mov    %eax,0x20(%edx)
}
c040404f:	83 c4 14             	add    $0x14,%esp
c0404052:	5b                   	pop    %ebx
c0404053:	5e                   	pop    %esi
c0404054:	c3                   	ret    

c0404055 <syscall_do_msg_recv>:
/* syscall:msg_send - receive a message or block until a message is received
   => eax = pointer to message description block
   <= eax = 0 for success or a diosix-specific error code
*/
void syscall_do_msg_recv(int_registers_block *regs)
{
c0404055:	56                   	push   %esi
c0404056:	53                   	push   %ebx
c0404057:	83 ec 14             	sub    $0x14,%esp
	thread *current = cpu_table[CPU_ID].current;
c040405a:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0404060:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404065:	3c 01                	cmp    $0x1,%al
c0404067:	76 0f                	jbe    c0404078 <syscall_do_msg_recv+0x23>
c0404069:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040406e:	8b 00                	mov    (%eax),%eax
c0404070:	c1 e8 18             	shr    $0x18,%eax
c0404073:	c1 e0 06             	shl    $0x6,%eax
c0404076:	eb 0b                	jmp    c0404083 <syscall_do_msg_recv+0x2e>
c0404078:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040407d:	0f b6 c0             	movzbl %al,%eax
c0404080:	c1 e0 06             	shl    $0x6,%eax
c0404083:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0404086:	8b 40 04             	mov    0x4(%eax),%eax
c0404089:	89 44 24 08          	mov    %eax,0x8(%esp)
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
c040408d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404091:	8b 40 20             	mov    0x20(%eax),%eax
c0404094:	89 44 24 0c          	mov    %eax,0xc(%esp)

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);
c0404098:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040409e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04040a3:	3c 01                	cmp    $0x1,%al
c04040a5:	76 0f                	jbe    c04040b6 <syscall_do_msg_recv+0x61>
c04040a7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04040ac:	8b 00                	mov    (%eax),%eax
c04040ae:	c1 e8 18             	shr    $0x18,%eax
c04040b1:	c1 e0 06             	shl    $0x6,%eax
c04040b4:	eb 0b                	jmp    c04040c1 <syscall_do_msg_recv+0x6c>
c04040b6:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04040bb:	0f b6 c0             	movzbl %al,%eax
c04040be:	c1 e0 06             	shl    $0x6,%eax
c04040c1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04040c4:	8b 40 04             	mov    0x4(%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04040c7:	8b 70 04             	mov    0x4(%eax),%esi
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04040ca:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04040d0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04040d5:	3c 01                	cmp    $0x1,%al
c04040d7:	76 0f                	jbe    c04040e8 <syscall_do_msg_recv+0x93>
c04040d9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04040de:	8b 00                	mov    (%eax),%eax
c04040e0:	c1 e8 18             	shr    $0x18,%eax
c04040e3:	c1 e0 06             	shl    $0x6,%eax
c04040e6:	eb 0b                	jmp    c04040f3 <syscall_do_msg_recv+0x9e>
c04040e8:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04040ed:	0f b6 c0             	movzbl %al,%eax
c04040f0:	c1 e0 06             	shl    $0x6,%eax
c04040f3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04040f6:	8b 40 04             	mov    0x4(%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c04040f9:	8b 18                	mov    (%eax),%ebx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c04040fb:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0404101:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404106:	3c 01                	cmp    $0x1,%al
c0404108:	76 0f                	jbe    c0404119 <syscall_do_msg_recv+0xc4>
c040410a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040410f:	8b 00                	mov    (%eax),%eax
c0404111:	c1 e8 18             	shr    $0x18,%eax
c0404114:	c1 e0 06             	shl    $0x6,%eax
c0404117:	eb 0b                	jmp    c0404124 <syscall_do_msg_recv+0xcf>
c0404119:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040411e:	0f b6 c0             	movzbl %al,%eax
c0404121:	c1 e0 06             	shl    $0x6,%eax
c0404124:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0404127:	8b 40 04             	mov    0x4(%eax),%eax
c040412a:	8b 00                	mov    (%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040412c:	8b 08                	mov    (%eax),%ecx
c040412e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404132:	8b 50 20             	mov    0x20(%eax),%edx
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c0404135:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c040413a:	3c 01                	cmp    $0x1,%al
c040413c:	76 0c                	jbe    c040414a <syscall_do_msg_recv+0xf5>
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
c040413e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404143:	8b 00                	mov    (%eax),%eax
{
	thread *current = cpu_table[CPU_ID].current;
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;

#ifdef SYSCALL_DEBUG
	dprintf(DEBUG_COL_SYSCALLS "[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n" DEBUG_COL_OFF,
c0404145:	c1 e8 18             	shr    $0x18,%eax
c0404148:	eb 08                	jmp    c0404152 <syscall_do_msg_recv+0xfd>
c040414a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040414f:	0f b6 c0             	movzbl %al,%eax
c0404152:	83 ec 08             	sub    $0x8,%esp
c0404155:	56                   	push   %esi
c0404156:	53                   	push   %ebx
c0404157:	51                   	push   %ecx
c0404158:	52                   	push   %edx
c0404159:	50                   	push   %eax
c040415a:	68 f0 e6 40 c0       	push   $0xc040e6f0
c040415f:	e8 f2 92 00 00       	call   c040d456 <debug_printf>
c0404164:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);
#endif
	
	/* sanitise the input data while we're here */
	if(!msg || ((unsigned int)msg >= KERNEL_SPACE_BASE)) SYSCALL_RETURN(e_bad_address);
c0404167:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040416c:	74 0b                	je     c0404179 <syscall_do_msg_recv+0x124>
c040416e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404172:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0404177:	76 0d                	jbe    c0404186 <syscall_do_msg_recv+0x131>
c0404179:	8b 44 24 20          	mov    0x20(%esp),%eax
c040417d:	c7 40 20 11 00 00 00 	movl   $0x11,0x20(%eax)
c0404184:	eb 1a                	jmp    c04041a0 <syscall_do_msg_recv+0x14b>
	
	/* do the actual receiving */
	regs->eax = msg_recv(current, msg);
c0404186:	83 ec 08             	sub    $0x8,%esp
c0404189:	ff 74 24 14          	pushl  0x14(%esp)
c040418d:	ff 74 24 14          	pushl  0x14(%esp)
c0404191:	e8 0d 07 00 00       	call   c04048a3 <msg_recv>
c0404196:	83 c4 10             	add    $0x10,%esp
c0404199:	8b 54 24 20          	mov    0x20(%esp),%edx
c040419d:	89 42 20             	mov    %eax,0x20(%edx)
}
c04041a0:	83 c4 14             	add    $0x14,%esp
c04041a3:	5b                   	pop    %ebx
c04041a4:	5e                   	pop    %esi
c04041a5:	c3                   	ret    
	...

c04041a8 <msg_send_signal>:
		signum  = signal code to send
      sigcode = additional reason code
   <= 0 for success or an error reason code */
kresult msg_send_signal(process *target, unsigned int signum, unsigned int sigcode)
{
	return e_no_handler;
c04041a8:	b8 05 00 00 00       	mov    $0x5,%eax
}
c04041ad:	c3                   	ret    

c04041ae <msg_test_receiver>:
      target = thread message is trying to be sent to
      msg = message block trying to be sent
   <= 0 for success, or an error code
*/
kresult msg_test_receiver(thread *sender, thread *target, diosix_msg_info *msg)
{
c04041ae:	83 ec 1c             	sub    $0x1c,%esp
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
c04041b1:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c04041b6:	74 0e                	je     c04041c6 <msg_test_receiver+0x18>
c04041b8:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04041bd:	74 07                	je     c04041c6 <msg_test_receiver+0x18>
c04041bf:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04041c4:	75 44                	jne    c040420a <msg_test_receiver+0x5c>
	{
		dprintf("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
				  CPU_ID, sender, target, msg);
c04041c6:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
	{
		dprintf("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
c04041cb:	3c 01                	cmp    $0x1,%al
c04041cd:	76 0c                	jbe    c04041db <msg_test_receiver+0x2d>
				  CPU_ID, sender, target, msg);
c04041cf:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04041d4:	8b 00                	mov    (%eax),%eax
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
	{
		dprintf("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
c04041d6:	c1 e8 18             	shr    $0x18,%eax
c04041d9:	eb 08                	jmp    c04041e3 <msg_test_receiver+0x35>
c04041db:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04041e0:	0f b6 c0             	movzbl %al,%eax
c04041e3:	83 ec 0c             	sub    $0xc,%esp
c04041e6:	ff 74 24 34          	pushl  0x34(%esp)
c04041ea:	ff 74 24 34          	pushl  0x34(%esp)
c04041ee:	ff 74 24 34          	pushl  0x34(%esp)
c04041f2:	50                   	push   %eax
c04041f3:	68 38 e7 40 c0       	push   $0xc040e738
c04041f8:	e8 59 92 00 00       	call   c040d456 <debug_printf>
c04041fd:	83 c4 20             	add    $0x20,%esp
				  CPU_ID, sender, target, msg);
		return e_failure;
c0404200:	b8 01 00 00 00       	mov    $0x1,%eax
c0404205:	e9 e9 00 00 00       	jmp    c04042f3 <msg_test_receiver+0x145>
	}
	
	/* protect us from changes to the target's metadata */
	lock_gate(&(target->lock), LOCK_READ);
c040420a:	8b 44 24 24          	mov    0x24(%esp),%eax
c040420e:	83 c0 1c             	add    $0x1c,%eax
c0404211:	83 ec 08             	sub    $0x8,%esp
c0404214:	6a 00                	push   $0x0
c0404216:	50                   	push   %eax
c0404217:	e8 6f c2 ff ff       	call   c040048b <lock_gate>
c040421c:	83 c4 10             	add    $0x10,%esp
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c040421f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0404223:	8b 40 10             	mov    0x10(%eax),%eax
c0404226:	83 f8 03             	cmp    $0x3,%eax
c0404229:	75 1c                	jne    c0404247 <msg_test_receiver+0x99>
		(msg->flags & DIOSIX_MSG_REPLY) &&
c040422b:	8b 44 24 28          	mov    0x28(%esp),%eax
c040422f:	8b 40 08             	mov    0x8(%eax),%eax
	
	/* protect us from changes to the target's metadata */
	lock_gate(&(target->lock), LOCK_READ);
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c0404232:	85 c0                	test   %eax,%eax
c0404234:	79 11                	jns    c0404247 <msg_test_receiver+0x99>
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
c0404236:	8b 44 24 24          	mov    0x24(%esp),%eax
c040423a:	8b 40 14             	mov    0x14(%eax),%eax
	
	/* protect us from changes to the target's metadata */
	lock_gate(&(target->lock), LOCK_READ);
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c040423d:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404241:	0f 84 8e 00 00 00    	je     c04042d5 <msg_test_receiver+0x127>
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
		goto msg_test_receiver_success;
	
	/* is the target thread willing to accept the message type? */
	if(target->msg)
c0404247:	8b 44 24 24          	mov    0x24(%esp),%eax
c040424b:	8b 40 18             	mov    0x18(%eax),%eax
c040424e:	85 c0                	test   %eax,%eax
c0404250:	74 4a                	je     c040429c <msg_test_receiver+0xee>
	{
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
c0404252:	8b 44 24 24          	mov    0x24(%esp),%eax
c0404256:	8b 08                	mov    (%eax),%ecx
c0404258:	8b 44 24 24          	mov    0x24(%esp),%eax
c040425c:	8b 40 18             	mov    0x18(%eax),%eax
c040425f:	89 c2                	mov    %eax,%edx
c0404261:	8d 44 24 0c          	lea    0xc(%esp),%eax
c0404265:	83 ec 04             	sub    $0x4,%esp
c0404268:	51                   	push   %ecx
c0404269:	52                   	push   %edx
c040426a:	50                   	push   %eax
c040426b:	e8 ec 5b 00 00       	call   c0409e5c <pg_user2kernel>
c0404270:	83 c4 10             	add    $0x10,%esp
c0404273:	85 c0                	test   %eax,%eax
c0404275:	75 41                	jne    c04042b8 <msg_test_receiver+0x10a>
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
c0404277:	8b 44 24 24          	mov    0x24(%esp),%eax
c040427b:	8b 40 10             	mov    0x10(%eax),%eax
c040427e:	83 f8 04             	cmp    $0x4,%eax
c0404281:	75 19                	jne    c040429c <msg_test_receiver+0xee>
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
c0404283:	8b 44 24 28          	mov    0x28(%esp),%eax
c0404287:	8b 50 08             	mov    0x8(%eax),%edx
c040428a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040428e:	8b 40 08             	mov    0x8(%eax),%eax
c0404291:	21 d0                	and    %edx,%eax
c0404293:	25 ff 0f 00 00       	and    $0xfff,%eax
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
c0404298:	85 c0                	test   %eax,%eax
c040429a:	75 3c                	jne    c04042d8 <msg_test_receiver+0x12a>
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
			goto msg_test_receiver_success;
	}
	
	/* give up */
	unlock_gate(&(target->lock), LOCK_READ);
c040429c:	8b 44 24 24          	mov    0x24(%esp),%eax
c04042a0:	83 c0 1c             	add    $0x1c,%eax
c04042a3:	83 ec 08             	sub    $0x8,%esp
c04042a6:	6a 00                	push   $0x0
c04042a8:	50                   	push   %eax
c04042a9:	e8 fa c3 ff ff       	call   c04006a8 <unlock_gate>
c04042ae:	83 c4 10             	add    $0x10,%esp
	return e_no_receiver;
c04042b1:	b8 07 00 00 00       	mov    $0x7,%eax
c04042b6:	eb 3b                	jmp    c04042f3 <msg_test_receiver+0x145>
	if(target->msg)
	{
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
c04042b8:	90                   	nop
	/* give up */
	unlock_gate(&(target->lock), LOCK_READ);
	return e_no_receiver;
	
msg_test_receiver_failure:
	unlock_gate(&(target->lock), LOCK_READ);
c04042b9:	8b 44 24 24          	mov    0x24(%esp),%eax
c04042bd:	83 c0 1c             	add    $0x1c,%eax
c04042c0:	83 ec 08             	sub    $0x8,%esp
c04042c3:	6a 00                	push   $0x0
c04042c5:	50                   	push   %eax
c04042c6:	e8 dd c3 ff ff       	call   c04006a8 <unlock_gate>
c04042cb:	83 c4 10             	add    $0x10,%esp
	return e_failure;
c04042ce:	b8 01 00 00 00       	mov    $0x1,%eax
c04042d3:	eb 1e                	jmp    c04042f3 <msg_test_receiver+0x145>
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
		goto msg_test_receiver_success;
c04042d5:	90                   	nop
c04042d6:	eb 01                	jmp    c04042d9 <msg_test_receiver+0x12b>
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
			goto msg_test_receiver_success;
c04042d8:	90                   	nop
	unlock_gate(&(target->lock), LOCK_READ);
	return e_failure;
	
	/* unlock and escape with success */
msg_test_receiver_success:
	unlock_gate(&(target->lock), LOCK_READ);
c04042d9:	8b 44 24 24          	mov    0x24(%esp),%eax
c04042dd:	83 c0 1c             	add    $0x1c,%eax
c04042e0:	83 ec 08             	sub    $0x8,%esp
c04042e3:	6a 00                	push   $0x0
c04042e5:	50                   	push   %eax
c04042e6:	e8 bd c3 ff ff       	call   c04006a8 <unlock_gate>
c04042eb:	83 c4 10             	add    $0x10,%esp
	return success;
c04042ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04042f3:	83 c4 1c             	add    $0x1c,%esp
c04042f6:	c3                   	ret    

c04042f7 <msg_find_receiver>:
   => sender = thread trying to send the message
      msg = message block trying to be sent
   <= pointer to thread to send the message to, or NULL for none
*/
thread *msg_find_receiver(thread *sender, diosix_msg_info *msg)
{
c04042f7:	83 ec 1c             	sub    $0x1c,%esp
	process *proc;
	thread *recv;
	
	/* start with basic checks */
	if(!msg) return NULL;
c04042fa:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04042ff:	75 0a                	jne    c040430b <msg_find_receiver+0x14>
c0404301:	b8 00 00 00 00       	mov    $0x0,%eax
c0404306:	e9 16 01 00 00       	jmp    c0404421 <msg_find_receiver+0x12a>
	proc = proc_find_proc(msg->pid);
c040430b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040430f:	8b 00                	mov    (%eax),%eax
c0404311:	83 ec 0c             	sub    $0xc,%esp
c0404314:	50                   	push   %eax
c0404315:	e8 e6 6d 00 00       	call   c040b100 <proc_find_proc>
c040431a:	83 c4 10             	add    $0x10,%esp
c040431d:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(!proc) return NULL;
c0404321:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0404326:	75 0a                	jne    c0404332 <msg_find_receiver+0x3b>
c0404328:	b8 00 00 00 00       	mov    $0x0,%eax
c040432d:	e9 ef 00 00 00       	jmp    c0404421 <msg_find_receiver+0x12a>
	dprintf("[msg:%i] trying to find a receiver, sender=[tid %i pid %i] msg %p target=[tid %i pid %i]\n",
			  CPU_ID, sender->tid, sender->proc->pid, msg, msg->tid, msg->pid);
#endif
	
	/* if a specific tid is given, then try that one */ 
	if(msg->tid != DIOSIX_MSG_ANY_THREAD)
c0404332:	8b 44 24 24          	mov    0x24(%esp),%eax
c0404336:	8b 40 04             	mov    0x4(%eax),%eax
c0404339:	85 c0                	test   %eax,%eax
c040433b:	74 43                	je     c0404380 <msg_find_receiver+0x89>
	{
		recv = thread_find_thread(proc, msg->tid);
c040433d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0404341:	8b 40 04             	mov    0x4(%eax),%eax
c0404344:	83 ec 08             	sub    $0x8,%esp
c0404347:	50                   	push   %eax
c0404348:	ff 74 24 10          	pushl  0x10(%esp)
c040434c:	e8 f7 62 00 00       	call   c040a648 <thread_find_thread>
c0404351:	83 c4 10             	add    $0x10,%esp
c0404354:	89 44 24 08          	mov    %eax,0x8(%esp)
		if(msg_test_receiver(sender, recv, msg) == success) return recv;
c0404358:	83 ec 04             	sub    $0x4,%esp
c040435b:	ff 74 24 28          	pushl  0x28(%esp)
c040435f:	ff 74 24 10          	pushl  0x10(%esp)
c0404363:	ff 74 24 2c          	pushl  0x2c(%esp)
c0404367:	e8 42 fe ff ff       	call   c04041ae <msg_test_receiver>
c040436c:	83 c4 10             	add    $0x10,%esp
c040436f:	85 c0                	test   %eax,%eax
c0404371:	0f 85 a4 00 00 00    	jne    c040441b <msg_find_receiver+0x124>
c0404377:	8b 44 24 08          	mov    0x8(%esp),%eax
c040437b:	e9 a1 00 00 00       	jmp    c0404421 <msg_find_receiver+0x12a>
		/* otherwise search the targetted process for a thread that's blocking on
		 receive */
		unsigned int loop;
		
		/* protect us from process table changes */
		lock_gate(&proc_lock, LOCK_READ);
c0404380:	83 ec 08             	sub    $0x8,%esp
c0404383:	6a 00                	push   $0x0
c0404385:	68 ac 18 41 c0       	push   $0xc04118ac
c040438a:	e8 fc c0 ff ff       	call   c040048b <lock_gate>
c040438f:	83 c4 10             	add    $0x10,%esp
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0404392:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0404399:	00 
c040439a:	eb 64                	jmp    c0404400 <msg_find_receiver+0x109>
		{
			recv = proc->threads[loop];
c040439c:	8b 44 24 04          	mov    0x4(%esp),%eax
c04043a0:	8b 40 38             	mov    0x38(%eax),%eax
c04043a3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04043a7:	c1 e2 02             	shl    $0x2,%edx
c04043aa:	01 d0                	add    %edx,%eax
c04043ac:	8b 00                	mov    (%eax),%eax
c04043ae:	89 44 24 08          	mov    %eax,0x8(%esp)
			while(recv)
c04043b2:	eb 41                	jmp    c04043f5 <msg_find_receiver+0xfe>
			{
				if(msg_test_receiver(sender, recv, msg) == success)
c04043b4:	83 ec 04             	sub    $0x4,%esp
c04043b7:	ff 74 24 28          	pushl  0x28(%esp)
c04043bb:	ff 74 24 10          	pushl  0x10(%esp)
c04043bf:	ff 74 24 2c          	pushl  0x2c(%esp)
c04043c3:	e8 e6 fd ff ff       	call   c04041ae <msg_test_receiver>
c04043c8:	83 c4 10             	add    $0x10,%esp
c04043cb:	85 c0                	test   %eax,%eax
c04043cd:	75 18                	jne    c04043e7 <msg_find_receiver+0xf0>
				{
					unlock_gate(&proc_lock, LOCK_READ);
c04043cf:	83 ec 08             	sub    $0x8,%esp
c04043d2:	6a 00                	push   $0x0
c04043d4:	68 ac 18 41 c0       	push   $0xc04118ac
c04043d9:	e8 ca c2 ff ff       	call   c04006a8 <unlock_gate>
c04043de:	83 c4 10             	add    $0x10,%esp
					return recv;
c04043e1:	8b 44 24 08          	mov    0x8(%esp),%eax
c04043e5:	eb 3a                	jmp    c0404421 <msg_find_receiver+0x12a>
				}
				recv = recv->hash_next;
c04043e7:	8b 44 24 08          	mov    0x8(%esp),%eax
c04043eb:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c04043f1:	89 44 24 08          	mov    %eax,0x8(%esp)
		lock_gate(&proc_lock, LOCK_READ);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
		{
			recv = proc->threads[loop];
			while(recv)
c04043f5:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c04043fa:	75 b8                	jne    c04043b4 <msg_find_receiver+0xbd>
		unsigned int loop;
		
		/* protect us from process table changes */
		lock_gate(&proc_lock, LOCK_READ);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c04043fc:	ff 44 24 0c          	incl   0xc(%esp)
c0404400:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
c0404405:	76 95                	jbe    c040439c <msg_find_receiver+0xa5>
				}
				recv = recv->hash_next;
			}
		}
		
		unlock_gate(&proc_lock, LOCK_READ);
c0404407:	83 ec 08             	sub    $0x8,%esp
c040440a:	6a 00                	push   $0x0
c040440c:	68 ac 18 41 c0       	push   $0xc04118ac
c0404411:	e8 92 c2 ff ff       	call   c04006a8 <unlock_gate>
c0404416:	83 c4 10             	add    $0x10,%esp
c0404419:	eb 01                	jmp    c040441c <msg_find_receiver+0x125>
	
	/* if a specific tid is given, then try that one */ 
	if(msg->tid != DIOSIX_MSG_ANY_THREAD)
	{
		recv = thread_find_thread(proc, msg->tid);
		if(msg_test_receiver(sender, recv, msg) == success) return recv;
c040441b:	90                   	nop
		
		unlock_gate(&proc_lock, LOCK_READ);
	}
	
	/* fall through to returning with nothing */
	return NULL;
c040441c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404421:	83 c4 1c             	add    $0x1c,%esp
c0404424:	c3                   	ret    

c0404425 <msg_copy>:
               NB: this function updates this word to contain the offset after the copied data
      sender = thread sending the message
   <= 0 for success, or an error code
*/
kresult msg_copy(thread *receiver, void *data, unsigned int size, unsigned int *offset, thread *sender)
{
c0404425:	83 ec 1c             	sub    $0x1c,%esp
	diosix_msg_info *rmsg;
	unsigned int recv;
	unsigned int recv_base;
	
	/* protect us from metadata changes */
	lock_gate(&(receiver->lock), LOCK_READ);
c0404428:	8b 44 24 20          	mov    0x20(%esp),%eax
c040442c:	83 c0 1c             	add    $0x1c,%eax
c040442f:	83 ec 08             	sub    $0x8,%esp
c0404432:	6a 00                	push   $0x0
c0404434:	50                   	push   %eax
c0404435:	e8 51 c0 ff ff       	call   c040048b <lock_gate>
c040443a:	83 c4 10             	add    $0x10,%esp
	
	/* don't forget that within the context of the sending thread we can't access the
	 receiver's msg structure unless we go via a kernel mapping.. */
	if(pg_user2kernel((unsigned int *)&rmsg, (unsigned int)(receiver->msg), receiver->proc))
c040443d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404441:	8b 08                	mov    (%eax),%ecx
c0404443:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404447:	8b 40 18             	mov    0x18(%eax),%eax
c040444a:	89 c2                	mov    %eax,%edx
c040444c:	8d 44 24 04          	lea    0x4(%esp),%eax
c0404450:	83 ec 04             	sub    $0x4,%esp
c0404453:	51                   	push   %ecx
c0404454:	52                   	push   %edx
c0404455:	50                   	push   %eax
c0404456:	e8 01 5a 00 00       	call   c0409e5c <pg_user2kernel>
c040445b:	83 c4 10             	add    $0x10,%esp
c040445e:	85 c0                	test   %eax,%eax
c0404460:	74 1f                	je     c0404481 <msg_copy+0x5c>
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c0404462:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404466:	83 c0 1c             	add    $0x1c,%eax
c0404469:	83 ec 08             	sub    $0x8,%esp
c040446c:	6a 00                	push   $0x0
c040446e:	50                   	push   %eax
c040446f:	e8 34 c2 ff ff       	call   c04006a8 <unlock_gate>
c0404474:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404477:	b8 01 00 00 00       	mov    $0x1,%eax
c040447c:	e9 0c 01 00 00       	jmp    c040458d <msg_copy+0x168>
	}
	
	recv = (unsigned int)rmsg->recv;
c0404481:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404485:	8b 40 1c             	mov    0x1c(%eax),%eax
c0404488:	89 44 24 08          	mov    %eax,0x8(%esp)
	recv_base = recv + (*(offset));
c040448c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0404490:	8b 00                	mov    (%eax),%eax
c0404492:	03 44 24 08          	add    0x8(%esp),%eax
c0404496:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* stop abusive processes trying to smash out of a recv buffer */
	if((size > DIOSIX_MSG_MAX_SIZE) ||
c040449a:	81 7c 24 28 00 40 00 	cmpl   $0x4000,0x28(%esp)
c04044a1:	00 
c04044a2:	77 19                	ja     c04044bd <msg_copy+0x98>
		((recv_base + size) > (recv + rmsg->recv_max_size)))
c04044a4:	8b 44 24 28          	mov    0x28(%esp),%eax
c04044a8:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04044ac:	01 c2                	add    %eax,%edx
c04044ae:	8b 44 24 04          	mov    0x4(%esp),%eax
c04044b2:	8b 40 14             	mov    0x14(%eax),%eax
c04044b5:	03 44 24 08          	add    0x8(%esp),%eax
	
	recv = (unsigned int)rmsg->recv;
	recv_base = recv + (*(offset));
	
	/* stop abusive processes trying to smash out of a recv buffer */
	if((size > DIOSIX_MSG_MAX_SIZE) ||
c04044b9:	39 c2                	cmp    %eax,%edx
c04044bb:	76 1f                	jbe    c04044dc <msg_copy+0xb7>
		((recv_base + size) > (recv + rmsg->recv_max_size)))
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c04044bd:	8b 44 24 20          	mov    0x20(%esp),%eax
c04044c1:	83 c0 1c             	add    $0x1c,%eax
c04044c4:	83 ec 08             	sub    $0x8,%esp
c04044c7:	6a 00                	push   $0x0
c04044c9:	50                   	push   %eax
c04044ca:	e8 d9 c1 ff ff       	call   c04006a8 <unlock_gate>
c04044cf:	83 c4 10             	add    $0x10,%esp
		return e_too_big;
c04044d2:	b8 0c 00 00 00       	mov    $0xc,%eax
c04044d7:	e9 b1 00 00 00       	jmp    c040458d <msg_copy+0x168>
	}
	
	lock_gate(&(sender->lock), LOCK_READ);
c04044dc:	8b 44 24 30          	mov    0x30(%esp),%eax
c04044e0:	83 c0 1c             	add    $0x1c,%eax
c04044e3:	83 ec 08             	sub    $0x8,%esp
c04044e6:	6a 00                	push   $0x0
c04044e8:	50                   	push   %eax
c04044e9:	e8 9d bf ff ff       	call   c040048b <lock_gate>
c04044ee:	83 c4 10             	add    $0x10,%esp
	
	/* hand it over to the vmm to copy process-to-process - it'll sanity check the addresses */
	if(vmm_memcpyuser((void *)recv_base, receiver->proc, data, sender->proc, size))
c04044f1:	8b 44 24 30          	mov    0x30(%esp),%eax
c04044f5:	8b 08                	mov    (%eax),%ecx
c04044f7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04044fb:	8b 10                	mov    (%eax),%edx
c04044fd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404501:	83 ec 0c             	sub    $0xc,%esp
c0404504:	ff 74 24 34          	pushl  0x34(%esp)
c0404508:	51                   	push   %ecx
c0404509:	ff 74 24 38          	pushl  0x38(%esp)
c040450d:	52                   	push   %edx
c040450e:	50                   	push   %eax
c040450f:	e8 57 28 00 00       	call   c0406d6b <vmm_memcpyuser>
c0404514:	83 c4 20             	add    $0x20,%esp
c0404517:	85 c0                	test   %eax,%eax
c0404519:	74 31                	je     c040454c <msg_copy+0x127>
	{
		unlock_gate(&(sender->lock), LOCK_READ);
c040451b:	8b 44 24 30          	mov    0x30(%esp),%eax
c040451f:	83 c0 1c             	add    $0x1c,%eax
c0404522:	83 ec 08             	sub    $0x8,%esp
c0404525:	6a 00                	push   $0x0
c0404527:	50                   	push   %eax
c0404528:	e8 7b c1 ff ff       	call   c04006a8 <unlock_gate>
c040452d:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(receiver->lock), LOCK_READ);
c0404530:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404534:	83 c0 1c             	add    $0x1c,%eax
c0404537:	83 ec 08             	sub    $0x8,%esp
c040453a:	6a 00                	push   $0x0
c040453c:	50                   	push   %eax
c040453d:	e8 66 c1 ff ff       	call   c04006a8 <unlock_gate>
c0404542:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404545:	b8 01 00 00 00       	mov    $0x1,%eax
c040454a:	eb 41                	jmp    c040458d <msg_copy+0x168>
	}
	
	/* update offset */
	*(offset) += size;
c040454c:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0404550:	8b 00                	mov    (%eax),%eax
c0404552:	89 c2                	mov    %eax,%edx
c0404554:	03 54 24 28          	add    0x28(%esp),%edx
c0404558:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040455c:	89 10                	mov    %edx,(%eax)
	
	unlock_gate(&(sender->lock), LOCK_READ);
c040455e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0404562:	83 c0 1c             	add    $0x1c,%eax
c0404565:	83 ec 08             	sub    $0x8,%esp
c0404568:	6a 00                	push   $0x0
c040456a:	50                   	push   %eax
c040456b:	e8 38 c1 ff ff       	call   c04006a8 <unlock_gate>
c0404570:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(receiver->lock), LOCK_READ);
c0404573:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404577:	83 c0 1c             	add    $0x1c,%eax
c040457a:	83 ec 08             	sub    $0x8,%esp
c040457d:	6a 00                	push   $0x0
c040457f:	50                   	push   %eax
c0404580:	e8 23 c1 ff ff       	call   c04006a8 <unlock_gate>
c0404585:	83 c4 10             	add    $0x10,%esp
	return success;
c0404588:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040458d:	83 c4 1c             	add    $0x1c,%esp
c0404590:	c3                   	ret    

c0404591 <msg_send>:
   => sender = thread trying to send the message
      msg = message block
   <= 0 for success, or an error code
*/
kresult msg_send(thread *sender, diosix_msg_info *msg)
{
c0404591:	83 ec 2c             	sub    $0x2c,%esp
	thread *receiver;
	kresult err;
	unsigned int bytes_copied = 0, priority;
c0404594:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040459b:	00 
	diosix_msg_info *rmsg;

	/* sanity check the msg data */
	if(!msg || !sender) return e_bad_address;
c040459c:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04045a1:	74 07                	je     c04045aa <msg_send+0x19>
c04045a3:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04045a8:	75 0a                	jne    c04045b4 <msg_send+0x23>
c04045aa:	b8 11 00 00 00       	mov    $0x11,%eax
c04045af:	e9 eb 02 00 00       	jmp    c040489f <msg_send+0x30e>
	
	/* identify the receiver */
	receiver = msg_find_receiver(sender, msg);
c04045b4:	83 ec 08             	sub    $0x8,%esp
c04045b7:	ff 74 24 3c          	pushl  0x3c(%esp)
c04045bb:	ff 74 24 3c          	pushl  0x3c(%esp)
c04045bf:	e8 33 fd ff ff       	call   c04042f7 <msg_find_receiver>
c04045c4:	83 c4 10             	add    $0x10,%esp
c04045c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(!receiver) return e_no_receiver;
c04045cb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04045d0:	75 0a                	jne    c04045dc <msg_send+0x4b>
c04045d2:	b8 07 00 00 00       	mov    $0x7,%eax
c04045d7:	e9 c3 02 00 00       	jmp    c040489f <msg_send+0x30e>
	
	/* copy the message data */
	if(msg->flags & DIOSIX_MSG_MULTIPART)
c04045dc:	8b 44 24 34          	mov    0x34(%esp),%eax
c04045e0:	8b 40 08             	mov    0x8(%eax),%eax
c04045e3:	25 00 00 00 40       	and    $0x40000000,%eax
c04045e8:	85 c0                	test   %eax,%eax
c04045ea:	0f 84 99 00 00 00    	je     c0404689 <msg_send+0xf8>
	{
		/* gather the multipart message blocks */
		unsigned int loop;
		
		diosix_msg_multipart *parts = msg->send;
c04045f0:	8b 44 24 34          	mov    0x34(%esp),%eax
c04045f4:	8b 40 10             	mov    0x10(%eax),%eax
c04045f7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
c04045fb:	8b 44 24 34          	mov    0x34(%esp),%eax
c04045ff:	8b 40 0c             	mov    0xc(%eax),%eax
c0404602:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c0404609:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040460d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0404610:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0404615:	76 0a                	jbe    c0404621 <msg_send+0x90>
			return e_bad_address;
c0404617:	b8 11 00 00 00       	mov    $0x11,%eax
c040461c:	e9 7e 02 00 00       	jmp    c040489f <msg_send+0x30e>
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c0404621:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0404628:	00 
c0404629:	eb 4f                	jmp    c040467a <msg_send+0xe9>
		{
			err = msg_copy(receiver, parts[loop].data, parts[loop].size, &bytes_copied, sender);
c040462b:	8b 44 24 18          	mov    0x18(%esp),%eax
c040462f:	c1 e0 03             	shl    $0x3,%eax
c0404632:	03 44 24 1c          	add    0x1c(%esp),%eax
c0404636:	8b 10                	mov    (%eax),%edx
c0404638:	8b 44 24 18          	mov    0x18(%esp),%eax
c040463c:	c1 e0 03             	shl    $0x3,%eax
c040463f:	03 44 24 1c          	add    0x1c(%esp),%eax
c0404643:	8b 40 04             	mov    0x4(%eax),%eax
c0404646:	83 ec 0c             	sub    $0xc,%esp
c0404649:	ff 74 24 3c          	pushl  0x3c(%esp)
c040464d:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c0404651:	51                   	push   %ecx
c0404652:	52                   	push   %edx
c0404653:	50                   	push   %eax
c0404654:	ff 74 24 28          	pushl  0x28(%esp)
c0404658:	e8 c8 fd ff ff       	call   c0404425 <msg_copy>
c040465d:	83 c4 20             	add    $0x20,%esp
c0404660:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(err || (bytes_copied > DIOSIX_MSG_MAX_SIZE)) break;
c0404664:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0404669:	75 4c                	jne    c04046b7 <msg_send+0x126>
c040466b:	8b 44 24 08          	mov    0x8(%esp),%eax
c040466f:	3d 00 40 00 00       	cmp    $0x4000,%eax
c0404674:	77 44                	ja     c04046ba <msg_send+0x129>
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
			return e_bad_address;
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c0404676:	ff 44 24 18          	incl   0x18(%esp)
c040467a:	8b 44 24 34          	mov    0x34(%esp),%eax
c040467e:	8b 40 0c             	mov    0xc(%eax),%eax
c0404681:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0404685:	77 a4                	ja     c040462b <msg_send+0x9a>
c0404687:	eb 32                	jmp    c04046bb <msg_send+0x12a>
			if(err || (bytes_copied > DIOSIX_MSG_MAX_SIZE)) break;
		}
	}
	else
		/* do a simple message copy */
		err = msg_copy(receiver, msg->send, msg->send_size, &bytes_copied, sender);
c0404689:	8b 44 24 34          	mov    0x34(%esp),%eax
c040468d:	8b 50 0c             	mov    0xc(%eax),%edx
c0404690:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404694:	8b 40 10             	mov    0x10(%eax),%eax
c0404697:	83 ec 0c             	sub    $0xc,%esp
c040469a:	ff 74 24 3c          	pushl  0x3c(%esp)
c040469e:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c04046a2:	51                   	push   %ecx
c04046a3:	52                   	push   %edx
c04046a4:	50                   	push   %eax
c04046a5:	ff 74 24 28          	pushl  0x28(%esp)
c04046a9:	e8 77 fd ff ff       	call   c0404425 <msg_copy>
c04046ae:	83 c4 20             	add    $0x20,%esp
c04046b1:	89 44 24 10          	mov    %eax,0x10(%esp)
c04046b5:	eb 04                	jmp    c04046bb <msg_send+0x12a>
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
			return e_bad_address;
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c04046b7:	90                   	nop
c04046b8:	eb 01                	jmp    c04046bb <msg_send+0x12a>
c04046ba:	90                   	nop
	}
	else
		/* do a simple message copy */
		err = msg_copy(receiver, msg->send, msg->send_size, &bytes_copied, sender);
	
	if(err) return err;
c04046bb:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c04046c0:	74 09                	je     c04046cb <msg_send+0x13a>
c04046c2:	8b 44 24 10          	mov    0x10(%esp),%eax
c04046c6:	e9 d4 01 00 00       	jmp    c040489f <msg_send+0x30e>
	
	/* protect us from changes to the receiver's metadata */
	lock_gate(&(receiver->lock), LOCK_READ);
c04046cb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04046cf:	83 c0 1c             	add    $0x1c,%eax
c04046d2:	83 ec 08             	sub    $0x8,%esp
c04046d5:	6a 00                	push   $0x0
c04046d7:	50                   	push   %eax
c04046d8:	e8 ae bd ff ff       	call   c040048b <lock_gate>
c04046dd:	83 c4 10             	add    $0x10,%esp
	
	/* update the sender's and receiver's message block*/
	msg->pid = receiver->proc->pid;
c04046e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04046e4:	8b 00                	mov    (%eax),%eax
c04046e6:	8b 10                	mov    (%eax),%edx
c04046e8:	8b 44 24 34          	mov    0x34(%esp),%eax
c04046ec:	89 10                	mov    %edx,(%eax)
	msg->tid = receiver->tid;
c04046ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04046f2:	8b 50 04             	mov    0x4(%eax),%edx
c04046f5:	8b 44 24 34          	mov    0x34(%esp),%eax
c04046f9:	89 50 04             	mov    %edx,0x4(%eax)
	
	/* don't forget that within the context of the sending thread we can't access the
	 receiver's msg structure unless we go via a kernel mapping.. */
	if(pg_user2kernel((unsigned int *)&rmsg, (unsigned int)(receiver->msg), receiver->proc))
c04046fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404700:	8b 08                	mov    (%eax),%ecx
c0404702:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404706:	8b 40 18             	mov    0x18(%eax),%eax
c0404709:	89 c2                	mov    %eax,%edx
c040470b:	8d 44 24 04          	lea    0x4(%esp),%eax
c040470f:	83 ec 04             	sub    $0x4,%esp
c0404712:	51                   	push   %ecx
c0404713:	52                   	push   %edx
c0404714:	50                   	push   %eax
c0404715:	e8 42 57 00 00       	call   c0409e5c <pg_user2kernel>
c040471a:	83 c4 10             	add    $0x10,%esp
c040471d:	85 c0                	test   %eax,%eax
c040471f:	74 1f                	je     c0404740 <msg_send+0x1af>
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c0404721:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404725:	83 c0 1c             	add    $0x1c,%eax
c0404728:	83 ec 08             	sub    $0x8,%esp
c040472b:	6a 00                	push   $0x0
c040472d:	50                   	push   %eax
c040472e:	e8 75 bf ff ff       	call   c04006a8 <unlock_gate>
c0404733:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404736:	b8 01 00 00 00       	mov    $0x1,%eax
c040473b:	e9 5f 01 00 00       	jmp    c040489f <msg_send+0x30e>
	}

	/* protect us from changes to the sender's metadata */
	lock_gate(&(sender->lock), LOCK_READ);
c0404740:	8b 44 24 30          	mov    0x30(%esp),%eax
c0404744:	83 c0 1c             	add    $0x1c,%eax
c0404747:	83 ec 08             	sub    $0x8,%esp
c040474a:	6a 00                	push   $0x0
c040474c:	50                   	push   %eax
c040474d:	e8 39 bd ff ff       	call   c040048b <lock_gate>
c0404752:	83 c4 10             	add    $0x10,%esp
	
	rmsg->recv_size = bytes_copied;
c0404755:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404759:	8b 54 24 08          	mov    0x8(%esp),%edx
c040475d:	89 50 18             	mov    %edx,0x18(%eax)
	rmsg->pid = sender->proc->pid;
c0404760:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404764:	8b 54 24 30          	mov    0x30(%esp),%edx
c0404768:	8b 12                	mov    (%edx),%edx
c040476a:	8b 12                	mov    (%edx),%edx
c040476c:	89 10                	mov    %edx,(%eax)
	rmsg->tid = sender->tid;
c040476e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404772:	8b 54 24 30          	mov    0x30(%esp),%edx
c0404776:	8b 52 04             	mov    0x4(%edx),%edx
c0404779:	89 50 04             	mov    %edx,0x4(%eax)
	
	/* was the send a reply or an actual send? */
	if(msg->flags & DIOSIX_MSG_REPLY)
c040477c:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404780:	8b 40 08             	mov    0x8(%eax),%eax
c0404783:	85 c0                	test   %eax,%eax
c0404785:	79 38                	jns    c04047bf <msg_send+0x22e>
	{
		/* restore the receiver's priority if it was bumped up to send this reply */
		if(receiver->prev_priority > receiver->priority)
c0404787:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040478b:	8a 50 0f             	mov    0xf(%eax),%dl
c040478e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404792:	8a 40 0e             	mov    0xe(%eax),%al
c0404795:	38 c2                	cmp    %al,%dl
c0404797:	76 13                	jbe    c04047ac <msg_send+0x21b>
			priority = receiver->prev_priority;
c0404799:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040479d:	8a 40 0f             	mov    0xf(%eax),%al
c04047a0:	0f b6 c0             	movzbl %al,%eax
c04047a3:	89 44 24 14          	mov    %eax,0x14(%esp)
		else
			priority = receiver->priority;
c04047a7:	e9 a2 00 00 00       	jmp    c040484e <msg_send+0x2bd>
c04047ac:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04047b0:	8a 40 0e             	mov    0xe(%eax),%al
c04047b3:	0f b6 c0             	movzbl %al,%eax
c04047b6:	89 44 24 14          	mov    %eax,0x14(%esp)
c04047ba:	e9 8f 00 00 00       	jmp    c040484e <msg_send+0x2bd>
	}
	else
	{		
		/* if the sent message wasn't a reply, block sending thread to wait for a reply */
		sched_remove(sender, waitingforreply);
c04047bf:	83 ec 08             	sub    $0x8,%esp
c04047c2:	6a 03                	push   $0x3
c04047c4:	ff 74 24 3c          	pushl  0x3c(%esp)
c04047c8:	e8 74 12 00 00       	call   c0405a41 <sched_remove>
c04047cd:	83 c4 10             	add    $0x10,%esp
		
		lock_gate(&(sender->lock), LOCK_WRITE);
c04047d0:	8b 44 24 30          	mov    0x30(%esp),%eax
c04047d4:	83 c0 1c             	add    $0x1c,%eax
c04047d7:	83 ec 08             	sub    $0x8,%esp
c04047da:	6a 01                	push   $0x1
c04047dc:	50                   	push   %eax
c04047dd:	e8 a9 bc ff ff       	call   c040048b <lock_gate>
c04047e2:	83 c4 10             	add    $0x10,%esp

		sender->replysource = receiver;
c04047e5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04047e9:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04047ed:	89 50 14             	mov    %edx,0x14(%eax)
		
		/* take a copy of the message block ptr */
		sender->msg = msg;
c04047f0:	8b 44 24 30          	mov    0x30(%esp),%eax
c04047f4:	8b 54 24 34          	mov    0x34(%esp),%edx
c04047f8:	89 50 18             	mov    %edx,0x18(%eax)

		unlock_gate(&(sender->lock), LOCK_WRITE);
c04047fb:	8b 44 24 30          	mov    0x30(%esp),%eax
c04047ff:	83 c0 1c             	add    $0x1c,%eax
c0404802:	83 ec 08             	sub    $0x8,%esp
c0404805:	6a 01                	push   $0x1
c0404807:	50                   	push   %eax
c0404808:	e8 9b be ff ff       	call   c04006a8 <unlock_gate>
c040480d:	83 c4 10             	add    $0x10,%esp
		
		/* bump the receiver's priority up if the sender has a higher priority to
		   avoid priority inversion */
		receiver->prev_priority = receiver->priority;
c0404810:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404814:	8a 50 0e             	mov    0xe(%eax),%dl
c0404817:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040481b:	88 50 0f             	mov    %dl,0xf(%eax)
		if(sender->priority < receiver->priority)
c040481e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0404822:	8a 50 0e             	mov    0xe(%eax),%dl
c0404825:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404829:	8a 40 0e             	mov    0xe(%eax),%al
c040482c:	38 c2                	cmp    %al,%dl
c040482e:	73 10                	jae    c0404840 <msg_send+0x2af>
			priority = sender->priority;
c0404830:	8b 44 24 30          	mov    0x30(%esp),%eax
c0404834:	8a 40 0e             	mov    0xe(%eax),%al
c0404837:	0f b6 c0             	movzbl %al,%eax
c040483a:	89 44 24 14          	mov    %eax,0x14(%esp)
c040483e:	eb 0e                	jmp    c040484e <msg_send+0x2bd>
		else
			priority = receiver->priority;		
c0404840:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404844:	8a 40 0e             	mov    0xe(%eax),%al
c0404847:	0f b6 c0             	movzbl %al,%eax
c040484a:	89 44 24 14          	mov    %eax,0x14(%esp)
	}

	unlock_gate(&(sender->lock), LOCK_READ);
c040484e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0404852:	83 c0 1c             	add    $0x1c,%eax
c0404855:	83 ec 08             	sub    $0x8,%esp
c0404858:	6a 00                	push   $0x0
c040485a:	50                   	push   %eax
c040485b:	e8 48 be ff ff       	call   c04006a8 <unlock_gate>
c0404860:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(receiver->lock), LOCK_READ);
c0404863:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404867:	83 c0 1c             	add    $0x1c,%eax
c040486a:	83 ec 08             	sub    $0x8,%esp
c040486d:	6a 00                	push   $0x0
c040486f:	50                   	push   %eax
c0404870:	e8 33 be ff ff       	call   c04006a8 <unlock_gate>
c0404875:	83 c4 10             	add    $0x10,%esp
	
	/* wake up the receiving thread */
	sched_add(receiver->cpu, priority, receiver);
c0404878:	8b 44 24 14          	mov    0x14(%esp),%eax
c040487c:	0f b6 d0             	movzbl %al,%edx
c040487f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404883:	8b 40 08             	mov    0x8(%eax),%eax
c0404886:	0f b6 c0             	movzbl %al,%eax
c0404889:	83 ec 04             	sub    $0x4,%esp
c040488c:	ff 74 24 10          	pushl  0x10(%esp)
c0404890:	52                   	push   %edx
c0404891:	50                   	push   %eax
c0404892:	e8 88 0f 00 00       	call   c040581f <sched_add>
c0404897:	83 c4 10             	add    $0x10,%esp
	dprintf("[msg:%x] thread %i of process %i sent message %x (%i bytes first word %x) to thread %i of process %i\n",
			  CPU_ID, sender->tid, sender->proc->pid, msg->send, msg->send_size, *((unsigned int *)msg->send),
			  receiver->tid, receiver->proc->pid);
#endif
	
	return success;
c040489a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040489f:	83 c4 2c             	add    $0x2c,%esp
c04048a2:	c3                   	ret    

c04048a3 <msg_recv>:
   => receiver = thread waiting to receive
		info = block to fill with received message details
   <= success or an error code
*/
kresult msg_recv(thread *receiver, diosix_msg_info *msg)
{
c04048a3:	83 ec 0c             	sub    $0xc,%esp
	/* basic sanity checks */
	if(!receiver || !msg) return e_bad_address;
c04048a6:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c04048ab:	74 07                	je     c04048b4 <msg_recv+0x11>
c04048ad:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c04048b2:	75 07                	jne    c04048bb <msg_recv+0x18>
c04048b4:	b8 11 00 00 00       	mov    $0x11,%eax
c04048b9:	eb 7d                	jmp    c0404938 <msg_recv+0x95>
	if(((unsigned int)msg + sizeof(diosix_msg_info)) >= KERNEL_SPACE_BASE)
c04048bb:	8b 44 24 14          	mov    0x14(%esp),%eax
c04048bf:	83 c0 20             	add    $0x20,%eax
c04048c2:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c04048c7:	76 07                	jbe    c04048d0 <msg_recv+0x2d>
		return e_bad_address;
c04048c9:	b8 11 00 00 00       	mov    $0x11,%eax
c04048ce:	eb 68                	jmp    c0404938 <msg_recv+0x95>
	if(!(msg->recv) || !(msg->recv_max_size)) return e_bad_address;
c04048d0:	8b 44 24 14          	mov    0x14(%esp),%eax
c04048d4:	8b 40 1c             	mov    0x1c(%eax),%eax
c04048d7:	85 c0                	test   %eax,%eax
c04048d9:	74 0b                	je     c04048e6 <msg_recv+0x43>
c04048db:	8b 44 24 14          	mov    0x14(%esp),%eax
c04048df:	8b 40 14             	mov    0x14(%eax),%eax
c04048e2:	85 c0                	test   %eax,%eax
c04048e4:	75 07                	jne    c04048ed <msg_recv+0x4a>
c04048e6:	b8 11 00 00 00       	mov    $0x11,%eax
c04048eb:	eb 4b                	jmp    c0404938 <msg_recv+0x95>
	
	/* keep a copy of this pointer */
	lock_gate(&(receiver->lock), LOCK_WRITE);
c04048ed:	8b 44 24 10          	mov    0x10(%esp),%eax
c04048f1:	83 c0 1c             	add    $0x1c,%eax
c04048f4:	83 ec 08             	sub    $0x8,%esp
c04048f7:	6a 01                	push   $0x1
c04048f9:	50                   	push   %eax
c04048fa:	e8 8c bb ff ff       	call   c040048b <lock_gate>
c04048ff:	83 c4 10             	add    $0x10,%esp
	receiver->msg = msg;
c0404902:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404906:	8b 54 24 14          	mov    0x14(%esp),%edx
c040490a:	89 50 18             	mov    %edx,0x18(%eax)
	unlock_gate(&(receiver->lock), LOCK_WRITE);
c040490d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404911:	83 c0 1c             	add    $0x1c,%eax
c0404914:	83 ec 08             	sub    $0x8,%esp
c0404917:	6a 01                	push   $0x1
c0404919:	50                   	push   %eax
c040491a:	e8 89 bd ff ff       	call   c04006a8 <unlock_gate>
c040491f:	83 c4 10             	add    $0x10,%esp

	/* remove receiver from the queue until a message comes in */
	sched_remove(receiver, waitingformsg);
c0404922:	83 ec 08             	sub    $0x8,%esp
c0404925:	6a 04                	push   $0x4
c0404927:	ff 74 24 1c          	pushl  0x1c(%esp)
c040492b:	e8 11 11 00 00       	call   c0405a41 <sched_remove>
c0404930:	83 c4 10             	add    $0x10,%esp
#ifdef MSG_DEBUG
	dprintf("[msg:%i] tid %i pid %i now receiving (%p)\n",
			  CPU_ID, receiver->tid, receiver->proc->pid, msg);
#endif

	return success;
c0404933:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404938:	83 c4 0c             	add    $0xc,%esp
c040493b:	c3                   	ret    

c040493c <sched_inc_queued_threads>:
unsigned int sched_total_queued = 0; /* number of threads queued */

/* sched_inc_queued_threads
 Increment the number of queued threads total in a thread-safe manner */
void sched_inc_queued_threads(void)
{	
c040493c:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(sched_lock), LOCK_WRITE);
c040493f:	83 ec 08             	sub    $0x8,%esp
c0404942:	6a 01                	push   $0x1
c0404944:	68 7c 18 41 c0       	push   $0xc041187c
c0404949:	e8 3d bb ff ff       	call   c040048b <lock_gate>
c040494e:	83 c4 10             	add    $0x10,%esp
	sched_total_queued++;
c0404951:	a1 c4 38 41 c0       	mov    0xc04138c4,%eax
c0404956:	40                   	inc    %eax
c0404957:	a3 c4 38 41 c0       	mov    %eax,0xc04138c4
	unlock_gate(&(sched_lock), LOCK_WRITE);
c040495c:	83 ec 08             	sub    $0x8,%esp
c040495f:	6a 01                	push   $0x1
c0404961:	68 7c 18 41 c0       	push   $0xc041187c
c0404966:	e8 3d bd ff ff       	call   c04006a8 <unlock_gate>
c040496b:	83 c4 10             	add    $0x10,%esp
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] total queued threads now: %i (up one)\n", CPU_ID, sched_total_queued);
c040496e:	8b 15 c4 38 41 c0    	mov    0xc04138c4,%edx
c0404974:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404979:	3c 01                	cmp    $0x1,%al
c040497b:	76 0c                	jbe    c0404989 <sched_inc_queued_threads+0x4d>
c040497d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404982:	8b 00                	mov    (%eax),%eax
c0404984:	c1 e8 18             	shr    $0x18,%eax
c0404987:	eb 08                	jmp    c0404991 <sched_inc_queued_threads+0x55>
c0404989:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040498e:	0f b6 c0             	movzbl %al,%eax
c0404991:	83 ec 04             	sub    $0x4,%esp
c0404994:	52                   	push   %edx
c0404995:	50                   	push   %eax
c0404996:	68 84 e7 40 c0       	push   $0xc040e784
c040499b:	e8 b6 8a 00 00       	call   c040d456 <debug_printf>
c04049a0:	83 c4 10             	add    $0x10,%esp
#endif
}
c04049a3:	83 c4 0c             	add    $0xc,%esp
c04049a6:	c3                   	ret    

c04049a7 <sched_dec_queued_threads>:

/* sched_dec_queued_threads
   Decrement the number of queued threads total in a thread-safe manner */
void sched_dec_queued_threads(void)
{
c04049a7:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(sched_lock), LOCK_WRITE);
c04049aa:	83 ec 08             	sub    $0x8,%esp
c04049ad:	6a 01                	push   $0x1
c04049af:	68 7c 18 41 c0       	push   $0xc041187c
c04049b4:	e8 d2 ba ff ff       	call   c040048b <lock_gate>
c04049b9:	83 c4 10             	add    $0x10,%esp
	sched_total_queued--;
c04049bc:	a1 c4 38 41 c0       	mov    0xc04138c4,%eax
c04049c1:	48                   	dec    %eax
c04049c2:	a3 c4 38 41 c0       	mov    %eax,0xc04138c4
	unlock_gate(&(sched_lock), LOCK_WRITE);
c04049c7:	83 ec 08             	sub    $0x8,%esp
c04049ca:	6a 01                	push   $0x1
c04049cc:	68 7c 18 41 c0       	push   $0xc041187c
c04049d1:	e8 d2 bc ff ff       	call   c04006a8 <unlock_gate>
c04049d6:	83 c4 10             	add    $0x10,%esp
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] total queued threads now: %i (down one)\n", CPU_ID, sched_total_queued);
c04049d9:	8b 15 c4 38 41 c0    	mov    0xc04138c4,%edx
c04049df:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04049e4:	3c 01                	cmp    $0x1,%al
c04049e6:	76 0c                	jbe    c04049f4 <sched_dec_queued_threads+0x4d>
c04049e8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04049ed:	8b 00                	mov    (%eax),%eax
c04049ef:	c1 e8 18             	shr    $0x18,%eax
c04049f2:	eb 08                	jmp    c04049fc <sched_dec_queued_threads+0x55>
c04049f4:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04049f9:	0f b6 c0             	movzbl %al,%eax
c04049fc:	83 ec 04             	sub    $0x4,%esp
c04049ff:	52                   	push   %edx
c0404a00:	50                   	push   %eax
c0404a01:	68 b8 e7 40 c0       	push   $0xc040e7b8
c0404a06:	e8 4b 8a 00 00       	call   c040d456 <debug_printf>
c0404a0b:	83 c4 10             	add    $0x10,%esp
#endif
}
c0404a0e:	83 c4 0c             	add    $0xc,%esp
c0404a11:	c3                   	ret    

c0404a12 <sched_lock_thread>:
 on exit from this function.
 => victim = thread to pause
 <= success or a failure code
 */
kresult sched_lock_thread(thread *victim)
{
c0404a12:	83 ec 1c             	sub    $0x1c,%esp
	unsigned char id = CPU_ID;
c0404a15:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404a1a:	3c 01                	cmp    $0x1,%al
c0404a1c:	76 0c                	jbe    c0404a2a <sched_lock_thread+0x18>
c0404a1e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404a23:	8b 00                	mov    (%eax),%eax
c0404a25:	c1 e8 18             	shr    $0x18,%eax
c0404a28:	eb 05                	jmp    c0404a2f <sched_lock_thread+0x1d>
c0404a2a:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404a2f:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!victim) return e_failure;
c0404a33:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0404a38:	75 0a                	jne    c0404a44 <sched_lock_thread+0x32>
c0404a3a:	b8 01 00 00 00       	mov    $0x1,%eax
c0404a3f:	e9 cb 00 00 00       	jmp    c0404b0f <sched_lock_thread+0xfd>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404a44:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404a49:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404a4e:	c1 e2 06             	shl    $0x6,%edx
c0404a51:	01 d0                	add    %edx,%eax
c0404a53:	83 c0 08             	add    $0x8,%eax
c0404a56:	83 ec 08             	sub    $0x8,%esp
c0404a59:	6a 00                	push   $0x0
c0404a5b:	50                   	push   %eax
c0404a5c:	e8 2a ba ff ff       	call   c040048b <lock_gate>
c0404a61:	83 c4 10             	add    $0x10,%esp
	
	if(victim == cpu_table[id].current)
c0404a64:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404a69:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404a6e:	c1 e2 06             	shl    $0x6,%edx
c0404a71:	01 d0                	add    %edx,%eax
c0404a73:	8b 40 04             	mov    0x4(%eax),%eax
c0404a76:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404a7a:	75 27                	jne    c0404aa3 <sched_lock_thread+0x91>
	{
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404a7c:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404a81:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404a86:	c1 e2 06             	shl    $0x6,%edx
c0404a89:	01 d0                	add    %edx,%eax
c0404a8b:	83 c0 08             	add    $0x8,%eax
c0404a8e:	83 ec 08             	sub    $0x8,%esp
c0404a91:	6a 00                	push   $0x0
c0404a93:	50                   	push   %eax
c0404a94:	e8 0f bc ff ff       	call   c04006a8 <unlock_gate>
c0404a99:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404a9c:	b8 01 00 00 00       	mov    $0x1,%eax
c0404aa1:	eb 6c                	jmp    c0404b0f <sched_lock_thread+0xfd>
	}
	
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404aa3:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404aa8:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404aad:	c1 e2 06             	shl    $0x6,%edx
c0404ab0:	01 d0                	add    %edx,%eax
c0404ab2:	83 c0 08             	add    $0x8,%eax
c0404ab5:	83 ec 08             	sub    $0x8,%esp
c0404ab8:	6a 00                	push   $0x0
c0404aba:	50                   	push   %eax
c0404abb:	e8 e8 bb ff ff       	call   c04006a8 <unlock_gate>
c0404ac0:	83 c4 10             	add    $0x10,%esp
	
	/* if the process is running then interrupt the other cpu */
	lock_gate(&(victim->lock), LOCK_READ);
c0404ac3:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404ac7:	83 c0 1c             	add    $0x1c,%eax
c0404aca:	83 ec 08             	sub    $0x8,%esp
c0404acd:	6a 00                	push   $0x0
c0404acf:	50                   	push   %eax
c0404ad0:	e8 b6 b9 ff ff       	call   c040048b <lock_gate>
c0404ad5:	83 c4 10             	add    $0x10,%esp
	
	if(victim->state == inrunqueue)
c0404ad8:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404adc:	8b 40 10             	mov    0x10(%eax),%eax
c0404adf:	83 f8 01             	cmp    $0x1,%eax
c0404ae2:	75 11                	jne    c0404af5 <sched_lock_thread+0xe3>
		sched_remove(victim, held);
c0404ae4:	83 ec 08             	sub    $0x8,%esp
c0404ae7:	6a 05                	push   $0x5
c0404ae9:	ff 74 24 2c          	pushl  0x2c(%esp)
c0404aed:	e8 4f 0f 00 00       	call   c0405a41 <sched_remove>
c0404af2:	83 c4 10             	add    $0x10,%esp
	
	unlock_gate(&(victim->lock), LOCK_READ);
c0404af5:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404af9:	83 c0 1c             	add    $0x1c,%eax
c0404afc:	83 ec 08             	sub    $0x8,%esp
c0404aff:	6a 00                	push   $0x0
c0404b01:	50                   	push   %eax
c0404b02:	e8 a1 bb ff ff       	call   c04006a8 <unlock_gate>
c0404b07:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0404b0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404b0f:	83 c4 1c             	add    $0x1c,%esp
c0404b12:	c3                   	ret    

c0404b13 <sched_lock_proc>:
	on exit from this function.
	=> proc = process to pause
   <= success or a failure code
*/
kresult sched_lock_proc(process *proc)
{
c0404b13:	83 ec 1c             	sub    $0x1c,%esp
	thread *t;
	unsigned char id = CPU_ID;
c0404b16:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404b1b:	3c 01                	cmp    $0x1,%al
c0404b1d:	76 0c                	jbe    c0404b2b <sched_lock_proc+0x18>
c0404b1f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404b24:	8b 00                	mov    (%eax),%eax
c0404b26:	c1 e8 18             	shr    $0x18,%eax
c0404b29:	eb 05                	jmp    c0404b30 <sched_lock_proc+0x1d>
c0404b2b:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404b30:	88 44 24 07          	mov    %al,0x7(%esp)
	unsigned int loop, tfound;
	
	if(!proc) return e_failure;
c0404b34:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0404b39:	75 0a                	jne    c0404b45 <sched_lock_proc+0x32>
c0404b3b:	b8 01 00 00 00       	mov    $0x1,%eax
c0404b40:	e9 ee 01 00 00       	jmp    c0404d33 <sched_lock_proc+0x220>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404b45:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404b4a:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404b4f:	c1 e2 06             	shl    $0x6,%edx
c0404b52:	01 d0                	add    %edx,%eax
c0404b54:	83 c0 08             	add    $0x8,%eax
c0404b57:	83 ec 08             	sub    $0x8,%esp
c0404b5a:	6a 00                	push   $0x0
c0404b5c:	50                   	push   %eax
c0404b5d:	e8 29 b9 ff ff       	call   c040048b <lock_gate>
c0404b62:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404b65:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404b6a:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404b6f:	c1 e2 06             	shl    $0x6,%edx
c0404b72:	01 d0                	add    %edx,%eax
c0404b74:	8b 40 04             	mov    0x4(%eax),%eax
c0404b77:	83 c0 1c             	add    $0x1c,%eax
c0404b7a:	83 ec 08             	sub    $0x8,%esp
c0404b7d:	6a 00                	push   $0x0
c0404b7f:	50                   	push   %eax
c0404b80:	e8 06 b9 ff ff       	call   c040048b <lock_gate>
c0404b85:	83 c4 10             	add    $0x10,%esp
	
	if(proc == cpu_table[id].current->proc)
c0404b88:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404b8d:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404b92:	c1 e2 06             	shl    $0x6,%edx
c0404b95:	01 d0                	add    %edx,%eax
c0404b97:	8b 40 04             	mov    0x4(%eax),%eax
c0404b9a:	8b 00                	mov    (%eax),%eax
c0404b9c:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404ba0:	75 4d                	jne    c0404bef <sched_lock_proc+0xdc>
	{
		unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404ba2:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404ba7:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404bac:	c1 e2 06             	shl    $0x6,%edx
c0404baf:	01 d0                	add    %edx,%eax
c0404bb1:	8b 40 04             	mov    0x4(%eax),%eax
c0404bb4:	83 c0 1c             	add    $0x1c,%eax
c0404bb7:	83 ec 08             	sub    $0x8,%esp
c0404bba:	6a 00                	push   $0x0
c0404bbc:	50                   	push   %eax
c0404bbd:	e8 e6 ba ff ff       	call   c04006a8 <unlock_gate>
c0404bc2:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404bc5:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404bca:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404bcf:	c1 e2 06             	shl    $0x6,%edx
c0404bd2:	01 d0                	add    %edx,%eax
c0404bd4:	83 c0 08             	add    $0x8,%eax
c0404bd7:	83 ec 08             	sub    $0x8,%esp
c0404bda:	6a 00                	push   $0x0
c0404bdc:	50                   	push   %eax
c0404bdd:	e8 c6 ba ff ff       	call   c04006a8 <unlock_gate>
c0404be2:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404be5:	b8 01 00 00 00       	mov    $0x1,%eax
c0404bea:	e9 44 01 00 00       	jmp    c0404d33 <sched_lock_proc+0x220>
	}

	unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404bef:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404bf4:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404bf9:	c1 e2 06             	shl    $0x6,%edx
c0404bfc:	01 d0                	add    %edx,%eax
c0404bfe:	8b 40 04             	mov    0x4(%eax),%eax
c0404c01:	83 c0 1c             	add    $0x1c,%eax
c0404c04:	83 ec 08             	sub    $0x8,%esp
c0404c07:	6a 00                	push   $0x0
c0404c09:	50                   	push   %eax
c0404c0a:	e8 99 ba ff ff       	call   c04006a8 <unlock_gate>
c0404c0f:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404c12:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404c17:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0404c1c:	c1 e2 06             	shl    $0x6,%edx
c0404c1f:	01 d0                	add    %edx,%eax
c0404c21:	83 c0 08             	add    $0x8,%eax
c0404c24:	83 ec 08             	sub    $0x8,%esp
c0404c27:	6a 00                	push   $0x0
c0404c29:	50                   	push   %eax
c0404c2a:	e8 79 ba ff ff       	call   c04006a8 <unlock_gate>
c0404c2f:	83 c4 10             	add    $0x10,%esp
	
	dprintf("[sched:%i] locking process %i (%p)\n", CPU_ID, proc->pid, proc);
c0404c32:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404c36:	8b 10                	mov    (%eax),%edx
c0404c38:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404c3d:	3c 01                	cmp    $0x1,%al
c0404c3f:	76 0c                	jbe    c0404c4d <sched_lock_proc+0x13a>
c0404c41:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404c46:	8b 00                	mov    (%eax),%eax
c0404c48:	c1 e8 18             	shr    $0x18,%eax
c0404c4b:	eb 08                	jmp    c0404c55 <sched_lock_proc+0x142>
c0404c4d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404c52:	0f b6 c0             	movzbl %al,%eax
c0404c55:	ff 74 24 20          	pushl  0x20(%esp)
c0404c59:	52                   	push   %edx
c0404c5a:	50                   	push   %eax
c0404c5b:	68 ec e7 40 c0       	push   $0xc040e7ec
c0404c60:	e8 f1 87 00 00       	call   c040d456 <debug_printf>
c0404c65:	83 c4 10             	add    $0x10,%esp
	
	/* make sure we're the only one's updating this process */
	lock_gate(&(proc->lock), LOCK_WRITE);
c0404c68:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404c6c:	83 c0 10             	add    $0x10,%eax
c0404c6f:	83 ec 08             	sub    $0x8,%esp
c0404c72:	6a 01                	push   $0x1
c0404c74:	50                   	push   %eax
c0404c75:	e8 11 b8 ff ff       	call   c040048b <lock_gate>
c0404c7a:	83 c4 10             	add    $0x10,%esp
	
	/* warn the scheduler not to run threads in this process */
	proc->flags |= PROC_FLAG_RUNLOCKED;
c0404c7d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404c81:	8a 40 0d             	mov    0xd(%eax),%al
c0404c84:	88 c2                	mov    %al,%dl
c0404c86:	83 ca 01             	or     $0x1,%edx
c0404c89:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404c8d:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0404c90:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0404c97:	00 
c0404c98:	eb 75                	jmp    c0404d0f <sched_lock_proc+0x1fc>
	{
		t = proc->threads[loop];
c0404c9a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404c9e:	8b 40 38             	mov    0x38(%eax),%eax
c0404ca1:	8b 54 24 08          	mov    0x8(%esp),%edx
c0404ca5:	c1 e2 02             	shl    $0x2,%edx
c0404ca8:	01 d0                	add    %edx,%eax
c0404caa:	8b 00                	mov    (%eax),%eax
c0404cac:	89 04 24             	mov    %eax,(%esp)
		while(t)
c0404caf:	eb 47                	jmp    c0404cf8 <sched_lock_proc+0x1e5>
		{
			
			sched_lock_thread(t);
c0404cb1:	83 ec 0c             	sub    $0xc,%esp
c0404cb4:	ff 74 24 0c          	pushl  0xc(%esp)
c0404cb8:	e8 55 fd ff ff       	call   c0404a12 <sched_lock_thread>
c0404cbd:	83 c4 10             	add    $0x10,%esp
			tfound++;
c0404cc0:	ff 44 24 0c          	incl   0xc(%esp)
			
			/* try the next thread */
			lock_gate(&(t->lock), LOCK_READ);
c0404cc4:	8b 04 24             	mov    (%esp),%eax
c0404cc7:	83 c0 1c             	add    $0x1c,%eax
c0404cca:	83 ec 08             	sub    $0x8,%esp
c0404ccd:	6a 00                	push   $0x0
c0404ccf:	50                   	push   %eax
c0404cd0:	e8 b6 b7 ff ff       	call   c040048b <lock_gate>
c0404cd5:	83 c4 10             	add    $0x10,%esp
			t = t->hash_next;
c0404cd8:	8b 04 24             	mov    (%esp),%eax
c0404cdb:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0404ce1:	89 04 24             	mov    %eax,(%esp)
			unlock_gate(&(t->lock), LOCK_READ);
c0404ce4:	8b 04 24             	mov    (%esp),%eax
c0404ce7:	83 c0 1c             	add    $0x1c,%eax
c0404cea:	83 ec 08             	sub    $0x8,%esp
c0404ced:	6a 00                	push   $0x0
c0404cef:	50                   	push   %eax
c0404cf0:	e8 b3 b9 ff ff       	call   c04006a8 <unlock_gate>
c0404cf5:	83 c4 10             	add    $0x10,%esp
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
	{
		t = proc->threads[loop];
		while(t)
c0404cf8:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0404cfc:	75 b3                	jne    c0404cb1 <sched_lock_proc+0x19e>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0404cfe:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404d02:	8b 40 3c             	mov    0x3c(%eax),%eax
c0404d05:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0404d09:	76 0d                	jbe    c0404d18 <sched_lock_proc+0x205>
	
	/* warn the scheduler not to run threads in this process */
	proc->flags |= PROC_FLAG_RUNLOCKED;
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0404d0b:	ff 44 24 08          	incl   0x8(%esp)
c0404d0f:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
c0404d14:	76 84                	jbe    c0404c9a <sched_lock_proc+0x187>
c0404d16:	eb 01                	jmp    c0404d19 <sched_lock_proc+0x206>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0404d18:	90                   	nop
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0404d19:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404d1d:	83 c0 10             	add    $0x10,%eax
c0404d20:	83 ec 08             	sub    $0x8,%esp
c0404d23:	6a 01                	push   $0x1
c0404d25:	50                   	push   %eax
c0404d26:	e8 7d b9 ff ff       	call   c04006a8 <unlock_gate>
c0404d2b:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0404d2e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404d33:	83 c4 1c             	add    $0x1c,%esp
c0404d36:	c3                   	ret    

c0404d37 <sched_unlock_thread>:
 somehow wake itself up.
 => proc = process to release
 <= success or a failure code
 */
kresult sched_unlock_thread(thread *towake)
{
c0404d37:	83 ec 1c             	sub    $0x1c,%esp
	unsigned char id = CPU_ID;
c0404d3a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404d3f:	3c 01                	cmp    $0x1,%al
c0404d41:	76 0c                	jbe    c0404d4f <sched_unlock_thread+0x18>
c0404d43:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404d48:	8b 00                	mov    (%eax),%eax
c0404d4a:	c1 e8 18             	shr    $0x18,%eax
c0404d4d:	eb 05                	jmp    c0404d54 <sched_unlock_thread+0x1d>
c0404d4f:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404d54:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!towake) return e_failure;
c0404d58:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0404d5d:	75 0a                	jne    c0404d69 <sched_unlock_thread+0x32>
c0404d5f:	b8 01 00 00 00       	mov    $0x1,%eax
c0404d64:	e9 13 01 00 00       	jmp    c0404e7c <sched_unlock_thread+0x145>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404d69:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404d6e:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404d73:	c1 e2 06             	shl    $0x6,%edx
c0404d76:	01 d0                	add    %edx,%eax
c0404d78:	83 c0 08             	add    $0x8,%eax
c0404d7b:	83 ec 08             	sub    $0x8,%esp
c0404d7e:	6a 00                	push   $0x0
c0404d80:	50                   	push   %eax
c0404d81:	e8 05 b7 ff ff       	call   c040048b <lock_gate>
c0404d86:	83 c4 10             	add    $0x10,%esp
	
	if(towake == cpu_table[id].current)
c0404d89:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404d8e:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404d93:	c1 e2 06             	shl    $0x6,%edx
c0404d96:	01 d0                	add    %edx,%eax
c0404d98:	8b 40 04             	mov    0x4(%eax),%eax
c0404d9b:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404d9f:	75 2a                	jne    c0404dcb <sched_unlock_thread+0x94>
	{
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404da1:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404da6:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404dab:	c1 e2 06             	shl    $0x6,%edx
c0404dae:	01 d0                	add    %edx,%eax
c0404db0:	83 c0 08             	add    $0x8,%eax
c0404db3:	83 ec 08             	sub    $0x8,%esp
c0404db6:	6a 00                	push   $0x0
c0404db8:	50                   	push   %eax
c0404db9:	e8 ea b8 ff ff       	call   c04006a8 <unlock_gate>
c0404dbe:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404dc1:	b8 01 00 00 00       	mov    $0x1,%eax
c0404dc6:	e9 b1 00 00 00       	jmp    c0404e7c <sched_unlock_thread+0x145>
	}
	
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404dcb:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404dd0:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404dd5:	c1 e2 06             	shl    $0x6,%edx
c0404dd8:	01 d0                	add    %edx,%eax
c0404dda:	83 c0 08             	add    $0x8,%eax
c0404ddd:	83 ec 08             	sub    $0x8,%esp
c0404de0:	6a 00                	push   $0x0
c0404de2:	50                   	push   %eax
c0404de3:	e8 c0 b8 ff ff       	call   c04006a8 <unlock_gate>
c0404de8:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(towake->lock), LOCK_READ);
c0404deb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404def:	83 c0 1c             	add    $0x1c,%eax
c0404df2:	83 ec 08             	sub    $0x8,%esp
c0404df5:	6a 00                	push   $0x0
c0404df7:	50                   	push   %eax
c0404df8:	e8 8e b6 ff ff       	call   c040048b <lock_gate>
c0404dfd:	83 c4 10             	add    $0x10,%esp
	
	/* if the thread is held then put it back on the run queue, but 
	   don't requeue if the whole process is blocked */
	if(towake->state == held && !(towake->proc->flags & PROC_FLAG_RUNLOCKED))
c0404e00:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e04:	8b 40 10             	mov    0x10(%eax),%eax
c0404e07:	83 f8 05             	cmp    $0x5,%eax
c0404e0a:	75 56                	jne    c0404e62 <sched_unlock_thread+0x12b>
c0404e0c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e10:	8b 00                	mov    (%eax),%eax
c0404e12:	8a 40 0d             	mov    0xd(%eax),%al
c0404e15:	0f b6 c0             	movzbl %al,%eax
c0404e18:	83 e0 01             	and    $0x1,%eax
c0404e1b:	85 c0                	test   %eax,%eax
c0404e1d:	75 43                	jne    c0404e62 <sched_unlock_thread+0x12b>
		sched_add(towake->proc->cpu, towake->priority, towake);
c0404e1f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e23:	8a 40 0e             	mov    0xe(%eax),%al
c0404e26:	0f b6 d0             	movzbl %al,%edx
c0404e29:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e2d:	8b 00                	mov    (%eax),%eax
c0404e2f:	8a 40 0c             	mov    0xc(%eax),%al
c0404e32:	0f b6 c0             	movzbl %al,%eax
c0404e35:	83 ec 04             	sub    $0x4,%esp
c0404e38:	ff 74 24 24          	pushl  0x24(%esp)
c0404e3c:	52                   	push   %edx
c0404e3d:	50                   	push   %eax
c0404e3e:	e8 dc 09 00 00       	call   c040581f <sched_add>
c0404e43:	83 c4 10             	add    $0x10,%esp
	{
		unlock_gate(&(towake->lock), LOCK_READ);
		return e_failure;
	}

	unlock_gate(&(towake->lock), LOCK_READ);
c0404e46:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e4a:	83 c0 1c             	add    $0x1c,%eax
c0404e4d:	83 ec 08             	sub    $0x8,%esp
c0404e50:	6a 00                	push   $0x0
c0404e52:	50                   	push   %eax
c0404e53:	e8 50 b8 ff ff       	call   c04006a8 <unlock_gate>
c0404e58:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0404e5b:	b8 00 00 00 00       	mov    $0x0,%eax
c0404e60:	eb 1a                	jmp    c0404e7c <sched_unlock_thread+0x145>
	   don't requeue if the whole process is blocked */
	if(towake->state == held && !(towake->proc->flags & PROC_FLAG_RUNLOCKED))
		sched_add(towake->proc->cpu, towake->priority, towake);
	else
	{
		unlock_gate(&(towake->lock), LOCK_READ);
c0404e62:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404e66:	83 c0 1c             	add    $0x1c,%eax
c0404e69:	83 ec 08             	sub    $0x8,%esp
c0404e6c:	6a 00                	push   $0x0
c0404e6e:	50                   	push   %eax
c0404e6f:	e8 34 b8 ff ff       	call   c04006a8 <unlock_gate>
c0404e74:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404e77:	b8 01 00 00 00       	mov    $0x1,%eax
	}

	unlock_gate(&(towake->lock), LOCK_READ);
	
	return success;
}
c0404e7c:	83 c4 1c             	add    $0x1c,%esp
c0404e7f:	c3                   	ret    

c0404e80 <sched_unlock_proc>:
   somehow wake itself up.
   => proc = process to release
   <= success or a failure code
*/
kresult sched_unlock_proc(process *proc)
{
c0404e80:	83 ec 1c             	sub    $0x1c,%esp
	thread *t;
	unsigned int loop, tfound;
	unsigned char id = CPU_ID;
c0404e83:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404e88:	3c 01                	cmp    $0x1,%al
c0404e8a:	76 0c                	jbe    c0404e98 <sched_unlock_proc+0x18>
c0404e8c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404e91:	8b 00                	mov    (%eax),%eax
c0404e93:	c1 e8 18             	shr    $0x18,%eax
c0404e96:	eb 05                	jmp    c0404e9d <sched_unlock_proc+0x1d>
c0404e98:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404e9d:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!proc) return e_failure;
c0404ea1:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0404ea6:	75 0a                	jne    c0404eb2 <sched_unlock_proc+0x32>
c0404ea8:	b8 01 00 00 00       	mov    $0x1,%eax
c0404ead:	e9 ee 01 00 00       	jmp    c04050a0 <sched_unlock_proc+0x220>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404eb2:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404eb7:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404ebc:	c1 e2 06             	shl    $0x6,%edx
c0404ebf:	01 d0                	add    %edx,%eax
c0404ec1:	83 c0 08             	add    $0x8,%eax
c0404ec4:	83 ec 08             	sub    $0x8,%esp
c0404ec7:	6a 00                	push   $0x0
c0404ec9:	50                   	push   %eax
c0404eca:	e8 bc b5 ff ff       	call   c040048b <lock_gate>
c0404ecf:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404ed2:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404ed7:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404edc:	c1 e2 06             	shl    $0x6,%edx
c0404edf:	01 d0                	add    %edx,%eax
c0404ee1:	8b 40 04             	mov    0x4(%eax),%eax
c0404ee4:	83 c0 1c             	add    $0x1c,%eax
c0404ee7:	83 ec 08             	sub    $0x8,%esp
c0404eea:	6a 00                	push   $0x0
c0404eec:	50                   	push   %eax
c0404eed:	e8 99 b5 ff ff       	call   c040048b <lock_gate>
c0404ef2:	83 c4 10             	add    $0x10,%esp
	
	if(proc == cpu_table[id].current->proc)
c0404ef5:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404efa:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404eff:	c1 e2 06             	shl    $0x6,%edx
c0404f02:	01 d0                	add    %edx,%eax
c0404f04:	8b 40 04             	mov    0x4(%eax),%eax
c0404f07:	8b 00                	mov    (%eax),%eax
c0404f09:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404f0d:	75 4d                	jne    c0404f5c <sched_unlock_proc+0xdc>
	{
		unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404f0f:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404f14:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404f19:	c1 e2 06             	shl    $0x6,%edx
c0404f1c:	01 d0                	add    %edx,%eax
c0404f1e:	8b 40 04             	mov    0x4(%eax),%eax
c0404f21:	83 c0 1c             	add    $0x1c,%eax
c0404f24:	83 ec 08             	sub    $0x8,%esp
c0404f27:	6a 00                	push   $0x0
c0404f29:	50                   	push   %eax
c0404f2a:	e8 79 b7 ff ff       	call   c04006a8 <unlock_gate>
c0404f2f:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404f32:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404f37:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404f3c:	c1 e2 06             	shl    $0x6,%edx
c0404f3f:	01 d0                	add    %edx,%eax
c0404f41:	83 c0 08             	add    $0x8,%eax
c0404f44:	83 ec 08             	sub    $0x8,%esp
c0404f47:	6a 00                	push   $0x0
c0404f49:	50                   	push   %eax
c0404f4a:	e8 59 b7 ff ff       	call   c04006a8 <unlock_gate>
c0404f4f:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0404f52:	b8 01 00 00 00       	mov    $0x1,%eax
c0404f57:	e9 44 01 00 00       	jmp    c04050a0 <sched_unlock_proc+0x220>
	}
	
	unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0404f5c:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404f61:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404f66:	c1 e2 06             	shl    $0x6,%edx
c0404f69:	01 d0                	add    %edx,%eax
c0404f6b:	8b 40 04             	mov    0x4(%eax),%eax
c0404f6e:	83 c0 1c             	add    $0x1c,%eax
c0404f71:	83 ec 08             	sub    $0x8,%esp
c0404f74:	6a 00                	push   $0x0
c0404f76:	50                   	push   %eax
c0404f77:	e8 2c b7 ff ff       	call   c04006a8 <unlock_gate>
c0404f7c:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0404f7f:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0404f84:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0404f89:	c1 e2 06             	shl    $0x6,%edx
c0404f8c:	01 d0                	add    %edx,%eax
c0404f8e:	83 c0 08             	add    $0x8,%eax
c0404f91:	83 ec 08             	sub    $0x8,%esp
c0404f94:	6a 00                	push   $0x0
c0404f96:	50                   	push   %eax
c0404f97:	e8 0c b7 ff ff       	call   c04006a8 <unlock_gate>
c0404f9c:	83 c4 10             	add    $0x10,%esp
	
	dprintf("[sched:%i] unlocking process %i (%p)\n", CPU_ID, proc->pid, proc);
c0404f9f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404fa3:	8b 10                	mov    (%eax),%edx
c0404fa5:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0404faa:	3c 01                	cmp    $0x1,%al
c0404fac:	76 0c                	jbe    c0404fba <sched_unlock_proc+0x13a>
c0404fae:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404fb3:	8b 00                	mov    (%eax),%eax
c0404fb5:	c1 e8 18             	shr    $0x18,%eax
c0404fb8:	eb 08                	jmp    c0404fc2 <sched_unlock_proc+0x142>
c0404fba:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0404fbf:	0f b6 c0             	movzbl %al,%eax
c0404fc2:	ff 74 24 20          	pushl  0x20(%esp)
c0404fc6:	52                   	push   %edx
c0404fc7:	50                   	push   %eax
c0404fc8:	68 10 e8 40 c0       	push   $0xc040e810
c0404fcd:	e8 84 84 00 00       	call   c040d456 <debug_printf>
c0404fd2:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c0404fd5:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404fd9:	83 c0 10             	add    $0x10,%eax
c0404fdc:	83 ec 08             	sub    $0x8,%esp
c0404fdf:	6a 01                	push   $0x1
c0404fe1:	50                   	push   %eax
c0404fe2:	e8 a4 b4 ff ff       	call   c040048b <lock_gate>
c0404fe7:	83 c4 10             	add    $0x10,%esp
	
	/* clear the blocked flag */
	proc->flags &= ~PROC_FLAG_RUNLOCKED;
c0404fea:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404fee:	8a 40 0d             	mov    0xd(%eax),%al
c0404ff1:	88 c2                	mov    %al,%dl
c0404ff3:	83 e2 fe             	and    $0xfffffffe,%edx
c0404ff6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404ffa:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0404ffd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0405004:	00 
c0405005:	eb 75                	jmp    c040507c <sched_unlock_proc+0x1fc>
	{
		t = proc->threads[loop];
c0405007:	8b 44 24 20          	mov    0x20(%esp),%eax
c040500b:	8b 40 38             	mov    0x38(%eax),%eax
c040500e:	8b 54 24 04          	mov    0x4(%esp),%edx
c0405012:	c1 e2 02             	shl    $0x2,%edx
c0405015:	01 d0                	add    %edx,%eax
c0405017:	8b 00                	mov    (%eax),%eax
c0405019:	89 04 24             	mov    %eax,(%esp)
		while(t)
c040501c:	eb 47                	jmp    c0405065 <sched_unlock_proc+0x1e5>
		{
			sched_unlock_thread(t);
c040501e:	83 ec 0c             	sub    $0xc,%esp
c0405021:	ff 74 24 0c          	pushl  0xc(%esp)
c0405025:	e8 0d fd ff ff       	call   c0404d37 <sched_unlock_thread>
c040502a:	83 c4 10             	add    $0x10,%esp
			tfound++;
c040502d:	ff 44 24 08          	incl   0x8(%esp)
			
			/* try the next thread */
			lock_gate(&(t->lock), LOCK_READ);
c0405031:	8b 04 24             	mov    (%esp),%eax
c0405034:	83 c0 1c             	add    $0x1c,%eax
c0405037:	83 ec 08             	sub    $0x8,%esp
c040503a:	6a 00                	push   $0x0
c040503c:	50                   	push   %eax
c040503d:	e8 49 b4 ff ff       	call   c040048b <lock_gate>
c0405042:	83 c4 10             	add    $0x10,%esp
			t = t->hash_next;
c0405045:	8b 04 24             	mov    (%esp),%eax
c0405048:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040504e:	89 04 24             	mov    %eax,(%esp)
			unlock_gate(&(t->lock), LOCK_READ);
c0405051:	8b 04 24             	mov    (%esp),%eax
c0405054:	83 c0 1c             	add    $0x1c,%eax
c0405057:	83 ec 08             	sub    $0x8,%esp
c040505a:	6a 00                	push   $0x0
c040505c:	50                   	push   %eax
c040505d:	e8 46 b6 ff ff       	call   c04006a8 <unlock_gate>
c0405062:	83 c4 10             	add    $0x10,%esp
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
	{
		t = proc->threads[loop];
		while(t)
c0405065:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0405069:	75 b3                	jne    c040501e <sched_unlock_proc+0x19e>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c040506b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040506f:	8b 40 3c             	mov    0x3c(%eax),%eax
c0405072:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0405076:	76 0d                	jbe    c0405085 <sched_unlock_proc+0x205>
	
	/* clear the blocked flag */
	proc->flags &= ~PROC_FLAG_RUNLOCKED;
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0405078:	ff 44 24 04          	incl   0x4(%esp)
c040507c:	83 7c 24 04 3f       	cmpl   $0x3f,0x4(%esp)
c0405081:	76 84                	jbe    c0405007 <sched_unlock_proc+0x187>
c0405083:	eb 01                	jmp    c0405086 <sched_unlock_proc+0x206>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0405085:	90                   	nop
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0405086:	8b 44 24 20          	mov    0x20(%esp),%eax
c040508a:	83 c0 10             	add    $0x10,%eax
c040508d:	83 ec 08             	sub    $0x8,%esp
c0405090:	6a 01                	push   $0x1
c0405092:	50                   	push   %eax
c0405093:	e8 10 b6 ff ff       	call   c04006a8 <unlock_gate>
c0405098:	83 c4 10             	add    $0x10,%esp
	
	return success;
c040509b:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04050a0:	83 c4 1c             	add    $0x1c,%esp
c04050a3:	c3                   	ret    

c04050a4 <sched_caretaker>:
   cpus by adjusting the cpu id for waiting threads. if a
   thread is to wake up on a loaded cpu, then move it to a
   quieter one. don't move running threads around for fear of
   cache performance issues */
void sched_caretaker(void)
{
c04050a4:	83 ec 0c             	sub    $0xc,%esp
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] caretaker tick\n", CPU_ID);
c04050a7:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04050ac:	3c 01                	cmp    $0x1,%al
c04050ae:	76 0c                	jbe    c04050bc <sched_caretaker+0x18>
c04050b0:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04050b5:	8b 00                	mov    (%eax),%eax
c04050b7:	c1 e8 18             	shr    $0x18,%eax
c04050ba:	eb 08                	jmp    c04050c4 <sched_caretaker+0x20>
c04050bc:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04050c1:	0f b6 c0             	movzbl %al,%eax
c04050c4:	83 ec 08             	sub    $0x8,%esp
c04050c7:	50                   	push   %eax
c04050c8:	68 36 e8 40 c0       	push   $0xc040e836
c04050cd:	e8 84 83 00 00       	call   c040d456 <debug_printf>
c04050d2:	83 c4 10             	add    $0x10,%esp
#endif
	dprintf("[sched:%i] caretaker tick\n", CPU_ID);
c04050d5:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04050da:	3c 01                	cmp    $0x1,%al
c04050dc:	76 0c                	jbe    c04050ea <sched_caretaker+0x46>
c04050de:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04050e3:	8b 00                	mov    (%eax),%eax
c04050e5:	c1 e8 18             	shr    $0x18,%eax
c04050e8:	eb 08                	jmp    c04050f2 <sched_caretaker+0x4e>
c04050ea:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04050ef:	0f b6 c0             	movzbl %al,%eax
c04050f2:	83 ec 08             	sub    $0x8,%esp
c04050f5:	50                   	push   %eax
c04050f6:	68 36 e8 40 c0       	push   $0xc040e836
c04050fb:	e8 56 83 00 00       	call   c040d456 <debug_printf>
c0405100:	83 c4 10             	add    $0x10,%esp
}
c0405103:	83 c4 0c             	add    $0xc,%esp
c0405106:	c3                   	ret    

c0405107 <sched_tick>:
	Called 100 times a second (SCHED_FREQUENCY). Pick a new
   thread, if necessary.
   => pointer to the interrupted thread's kernel stack
*/
void sched_tick(int_registers_block *regs)
{
c0405107:	83 ec 1c             	sub    $0x1c,%esp
	proc_cpu *cpu = &cpu_table[CPU_ID];
c040510a:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0405110:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405115:	3c 01                	cmp    $0x1,%al
c0405117:	76 0f                	jbe    c0405128 <sched_tick+0x21>
c0405119:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040511e:	8b 00                	mov    (%eax),%eax
c0405120:	c1 e8 18             	shr    $0x18,%eax
c0405123:	c1 e0 06             	shl    $0x6,%eax
c0405126:	eb 0b                	jmp    c0405133 <sched_tick+0x2c>
c0405128:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040512d:	0f b6 c0             	movzbl %al,%eax
c0405130:	c1 e0 06             	shl    $0x6,%eax
c0405133:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0405136:	89 44 24 0c          	mov    %eax,0xc(%esp)

	/* give up if no thread running */
	if(!(cpu->current)) return;
c040513a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040513e:	8b 40 04             	mov    0x4(%eax),%eax
c0405141:	85 c0                	test   %eax,%eax
c0405143:	0f 84 ab 01 00 00    	je     c04052f4 <sched_tick+0x1ed>
	
	/* check to see if it's time for maintanence */
	/* make sure only the boot cpu runs this? */
	if(CPU_ID == mp_boot_cpu)
c0405149:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040514e:	3c 01                	cmp    $0x1,%al
c0405150:	76 0c                	jbe    c040515e <sched_tick+0x57>
c0405152:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405157:	8b 00                	mov    (%eax),%eax
c0405159:	c1 e8 18             	shr    $0x18,%eax
c040515c:	eb 08                	jmp    c0405166 <sched_tick+0x5f>
c040515e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405163:	0f b6 c0             	movzbl %al,%eax
c0405166:	8a 15 f1 38 41 c0    	mov    0xc04138f1,%dl
c040516c:	0f b6 d2             	movzbl %dl,%edx
c040516f:	39 d0                	cmp    %edx,%eax
c0405171:	75 25                	jne    c0405198 <sched_tick+0x91>
	{
		if(tick)
c0405173:	a1 44 10 41 c0       	mov    0xc0411044,%eax
c0405178:	85 c0                	test   %eax,%eax
c040517a:	74 0d                	je     c0405189 <sched_tick+0x82>
			tick--;
c040517c:	a1 44 10 41 c0       	mov    0xc0411044,%eax
c0405181:	48                   	dec    %eax
c0405182:	a3 44 10 41 c0       	mov    %eax,0xc0411044
c0405187:	eb 0f                	jmp    c0405198 <sched_tick+0x91>
		else
		{
			sched_caretaker();
c0405189:	e8 16 ff ff ff       	call   c04050a4 <sched_caretaker>
			tick = SCHED_CARETAKER;
c040518e:	c7 05 44 10 41 c0 e8 	movl   $0x3e8,0xc0411044
c0405195:	03 00 00 
		}
	}
	
	lock_gate(&(cpu->lock), LOCK_READ);
c0405198:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040519c:	83 c0 08             	add    $0x8,%eax
c040519f:	83 ec 08             	sub    $0x8,%esp
c04051a2:	6a 00                	push   $0x0
c04051a4:	50                   	push   %eax
c04051a5:	e8 e1 b2 ff ff       	call   c040048b <lock_gate>
c04051aa:	83 c4 10             	add    $0x10,%esp
	/* bail out if we're not running anything */
	if(!(cpu->current))
c04051ad:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04051b1:	8b 40 04             	mov    0x4(%eax),%eax
c04051b4:	85 c0                	test   %eax,%eax
c04051b6:	75 1a                	jne    c04051d2 <sched_tick+0xcb>
	{
		unlock_gate(&(cpu->lock), LOCK_READ);
c04051b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04051bc:	83 c0 08             	add    $0x8,%eax
c04051bf:	83 ec 08             	sub    $0x8,%esp
c04051c2:	6a 00                	push   $0x0
c04051c4:	50                   	push   %eax
c04051c5:	e8 de b4 ff ff       	call   c04006a8 <unlock_gate>
c04051ca:	83 c4 10             	add    $0x10,%esp
		return;
c04051cd:	e9 23 01 00 00       	jmp    c04052f5 <sched_tick+0x1ee>
	}
	unlock_gate(&(cpu->lock), LOCK_READ);
c04051d2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04051d6:	83 c0 08             	add    $0x8,%eax
c04051d9:	83 ec 08             	sub    $0x8,%esp
c04051dc:	6a 00                	push   $0x0
c04051de:	50                   	push   %eax
c04051df:	e8 c4 b4 ff ff       	call   c04006a8 <unlock_gate>
c04051e4:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(cpu->current->lock), LOCK_WRITE);
c04051e7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04051eb:	8b 40 04             	mov    0x4(%eax),%eax
c04051ee:	83 c0 1c             	add    $0x1c,%eax
c04051f1:	83 ec 08             	sub    $0x8,%esp
c04051f4:	6a 01                	push   $0x1
c04051f6:	50                   	push   %eax
c04051f7:	e8 8f b2 ff ff       	call   c040048b <lock_gate>
c04051fc:	83 c4 10             	add    $0x10,%esp
	
	/* decrement timeslice */
	if(cpu->current->timeslice)
c04051ff:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405203:	8b 40 04             	mov    0x4(%eax),%eax
c0405206:	8a 40 0d             	mov    0xd(%eax),%al
c0405209:	84 c0                	test   %al,%al
c040520b:	74 0e                	je     c040521b <sched_tick+0x114>
		cpu->current->timeslice--;
c040520d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405211:	8b 40 04             	mov    0x4(%eax),%eax
c0405214:	8a 50 0d             	mov    0xd(%eax),%dl
c0405217:	4a                   	dec    %edx
c0405218:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
c040521b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040521f:	8b 40 04             	mov    0x4(%eax),%eax
c0405222:	8a 40 0d             	mov    0xd(%eax),%al
c0405225:	84 c0                	test   %al,%al
c0405227:	0f 85 ad 00 00 00    	jne    c04052da <sched_tick+0x1d3>
	{
#ifdef SCHED_DEBUG
		dprintf("[sched:%i] timeslice for thread %i of process %i expired\n",
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
c040522d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405231:	8b 40 04             	mov    0x4(%eax),%eax
c0405234:	8b 00                	mov    (%eax),%eax
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
	{
#ifdef SCHED_DEBUG
		dprintf("[sched:%i] timeslice for thread %i of process %i expired\n",
c0405236:	8b 08                	mov    (%eax),%ecx
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
c0405238:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040523c:	8b 40 04             	mov    0x4(%eax),%eax
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
	{
#ifdef SCHED_DEBUG
		dprintf("[sched:%i] timeslice for thread %i of process %i expired\n",
c040523f:	8b 50 04             	mov    0x4(%eax),%edx
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
c0405242:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
	{
#ifdef SCHED_DEBUG
		dprintf("[sched:%i] timeslice for thread %i of process %i expired\n",
c0405247:	3c 01                	cmp    $0x1,%al
c0405249:	76 0c                	jbe    c0405257 <sched_tick+0x150>
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
c040524b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405250:	8b 00                	mov    (%eax),%eax
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
	{
#ifdef SCHED_DEBUG
		dprintf("[sched:%i] timeslice for thread %i of process %i expired\n",
c0405252:	c1 e8 18             	shr    $0x18,%eax
c0405255:	eb 08                	jmp    c040525f <sched_tick+0x158>
c0405257:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040525c:	0f b6 c0             	movzbl %al,%eax
c040525f:	51                   	push   %ecx
c0405260:	52                   	push   %edx
c0405261:	50                   	push   %eax
c0405262:	68 54 e8 40 c0       	push   $0xc040e854
c0405267:	e8 ea 81 00 00       	call   c040d456 <debug_printf>
c040526c:	83 c4 10             	add    $0x10,%esp
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
#endif
		
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
c040526f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405273:	8b 40 04             	mov    0x4(%eax),%eax
c0405276:	83 c0 1c             	add    $0x1c,%eax
c0405279:	83 ec 08             	sub    $0x8,%esp
c040527c:	6a 01                	push   $0x1
c040527e:	50                   	push   %eax
c040527f:	e8 24 b4 ff ff       	call   c04006a8 <unlock_gate>
c0405284:	83 c4 10             	add    $0x10,%esp
		
		sched_move_to_end(CPU_ID, cpu->current->priority, cpu->current);
c0405287:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040528b:	8b 48 04             	mov    0x4(%eax),%ecx
c040528e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405292:	8b 40 04             	mov    0x4(%eax),%eax
c0405295:	8a 40 0e             	mov    0xe(%eax),%al
c0405298:	0f b6 d0             	movzbl %al,%edx
c040529b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04052a0:	3c 01                	cmp    $0x1,%al
c04052a2:	76 0f                	jbe    c04052b3 <sched_tick+0x1ac>
c04052a4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04052a9:	8b 00                	mov    (%eax),%eax
c04052ab:	c1 e8 18             	shr    $0x18,%eax
c04052ae:	0f b6 c0             	movzbl %al,%eax
c04052b1:	eb 08                	jmp    c04052bb <sched_tick+0x1b4>
c04052b3:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04052b8:	0f b6 c0             	movzbl %al,%eax
c04052bb:	83 ec 04             	sub    $0x4,%esp
c04052be:	51                   	push   %ecx
c04052bf:	52                   	push   %edx
c04052c0:	50                   	push   %eax
c04052c1:	e8 3f 03 00 00       	call   c0405605 <sched_move_to_end>
c04052c6:	83 c4 10             	add    $0x10,%esp
		sched_pick(regs);
c04052c9:	83 ec 0c             	sub    $0xc,%esp
c04052cc:	ff 74 24 2c          	pushl  0x2c(%esp)
c04052d0:	e8 24 00 00 00       	call   c04052f9 <sched_pick>
c04052d5:	83 c4 10             	add    $0x10,%esp
c04052d8:	eb 1b                	jmp    c04052f5 <sched_tick+0x1ee>
	}
	else
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
c04052da:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04052de:	8b 40 04             	mov    0x4(%eax),%eax
c04052e1:	83 c0 1c             	add    $0x1c,%eax
c04052e4:	83 ec 08             	sub    $0x8,%esp
c04052e7:	6a 01                	push   $0x1
c04052e9:	50                   	push   %eax
c04052ea:	e8 b9 b3 ff ff       	call   c04006a8 <unlock_gate>
c04052ef:	83 c4 10             	add    $0x10,%esp
c04052f2:	eb 01                	jmp    c04052f5 <sched_tick+0x1ee>
void sched_tick(int_registers_block *regs)
{
	proc_cpu *cpu = &cpu_table[CPU_ID];

	/* give up if no thread running */
	if(!(cpu->current)) return;
c04052f4:	90                   	nop
		sched_move_to_end(CPU_ID, cpu->current->priority, cpu->current);
		sched_pick(regs);
	}
	else
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
}
c04052f5:	83 c4 1c             	add    $0x1c,%esp
c04052f8:	c3                   	ret    

c04052f9 <sched_pick>:
/* sched_pick
   Check the run queues for new higher prority threads to run
   => pointer to the interrupted thread's kernel stack
*/
void sched_pick(int_registers_block *regs)
{
c04052f9:	56                   	push   %esi
c04052fa:	53                   	push   %ebx
c04052fb:	83 ec 14             	sub    $0x14,%esp
	thread *now, *next;

	proc_cpu *cpu = &cpu_table[CPU_ID];
c04052fe:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c0405304:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405309:	3c 01                	cmp    $0x1,%al
c040530b:	76 0f                	jbe    c040531c <sched_pick+0x23>
c040530d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405312:	8b 00                	mov    (%eax),%eax
c0405314:	c1 e8 18             	shr    $0x18,%eax
c0405317:	c1 e0 06             	shl    $0x6,%eax
c040531a:	eb 0b                	jmp    c0405327 <sched_pick+0x2e>
c040531c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405321:	0f b6 c0             	movzbl %al,%eax
c0405324:	c1 e0 06             	shl    $0x6,%eax
c0405327:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040532a:	89 44 24 08          	mov    %eax,0x8(%esp)
	
#ifdef SCHED_DEBUG
	{
		thread *t = cpu->queue_head;
c040532e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405332:	8b 40 18             	mov    0x18(%eax),%eax
c0405335:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(!t)
c0405339:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040533e:	75 33                	jne    c0405373 <sched_pick+0x7a>
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
c0405340:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405345:	3c 01                	cmp    $0x1,%al
c0405347:	76 0c                	jbe    c0405355 <sched_pick+0x5c>
c0405349:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040534e:	8b 00                	mov    (%eax),%eax
c0405350:	c1 e8 18             	shr    $0x18,%eax
c0405353:	eb 08                	jmp    c040535d <sched_pick+0x64>
c0405355:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040535a:	0f b6 c0             	movzbl %al,%eax
c040535d:	83 ec 08             	sub    $0x8,%esp
c0405360:	50                   	push   %eax
c0405361:	68 8e e8 40 c0       	push   $0xc040e88e
c0405366:	e8 eb 80 00 00       	call   c040d456 <debug_printf>
c040536b:	83 c4 10             	add    $0x10,%esp
c040536e:	e9 db 00 00 00       	jmp    c040544e <sched_pick+0x155>
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
c0405373:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405377:	8b 00                	mov    (%eax),%eax
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
c0405379:	8b 18                	mov    (%eax),%ebx
c040537b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040537f:	8b 48 04             	mov    0x4(%eax),%ecx
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
c0405382:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
c0405387:	3c 01                	cmp    $0x1,%al
c0405389:	76 0e                	jbe    c0405399 <sched_pick+0xa0>
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
c040538b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405390:	8b 00                	mov    (%eax),%eax
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
c0405392:	89 c2                	mov    %eax,%edx
c0405394:	c1 ea 18             	shr    $0x18,%edx
c0405397:	eb 08                	jmp    c04053a1 <sched_pick+0xa8>
c0405399:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040539e:	0f b6 d0             	movzbl %al,%edx
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
c04053a1:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
c04053a6:	3c 01                	cmp    $0x1,%al
c04053a8:	76 0c                	jbe    c04053b6 <sched_pick+0xbd>
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
c04053aa:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04053af:	8b 00                	mov    (%eax),%eax
		{
			dprintf("[sched:%i] queue empty!\n", CPU_ID);
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
c04053b1:	c1 e8 18             	shr    $0x18,%eax
c04053b4:	eb 08                	jmp    c04053be <sched_pick+0xc5>
c04053b6:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04053bb:	0f b6 c0             	movzbl %al,%eax
c04053be:	83 ec 0c             	sub    $0xc,%esp
c04053c1:	53                   	push   %ebx
c04053c2:	51                   	push   %ecx
c04053c3:	52                   	push   %edx
c04053c4:	50                   	push   %eax
c04053c5:	68 a8 e8 40 c0       	push   $0xc040e8a8
c04053ca:	e8 87 80 00 00       	call   c040d456 <debug_printf>
c04053cf:	83 c4 20             	add    $0x20,%esp
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
			while(t)
c04053d2:	eb 2f                	jmp    c0405403 <sched_pick+0x10a>
			{
				dprintf("(t%i p%i) ", t->tid, t->proc->pid);
c04053d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04053d8:	8b 00                	mov    (%eax),%eax
c04053da:	8b 10                	mov    (%eax),%edx
c04053dc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04053e0:	8b 40 04             	mov    0x4(%eax),%eax
c04053e3:	83 ec 04             	sub    $0x4,%esp
c04053e6:	52                   	push   %edx
c04053e7:	50                   	push   %eax
c04053e8:	68 de e8 40 c0       	push   $0xc040e8de
c04053ed:	e8 64 80 00 00       	call   c040d456 <debug_printf>
c04053f2:	83 c4 10             	add    $0x10,%esp
				t = t->queue_next;
c04053f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04053f9:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c04053ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
		}
		else
		{
			dprintf("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
					  CPU_ID, CPU_ID, t->tid, t->proc->pid);
			while(t)
c0405403:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0405408:	75 ca                	jne    c04053d4 <sched_pick+0xdb>
			{
				dprintf("(t%i p%i) ", t->tid, t->proc->pid);
				t = t->queue_next;
			}
			if(cpu->queue_tail)
c040540a:	8b 44 24 08          	mov    0x8(%esp),%eax
c040540e:	8b 40 1c             	mov    0x1c(%eax),%eax
c0405411:	85 c0                	test   %eax,%eax
c0405413:	74 29                	je     c040543e <sched_pick+0x145>
			{
				dprintf("end[t%i p%i]\n", cpu->queue_tail->tid, cpu->queue_tail->proc->pid);
c0405415:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405419:	8b 40 1c             	mov    0x1c(%eax),%eax
c040541c:	8b 00                	mov    (%eax),%eax
c040541e:	8b 10                	mov    (%eax),%edx
c0405420:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405424:	8b 40 1c             	mov    0x1c(%eax),%eax
c0405427:	8b 40 04             	mov    0x4(%eax),%eax
c040542a:	83 ec 04             	sub    $0x4,%esp
c040542d:	52                   	push   %edx
c040542e:	50                   	push   %eax
c040542f:	68 e9 e8 40 c0       	push   $0xc040e8e9
c0405434:	e8 1d 80 00 00       	call   c040d456 <debug_printf>
c0405439:	83 c4 10             	add    $0x10,%esp
c040543c:	eb 10                	jmp    c040544e <sched_pick+0x155>
			}
			else 
			{
				dprintf("end[NULL]\n");
c040543e:	83 ec 0c             	sub    $0xc,%esp
c0405441:	68 f7 e8 40 c0       	push   $0xc040e8f7
c0405446:	e8 0b 80 00 00       	call   c040d456 <debug_printf>
c040544b:	83 c4 10             	add    $0x10,%esp
		}
	}
#endif	

	/* this is the state of play */
	lock_gate(&(cpu->lock), LOCK_READ);
c040544e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405452:	83 c0 08             	add    $0x8,%eax
c0405455:	83 ec 08             	sub    $0x8,%esp
c0405458:	6a 00                	push   $0x0
c040545a:	50                   	push   %eax
c040545b:	e8 2b b0 ff ff       	call   c040048b <lock_gate>
c0405460:	83 c4 10             	add    $0x10,%esp
	now = cpu->current;
c0405463:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405467:	8b 40 04             	mov    0x4(%eax),%eax
c040546a:	89 04 24             	mov    %eax,(%esp)
	unlock_gate(&(cpu->lock), LOCK_READ);
c040546d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405471:	83 c0 08             	add    $0x8,%eax
c0405474:	83 ec 08             	sub    $0x8,%esp
c0405477:	6a 00                	push   $0x0
c0405479:	50                   	push   %eax
c040547a:	e8 29 b2 ff ff       	call   c04006a8 <unlock_gate>
c040547f:	83 c4 10             	add    $0x10,%esp
	
	/* if the queue head is empty, then spin until it's there */
	do
	{
		lock_gate(&(cpu->lock), LOCK_READ);
c0405482:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405486:	83 c0 08             	add    $0x8,%eax
c0405489:	83 ec 08             	sub    $0x8,%esp
c040548c:	6a 00                	push   $0x0
c040548e:	50                   	push   %eax
c040548f:	e8 f7 af ff ff       	call   c040048b <lock_gate>
c0405494:	83 c4 10             	add    $0x10,%esp
		next = (volatile thread *)(cpu->queue_head);
c0405497:	8b 44 24 08          	mov    0x8(%esp),%eax
c040549b:	8b 40 18             	mov    0x18(%eax),%eax
c040549e:	89 44 24 04          	mov    %eax,0x4(%esp)
		unlock_gate(&(cpu->lock), LOCK_READ);
c04054a2:	8b 44 24 08          	mov    0x8(%esp),%eax
c04054a6:	83 c0 08             	add    $0x8,%eax
c04054a9:	83 ec 08             	sub    $0x8,%esp
c04054ac:	6a 00                	push   $0x0
c04054ae:	50                   	push   %eax
c04054af:	e8 f4 b1 ff ff       	call   c04006a8 <unlock_gate>
c04054b4:	83 c4 10             	add    $0x10,%esp
	}
	while (!next);
c04054b7:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c04054bc:	74 c4                	je     c0405482 <sched_pick+0x189>
	
	if(next == now) return; /* easy quick switch back to where we were */
c04054be:	8b 44 24 04          	mov    0x4(%esp),%eax
c04054c2:	3b 04 24             	cmp    (%esp),%eax
c04054c5:	0f 84 33 01 00 00    	je     c04055fe <sched_pick+0x305>
	
	/* update thread states */
	lock_gate(&(now->lock), LOCK_WRITE);
c04054cb:	8b 04 24             	mov    (%esp),%eax
c04054ce:	83 c0 1c             	add    $0x1c,%eax
c04054d1:	83 ec 08             	sub    $0x8,%esp
c04054d4:	6a 01                	push   $0x1
c04054d6:	50                   	push   %eax
c04054d7:	e8 af af ff ff       	call   c040048b <lock_gate>
c04054dc:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(next->lock), LOCK_WRITE);
c04054df:	8b 44 24 04          	mov    0x4(%esp),%eax
c04054e3:	83 c0 1c             	add    $0x1c,%eax
c04054e6:	83 ec 08             	sub    $0x8,%esp
c04054e9:	6a 01                	push   $0x1
c04054eb:	50                   	push   %eax
c04054ec:	e8 9a af ff ff       	call   c040048b <lock_gate>
c04054f1:	83 c4 10             	add    $0x10,%esp
	
	if(now->state == running) now->state = inrunqueue;
c04054f4:	8b 04 24             	mov    (%esp),%eax
c04054f7:	8b 40 10             	mov    0x10(%eax),%eax
c04054fa:	83 f8 02             	cmp    $0x2,%eax
c04054fd:	75 0a                	jne    c0405509 <sched_pick+0x210>
c04054ff:	8b 04 24             	mov    (%esp),%eax
c0405502:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	next->cpu = CPU_ID;
c0405509:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040550e:	3c 01                	cmp    $0x1,%al
c0405510:	76 0c                	jbe    c040551e <sched_pick+0x225>
c0405512:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405517:	8b 00                	mov    (%eax),%eax
c0405519:	c1 e8 18             	shr    $0x18,%eax
c040551c:	eb 08                	jmp    c0405526 <sched_pick+0x22d>
c040551e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405523:	0f b6 c0             	movzbl %al,%eax
c0405526:	8b 54 24 04          	mov    0x4(%esp),%edx
c040552a:	89 42 08             	mov    %eax,0x8(%edx)
	next->state = running;
c040552d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405531:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	
	unlock_gate(&(next->lock), LOCK_WRITE);
c0405538:	8b 44 24 04          	mov    0x4(%esp),%eax
c040553c:	83 c0 1c             	add    $0x1c,%eax
c040553f:	83 ec 08             	sub    $0x8,%esp
c0405542:	6a 01                	push   $0x1
c0405544:	50                   	push   %eax
c0405545:	e8 5e b1 ff ff       	call   c04006a8 <unlock_gate>
c040554a:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(now->lock), LOCK_WRITE);
c040554d:	8b 04 24             	mov    (%esp),%eax
c0405550:	83 c0 1c             	add    $0x1c,%eax
c0405553:	83 ec 08             	sub    $0x8,%esp
c0405556:	6a 01                	push   $0x1
c0405558:	50                   	push   %eax
c0405559:	e8 4a b1 ff ff       	call   c04006a8 <unlock_gate>
c040555e:	83 c4 10             	add    $0x10,%esp

	/* this is the only place in core that we change cpu->current. the (un)lock_gate
		code relies on cpu->current not changing between lock-unlock pairs for a
	   given kernel thread. so we have to use a basic low-level spin lock on the
	   cpu's gate while we update this */	
	lock_spin(&(cpu->lock.spinlock));
c0405561:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405565:	83 c0 08             	add    $0x8,%eax
c0405568:	83 ec 0c             	sub    $0xc,%esp
c040556b:	50                   	push   %eax
c040556c:	e8 ef ae ff ff       	call   c0400460 <lock_spin>
c0405571:	83 c4 10             	add    $0x10,%esp
	cpu->current = next;
c0405574:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405578:	8b 54 24 04          	mov    0x4(%esp),%edx
c040557c:	89 50 04             	mov    %edx,0x4(%eax)
	unlock_spin(&(cpu->lock.spinlock));
c040557f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405583:	83 c0 08             	add    $0x8,%eax
c0405586:	83 ec 0c             	sub    $0xc,%esp
c0405589:	50                   	push   %eax
c040558a:	e8 f1 ae ff ff       	call   c0400480 <unlock_spin>
c040558f:	83 c4 10             	add    $0x10,%esp

	lowlevel_thread_switch(now, next, regs);
c0405592:	83 ec 04             	sub    $0x4,%esp
c0405595:	ff 74 24 24          	pushl  0x24(%esp)
c0405599:	ff 74 24 0c          	pushl  0xc(%esp)
c040559d:	ff 74 24 0c          	pushl  0xc(%esp)
c04055a1:	e8 3b be ff ff       	call   c04013e1 <lowlevel_thread_switch>
c04055a6:	83 c4 10             	add    $0x10,%esp
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
c04055a9:	8b 44 24 04          	mov    0x4(%esp),%eax
c04055ad:	8b 00                	mov    (%eax),%eax
	unlock_spin(&(cpu->lock.spinlock));

	lowlevel_thread_switch(now, next, regs);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
c04055af:	8b 30                	mov    (%eax),%esi
c04055b1:	8b 44 24 04          	mov    0x4(%esp),%eax
c04055b5:	8b 58 04             	mov    0x4(%eax),%ebx
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
c04055b8:	8b 04 24             	mov    (%esp),%eax
c04055bb:	8b 00                	mov    (%eax),%eax
	unlock_spin(&(cpu->lock.spinlock));

	lowlevel_thread_switch(now, next, regs);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
c04055bd:	8b 08                	mov    (%eax),%ecx
c04055bf:	8b 04 24             	mov    (%esp),%eax
c04055c2:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
c04055c5:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	unlock_spin(&(cpu->lock.spinlock));

	lowlevel_thread_switch(now, next, regs);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
c04055ca:	3c 01                	cmp    $0x1,%al
c04055cc:	76 0c                	jbe    c04055da <sched_pick+0x2e1>
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
c04055ce:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04055d3:	8b 00                	mov    (%eax),%eax
	unlock_spin(&(cpu->lock.spinlock));

	lowlevel_thread_switch(now, next, regs);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
c04055d5:	c1 e8 18             	shr    $0x18,%eax
c04055d8:	eb 08                	jmp    c04055e2 <sched_pick+0x2e9>
c04055da:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04055df:	0f b6 c0             	movzbl %al,%eax
c04055e2:	ff 74 24 04          	pushl  0x4(%esp)
c04055e6:	56                   	push   %esi
c04055e7:	53                   	push   %ebx
c04055e8:	ff 74 24 0c          	pushl  0xc(%esp)
c04055ec:	51                   	push   %ecx
c04055ed:	52                   	push   %edx
c04055ee:	50                   	push   %eax
c04055ef:	68 04 e9 40 c0       	push   $0xc040e904
c04055f4:	e8 5d 7e 00 00       	call   c040d456 <debug_printf>
c04055f9:	83 c4 20             	add    $0x20,%esp
c04055fc:	eb 01                	jmp    c04055ff <sched_pick+0x306>
		next = (volatile thread *)(cpu->queue_head);
		unlock_gate(&(cpu->lock), LOCK_READ);
	}
	while (!next);
	
	if(next == now) return; /* easy quick switch back to where we were */
c04055fe:	90                   	nop
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
#endif
}
c04055ff:	83 c4 14             	add    $0x14,%esp
c0405602:	5b                   	pop    %ebx
c0405603:	5e                   	pop    %esi
c0405604:	c3                   	ret    

c0405605 <sched_move_to_end>:
   => cpu = id of per-cpu run queue
      priority = priority queue to use
      toqueue = thread to queue up
*/
void sched_move_to_end(unsigned char cpu, unsigned char priority, thread *toqueue)
{
c0405605:	56                   	push   %esi
c0405606:	53                   	push   %ebx
c0405607:	83 ec 14             	sub    $0x14,%esp
c040560a:	8b 54 24 20          	mov    0x20(%esp),%edx
c040560e:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405612:	88 54 24 0c          	mov    %dl,0xc(%esp)
c0405616:	88 44 24 08          	mov    %al,0x8(%esp)
	if((cpu > mp_cpus) || !toqueue)
c040561a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040561f:	38 44 24 0c          	cmp    %al,0xc(%esp)
c0405623:	0f 87 ec 01 00 00    	ja     c0405815 <sched_move_to_end+0x210>
c0405629:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c040562e:	0f 84 e4 01 00 00    	je     c0405818 <sched_move_to_end+0x213>
		return; /* bail if parameters are insane */
	
	lock_gate(&(toqueue->lock), LOCK_WRITE);
c0405634:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405638:	83 c0 1c             	add    $0x1c,%eax
c040563b:	83 ec 08             	sub    $0x8,%esp
c040563e:	6a 01                	push   $0x1
c0405640:	50                   	push   %eax
c0405641:	e8 45 ae ff ff       	call   c040048b <lock_gate>
c0405646:	83 c4 10             	add    $0x10,%esp
	
	/* remove from the run queue if present */
	if(toqueue->state == running || toqueue->state == inrunqueue)
c0405649:	8b 44 24 28          	mov    0x28(%esp),%eax
c040564d:	8b 40 10             	mov    0x10(%eax),%eax
c0405650:	83 f8 02             	cmp    $0x2,%eax
c0405653:	74 0c                	je     c0405661 <sched_move_to_end+0x5c>
c0405655:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405659:	8b 40 10             	mov    0x10(%eax),%eax
c040565c:	83 f8 01             	cmp    $0x1,%eax
c040565f:	75 11                	jne    c0405672 <sched_move_to_end+0x6d>
		sched_remove(toqueue, held);
c0405661:	83 ec 08             	sub    $0x8,%esp
c0405664:	6a 05                	push   $0x5
c0405666:	ff 74 24 34          	pushl  0x34(%esp)
c040566a:	e8 d2 03 00 00       	call   c0405a41 <sched_remove>
c040566f:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0405672:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405677:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040567c:	c1 e2 06             	shl    $0x6,%edx
c040567f:	01 d0                	add    %edx,%eax
c0405681:	83 c0 08             	add    $0x8,%eax
c0405684:	83 ec 08             	sub    $0x8,%esp
c0405687:	6a 01                	push   $0x1
c0405689:	50                   	push   %eax
c040568a:	e8 fc ad ff ff       	call   c040048b <lock_gate>
c040568f:	83 c4 10             	add    $0x10,%esp
	
	/* add it to the end of the queue */
	if(cpu_table[cpu].queue_tail)
c0405692:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405697:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040569c:	c1 e2 06             	shl    $0x6,%edx
c040569f:	01 d0                	add    %edx,%eax
c04056a1:	8b 40 1c             	mov    0x1c(%eax),%eax
c04056a4:	85 c0                	test   %eax,%eax
c04056a6:	74 1c                	je     c04056c4 <sched_move_to_end+0xbf>
		cpu_table[cpu].queue_tail->queue_next = toqueue;
c04056a8:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04056ad:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04056b2:	c1 e2 06             	shl    $0x6,%edx
c04056b5:	01 d0                	add    %edx,%eax
c04056b7:	8b 40 1c             	mov    0x1c(%eax),%eax
c04056ba:	8b 54 24 28          	mov    0x28(%esp),%edx
c04056be:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)

	toqueue->queue_prev = cpu_table[cpu].queue_tail;
c04056c4:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04056c9:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04056ce:	c1 e2 06             	shl    $0x6,%edx
c04056d1:	01 d0                	add    %edx,%eax
c04056d3:	8b 50 1c             	mov    0x1c(%eax),%edx
c04056d6:	8b 44 24 28          	mov    0x28(%esp),%eax
c04056da:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
	
	/* if the head is empty, then fix up */
	if(cpu_table[cpu].queue_head == NULL)
c04056e0:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04056e5:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04056ea:	c1 e2 06             	shl    $0x6,%edx
c04056ed:	01 d0                	add    %edx,%eax
c04056ef:	8b 40 18             	mov    0x18(%eax),%eax
c04056f2:	85 c0                	test   %eax,%eax
c04056f4:	75 17                	jne    c040570d <sched_move_to_end+0x108>
		cpu_table[cpu].queue_head = toqueue;
c04056f6:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04056fb:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405700:	c1 e2 06             	shl    $0x6,%edx
c0405703:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0405706:	8b 44 24 28          	mov    0x28(%esp),%eax
c040570a:	89 42 18             	mov    %eax,0x18(%edx)
	
	cpu_table[cpu].queue_tail = toqueue;
c040570d:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405712:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405717:	c1 e2 06             	shl    $0x6,%edx
c040571a:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040571d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405721:	89 42 1c             	mov    %eax,0x1c(%edx)
	toqueue->queue_next = NULL;
c0405724:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405728:	c7 80 e4 00 00 00 00 	movl   $0x0,0xe4(%eax)
c040572f:	00 00 00 
	
	/* cap out-of-control priorities */
	if(priority >= SCHED_PRIORITY_LEVELS)
c0405732:	80 7c 24 08 03       	cmpb   $0x3,0x8(%esp)
c0405737:	76 05                	jbe    c040573e <sched_move_to_end+0x139>
		priority = SCHED_PRIORITY_LEVELS - 1;
c0405739:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)
	
	/* update accounting */
	if(toqueue->state != running && toqueue->state != inrunqueue)
c040573e:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405742:	8b 40 10             	mov    0x10(%eax),%eax
c0405745:	83 f8 02             	cmp    $0x2,%eax
c0405748:	74 27                	je     c0405771 <sched_move_to_end+0x16c>
c040574a:	8b 44 24 28          	mov    0x28(%esp),%eax
c040574e:	8b 40 10             	mov    0x10(%eax),%eax
c0405751:	83 f8 01             	cmp    $0x1,%eax
c0405754:	74 1b                	je     c0405771 <sched_move_to_end+0x16c>
	{
		cpu_table[cpu].queued++;
c0405756:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040575b:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405760:	c1 e2 06             	shl    $0x6,%edx
c0405763:	01 d0                	add    %edx,%eax
c0405765:	8b 50 30             	mov    0x30(%eax),%edx
c0405768:	42                   	inc    %edx
c0405769:	89 50 30             	mov    %edx,0x30(%eax)
		sched_inc_queued_threads();
c040576c:	e8 cb f1 ff ff       	call   c040493c <sched_inc_queued_threads>
	}

	toqueue->priority  = priority;
c0405771:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405775:	8a 54 24 08          	mov    0x8(%esp),%dl
c0405779:	88 50 0e             	mov    %dl,0xe(%eax)
	toqueue->state     = inrunqueue;
c040577c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405780:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	toqueue->timeslice = SCHED_TIMESLICE;
c0405787:	8b 44 24 28          	mov    0x28(%esp),%eax
c040578b:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c040578f:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405794:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405799:	c1 e2 06             	shl    $0x6,%edx
c040579c:	01 d0                	add    %edx,%eax
c040579e:	83 c0 08             	add    $0x8,%eax
c04057a1:	83 ec 08             	sub    $0x8,%esp
c04057a4:	6a 01                	push   $0x1
c04057a6:	50                   	push   %eax
c04057a7:	e8 fc ae ff ff       	call   c04006a8 <unlock_gate>
c04057ac:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
c04057af:	8b 44 24 28          	mov    0x28(%esp),%eax
c04057b3:	83 c0 1c             	add    $0x1c,%eax
c04057b6:	83 ec 08             	sub    $0x8,%esp
c04057b9:	6a 01                	push   $0x1
c04057bb:	50                   	push   %eax
c04057bc:	e8 e7 ae ff ff       	call   c04006a8 <unlock_gate>
c04057c1:	83 c4 10             	add    $0x10,%esp
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
c04057c4:	0f b6 74 24 08       	movzbl 0x8(%esp),%esi
c04057c9:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
			  CPU_ID, toqueue->tid, toqueue, toqueue->proc->pid, cpu, priority);
c04057ce:	8b 44 24 28          	mov    0x28(%esp),%eax
c04057d2:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
c04057d4:	8b 08                	mov    (%eax),%ecx
c04057d6:	8b 44 24 28          	mov    0x28(%esp),%eax
c04057da:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, toqueue->tid, toqueue, toqueue->proc->pid, cpu, priority);
c04057dd:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
c04057e2:	3c 01                	cmp    $0x1,%al
c04057e4:	76 0c                	jbe    c04057f2 <sched_move_to_end+0x1ed>
			  CPU_ID, toqueue->tid, toqueue, toqueue->proc->pid, cpu, priority);
c04057e6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04057eb:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
c04057ed:	c1 e8 18             	shr    $0x18,%eax
c04057f0:	eb 08                	jmp    c04057fa <sched_move_to_end+0x1f5>
c04057f2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04057f7:	0f b6 c0             	movzbl %al,%eax
c04057fa:	83 ec 04             	sub    $0x4,%esp
c04057fd:	56                   	push   %esi
c04057fe:	53                   	push   %ebx
c04057ff:	51                   	push   %ecx
c0405800:	ff 74 24 38          	pushl  0x38(%esp)
c0405804:	52                   	push   %edx
c0405805:	50                   	push   %eax
c0405806:	68 58 e9 40 c0       	push   $0xc040e958
c040580b:	e8 46 7c 00 00       	call   c040d456 <debug_printf>
c0405810:	83 c4 20             	add    $0x20,%esp
c0405813:	eb 04                	jmp    c0405819 <sched_move_to_end+0x214>
      toqueue = thread to queue up
*/
void sched_move_to_end(unsigned char cpu, unsigned char priority, thread *toqueue)
{
	if((cpu > mp_cpus) || !toqueue)
		return; /* bail if parameters are insane */
c0405815:	90                   	nop
c0405816:	eb 01                	jmp    c0405819 <sched_move_to_end+0x214>
c0405818:	90                   	nop
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
			  CPU_ID, toqueue->tid, toqueue, toqueue->proc->pid, cpu, priority);
#endif

}
c0405819:	83 c4 14             	add    $0x14,%esp
c040581c:	5b                   	pop    %ebx
c040581d:	5e                   	pop    %esi
c040581e:	c3                   	ret    

c040581f <sched_add>:
	=> cpu = id of the requested per-cpu run queue
      priority = the priority level of the process
      torun = the thread to add
*/
void sched_add(unsigned char cpu, unsigned char priority, thread *torun)
{
c040581f:	56                   	push   %esi
c0405820:	53                   	push   %ebx
c0405821:	83 ec 14             	sub    $0x14,%esp
c0405824:	8b 54 24 20          	mov    0x20(%esp),%edx
c0405828:	8b 44 24 24          	mov    0x24(%esp),%eax
c040582c:	88 54 24 0c          	mov    %dl,0xc(%esp)
c0405830:	88 44 24 08          	mov    %al,0x8(%esp)
	if((cpu > mp_cpus) || !torun)
c0405834:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405839:	38 44 24 0c          	cmp    %al,0xc(%esp)
c040583d:	0f 87 f4 01 00 00    	ja     c0405a37 <sched_add+0x218>
c0405843:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0405848:	0f 84 ec 01 00 00    	je     c0405a3a <sched_add+0x21b>
		return; /* bail if parameters are insane */

	/* perform some load balancing */
	cpu = sched_pick_queue(cpu);
c040584e:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0405853:	83 ec 0c             	sub    $0xc,%esp
c0405856:	50                   	push   %eax
c0405857:	e8 7c 03 00 00       	call   c0405bd8 <sched_pick_queue>
c040585c:	83 c4 10             	add    $0x10,%esp
c040585f:	88 44 24 0c          	mov    %al,0xc(%esp)
		
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0405863:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405868:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040586d:	c1 e2 06             	shl    $0x6,%edx
c0405870:	01 d0                	add    %edx,%eax
c0405872:	83 c0 08             	add    $0x8,%eax
c0405875:	83 ec 08             	sub    $0x8,%esp
c0405878:	6a 01                	push   $0x1
c040587a:	50                   	push   %eax
c040587b:	e8 0b ac ff ff       	call   c040048b <lock_gate>
c0405880:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(torun->lock), LOCK_WRITE);
c0405883:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405887:	83 c0 1c             	add    $0x1c,%eax
c040588a:	83 ec 08             	sub    $0x8,%esp
c040588d:	6a 01                	push   $0x1
c040588f:	50                   	push   %eax
c0405890:	e8 f6 ab ff ff       	call   c040048b <lock_gate>
c0405895:	83 c4 10             	add    $0x10,%esp
		
	/* add it to the start of the queue */
	if(cpu_table[cpu].queue_head)
c0405898:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040589d:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04058a2:	c1 e2 06             	shl    $0x6,%edx
c04058a5:	01 d0                	add    %edx,%eax
c04058a7:	8b 40 18             	mov    0x18(%eax),%eax
c04058aa:	85 c0                	test   %eax,%eax
c04058ac:	74 3a                	je     c04058e8 <sched_add+0xc9>
	{
		cpu_table[cpu].queue_head->queue_prev = torun;
c04058ae:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04058b3:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04058b8:	c1 e2 06             	shl    $0x6,%edx
c04058bb:	01 d0                	add    %edx,%eax
c04058bd:	8b 40 18             	mov    0x18(%eax),%eax
c04058c0:	8b 54 24 28          	mov    0x28(%esp),%edx
c04058c4:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
		torun->queue_next = cpu_table[cpu].queue_head;
c04058ca:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04058cf:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04058d4:	c1 e2 06             	shl    $0x6,%edx
c04058d7:	01 d0                	add    %edx,%eax
c04058d9:	8b 50 18             	mov    0x18(%eax),%edx
c04058dc:	8b 44 24 28          	mov    0x28(%esp),%eax
c04058e0:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)
c04058e6:	eb 0e                	jmp    c04058f6 <sched_add+0xd7>
	}
	else
	{
		torun->queue_next = NULL;
c04058e8:	8b 44 24 28          	mov    0x28(%esp),%eax
c04058ec:	c7 80 e4 00 00 00 00 	movl   $0x0,0xe4(%eax)
c04058f3:	00 00 00 
	}
	/* if the tail is empty, then fix up */
	if(!(cpu_table[cpu].queue_tail))
c04058f6:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04058fb:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405900:	c1 e2 06             	shl    $0x6,%edx
c0405903:	01 d0                	add    %edx,%eax
c0405905:	8b 40 1c             	mov    0x1c(%eax),%eax
c0405908:	85 c0                	test   %eax,%eax
c040590a:	75 17                	jne    c0405923 <sched_add+0x104>
		cpu_table[cpu].queue_tail = torun;
c040590c:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405911:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405916:	c1 e2 06             	shl    $0x6,%edx
c0405919:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040591c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405920:	89 42 1c             	mov    %eax,0x1c(%edx)
	
	cpu_table[cpu].queue_head = torun;
c0405923:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405928:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040592d:	c1 e2 06             	shl    $0x6,%edx
c0405930:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0405933:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405937:	89 42 18             	mov    %eax,0x18(%edx)
	torun->queue_prev = NULL;
c040593a:	8b 44 24 28          	mov    0x28(%esp),%eax
c040593e:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
c0405945:	00 00 00 
		
	/* cap out-of-control priorities */
	if(priority >= SCHED_PRIORITY_LEVELS)
c0405948:	80 7c 24 08 03       	cmpb   $0x3,0x8(%esp)
c040594d:	76 05                	jbe    c0405954 <sched_add+0x135>
		priority = SCHED_PRIORITY_LEVELS - 1;
c040594f:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)
	
	/* update accounting */
	if(torun->state != running && torun->state != inrunqueue)
c0405954:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405958:	8b 40 10             	mov    0x10(%eax),%eax
c040595b:	83 f8 02             	cmp    $0x2,%eax
c040595e:	74 27                	je     c0405987 <sched_add+0x168>
c0405960:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405964:	8b 40 10             	mov    0x10(%eax),%eax
c0405967:	83 f8 01             	cmp    $0x1,%eax
c040596a:	74 1b                	je     c0405987 <sched_add+0x168>
	{
		cpu_table[cpu].queued++;
c040596c:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405971:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405976:	c1 e2 06             	shl    $0x6,%edx
c0405979:	01 d0                	add    %edx,%eax
c040597b:	8b 50 30             	mov    0x30(%eax),%edx
c040597e:	42                   	inc    %edx
c040597f:	89 50 30             	mov    %edx,0x30(%eax)
		sched_inc_queued_threads();
c0405982:	e8 b5 ef ff ff       	call   c040493c <sched_inc_queued_threads>
	}

	torun->priority  = priority;
c0405987:	8b 44 24 28          	mov    0x28(%esp),%eax
c040598b:	8a 54 24 08          	mov    0x8(%esp),%dl
c040598f:	88 50 0e             	mov    %dl,0xe(%eax)
	torun->state     = inrunqueue;
c0405992:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405996:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	torun->timeslice = SCHED_TIMESLICE;
c040599d:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059a1:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	torun->cpu		  = cpu;
c04059a5:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04059aa:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059ae:	89 50 08             	mov    %edx,0x8(%eax)
	
	unlock_gate(&(torun->lock), LOCK_WRITE);
c04059b1:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059b5:	83 c0 1c             	add    $0x1c,%eax
c04059b8:	83 ec 08             	sub    $0x8,%esp
c04059bb:	6a 01                	push   $0x1
c04059bd:	50                   	push   %eax
c04059be:	e8 e5 ac ff ff       	call   c04006a8 <unlock_gate>
c04059c3:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c04059c6:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c04059cb:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04059d0:	c1 e2 06             	shl    $0x6,%edx
c04059d3:	01 d0                	add    %edx,%eax
c04059d5:	83 c0 08             	add    $0x8,%eax
c04059d8:	83 ec 08             	sub    $0x8,%esp
c04059db:	6a 01                	push   $0x1
c04059dd:	50                   	push   %eax
c04059de:	e8 c5 ac ff ff       	call   c04006a8 <unlock_gate>
c04059e3:	83 c4 10             	add    $0x10,%esp
		
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
c04059e6:	0f b6 74 24 08       	movzbl 0x8(%esp),%esi
c04059eb:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
			  CPU_ID, torun->tid, torun, torun->proc->pid, cpu, priority);
c04059f0:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059f4:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(torun->lock), LOCK_WRITE);
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
		
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
c04059f6:	8b 08                	mov    (%eax),%ecx
c04059f8:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059fc:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, torun->tid, torun, torun->proc->pid, cpu, priority);
c04059ff:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	unlock_gate(&(torun->lock), LOCK_WRITE);
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
		
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
c0405a04:	3c 01                	cmp    $0x1,%al
c0405a06:	76 0c                	jbe    c0405a14 <sched_add+0x1f5>
			  CPU_ID, torun->tid, torun, torun->proc->pid, cpu, priority);
c0405a08:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405a0d:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(torun->lock), LOCK_WRITE);
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
		
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
c0405a0f:	c1 e8 18             	shr    $0x18,%eax
c0405a12:	eb 08                	jmp    c0405a1c <sched_add+0x1fd>
c0405a14:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405a19:	0f b6 c0             	movzbl %al,%eax
c0405a1c:	83 ec 04             	sub    $0x4,%esp
c0405a1f:	56                   	push   %esi
c0405a20:	53                   	push   %ebx
c0405a21:	51                   	push   %ecx
c0405a22:	ff 74 24 38          	pushl  0x38(%esp)
c0405a26:	52                   	push   %edx
c0405a27:	50                   	push   %eax
c0405a28:	68 ac e9 40 c0       	push   $0xc040e9ac
c0405a2d:	e8 24 7a 00 00       	call   c040d456 <debug_printf>
c0405a32:	83 c4 20             	add    $0x20,%esp
c0405a35:	eb 04                	jmp    c0405a3b <sched_add+0x21c>
      torun = the thread to add
*/
void sched_add(unsigned char cpu, unsigned char priority, thread *torun)
{
	if((cpu > mp_cpus) || !torun)
		return; /* bail if parameters are insane */
c0405a37:	90                   	nop
c0405a38:	eb 01                	jmp    c0405a3b <sched_add+0x21c>
c0405a3a:	90                   	nop
		
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
			  CPU_ID, torun->tid, torun, torun->proc->pid, cpu, priority);
#endif
}
c0405a3b:	83 c4 14             	add    $0x14,%esp
c0405a3e:	5b                   	pop    %ebx
c0405a3f:	5e                   	pop    %esi
c0405a40:	c3                   	ret    

c0405a41 <sched_remove>:
	Remove a thread from a run queue for a cpu
   => victim = the thread to remove
      state = new thread state
*/
void sched_remove(thread *victim, thread_state state)
{
c0405a41:	53                   	push   %ebx
c0405a42:	83 ec 18             	sub    $0x18,%esp
	unsigned int cpu = victim->cpu;
c0405a45:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405a49:	8b 40 08             	mov    0x8(%eax),%eax
c0405a4c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0405a50:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405a55:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405a59:	c1 e2 06             	shl    $0x6,%edx
c0405a5c:	01 d0                	add    %edx,%eax
c0405a5e:	83 c0 08             	add    $0x8,%eax
c0405a61:	83 ec 08             	sub    $0x8,%esp
c0405a64:	6a 01                	push   $0x1
c0405a66:	50                   	push   %eax
c0405a67:	e8 1f aa ff ff       	call   c040048b <lock_gate>
c0405a6c:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(victim->lock), LOCK_WRITE);
c0405a6f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405a73:	83 c0 1c             	add    $0x1c,%eax
c0405a76:	83 ec 08             	sub    $0x8,%esp
c0405a79:	6a 01                	push   $0x1
c0405a7b:	50                   	push   %eax
c0405a7c:	e8 0a aa ff ff       	call   c040048b <lock_gate>
c0405a81:	83 c4 10             	add    $0x10,%esp
	
	/* remove it from the queue */
	if(victim->queue_next)
c0405a84:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405a88:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c0405a8e:	85 c0                	test   %eax,%eax
c0405a90:	74 1c                	je     c0405aae <sched_remove+0x6d>
		victim->queue_next->queue_prev = victim->queue_prev;
c0405a92:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405a96:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c0405a9c:	8b 54 24 20          	mov    0x20(%esp),%edx
c0405aa0:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
c0405aa6:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
c0405aac:	eb 1c                	jmp    c0405aca <sched_remove+0x89>
	else
		/* we were the tail, so fix up */
		cpu_table[cpu].queue_tail = victim->queue_prev;
c0405aae:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405ab3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405ab7:	c1 e2 06             	shl    $0x6,%edx
c0405aba:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0405abd:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405ac1:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c0405ac7:	89 42 1c             	mov    %eax,0x1c(%edx)
	if(victim->queue_prev)
c0405aca:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405ace:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c0405ad4:	85 c0                	test   %eax,%eax
c0405ad6:	74 1c                	je     c0405af4 <sched_remove+0xb3>
		victim->queue_prev->queue_next = victim->queue_next;
c0405ad8:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405adc:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c0405ae2:	8b 54 24 20          	mov    0x20(%esp),%edx
c0405ae6:	8b 92 e4 00 00 00    	mov    0xe4(%edx),%edx
c0405aec:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)
c0405af2:	eb 1c                	jmp    c0405b10 <sched_remove+0xcf>
	else
	/* we were the queue head, so fixup pointers */
		cpu_table[cpu].queue_head = victim->queue_next;
c0405af4:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405af9:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405afd:	c1 e2 06             	shl    $0x6,%edx
c0405b00:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0405b03:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b07:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c0405b0d:	89 42 18             	mov    %eax,0x18(%edx)
	
	/* update accounting */
	if(victim->state == running || victim->state == inrunqueue)
c0405b10:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b14:	8b 40 10             	mov    0x10(%eax),%eax
c0405b17:	83 f8 02             	cmp    $0x2,%eax
c0405b1a:	74 0c                	je     c0405b28 <sched_remove+0xe7>
c0405b1c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b20:	8b 40 10             	mov    0x10(%eax),%eax
c0405b23:	83 f8 01             	cmp    $0x1,%eax
c0405b26:	75 1a                	jne    c0405b42 <sched_remove+0x101>
	{
		cpu_table[cpu].queued--;
c0405b28:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405b2d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405b31:	c1 e2 06             	shl    $0x6,%edx
c0405b34:	01 d0                	add    %edx,%eax
c0405b36:	8b 50 30             	mov    0x30(%eax),%edx
c0405b39:	4a                   	dec    %edx
c0405b3a:	89 50 30             	mov    %edx,0x30(%eax)
		sched_dec_queued_threads();
c0405b3d:	e8 65 ee ff ff       	call   c04049a7 <sched_dec_queued_threads>
	}

	victim->state = state;
c0405b42:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b46:	8b 54 24 24          	mov    0x24(%esp),%edx
c0405b4a:	89 50 10             	mov    %edx,0x10(%eax)
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
c0405b4d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b51:	83 c0 1c             	add    $0x1c,%eax
c0405b54:	83 ec 08             	sub    $0x8,%esp
c0405b57:	6a 01                	push   $0x1
c0405b59:	50                   	push   %eax
c0405b5a:	e8 49 ab ff ff       	call   c04006a8 <unlock_gate>
c0405b5f:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0405b62:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405b67:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405b6b:	c1 e2 06             	shl    $0x6,%edx
c0405b6e:	01 d0                	add    %edx,%eax
c0405b70:	83 c0 08             	add    $0x8,%eax
c0405b73:	83 ec 08             	sub    $0x8,%esp
c0405b76:	6a 01                	push   $0x1
c0405b78:	50                   	push   %eax
c0405b79:	e8 2a ab ff ff       	call   c04006a8 <unlock_gate>
c0405b7e:	83 c4 10             	add    $0x10,%esp
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
c0405b81:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b85:	8a 40 0e             	mov    0xe(%eax),%al
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
c0405b88:	0f b6 d8             	movzbl %al,%ebx
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
c0405b8b:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b8f:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
c0405b91:	8b 08                	mov    (%eax),%ecx
c0405b93:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b97:	8b 50 04             	mov    0x4(%eax),%edx
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
c0405b9a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
c0405b9f:	3c 01                	cmp    $0x1,%al
c0405ba1:	76 0c                	jbe    c0405baf <sched_remove+0x16e>
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
c0405ba3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405ba8:	8b 00                	mov    (%eax),%eax
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
c0405baa:	c1 e8 18             	shr    $0x18,%eax
c0405bad:	eb 08                	jmp    c0405bb7 <sched_remove+0x176>
c0405baf:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405bb4:	0f b6 c0             	movzbl %al,%eax
c0405bb7:	83 ec 04             	sub    $0x4,%esp
c0405bba:	53                   	push   %ebx
c0405bbb:	ff 74 24 14          	pushl  0x14(%esp)
c0405bbf:	51                   	push   %ecx
c0405bc0:	ff 74 24 30          	pushl  0x30(%esp)
c0405bc4:	52                   	push   %edx
c0405bc5:	50                   	push   %eax
c0405bc6:	68 f8 e9 40 c0       	push   $0xc040e9f8
c0405bcb:	e8 86 78 00 00       	call   c040d456 <debug_printf>
c0405bd0:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
#endif
}
c0405bd3:	83 c4 18             	add    $0x18,%esp
c0405bd6:	5b                   	pop    %ebx
c0405bd7:	c3                   	ret    

c0405bd8 <sched_pick_queue>:
	to run on, biased in favour of the hinted cpu queue
   => hint = hinted cpu queue 
   <= cpu queue to use
*/
unsigned char sched_pick_queue(unsigned char hint)
{
c0405bd8:	57                   	push   %edi
c0405bd9:	56                   	push   %esi
c0405bda:	53                   	push   %ebx
c0405bdb:	83 ec 20             	sub    $0x20,%esp
c0405bde:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405be2:	88 44 24 0c          	mov    %al,0xc(%esp)
	unsigned char picked;
	unsigned int max_fair_share, original_sched_next;
	
	/* use the boot cpu queue if it's the only cpu */
	if(mp_cpus == 1) return mp_boot_cpu;
c0405be6:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405beb:	3c 01                	cmp    $0x1,%al
c0405bed:	75 0a                	jne    c0405bf9 <sched_pick_queue+0x21>
c0405bef:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405bf4:	e9 3b 02 00 00       	jmp    c0405e34 <sched_pick_queue+0x25c>
	
	/* use the boot cpu queue if the hint is wild */
	if(hint >= mp_cpus) hint = mp_boot_cpu;
c0405bf9:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405bfe:	38 44 24 0c          	cmp    %al,0xc(%esp)
c0405c02:	72 09                	jb     c0405c0d <sched_pick_queue+0x35>
c0405c04:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405c09:	88 44 24 0c          	mov    %al,0xc(%esp)
	
	/* protect the scheduler's critical section right here */
	lock_gate(&(sched_lock), LOCK_WRITE);
c0405c0d:	83 ec 08             	sub    $0x8,%esp
c0405c10:	6a 01                	push   $0x1
c0405c12:	68 7c 18 41 c0       	push   $0xc041187c
c0405c17:	e8 6f a8 ff ff       	call   c040048b <lock_gate>
c0405c1c:	83 c4 10             	add    $0x10,%esp

	/* the number of threads per cpu queue that's 'fair' to run
		is simply the total number of threads divided by cpu queues 
	   available */
	max_fair_share = sched_total_queued / mp_cpus;
c0405c1f:	a1 c4 38 41 c0       	mov    0xc04138c4,%eax
c0405c24:	8a 15 f0 38 41 c0    	mov    0xc04138f0,%dl
c0405c2a:	0f b6 d2             	movzbl %dl,%edx
c0405c2d:	89 d1                	mov    %edx,%ecx
c0405c2f:	ba 00 00 00 00       	mov    $0x0,%edx
c0405c34:	f7 f1                	div    %ecx
c0405c36:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(!max_fair_share) max_fair_share = 1; /* ensure a sane value */
c0405c3a:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0405c3f:	75 08                	jne    c0405c49 <sched_pick_queue+0x71>
c0405c41:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c0405c48:	00 

	/* ensure next_queue is sane */
	if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
c0405c49:	8a 15 c0 38 41 c0    	mov    0xc04138c0,%dl
c0405c4f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405c54:	38 c2                	cmp    %al,%dl
c0405c56:	72 07                	jb     c0405c5f <sched_pick_queue+0x87>
c0405c58:	c6 05 c0 38 41 c0 00 	movb   $0x0,0xc04138c0
	
	/* make sure the next queue is not the hinted queue */
	if(sched_next_queue == hint)
c0405c5f:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405c64:	3a 44 24 0c          	cmp    0xc(%esp),%al
c0405c68:	75 21                	jne    c0405c8b <sched_pick_queue+0xb3>
	{
		sched_next_queue++;
c0405c6a:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405c6f:	40                   	inc    %eax
c0405c70:	a2 c0 38 41 c0       	mov    %al,0xc04138c0
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
c0405c75:	8a 15 c0 38 41 c0    	mov    0xc04138c0,%dl
c0405c7b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405c80:	38 c2                	cmp    %al,%dl
c0405c82:	72 07                	jb     c0405c8b <sched_pick_queue+0xb3>
c0405c84:	c6 05 c0 38 41 c0 00 	movb   $0x0,0xc04138c0
	}
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: max threads per cpu: %i next queue: %i (%i) hint: %i (%i) total queued: %i\n",
c0405c8b:	8b 3d c4 38 41 c0    	mov    0xc04138c4,%edi
			  CPU_ID, max_fair_share, sched_next_queue, cpu_table[sched_next_queue].queued,
			  hint, cpu_table[hint].queued, sched_total_queued);
c0405c91:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405c96:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405c9b:	c1 e2 06             	shl    $0x6,%edx
c0405c9e:	01 d0                	add    %edx,%eax
		sched_next_queue++;
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
	}
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: max threads per cpu: %i next queue: %i (%i) hint: %i (%i) total queued: %i\n",
c0405ca0:	8b 70 30             	mov    0x30(%eax),%esi
c0405ca3:	0f b6 5c 24 0c       	movzbl 0xc(%esp),%ebx
			  CPU_ID, max_fair_share, sched_next_queue, cpu_table[sched_next_queue].queued,
c0405ca8:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405cad:	8a 15 c0 38 41 c0    	mov    0xc04138c0,%dl
c0405cb3:	0f b6 d2             	movzbl %dl,%edx
c0405cb6:	c1 e2 06             	shl    $0x6,%edx
c0405cb9:	01 d0                	add    %edx,%eax
		sched_next_queue++;
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
	}
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: max threads per cpu: %i next queue: %i (%i) hint: %i (%i) total queued: %i\n",
c0405cbb:	8b 48 30             	mov    0x30(%eax),%ecx
c0405cbe:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405cc3:	0f b6 d0             	movzbl %al,%edx
			  CPU_ID, max_fair_share, sched_next_queue, cpu_table[sched_next_queue].queued,
c0405cc6:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		sched_next_queue++;
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
	}
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: max threads per cpu: %i next queue: %i (%i) hint: %i (%i) total queued: %i\n",
c0405ccb:	3c 01                	cmp    $0x1,%al
c0405ccd:	76 0c                	jbe    c0405cdb <sched_pick_queue+0x103>
			  CPU_ID, max_fair_share, sched_next_queue, cpu_table[sched_next_queue].queued,
c0405ccf:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405cd4:	8b 00                	mov    (%eax),%eax
		sched_next_queue++;
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
	}
	
#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: max threads per cpu: %i next queue: %i (%i) hint: %i (%i) total queued: %i\n",
c0405cd6:	c1 e8 18             	shr    $0x18,%eax
c0405cd9:	eb 08                	jmp    c0405ce3 <sched_pick_queue+0x10b>
c0405cdb:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405ce0:	0f b6 c0             	movzbl %al,%eax
c0405ce3:	57                   	push   %edi
c0405ce4:	56                   	push   %esi
c0405ce5:	53                   	push   %ebx
c0405ce6:	51                   	push   %ecx
c0405ce7:	52                   	push   %edx
c0405ce8:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405cec:	50                   	push   %eax
c0405ced:	68 48 ea 40 c0       	push   $0xc040ea48
c0405cf2:	e8 5f 77 00 00       	call   c040d456 <debug_printf>
c0405cf7:	83 c4 20             	add    $0x20,%esp
#endif
	
	/* the strategy is thus: use the hinted queue unless it has more than its
	   fair share of threads or the next queue is empty. in which case, use the next queue if possible and advance it if
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
c0405cfa:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405cff:	0f b6 c0             	movzbl %al,%eax
c0405d02:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
c0405d06:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405d0b:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405d10:	c1 e2 06             	shl    $0x6,%edx
c0405d13:	01 d0                	add    %edx,%eax
c0405d15:	83 c0 08             	add    $0x8,%eax
c0405d18:	83 ec 08             	sub    $0x8,%esp
c0405d1b:	6a 00                	push   $0x0
c0405d1d:	50                   	push   %eax
c0405d1e:	e8 68 a7 ff ff       	call   c040048b <lock_gate>
c0405d23:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
c0405d26:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405d2b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405d2f:	c1 e2 06             	shl    $0x6,%edx
c0405d32:	01 d0                	add    %edx,%eax
c0405d34:	83 c0 08             	add    $0x8,%eax
c0405d37:	83 ec 08             	sub    $0x8,%esp
c0405d3a:	6a 00                	push   $0x0
c0405d3c:	50                   	push   %eax
c0405d3d:	e8 49 a7 ff ff       	call   c040048b <lock_gate>
c0405d42:	83 c4 10             	add    $0x10,%esp
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0405d45:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405d4a:	8a 15 c0 38 41 c0    	mov    0xc04138c0,%dl
c0405d50:	0f b6 d2             	movzbl %dl,%edx
c0405d53:	c1 e2 06             	shl    $0x6,%edx
c0405d56:	01 d0                	add    %edx,%eax
c0405d58:	8b 40 30             	mov    0x30(%eax),%eax
c0405d5b:	85 c0                	test   %eax,%eax
c0405d5d:	74 18                	je     c0405d77 <sched_pick_queue+0x19f>
		 (cpu_table[hint].queued > max_fair_share)) &&
c0405d5f:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405d64:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405d69:	c1 e2 06             	shl    $0x6,%edx
c0405d6c:	01 d0                	add    %edx,%eax
c0405d6e:	8b 40 30             	mov    0x30(%eax),%eax
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0405d71:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0405d75:	76 2c                	jbe    c0405da3 <sched_pick_queue+0x1cb>
		 (cpu_table[hint].queued > max_fair_share)) &&
		(cpu_table[hint].queued != 0))
c0405d77:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405d7c:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405d81:	c1 e2 06             	shl    $0x6,%edx
c0405d84:	01 d0                	add    %edx,%eax
c0405d86:	8b 40 30             	mov    0x30(%eax),%eax
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0405d89:	85 c0                	test   %eax,%eax
c0405d8b:	74 16                	je     c0405da3 <sched_pick_queue+0x1cb>
		 (cpu_table[hint].queued > max_fair_share)) &&
		(cpu_table[hint].queued != 0))
	{
		picked = sched_next_queue;
c0405d8d:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405d92:	88 44 24 17          	mov    %al,0x17(%esp)
		sched_next_queue++;
c0405d96:	a0 c0 38 41 c0       	mov    0xc04138c0,%al
c0405d9b:	40                   	inc    %eax
c0405d9c:	a2 c0 38 41 c0       	mov    %al,0xc04138c0
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0405da1:	eb 08                	jmp    c0405dab <sched_pick_queue+0x1d3>
	{
		picked = sched_next_queue;
		sched_next_queue++;
	}
	else
		picked = hint;
c0405da3:	8a 44 24 0c          	mov    0xc(%esp),%al
c0405da7:	88 44 24 17          	mov    %al,0x17(%esp)

#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: selected queue: %i\n",
c0405dab:	0f b6 54 24 17       	movzbl 0x17(%esp),%edx
			  CPU_ID, picked);
c0405db0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	}
	else
		picked = hint;

#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: selected queue: %i\n",
c0405db5:	3c 01                	cmp    $0x1,%al
c0405db7:	76 0c                	jbe    c0405dc5 <sched_pick_queue+0x1ed>
			  CPU_ID, picked);
c0405db9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405dbe:	8b 00                	mov    (%eax),%eax
	}
	else
		picked = hint;

#ifdef SCHED_DEBUG
	dprintf("[sched:%i] load balancing: selected queue: %i\n",
c0405dc0:	c1 e8 18             	shr    $0x18,%eax
c0405dc3:	eb 08                	jmp    c0405dcd <sched_pick_queue+0x1f5>
c0405dc5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405dca:	0f b6 c0             	movzbl %al,%eax
c0405dcd:	83 ec 04             	sub    $0x4,%esp
c0405dd0:	52                   	push   %edx
c0405dd1:	50                   	push   %eax
c0405dd2:	68 b0 ea 40 c0       	push   $0xc040eab0
c0405dd7:	e8 7a 76 00 00       	call   c040d456 <debug_printf>
c0405ddc:	83 c4 10             	add    $0x10,%esp
			  CPU_ID, picked);
#endif 
	
	unlock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
c0405ddf:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405de4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405de8:	c1 e2 06             	shl    $0x6,%edx
c0405deb:	01 d0                	add    %edx,%eax
c0405ded:	83 c0 08             	add    $0x8,%eax
c0405df0:	83 ec 08             	sub    $0x8,%esp
c0405df3:	6a 00                	push   $0x0
c0405df5:	50                   	push   %eax
c0405df6:	e8 ad a8 ff ff       	call   c04006a8 <unlock_gate>
c0405dfb:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[hint].lock), LOCK_READ);			
c0405dfe:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c0405e03:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0405e08:	c1 e2 06             	shl    $0x6,%edx
c0405e0b:	01 d0                	add    %edx,%eax
c0405e0d:	83 c0 08             	add    $0x8,%eax
c0405e10:	83 ec 08             	sub    $0x8,%esp
c0405e13:	6a 00                	push   $0x0
c0405e15:	50                   	push   %eax
c0405e16:	e8 8d a8 ff ff       	call   c04006a8 <unlock_gate>
c0405e1b:	83 c4 10             	add    $0x10,%esp

	unlock_gate(&(sched_lock), LOCK_WRITE);
c0405e1e:	83 ec 08             	sub    $0x8,%esp
c0405e21:	6a 01                	push   $0x1
c0405e23:	68 7c 18 41 c0       	push   $0xc041187c
c0405e28:	e8 7b a8 ff ff       	call   c04006a8 <unlock_gate>
c0405e2d:	83 c4 10             	add    $0x10,%esp
	
	return picked;
c0405e30:	8a 44 24 17          	mov    0x17(%esp),%al
}
c0405e34:	83 c4 20             	add    $0x20,%esp
c0405e37:	5b                   	pop    %ebx
c0405e38:	5e                   	pop    %esi
c0405e39:	5f                   	pop    %edi
c0405e3a:	c3                   	ret    

c0405e3b <sched_pre_initalise>:

/* sched_pre_initalise
   Perform initialisation prior to any sched_*() calls */
void sched_pre_initalise(void)
{
c0405e3b:	83 ec 0c             	sub    $0xc,%esp
	/* initialise lock */
	vmm_memset(&sched_lock, 0, sizeof(rw_gate));	
c0405e3e:	83 ec 04             	sub    $0x4,%esp
c0405e41:	6a 10                	push   $0x10
c0405e43:	6a 00                	push   $0x0
c0405e45:	68 7c 18 41 c0       	push   $0xc041187c
c0405e4a:	e8 97 0e 00 00       	call   c0406ce6 <vmm_memset>
c0405e4f:	83 c4 10             	add    $0x10,%esp
}
c0405e52:	83 c4 0c             	add    $0xc,%esp
c0405e55:	c3                   	ret    

c0405e56 <sched_initialise>:

/* sched_initialise
	Prepare the default scheduler for action */
void sched_initialise(void)
{
c0405e56:	83 ec 0c             	sub    $0xc,%esp
	dprintf("[sched:%i] starting operating system...\n", CPU_ID);
c0405e59:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0405e5e:	3c 01                	cmp    $0x1,%al
c0405e60:	76 0c                	jbe    c0405e6e <sched_initialise+0x18>
c0405e62:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405e67:	8b 00                	mov    (%eax),%eax
c0405e69:	c1 e8 18             	shr    $0x18,%eax
c0405e6c:	eb 08                	jmp    c0405e76 <sched_initialise+0x20>
c0405e6e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405e73:	0f b6 c0             	movzbl %al,%eax
c0405e76:	83 ec 08             	sub    $0x8,%esp
c0405e79:	50                   	push   %eax
c0405e7a:	68 e0 ea 40 c0       	push   $0xc040eae0
c0405e7f:	e8 d2 75 00 00       	call   c040d456 <debug_printf>
c0405e84:	83 c4 10             	add    $0x10,%esp

	/* start running process 1, thread 1 in user mode, which
	   should spawn system managers and continue the boot process */
	while(1) lowlevel_kickstart();
c0405e87:	e8 04 b7 ff ff       	call   c0401590 <lowlevel_kickstart>
c0405e8c:	eb f9                	jmp    c0405e87 <sched_initialise+0x31>
	...

c0405e90 <vmm_malloc>:
             be written. the address will be a kernel logical one.
      size = size of block required.
   <= 0 for success, or result code
*/
kresult vmm_malloc(void **addr, unsigned int size)
{
c0405e90:	83 ec 2c             	sub    $0x2c,%esp
   unsigned int safe_size, *addr_word = (unsigned int *)addr;
c0405e93:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405e97:	89 44 24 0c          	mov    %eax,0xc(%esp)
   kheap_block *block, *extra;
	
	lock_gate(&(vmm_lock), LOCK_WRITE);
c0405e9b:	83 ec 08             	sub    $0x8,%esp
c0405e9e:	6a 01                	push   $0x1
c0405ea0:	68 98 18 41 c0       	push   $0xc0411898
c0405ea5:	e8 e1 a5 ff ff       	call   c040048b <lock_gate>
c0405eaa:	83 c4 10             	add    $0x10,%esp
	
   /* adjust size to include our block header plus enough memory to tack
      a header onto any left over memory */
   size += sizeof(kheap_block);
c0405ead:	83 44 24 34 10       	addl   $0x10,0x34(%esp)
   safe_size = size + sizeof(kheap_block);
c0405eb2:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405eb6:	83 c0 10             	add    $0x10,%eax
c0405eb9:	89 44 24 08          	mov    %eax,0x8(%esp)
   
   /* scan through free list to find the first block that will fit the
      requested size */
   block = kheap_free;
c0405ebd:	a1 d0 38 41 c0       	mov    0xc04138d0,%eax
c0405ec2:	89 44 24 04          	mov    %eax,0x4(%esp)
   while(block)
c0405ec6:	eb 18                	jmp    c0405ee0 <vmm_malloc+0x50>
   {
      if(block->size > safe_size)
c0405ec8:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405ecc:	8b 40 04             	mov    0x4(%eax),%eax
c0405ecf:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0405ed3:	77 15                	ja     c0405eea <vmm_malloc+0x5a>
         break;
      block = block->next;
c0405ed5:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405ed9:	8b 40 0c             	mov    0xc(%eax),%eax
c0405edc:	89 44 24 04          	mov    %eax,0x4(%esp)
   safe_size = size + sizeof(kheap_block);
   
   /* scan through free list to find the first block that will fit the
      requested size */
   block = kheap_free;
   while(block)
c0405ee0:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405ee4:	85 c0                	test   %eax,%eax
c0405ee6:	75 e0                	jne    c0405ec8 <vmm_malloc+0x38>
c0405ee8:	eb 01                	jmp    c0405eeb <vmm_malloc+0x5b>
   {
      if(block->size > safe_size)
         break;
c0405eea:	90                   	nop
      block = block->next;
   }

   /* if the block is set, then we've found something suitable in the free
      list. remove it from the free list */
   if(block)
c0405eeb:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405eef:	85 c0                	test   %eax,%eax
c0405ef1:	74 52                	je     c0405f45 <vmm_malloc+0xb5>
   {
      if(block->previous)
c0405ef3:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405ef7:	8b 40 08             	mov    0x8(%eax),%eax
c0405efa:	85 c0                	test   %eax,%eax
c0405efc:	74 11                	je     c0405f0f <vmm_malloc+0x7f>
         block->previous->next = block->next;
c0405efe:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f02:	8b 40 08             	mov    0x8(%eax),%eax
c0405f05:	8b 54 24 04          	mov    0x4(%esp),%edx
c0405f09:	8b 52 0c             	mov    0xc(%edx),%edx
c0405f0c:	89 50 0c             	mov    %edx,0xc(%eax)
      
      if(block->next)
c0405f0f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f13:	8b 40 0c             	mov    0xc(%eax),%eax
c0405f16:	85 c0                	test   %eax,%eax
c0405f18:	74 11                	je     c0405f2b <vmm_malloc+0x9b>
         block->next->previous = block->previous;
c0405f1a:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f1e:	8b 40 0c             	mov    0xc(%eax),%eax
c0405f21:	8b 54 24 04          	mov    0x4(%esp),%edx
c0405f25:	8b 52 08             	mov    0x8(%edx),%edx
c0405f28:	89 50 08             	mov    %edx,0x8(%eax)
      
      if(kheap_free == block)
c0405f2b:	8b 15 d0 38 41 c0    	mov    0xc04138d0,%edx
c0405f31:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f35:	39 c2                	cmp    %eax,%edx
c0405f37:	75 0c                	jne    c0405f45 <vmm_malloc+0xb5>
         kheap_free = block->next;
c0405f39:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f3d:	8b 40 0c             	mov    0xc(%eax),%eax
c0405f40:	a3 d0 38 41 c0       	mov    %eax,0xc04138d0
   }

   /* if block is unset then we haven't found a suitable block (or the free
      list is empty). so allocate enough pages for the request */
   if(!block)
c0405f45:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405f49:	85 c0                	test   %eax,%eax
c0405f4b:	0f 85 43 01 00 00    	jne    c0406094 <vmm_malloc+0x204>
   {
      int pg_count, type = MEM_HIGH_PG;
c0405f51:	c7 44 24 18 02 00 00 	movl   $0x2,0x18(%esp)
c0405f58:	00 
      kresult result = vmm_ensure_pgs(safe_size, type);
c0405f59:	83 ec 08             	sub    $0x8,%esp
c0405f5c:	ff 74 24 20          	pushl  0x20(%esp)
c0405f60:	ff 74 24 14          	pushl  0x14(%esp)
c0405f64:	e8 89 07 00 00       	call   c04066f2 <vmm_ensure_pgs>
c0405f69:	83 c4 10             	add    $0x10,%esp
c0405f6c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      if(result)
c0405f70:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405f75:	74 73                	je     c0405fea <vmm_malloc+0x15a>
      {
         /* try using low memory */
         type = MEM_LOW_PG;
c0405f77:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0405f7e:	00 
         result = vmm_ensure_pgs(safe_size, type);
c0405f7f:	83 ec 08             	sub    $0x8,%esp
c0405f82:	ff 74 24 20          	pushl  0x20(%esp)
c0405f86:	ff 74 24 14          	pushl  0x14(%esp)
c0405f8a:	e8 63 07 00 00       	call   c04066f2 <vmm_ensure_pgs>
c0405f8f:	83 c4 10             	add    $0x10,%esp
c0405f92:	89 44 24 1c          	mov    %eax,0x1c(%esp)
         if(result)
c0405f96:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405f9b:	74 4d                	je     c0405fea <vmm_malloc+0x15a>
			{
				dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: failed to grab physical pages for kernel heap (req size %i bytes)\n" DEBUG_COL_OFF,
						  CPU_ID, safe_size);
c0405f9d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
         /* try using low memory */
         type = MEM_LOW_PG;
         result = vmm_ensure_pgs(safe_size, type);
         if(result)
			{
				dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: failed to grab physical pages for kernel heap (req size %i bytes)\n" DEBUG_COL_OFF,
c0405fa2:	3c 01                	cmp    $0x1,%al
c0405fa4:	76 0c                	jbe    c0405fb2 <vmm_malloc+0x122>
						  CPU_ID, safe_size);
c0405fa6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0405fab:	8b 00                	mov    (%eax),%eax
         /* try using low memory */
         type = MEM_LOW_PG;
         result = vmm_ensure_pgs(safe_size, type);
         if(result)
			{
				dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: failed to grab physical pages for kernel heap (req size %i bytes)\n" DEBUG_COL_OFF,
c0405fad:	c1 e8 18             	shr    $0x18,%eax
c0405fb0:	eb 08                	jmp    c0405fba <vmm_malloc+0x12a>
c0405fb2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0405fb7:	0f b6 c0             	movzbl %al,%eax
c0405fba:	83 ec 04             	sub    $0x4,%esp
c0405fbd:	ff 74 24 0c          	pushl  0xc(%esp)
c0405fc1:	50                   	push   %eax
c0405fc2:	68 0c eb 40 c0       	push   $0xc040eb0c
c0405fc7:	e8 8a 74 00 00       	call   c040d456 <debug_printf>
c0405fcc:	83 c4 10             	add    $0x10,%esp
						  CPU_ID, safe_size);
				unlock_gate(&(vmm_lock), LOCK_WRITE);
c0405fcf:	83 ec 08             	sub    $0x8,%esp
c0405fd2:	6a 01                	push   $0x1
c0405fd4:	68 98 18 41 c0       	push   $0xc0411898
c0405fd9:	e8 ca a6 ff ff       	call   c04006a8 <unlock_gate>
c0405fde:	83 c4 10             	add    $0x10,%esp
				return result; /* give up otherwise */
c0405fe1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405fe5:	e9 52 01 00 00       	jmp    c040613c <vmm_malloc+0x2ac>
			}
      }
		
      /* by now, we've verified that we have a run of pages so grab them */
      for(pg_count = 0; pg_count < ((safe_size / MEM_PGSIZE) + 1); pg_count++)
c0405fea:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0405ff1:	00 
c0405ff2:	eb 6c                	jmp    c0406060 <vmm_malloc+0x1d0>
      {
         result = vmm_req_phys_pg((void **)&block, type); /* get pages in reverse order */
c0405ff4:	8d 44 24 04          	lea    0x4(%esp),%eax
c0405ff8:	83 ec 08             	sub    $0x8,%esp
c0405ffb:	ff 74 24 20          	pushl  0x20(%esp)
c0405fff:	50                   	push   %eax
c0406000:	e8 0e 04 00 00       	call   c0406413 <vmm_req_phys_pg>
c0406005:	83 c4 10             	add    $0x10,%esp
c0406008:	89 44 24 1c          	mov    %eax,0x1c(%esp)
         if(result)
c040600c:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0406011:	74 49                	je     c040605c <vmm_malloc+0x1cc>
			{
				dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: failed to grab physical page for kernel heap\n" DEBUG_COL_OFF, CPU_ID);
c0406013:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c0406018:	3c 01                	cmp    $0x1,%al
c040601a:	76 0c                	jbe    c0406028 <vmm_malloc+0x198>
c040601c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406021:	8b 00                	mov    (%eax),%eax
c0406023:	c1 e8 18             	shr    $0x18,%eax
c0406026:	eb 08                	jmp    c0406030 <vmm_malloc+0x1a0>
c0406028:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040602d:	0f b6 c0             	movzbl %al,%eax
c0406030:	83 ec 08             	sub    $0x8,%esp
c0406033:	50                   	push   %eax
c0406034:	68 60 eb 40 c0       	push   $0xc040eb60
c0406039:	e8 18 74 00 00       	call   c040d456 <debug_printf>
c040603e:	83 c4 10             	add    $0x10,%esp
				unlock_gate(&(vmm_lock), LOCK_WRITE);
c0406041:	83 ec 08             	sub    $0x8,%esp
c0406044:	6a 01                	push   $0x1
c0406046:	68 98 18 41 c0       	push   $0xc0411898
c040604b:	e8 58 a6 ff ff       	call   c04006a8 <unlock_gate>
c0406050:	83 c4 10             	add    $0x10,%esp
				return result; /* XXX shouldn't happen - memory leak */
c0406053:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406057:	e9 e0 00 00 00       	jmp    c040613c <vmm_malloc+0x2ac>
				return result; /* give up otherwise */
			}
      }
		
      /* by now, we've verified that we have a run of pages so grab them */
      for(pg_count = 0; pg_count < ((safe_size / MEM_PGSIZE) + 1); pg_count++)
c040605c:	ff 44 24 14          	incl   0x14(%esp)
c0406060:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406064:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406068:	c1 ea 0c             	shr    $0xc,%edx
c040606b:	42                   	inc    %edx
c040606c:	39 d0                	cmp    %edx,%eax
c040606e:	72 84                	jb     c0405ff4 <vmm_malloc+0x164>
#ifdef VMM_DEBUG
		dprintf(DEBUG_COL_VMM "[vmm:%i] asked for a block of pages for %i bytes: %p\n" DEBUG_COL_OFF, CPU_ID, safe_size, block);
#endif
		
      /* don't forget to convert from physical to kernel's logical */
      block = KERNEL_PHYS2LOG(block);
c0406070:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406074:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0406079:	89 44 24 04          	mov    %eax,0x4(%esp)
      block->size = (unsigned int)MEM_PGALIGN(safe_size) + MEM_PGSIZE;
c040607d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406081:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406085:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c040608b:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0406091:	89 50 04             	mov    %edx,0x4(%eax)
      dprintf(DEBUG_COL_VMM "[vmm:%i] grabbed %i bytes from mem %p for heap\n" DEBUG_COL_OFF, CPU_ID, block->size, block); 
#endif
   }

   /* trim off excess memory and add this to the free list */
   extra = (kheap_block *)((unsigned int)block + size);
c0406094:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406098:	03 44 24 34          	add    0x34(%esp),%eax
c040609c:	89 44 24 10          	mov    %eax,0x10(%esp)
   extra->magic = KHEAP_FREE;
c04060a0:	8b 44 24 10          	mov    0x10(%esp),%eax
c04060a4:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)
   extra->size = block->size - size;
c04060aa:	8b 44 24 04          	mov    0x4(%esp),%eax
c04060ae:	8b 40 04             	mov    0x4(%eax),%eax
c04060b1:	89 c2                	mov    %eax,%edx
c04060b3:	2b 54 24 34          	sub    0x34(%esp),%edx
c04060b7:	8b 44 24 10          	mov    0x10(%esp),%eax
c04060bb:	89 50 04             	mov    %edx,0x4(%eax)
   vmm_heap_add_to_free(extra);
c04060be:	83 ec 0c             	sub    $0xc,%esp
c04060c1:	ff 74 24 1c          	pushl  0x1c(%esp)
c04060c5:	e8 76 00 00 00       	call   c0406140 <vmm_heap_add_to_free>
c04060ca:	83 c4 10             	add    $0x10,%esp

   /* write pointer to the start of data and the block's header details */
   *addr_word = (unsigned int)block + sizeof(kheap_block);
c04060cd:	8b 44 24 04          	mov    0x4(%esp),%eax
c04060d1:	8d 50 10             	lea    0x10(%eax),%edx
c04060d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04060d8:	89 10                	mov    %edx,(%eax)
   block->magic = KHEAP_INUSE;
c04060da:	8b 44 24 04          	mov    0x4(%esp),%eax
c04060de:	c7 00 68 42 6c 6b    	movl   $0x6b6c4268,(%eax)
   block->size = size; /* the true size of the requested block inc header */
c04060e4:	8b 44 24 04          	mov    0x4(%esp),%eax
c04060e8:	8b 54 24 34          	mov    0x34(%esp),%edx
c04060ec:	89 50 04             	mov    %edx,0x4(%eax)

   /* add to head of allocated link list */
   block->next = kheap_allocated;
c04060ef:	8b 44 24 04          	mov    0x4(%esp),%eax
c04060f3:	8b 15 d4 38 41 c0    	mov    0xc04138d4,%edx
c04060f9:	89 50 0c             	mov    %edx,0xc(%eax)
   if(kheap_allocated) kheap_allocated->previous = block;
c04060fc:	a1 d4 38 41 c0       	mov    0xc04138d4,%eax
c0406101:	85 c0                	test   %eax,%eax
c0406103:	74 0c                	je     c0406111 <vmm_malloc+0x281>
c0406105:	a1 d4 38 41 c0       	mov    0xc04138d4,%eax
c040610a:	8b 54 24 04          	mov    0x4(%esp),%edx
c040610e:	89 50 08             	mov    %edx,0x8(%eax)
   block->previous = NULL;
c0406111:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406115:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   kheap_allocated = block;
c040611c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406120:	a3 d4 38 41 c0       	mov    %eax,0xc04138d4

	unlock_gate(&(vmm_lock), LOCK_WRITE);
c0406125:	83 ec 08             	sub    $0x8,%esp
c0406128:	6a 01                	push   $0x1
c040612a:	68 98 18 41 c0       	push   $0xc0411898
c040612f:	e8 74 a5 ff ff       	call   c04006a8 <unlock_gate>
c0406134:	83 c4 10             	add    $0x10,%esp
   return success;
c0406137:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040613c:	83 c4 2c             	add    $0x2c,%esp
c040613f:	c3                   	ret    

c0406140 <vmm_heap_add_to_free>:
   base address, lowest first (at the head) and ascending. Then, scan the free
   list and merge adjoining blocks together.
   => pointer to heap block
*/
void vmm_heap_add_to_free(kheap_block *block)
{
c0406140:	83 ec 1c             	sub    $0x1c,%esp
	lock_gate(&(vmm_lock), LOCK_WRITE);
c0406143:	83 ec 08             	sub    $0x8,%esp
c0406146:	6a 01                	push   $0x1
c0406148:	68 98 18 41 c0       	push   $0xc0411898
c040614d:	e8 39 a3 ff ff       	call   c040048b <lock_gate>
c0406152:	83 c4 10             	add    $0x10,%esp
	
   kheap_block *block_loop = kheap_free;
c0406155:	a1 d0 38 41 c0       	mov    0xc04138d0,%eax
c040615a:	89 44 24 08          	mov    %eax,0x8(%esp)

   while(block_loop)
c040615e:	e9 96 00 00 00       	jmp    c04061f9 <vmm_heap_add_to_free+0xb9>
   {
      /* insert block in front of block_loop */
      if(block < block_loop)
c0406163:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406167:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040616b:	73 53                	jae    c04061c0 <vmm_heap_add_to_free+0x80>
      {
         block->next = block_loop;
c040616d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406171:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406175:	89 50 0c             	mov    %edx,0xc(%eax)
         block->previous = block_loop->previous;
c0406178:	8b 44 24 08          	mov    0x8(%esp),%eax
c040617c:	8b 50 08             	mov    0x8(%eax),%edx
c040617f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406183:	89 50 08             	mov    %edx,0x8(%eax)
         if(!block->previous) kheap_free = block; /* connect to head if first */
c0406186:	8b 44 24 20          	mov    0x20(%esp),%eax
c040618a:	8b 40 08             	mov    0x8(%eax),%eax
c040618d:	85 c0                	test   %eax,%eax
c040618f:	75 09                	jne    c040619a <vmm_heap_add_to_free+0x5a>
c0406191:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406195:	a3 d0 38 41 c0       	mov    %eax,0xc04138d0

         if(block_loop->previous)
c040619a:	8b 44 24 08          	mov    0x8(%esp),%eax
c040619e:	8b 40 08             	mov    0x8(%eax),%eax
c04061a1:	85 c0                	test   %eax,%eax
c04061a3:	74 0e                	je     c04061b3 <vmm_heap_add_to_free+0x73>
            block_loop->previous->next = block;
c04061a5:	8b 44 24 08          	mov    0x8(%esp),%eax
c04061a9:	8b 40 08             	mov    0x8(%eax),%eax
c04061ac:	8b 54 24 20          	mov    0x20(%esp),%edx
c04061b0:	89 50 0c             	mov    %edx,0xc(%eax)

         block_loop->previous = block;
c04061b3:	8b 44 24 08          	mov    0x8(%esp),%eax
c04061b7:	8b 54 24 20          	mov    0x20(%esp),%edx
c04061bb:	89 50 08             	mov    %edx,0x8(%eax)
         break;
c04061be:	eb 44                	jmp    c0406204 <vmm_heap_add_to_free+0xc4>
      }

      /* add to end of the free list */
      if(!block_loop->next)
c04061c0:	8b 44 24 08          	mov    0x8(%esp),%eax
c04061c4:	8b 40 0c             	mov    0xc(%eax),%eax
c04061c7:	85 c0                	test   %eax,%eax
c04061c9:	75 23                	jne    c04061ee <vmm_heap_add_to_free+0xae>
      {
         block_loop->next = block;
c04061cb:	8b 44 24 08          	mov    0x8(%esp),%eax
c04061cf:	8b 54 24 20          	mov    0x20(%esp),%edx
c04061d3:	89 50 0c             	mov    %edx,0xc(%eax)
         block->next = NULL;
c04061d6:	8b 44 24 20          	mov    0x20(%esp),%eax
c04061da:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
         block->previous = block_loop;
c04061e1:	8b 44 24 20          	mov    0x20(%esp),%eax
c04061e5:	8b 54 24 08          	mov    0x8(%esp),%edx
c04061e9:	89 50 08             	mov    %edx,0x8(%eax)
         break;
c04061ec:	eb 16                	jmp    c0406204 <vmm_heap_add_to_free+0xc4>
      }

      block_loop = block_loop->next;
c04061ee:	8b 44 24 08          	mov    0x8(%esp),%eax
c04061f2:	8b 40 0c             	mov    0xc(%eax),%eax
c04061f5:	89 44 24 08          	mov    %eax,0x8(%esp)
{
	lock_gate(&(vmm_lock), LOCK_WRITE);
	
   kheap_block *block_loop = kheap_free;

   while(block_loop)
c04061f9:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c04061fe:	0f 85 5f ff ff ff    	jne    c0406163 <vmm_heap_add_to_free+0x23>

      block_loop = block_loop->next;
   }

   /* if list is empty, then start it with block */
   if(!kheap_free)
c0406204:	a1 d0 38 41 c0       	mov    0xc04138d0,%eax
c0406209:	85 c0                	test   %eax,%eax
c040620b:	75 1f                	jne    c040622c <vmm_heap_add_to_free+0xec>
   {
      block->next = NULL;
c040620d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406211:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      block->previous = NULL;
c0406218:	8b 44 24 20          	mov    0x20(%esp),%eax
c040621c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      kheap_free = block;
c0406223:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406227:	a3 d0 38 41 c0       	mov    %eax,0xc04138d0
   }

   block->magic = KHEAP_FREE;
c040622c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406230:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)

   /* merge adjoining blocks */
   block_loop = kheap_free;
c0406236:	a1 d0 38 41 c0       	mov    0xc04138d0,%eax
c040623b:	89 44 24 08          	mov    %eax,0x8(%esp)
   while(block_loop)
c040623f:	eb 71                	jmp    c04062b2 <vmm_heap_add_to_free+0x172>
   {
      kheap_block *target = block_loop->next;
c0406241:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406245:	8b 40 0c             	mov    0xc(%eax),%eax
c0406248:	89 44 24 0c          	mov    %eax,0xc(%esp)
      if(!target) break; /* sanity check next ptr */
c040624c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0406251:	74 68                	je     c04062bb <vmm_heap_add_to_free+0x17b>

      if((unsigned int)target == ((unsigned int)block_loop + block_loop->size))
c0406253:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0406257:	8b 44 24 08          	mov    0x8(%esp),%eax
c040625b:	8b 48 04             	mov    0x4(%eax),%ecx
c040625e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406262:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0406265:	39 c2                	cmp    %eax,%edx
c0406267:	75 3e                	jne    c04062a7 <vmm_heap_add_to_free+0x167>
      {
         block_loop->next = target->next;
c0406269:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040626d:	8b 50 0c             	mov    0xc(%eax),%edx
c0406270:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406274:	89 50 0c             	mov    %edx,0xc(%eax)
         if(target->next)
c0406277:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040627b:	8b 40 0c             	mov    0xc(%eax),%eax
c040627e:	85 c0                	test   %eax,%eax
c0406280:	74 0e                	je     c0406290 <vmm_heap_add_to_free+0x150>
            target->next->previous = block_loop;
c0406282:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406286:	8b 40 0c             	mov    0xc(%eax),%eax
c0406289:	8b 54 24 08          	mov    0x8(%esp),%edx
c040628d:	89 50 08             	mov    %edx,0x8(%eax)
         block_loop->size += target->size;
c0406290:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406294:	8b 50 04             	mov    0x4(%eax),%edx
c0406297:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040629b:	8b 40 04             	mov    0x4(%eax),%eax
c040629e:	01 c2                	add    %eax,%edx
c04062a0:	8b 44 24 08          	mov    0x8(%esp),%eax
c04062a4:	89 50 04             	mov    %edx,0x4(%eax)
      }
      block_loop = block_loop->next;
c04062a7:	8b 44 24 08          	mov    0x8(%esp),%eax
c04062ab:	8b 40 0c             	mov    0xc(%eax),%eax
c04062ae:	89 44 24 08          	mov    %eax,0x8(%esp)

   block->magic = KHEAP_FREE;

   /* merge adjoining blocks */
   block_loop = kheap_free;
   while(block_loop)
c04062b2:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c04062b7:	75 88                	jne    c0406241 <vmm_heap_add_to_free+0x101>
c04062b9:	eb 01                	jmp    c04062bc <vmm_heap_add_to_free+0x17c>
   {
      kheap_block *target = block_loop->next;
      if(!target) break; /* sanity check next ptr */
c04062bb:	90                   	nop
         block_loop->size += target->size;
      }
      block_loop = block_loop->next;
   }
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c04062bc:	83 ec 08             	sub    $0x8,%esp
c04062bf:	6a 01                	push   $0x1
c04062c1:	68 98 18 41 c0       	push   $0xc0411898
c04062c6:	e8 dd a3 ff ff       	call   c04006a8 <unlock_gate>
c04062cb:	83 c4 10             	add    $0x10,%esp
}
c04062ce:	83 c4 1c             	add    $0x1c,%esp
c04062d1:	c3                   	ret    

c04062d2 <vmm_free>:
   free lists. the address of the block must be a kernel logical one.
   => addr = base of block to free up
   <= 0 for success, or result code
*/
kresult vmm_free(void *addr)
{
c04062d2:	83 ec 1c             	sub    $0x1c,%esp
   kheap_block *block;

   /* get out now if the addr is insane */
   if((unsigned int)addr < KERNEL_VIRTUAL_BASE) /* XXX assumes high knl */
c04062d5:	8b 44 24 20          	mov    0x20(%esp),%eax
c04062d9:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c04062de:	77 41                	ja     c0406321 <vmm_free+0x4f>
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_free: given nonsense address %x\n" DEBUG_COL_OFF, CPU_ID, addr);
c04062e0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04062e5:	3c 01                	cmp    $0x1,%al
c04062e7:	76 0c                	jbe    c04062f5 <vmm_free+0x23>
c04062e9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04062ee:	8b 00                	mov    (%eax),%eax
c04062f0:	c1 e8 18             	shr    $0x18,%eax
c04062f3:	eb 08                	jmp    c04062fd <vmm_free+0x2b>
c04062f5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04062fa:	0f b6 c0             	movzbl %al,%eax
c04062fd:	83 ec 04             	sub    $0x4,%esp
c0406300:	ff 74 24 24          	pushl  0x24(%esp)
c0406304:	50                   	push   %eax
c0406305:	68 a0 eb 40 c0       	push   $0xc040eba0
c040630a:	e8 47 71 00 00       	call   c040d456 <debug_printf>
c040630f:	83 c4 10             	add    $0x10,%esp
		debug_stacktrace();
c0406312:	e8 5c 6a 00 00       	call   c040cd73 <debug_stacktrace>
      return e_bad_address;
c0406317:	b8 11 00 00 00       	mov    $0x11,%eax
c040631c:	e9 ee 00 00 00       	jmp    c040640f <vmm_free+0x13d>
   }

   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));
c0406321:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406325:	83 e8 10             	sub    $0x10,%eax
c0406328:	89 44 24 0c          	mov    %eax,0xc(%esp)

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
c040632c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406330:	8b 00                	mov    (%eax),%eax
c0406332:	3d 68 42 6c 6b       	cmp    $0x6b6c4268,%eax
c0406337:	74 45                	je     c040637e <vmm_free+0xac>
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n" DEBUG_COL_OFF,
c0406339:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040633d:	8b 10                	mov    (%eax),%edx
              CPU_ID, block, block->magic);
c040633f:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n" DEBUG_COL_OFF,
c0406344:	3c 01                	cmp    $0x1,%al
c0406346:	76 0c                	jbe    c0406354 <vmm_free+0x82>
              CPU_ID, block, block->magic);
c0406348:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040634d:	8b 00                	mov    (%eax),%eax
   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n" DEBUG_COL_OFF,
c040634f:	c1 e8 18             	shr    $0x18,%eax
c0406352:	eb 08                	jmp    c040635c <vmm_free+0x8a>
c0406354:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406359:	0f b6 c0             	movzbl %al,%eax
c040635c:	52                   	push   %edx
c040635d:	ff 74 24 10          	pushl  0x10(%esp)
c0406361:	50                   	push   %eax
c0406362:	68 d8 eb 40 c0       	push   $0xc040ebd8
c0406367:	e8 ea 70 00 00       	call   c040d456 <debug_printf>
c040636c:	83 c4 10             	add    $0x10,%esp
              CPU_ID, block, block->magic);
		debug_stacktrace();
c040636f:	e8 ff 69 00 00       	call   c040cd73 <debug_stacktrace>
      return e_bad_magic;
c0406374:	b8 12 00 00 00       	mov    $0x12,%eax
c0406379:	e9 91 00 00 00       	jmp    c040640f <vmm_free+0x13d>
   }

	lock_gate(&(vmm_lock), LOCK_WRITE);
c040637e:	83 ec 08             	sub    $0x8,%esp
c0406381:	6a 01                	push   $0x1
c0406383:	68 98 18 41 c0       	push   $0xc0411898
c0406388:	e8 fe a0 ff ff       	call   c040048b <lock_gate>
c040638d:	83 c4 10             	add    $0x10,%esp
	
   /* update magic */
   block->magic = KHEAP_FREE;
c0406390:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406394:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)

   /* remove from allocated linked list */
   if(block->previous)
c040639a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040639e:	8b 40 08             	mov    0x8(%eax),%eax
c04063a1:	85 c0                	test   %eax,%eax
c04063a3:	74 11                	je     c04063b6 <vmm_free+0xe4>
      block->previous->next = block->next;
c04063a5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04063a9:	8b 40 08             	mov    0x8(%eax),%eax
c04063ac:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04063b0:	8b 52 0c             	mov    0xc(%edx),%edx
c04063b3:	89 50 0c             	mov    %edx,0xc(%eax)

   if(block->next)
c04063b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04063ba:	8b 40 0c             	mov    0xc(%eax),%eax
c04063bd:	85 c0                	test   %eax,%eax
c04063bf:	74 11                	je     c04063d2 <vmm_free+0x100>
      block->next->previous = block->previous;
c04063c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04063c5:	8b 40 0c             	mov    0xc(%eax),%eax
c04063c8:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04063cc:	8b 52 08             	mov    0x8(%edx),%edx
c04063cf:	89 50 08             	mov    %edx,0x8(%eax)

   if(kheap_allocated == block)
c04063d2:	a1 d4 38 41 c0       	mov    0xc04138d4,%eax
c04063d7:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c04063db:	75 0c                	jne    c04063e9 <vmm_free+0x117>
      kheap_allocated = block->next;
c04063dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04063e1:	8b 40 0c             	mov    0xc(%eax),%eax
c04063e4:	a3 d4 38 41 c0       	mov    %eax,0xc04138d4

   /* add to head of free list */
   vmm_heap_add_to_free(block);
c04063e9:	83 ec 0c             	sub    $0xc,%esp
c04063ec:	ff 74 24 18          	pushl  0x18(%esp)
c04063f0:	e8 4b fd ff ff       	call   c0406140 <vmm_heap_add_to_free>
c04063f5:	83 c4 10             	add    $0x10,%esp

	unlock_gate(&(vmm_lock), LOCK_WRITE);
c04063f8:	83 ec 08             	sub    $0x8,%esp
c04063fb:	6a 01                	push   $0x1
c04063fd:	68 98 18 41 c0       	push   $0xc0411898
c0406402:	e8 a1 a2 ff ff       	call   c04006a8 <unlock_gate>
c0406407:	83 c4 10             	add    $0x10,%esp
	
   return success;
c040640a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040640f:	83 c4 1c             	add    $0x1c,%esp
c0406412:	c3                   	ret    

c0406413 <vmm_req_phys_pg>:
      pref = 0 to request a page from below the DMA marker, otherwise 1 for no
             preference.
   <= 0 for success or error code
*/
kresult vmm_req_phys_pg(void **addr, int pref)
{	
c0406413:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(vmm_lock), LOCK_WRITE);
c0406416:	83 ec 08             	sub    $0x8,%esp
c0406419:	6a 01                	push   $0x1
c040641b:	68 98 18 41 c0       	push   $0xc0411898
c0406420:	e8 66 a0 ff ff       	call   c040048b <lock_gate>
c0406425:	83 c4 10             	add    $0x10,%esp
	
   /* is a DMA-able physical page requested? */
   if(pref == MEM_LOW_PG)
c0406428:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040642d:	75 2b                	jne    c040645a <vmm_req_phys_pg+0x47>
   {
      /* if ptr is above the base, then the stack's empty */
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
c040642f:	8b 15 94 18 41 c0    	mov    0xc0411894,%edx
c0406435:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c040643a:	39 c2                	cmp    %eax,%edx
c040643c:	76 5f                	jbe    c040649d <vmm_req_phys_pg+0x8a>
		{
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c040643e:	83 ec 08             	sub    $0x8,%esp
c0406441:	6a 01                	push   $0x1
c0406443:	68 98 18 41 c0       	push   $0xc0411898
c0406448:	e8 5b a2 ff ff       	call   c04006a8 <unlock_gate>
c040644d:	83 c4 10             	add    $0x10,%esp
         return e_no_phys_pgs;
c0406450:	b8 04 00 00 00       	mov    $0x4,%eax
c0406455:	e9 a3 00 00 00       	jmp    c04064fd <vmm_req_phys_pg+0xea>
      /* otherwise, hand out a page frame */
      goto get_low_page;
   }

   /* try to get a 'normal' phys page frame first, then try low */
   if(phys_pg_stack_high_ptr > phys_pg_stack_high_base)
c040645a:	8b 15 8c 18 41 c0    	mov    0xc041188c,%edx
c0406460:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c0406465:	39 c2                	cmp    %eax,%edx
c0406467:	76 16                	jbe    c040647f <vmm_req_phys_pg+0x6c>
   {
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
c0406469:	8b 15 94 18 41 c0    	mov    0xc0411894,%edx
c040646f:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c0406474:	39 c2                	cmp    %eax,%edx
c0406476:	76 28                	jbe    c04064a0 <vmm_req_phys_pg+0x8d>
         return e_no_phys_pgs;
c0406478:	b8 04 00 00 00       	mov    $0x4,%eax
c040647d:	eb 7e                	jmp    c04064fd <vmm_req_phys_pg+0xea>
      else
         goto get_low_page;
   }
   /* fall through to getting a high page */

   *addr = (unsigned int *)*phys_pg_stack_high_ptr;
c040647f:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406484:	8b 00                	mov    (%eax),%eax
c0406486:	89 c2                	mov    %eax,%edx
c0406488:	8b 44 24 10          	mov    0x10(%esp),%eax
c040648c:	89 10                	mov    %edx,(%eax)
   phys_pg_stack_high_ptr++;
c040648e:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406493:	83 c0 04             	add    $0x4,%eax
c0406496:	a3 8c 18 41 c0       	mov    %eax,0xc041188c
   goto get_page_success;
c040649b:	eb 20                	jmp    c04064bd <vmm_req_phys_pg+0xaa>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
         return e_no_phys_pgs;
		}

      /* otherwise, hand out a page frame */
      goto get_low_page;
c040649d:	90                   	nop
c040649e:	eb 01                	jmp    c04064a1 <vmm_req_phys_pg+0x8e>
   if(phys_pg_stack_high_ptr > phys_pg_stack_high_base)
   {
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
         return e_no_phys_pgs;
      else
         goto get_low_page;
c04064a0:	90                   	nop
   phys_pg_stack_high_ptr++;
   goto get_page_success;

   /* are these gotos ugly? */
get_low_page:
   *addr = (unsigned int *)*phys_pg_stack_low_ptr;
c04064a1:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c04064a6:	8b 00                	mov    (%eax),%eax
c04064a8:	89 c2                	mov    %eax,%edx
c04064aa:	8b 44 24 10          	mov    0x10(%esp),%eax
c04064ae:	89 10                	mov    %edx,(%eax)
   phys_pg_stack_low_ptr++;
c04064b0:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c04064b5:	83 c0 04             	add    $0x4,%eax
c04064b8:	a3 94 18 41 c0       	mov    %eax,0xc0411894
   /* fall through to success */

get_page_success:
   phys_pg_reqed++; /* update accounting totals */
c04064bd:	a1 cc 38 41 c0       	mov    0xc04138cc,%eax
c04064c2:	40                   	inc    %eax
c04064c3:	a3 cc 38 41 c0       	mov    %eax,0xc04138cc
	/* we don't clean the page at this stage - it has
	   to be mapped in first */
	
	/* would be nice to clean this page */
	vmm_memset(KERNEL_PHYS2LOG(*addr), 0, MEM_PGSIZE);
c04064c8:	8b 44 24 10          	mov    0x10(%esp),%eax
c04064cc:	8b 00                	mov    (%eax),%eax
c04064ce:	2d 00 00 00 40       	sub    $0x40000000,%eax
c04064d3:	83 ec 04             	sub    $0x4,%esp
c04064d6:	68 00 10 00 00       	push   $0x1000
c04064db:	6a 00                	push   $0x0
c04064dd:	50                   	push   %eax
c04064de:	e8 03 08 00 00       	call   c0406ce6 <vmm_memset>
c04064e3:	83 c4 10             	add    $0x10,%esp
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c04064e6:	83 ec 08             	sub    $0x8,%esp
c04064e9:	6a 01                	push   $0x1
c04064eb:	68 98 18 41 c0       	push   $0xc0411898
c04064f0:	e8 b3 a1 ff ff       	call   c04006a8 <unlock_gate>
c04064f5:	83 c4 10             	add    $0x10,%esp
   return success;
c04064f8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04064fd:	83 c4 0c             	add    $0xc,%esp
c0406500:	c3                   	ret    

c0406501 <vmm_return_phys_pg>:
   reused.
   => addr = physical page frame base address
   <= 0 for success or error code
*/
kresult vmm_return_phys_pg(void *addr)
{	
c0406501:	83 ec 0c             	sub    $0xc,%esp
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
c0406504:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406508:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c040650d:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0406511:	74 41                	je     c0406554 <vmm_return_phys_pg+0x53>
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
              "%x not page aligned!\n" DEBUG_COL_OFF, CPU_ID, addr);
c0406513:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
kresult vmm_return_phys_pg(void *addr)
{	
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
c0406518:	3c 01                	cmp    $0x1,%al
c040651a:	76 0c                	jbe    c0406528 <vmm_return_phys_pg+0x27>
              "%x not page aligned!\n" DEBUG_COL_OFF, CPU_ID, addr);
c040651c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406521:	8b 00                	mov    (%eax),%eax
kresult vmm_return_phys_pg(void *addr)
{	
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
   {
      dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
c0406523:	c1 e8 18             	shr    $0x18,%eax
c0406526:	eb 08                	jmp    c0406530 <vmm_return_phys_pg+0x2f>
c0406528:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040652d:	0f b6 c0             	movzbl %al,%eax
c0406530:	83 ec 04             	sub    $0x4,%esp
c0406533:	ff 74 24 14          	pushl  0x14(%esp)
c0406537:	50                   	push   %eax
c0406538:	68 10 ec 40 c0       	push   $0xc040ec10
c040653d:	e8 14 6f 00 00       	call   c040d456 <debug_printf>
c0406542:	83 c4 10             	add    $0x10,%esp
              "%x not page aligned!\n" DEBUG_COL_OFF, CPU_ID, addr);
		debug_stacktrace();
c0406545:	e8 29 68 00 00       	call   c040cd73 <debug_stacktrace>
      return e_not_pg_aligned;
c040654a:	b8 08 00 00 00       	mov    $0x8,%eax
c040654f:	e9 2a 01 00 00       	jmp    c040667e <vmm_return_phys_pg+0x17d>
   }

	lock_gate(&(vmm_lock), LOCK_WRITE);
c0406554:	83 ec 08             	sub    $0x8,%esp
c0406557:	6a 01                	push   $0x1
c0406559:	68 98 18 41 c0       	push   $0xc0411898
c040655e:	e8 28 9f ff ff       	call   c040048b <lock_gate>
c0406563:	83 c4 10             	add    $0x10,%esp
	
   /* decide which stack we're going to return this page frame onto */
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
c0406566:	8b 44 24 10          	mov    0x10(%esp),%eax
c040656a:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c040656f:	77 78                	ja     c04065e9 <vmm_return_phys_pg+0xe8>
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
c0406571:	8b 15 94 18 41 c0    	mov    0xc0411894,%edx
c0406577:	a1 90 18 41 c0       	mov    0xc0411890,%eax
c040657c:	39 c2                	cmp    %eax,%edx
c040657e:	77 4f                	ja     c04065cf <vmm_return_phys_pg+0xce>
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
c0406580:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
c0406585:	3c 01                	cmp    $0x1,%al
c0406587:	76 0c                	jbe    c0406595 <vmm_return_phys_pg+0x94>
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
c0406589:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040658e:	8b 00                	mov    (%eax),%eax
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
c0406590:	c1 e8 18             	shr    $0x18,%eax
c0406593:	eb 08                	jmp    c040659d <vmm_return_phys_pg+0x9c>
c0406595:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040659a:	0f b6 c0             	movzbl %al,%eax
c040659d:	83 ec 08             	sub    $0x8,%esp
c04065a0:	50                   	push   %eax
c04065a1:	68 60 ec 40 c0       	push   $0xc040ec60
c04065a6:	e8 ab 6e 00 00       	call   c040d456 <debug_printf>
c04065ab:	83 c4 10             	add    $0x10,%esp
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
			debug_stacktrace();
c04065ae:	e8 c0 67 00 00       	call   c040cd73 <debug_stacktrace>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c04065b3:	83 ec 08             	sub    $0x8,%esp
c04065b6:	6a 01                	push   $0x1
c04065b8:	68 98 18 41 c0       	push   $0xc0411898
c04065bd:	e8 e6 a0 ff ff       	call   c04006a8 <unlock_gate>
c04065c2:	83 c4 10             	add    $0x10,%esp
         return e_phys_stk_overflow;
c04065c5:	b8 0d 00 00 00       	mov    $0xd,%eax
c04065ca:	e9 af 00 00 00       	jmp    c040667e <vmm_return_phys_pg+0x17d>
      }

      /* push stack frame onto lower stack */
      phys_pg_stack_low_ptr--;
c04065cf:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c04065d4:	83 e8 04             	sub    $0x4,%eax
c04065d7:	a3 94 18 41 c0       	mov    %eax,0xc0411894
      *phys_pg_stack_low_ptr = (unsigned int)addr;
c04065dc:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c04065e1:	8b 54 24 10          	mov    0x10(%esp),%edx
c04065e5:	89 10                	mov    %edx,(%eax)
c04065e7:	eb 73                	jmp    c040665c <vmm_return_phys_pg+0x15b>
   }
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
c04065e9:	8b 15 8c 18 41 c0    	mov    0xc041188c,%edx
c04065ef:	a1 a8 18 41 c0       	mov    0xc04118a8,%eax
c04065f4:	39 c2                	cmp    %eax,%edx
c04065f6:	77 4c                	ja     c0406644 <vmm_return_phys_pg+0x143>
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
c04065f8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
c04065fd:	3c 01                	cmp    $0x1,%al
c04065ff:	76 0c                	jbe    c040660d <vmm_return_phys_pg+0x10c>
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
c0406601:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406606:	8b 00                	mov    (%eax),%eax
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
      {
         dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
c0406608:	c1 e8 18             	shr    $0x18,%eax
c040660b:	eb 08                	jmp    c0406615 <vmm_return_phys_pg+0x114>
c040660d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406612:	0f b6 c0             	movzbl %al,%eax
c0406615:	83 ec 08             	sub    $0x8,%esp
c0406618:	50                   	push   %eax
c0406619:	68 b0 ec 40 c0       	push   $0xc040ecb0
c040661e:	e8 33 6e 00 00       	call   c040d456 <debug_printf>
c0406623:	83 c4 10             	add    $0x10,%esp
                 "has overflowed!\n" DEBUG_COL_OFF, CPU_ID);
			debug_stacktrace();
c0406626:	e8 48 67 00 00       	call   c040cd73 <debug_stacktrace>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c040662b:	83 ec 08             	sub    $0x8,%esp
c040662e:	6a 01                	push   $0x1
c0406630:	68 98 18 41 c0       	push   $0xc0411898
c0406635:	e8 6e a0 ff ff       	call   c04006a8 <unlock_gate>
c040663a:	83 c4 10             	add    $0x10,%esp
         return e_phys_stk_overflow;
c040663d:	b8 0d 00 00 00       	mov    $0xd,%eax
c0406642:	eb 3a                	jmp    c040667e <vmm_return_phys_pg+0x17d>
      }

      /* push stack frame onto upper stack */
      phys_pg_stack_high_ptr--;
c0406644:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406649:	83 e8 04             	sub    $0x4,%eax
c040664c:	a3 8c 18 41 c0       	mov    %eax,0xc041188c
      *phys_pg_stack_high_ptr = (unsigned int)addr;
c0406651:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406656:	8b 54 24 10          	mov    0x10(%esp),%edx
c040665a:	89 10                	mov    %edx,(%eax)
   }

   phys_pg_reqed--; /* update accounting totals */
c040665c:	a1 cc 38 41 c0       	mov    0xc04138cc,%eax
c0406661:	48                   	dec    %eax
c0406662:	a3 cc 38 41 c0       	mov    %eax,0xc04138cc
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c0406667:	83 ec 08             	sub    $0x8,%esp
c040666a:	6a 01                	push   $0x1
c040666c:	68 98 18 41 c0       	push   $0xc0411898
c0406671:	e8 32 a0 ff ff       	call   c04006a8 <unlock_gate>
c0406676:	83 c4 10             	add    $0x10,%esp
	
   return success;
c0406679:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040667e:	83 c4 0c             	add    $0xc,%esp
c0406681:	c3                   	ret    

c0406682 <vmm_enough_pgs>:
   of memory.
   => size = amount of memory to check for
   <= 0 for success (sufficient mem), or result code
*/
kresult vmm_enough_pgs(unsigned int size)
{
c0406682:	83 ec 0c             	sub    $0xc,%esp
   if(!size) return success; /* there's always room for zero bytes ;) */
c0406685:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040668a:	75 07                	jne    c0406693 <vmm_enough_pgs+0x11>
c040668c:	b8 00 00 00 00       	mov    $0x0,%eax
c0406691:	eb 5b                	jmp    c04066ee <vmm_enough_pgs+0x6c>

	lock_gate(&(vmm_lock), LOCK_READ);
c0406693:	83 ec 08             	sub    $0x8,%esp
c0406696:	6a 00                	push   $0x0
c0406698:	68 98 18 41 c0       	push   $0xc0411898
c040669d:	e8 e9 9d ff ff       	call   c040048b <lock_gate>
c04066a2:	83 c4 10             	add    $0x10,%esp
	
   /* convert size into whole number of pages, rounding up */
   if((phys_pg_count - phys_pg_reqed) < ((size / MEM_PGSIZE) + 1))
c04066a5:	8b 15 c8 38 41 c0    	mov    0xc04138c8,%edx
c04066ab:	a1 cc 38 41 c0       	mov    0xc04138cc,%eax
c04066b0:	29 c2                	sub    %eax,%edx
c04066b2:	8b 44 24 10          	mov    0x10(%esp),%eax
c04066b6:	c1 e8 0c             	shr    $0xc,%eax
c04066b9:	40                   	inc    %eax
c04066ba:	39 c2                	cmp    %eax,%edx
c04066bc:	73 19                	jae    c04066d7 <vmm_enough_pgs+0x55>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c04066be:	83 ec 08             	sub    $0x8,%esp
c04066c1:	6a 00                	push   $0x0
c04066c3:	68 98 18 41 c0       	push   $0xc0411898
c04066c8:	e8 db 9f ff ff       	call   c04006a8 <unlock_gate>
c04066cd:	83 c4 10             	add    $0x10,%esp
      return e_not_enough_pgs;
c04066d0:	b8 09 00 00 00       	mov    $0x9,%eax
c04066d5:	eb 17                	jmp    c04066ee <vmm_enough_pgs+0x6c>
	}

	unlock_gate(&(vmm_lock), LOCK_READ);
c04066d7:	83 ec 08             	sub    $0x8,%esp
c04066da:	6a 00                	push   $0x0
c04066dc:	68 98 18 41 c0       	push   $0xc0411898
c04066e1:	e8 c2 9f ff ff       	call   c04006a8 <unlock_gate>
c04066e6:	83 c4 10             	add    $0x10,%esp
   return success;
c04066e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04066ee:	83 c4 0c             	add    $0xc,%esp
c04066f1:	c3                   	ret    

c04066f2 <vmm_ensure_pgs>:
   given area. Note: it will only check the selected type of mem.
   => size = number of bytes to check for
      type = 0 for DMA-able memory, 2 for non-DMA-able
*/
kresult vmm_ensure_pgs(unsigned int size, int type)
{
c04066f2:	83 ec 1c             	sub    $0x1c,%esp
   unsigned int pg_loop;
	unsigned int *pg_ptr, *pg_base;
	
	lock_gate(&(vmm_lock), LOCK_READ);
c04066f5:	83 ec 08             	sub    $0x8,%esp
c04066f8:	6a 00                	push   $0x0
c04066fa:	68 98 18 41 c0       	push   $0xc0411898
c04066ff:	e8 87 9d ff ff       	call   c040048b <lock_gate>
c0406704:	83 c4 10             	add    $0x10,%esp

   /* are we checking DMA-able physical memory? */
   if(type == MEM_LOW_PG)
c0406707:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040670c:	75 14                	jne    c0406722 <vmm_ensure_pgs+0x30>
   {
      pg_ptr = phys_pg_stack_low_ptr;
c040670e:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406713:	89 44 24 04          	mov    %eax,0x4(%esp)
      pg_base = phys_pg_stack_low_base;
c0406717:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c040671c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0406720:	eb 12                	jmp    c0406734 <vmm_ensure_pgs+0x42>
   }
   else /* or higher mem? */
   {
      pg_ptr = phys_pg_stack_high_ptr;
c0406722:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406727:	89 44 24 04          	mov    %eax,0x4(%esp)
      pg_base = phys_pg_stack_high_base;
c040672b:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c0406730:	89 44 24 08          	mov    %eax,0x8(%esp)
   }

   /* find number of pages fitting into size, rounding down for the benefit
      of the following checks. make sure physical pages are avaliable and
      that there's enough to bother checking before continuing. */
   pg_loop = (size / MEM_PGSIZE); 
c0406734:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406738:	c1 e8 0c             	shr    $0xc,%eax
c040673b:	89 04 24             	mov    %eax,(%esp)
   
	if(pg_ptr > pg_base)
c040673e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406742:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0406746:	76 1c                	jbe    c0406764 <vmm_ensure_pgs+0x72>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c0406748:	83 ec 08             	sub    $0x8,%esp
c040674b:	6a 00                	push   $0x0
c040674d:	68 98 18 41 c0       	push   $0xc0411898
c0406752:	e8 51 9f ff ff       	call   c04006a8 <unlock_gate>
c0406757:	83 c4 10             	add    $0x10,%esp
		return e_no_phys_pgs;
c040675a:	b8 04 00 00 00       	mov    $0x4,%eax
c040675f:	e9 8f 00 00 00       	jmp    c04067f3 <vmm_ensure_pgs+0x101>
	}
	
   if((pg_base - pg_ptr) < pg_loop)
c0406764:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406768:	8b 44 24 04          	mov    0x4(%esp),%eax
c040676c:	89 d1                	mov    %edx,%ecx
c040676e:	29 c1                	sub    %eax,%ecx
c0406770:	89 c8                	mov    %ecx,%eax
c0406772:	c1 f8 02             	sar    $0x2,%eax
c0406775:	3b 04 24             	cmp    (%esp),%eax
c0406778:	73 5c                	jae    c04067d6 <vmm_ensure_pgs+0xe4>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c040677a:	83 ec 08             	sub    $0x8,%esp
c040677d:	6a 00                	push   $0x0
c040677f:	68 98 18 41 c0       	push   $0xc0411898
c0406784:	e8 1f 9f ff ff       	call   c04006a8 <unlock_gate>
c0406789:	83 c4 10             	add    $0x10,%esp
		return e_no_phys_pgs;
c040678c:	b8 04 00 00 00       	mov    $0x4,%eax
c0406791:	eb 60                	jmp    c04067f3 <vmm_ensure_pgs+0x101>

   /* we check to see if there is a run of contiguous stack frame pointers
      that descend in value as the loop moves up towards the stack base */
   while(pg_loop)
   {
      unsigned int *pg_next = pg_ptr;
c0406793:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406797:	89 44 24 0c          	mov    %eax,0xc(%esp)
		pg_next++;
c040679b:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)

      if(*pg_ptr != (*pg_next + MEM_PGSIZE))
c04067a0:	8b 44 24 04          	mov    0x4(%esp),%eax
c04067a4:	8b 10                	mov    (%eax),%edx
c04067a6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04067aa:	8b 00                	mov    (%eax),%eax
c04067ac:	05 00 10 00 00       	add    $0x1000,%eax
c04067b1:	39 c2                	cmp    %eax,%edx
c04067b3:	74 19                	je     c04067ce <vmm_ensure_pgs+0xdc>
		{
			unlock_gate(&(vmm_lock), LOCK_READ);
c04067b5:	83 ec 08             	sub    $0x8,%esp
c04067b8:	6a 00                	push   $0x0
c04067ba:	68 98 18 41 c0       	push   $0xc0411898
c04067bf:	e8 e4 9e ff ff       	call   c04006a8 <unlock_gate>
c04067c4:	83 c4 10             	add    $0x10,%esp
			return e_not_contiguous;
c04067c7:	b8 0a 00 00 00       	mov    $0xa,%eax
c04067cc:	eb 25                	jmp    c04067f3 <vmm_ensure_pgs+0x101>
		}
      pg_loop--;
c04067ce:	ff 0c 24             	decl   (%esp)
      pg_ptr++;
c04067d1:	83 44 24 04 04       	addl   $0x4,0x4(%esp)
		return e_no_phys_pgs;
	}

   /* we check to see if there is a run of contiguous stack frame pointers
      that descend in value as the loop moves up towards the stack base */
   while(pg_loop)
c04067d6:	83 3c 24 00          	cmpl   $0x0,(%esp)
c04067da:	75 b7                	jne    c0406793 <vmm_ensure_pgs+0xa1>
		}
      pg_loop--;
      pg_ptr++;
   }

	unlock_gate(&(vmm_lock), LOCK_READ);
c04067dc:	83 ec 08             	sub    $0x8,%esp
c04067df:	6a 00                	push   $0x0
c04067e1:	68 98 18 41 c0       	push   $0xc0411898
c04067e6:	e8 bd 9e ff ff       	call   c04006a8 <unlock_gate>
c04067eb:	83 c4 10             	add    $0x10,%esp
   return success; /* managed to find run of pages */
c04067ee:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04067f3:	83 c4 1c             	add    $0x1c,%esp
c04067f6:	c3                   	ret    

c04067f7 <vmm_initialise>:
   by the hardware-dependent code's start.s
   => mbd = ptr to multiboot data about the system around us
   <= 0 for success or error code
*/
kresult vmm_initialise(multiboot_info_t *mbd)
{
c04067f7:	53                   	push   %ebx
c04067f8:	83 ec 38             	sub    $0x38,%esp
   mb_memory_map_t *region;
   void *heap_init;
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
c04067fb:	83 ec 04             	sub    $0x4,%esp
c04067fe:	6a 10                	push   $0x10
c0406800:	6a 00                	push   $0x0
c0406802:	68 98 18 41 c0       	push   $0xc0411898
c0406807:	e8 da 04 00 00       	call   c0406ce6 <vmm_memset>
c040680c:	83 c4 10             	add    $0x10,%esp
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c040680f:	ba 08 39 41 c0       	mov    $0xc0413908,%edx
c0406814:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c0406819:	89 d1                	mov    %edx,%ecx
c040681b:	29 c1                	sub    %eax,%ecx
c040681d:	89 c8                	mov    %ecx,%eax
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
c040681f:	c1 f8 02             	sar    $0x2,%eax
c0406822:	89 c2                	mov    %eax,%edx
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c0406824:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
c0406829:	3c 01                	cmp    $0x1,%al
c040682b:	76 0c                	jbe    c0406839 <vmm_initialise+0x42>
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c040682d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406832:	8b 00                	mov    (%eax),%eax
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
c0406834:	c1 e8 18             	shr    $0x18,%eax
c0406837:	eb 08                	jmp    c0406841 <vmm_initialise+0x4a>
c0406839:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040683e:	0f b6 c0             	movzbl %al,%eax
c0406841:	83 ec 0c             	sub    $0xc,%esp
c0406844:	52                   	push   %edx
c0406845:	68 08 39 41 c0       	push   $0xc0413908
c040684a:	68 00 00 40 c0       	push   $0xc0400000
c040684f:	50                   	push   %eax
c0406850:	68 fc ec 40 c0       	push   $0xc040ecfc
c0406855:	e8 fc 6b 00 00       	call   c040d456 <debug_printf>
c040685a:	83 c4 20             	add    $0x20,%esp
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: physical start %x end %x aligned end %x\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
           KERNEL_PHYSICAL_END_ALIGNED);
c040685d:	ba 08 39 41 c0       	mov    $0xc0413908,%edx
c0406862:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c0406867:	89 d3                	mov    %edx,%ebx
c0406869:	29 c3                	sub    %eax,%ebx
c040686b:	89 d8                	mov    %ebx,%eax
c040686d:	c1 f8 02             	sar    $0x2,%eax
c0406870:	05 00 10 40 00       	add    $0x401000,%eax
c0406875:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: physical start %x end %x aligned end %x\n" DEBUG_COL_OFF,
c040687a:	89 c2                	mov    %eax,%edx
           CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c040687c:	b9 08 39 41 c0       	mov    $0xc0413908,%ecx
c0406881:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c0406886:	89 cb                	mov    %ecx,%ebx
c0406888:	29 c3                	sub    %eax,%ebx
c040688a:	89 d8                	mov    %ebx,%eax
c040688c:	c1 f8 02             	sar    $0x2,%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: physical start %x end %x aligned end %x\n" DEBUG_COL_OFF,
c040688f:	8d 88 00 00 40 00    	lea    0x400000(%eax),%ecx
           CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c0406895:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: physical start %x end %x aligned end %x\n" DEBUG_COL_OFF,
c040689a:	3c 01                	cmp    $0x1,%al
c040689c:	76 0c                	jbe    c04068aa <vmm_initialise+0xb3>
           CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c040689e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04068a3:	8b 00                	mov    (%eax),%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: logical start %x end %x size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   dprintf(DEBUG_COL_VMM "[vmm:%i] kernel: physical start %x end %x aligned end %x\n" DEBUG_COL_OFF,
c04068a5:	c1 e8 18             	shr    $0x18,%eax
c04068a8:	eb 08                	jmp    c04068b2 <vmm_initialise+0xbb>
c04068aa:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04068af:	0f b6 c0             	movzbl %al,%eax
c04068b2:	83 ec 0c             	sub    $0xc,%esp
c04068b5:	52                   	push   %edx
c04068b6:	51                   	push   %ecx
c04068b7:	68 00 00 40 00       	push   $0x400000
c04068bc:	50                   	push   %eax
c04068bd:	68 34 ed 40 c0       	push   $0xc040ed34
c04068c2:	e8 8f 6b 00 00       	call   c040d456 <debug_printf>
c04068c7:	83 c4 20             	add    $0x20,%esp
           CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
           KERNEL_PHYSICAL_END_ALIGNED);

   /* check bit six to see if we can access mmap info */
   if(!(mbd->flags & (1<<6)))
c04068ca:	8b 44 24 40          	mov    0x40(%esp),%eax
c04068ce:	8b 00                	mov    (%eax),%eax
c04068d0:	83 e0 40             	and    $0x40,%eax
c04068d3:	85 c0                	test   %eax,%eax
c04068d5:	75 21                	jne    c04068f8 <vmm_initialise+0x101>
   {
      dprintf("*** missing mem map data from multiboot. (%x)\n" DEBUG_COL_OFF, mbd->flags);
c04068d7:	8b 44 24 40          	mov    0x40(%esp),%eax
c04068db:	8b 00                	mov    (%eax),%eax
c04068dd:	83 ec 08             	sub    $0x8,%esp
c04068e0:	50                   	push   %eax
c04068e1:	68 70 ed 40 c0       	push   $0xc040ed70
c04068e6:	e8 6b 6b 00 00       	call   c040d456 <debug_printf>
c04068eb:	83 c4 10             	add    $0x10,%esp
      return e_missing_mb_data;
c04068ee:	b8 03 00 00 00       	mov    $0x3,%eax
c04068f3:	e9 e9 03 00 00       	jmp    c0406ce1 <vmm_initialise+0x4ea>
   }

   /* set up physical page frame stacks, initially empty.
      note: stack ptrs always point to the top available word. */
   phys_pg_stack_low_ptr    = phys_pg_stack_low_base;
c04068f8:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c04068fd:	a3 94 18 41 c0       	mov    %eax,0xc0411894
   phys_pg_stack_low_limit  = phys_pg_stack_low_base;
c0406902:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c0406907:	a3 90 18 41 c0       	mov    %eax,0xc0411890
   phys_pg_stack_high_ptr   = phys_pg_stack_high_base;
c040690c:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c0406911:	a3 8c 18 41 c0       	mov    %eax,0xc041188c
   phys_pg_stack_high_limit = phys_pg_stack_high_base;
c0406916:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c040691b:	a3 a8 18 41 c0       	mov    %eax,0xc04118a8
   /* do a quick count up of physical memory so we know how large our stacks
      need to be and thus, we can keep the physical page frames holding the
      stacks out of the stacks - we must make sure we do not hand out page
      frames holding the stacks and the kernel to the rest of the system to use
    */
   region = (mb_memory_map_t *)mbd->mmap_addr;
c0406920:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406924:	8b 40 30             	mov    0x30(%eax),%eax
c0406927:	89 44 24 10          	mov    %eax,0x10(%esp)
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c040692b:	eb 39                	jmp    c0406966 <vmm_initialise+0x16f>
   {
		if(region->type == 1) /* if region is present RAM */
c040692d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406931:	8b 40 14             	mov    0x14(%eax),%eax
c0406934:	83 f8 01             	cmp    $0x1,%eax
c0406937:	75 19                	jne    c0406952 <vmm_initialise+0x15b>
			phys_pg_count += (region->length_low / MEM_PGSIZE);
c0406939:	8b 44 24 10          	mov    0x10(%esp),%eax
c040693d:	8b 40 0c             	mov    0xc(%eax),%eax
c0406940:	89 c2                	mov    %eax,%edx
c0406942:	c1 ea 0c             	shr    $0xc,%edx
c0406945:	a1 c8 38 41 c0       	mov    0xc04138c8,%eax
c040694a:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040694d:	a3 c8 38 41 c0       	mov    %eax,0xc04138c8

      /* get next region */
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
c0406952:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406956:	8b 10                	mov    (%eax),%edx
c0406958:	8b 44 24 10          	mov    0x10(%esp),%eax
c040695c:	8d 04 02             	lea    (%edx,%eax,1),%eax
   {
		if(region->type == 1) /* if region is present RAM */
			phys_pg_count += (region->length_low / MEM_PGSIZE);

      /* get next region */
      region = (mb_memory_map_t *)((unsigned int)region +
c040695f:	83 c0 04             	add    $0x4,%eax
c0406962:	89 44 24 10          	mov    %eax,0x10(%esp)
      need to be and thus, we can keep the physical page frames holding the
      stacks out of the stacks - we must make sure we do not hand out page
      frames holding the stacks and the kernel to the rest of the system to use
    */
   region = (mb_memory_map_t *)mbd->mmap_addr;
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c0406966:	8b 54 24 10          	mov    0x10(%esp),%edx
c040696a:	8b 44 24 40          	mov    0x40(%esp),%eax
c040696e:	8b 48 30             	mov    0x30(%eax),%ecx
c0406971:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406975:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406978:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040697b:	39 c2                	cmp    %eax,%edx
c040697d:	72 ae                	jb     c040692d <vmm_initialise+0x136>
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
                                   sizeof(unsigned int));
   }

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
c040697f:	a1 c8 38 41 c0       	mov    0xc04138c8,%eax
c0406984:	c1 e0 02             	shl    $0x2,%eax
c0406987:	89 44 24 14          	mov    %eax,0x14(%esp)
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
c040698b:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c0406990:	2b 44 24 14          	sub    0x14(%esp),%eax
c0406994:	89 44 24 18          	mov    %eax,0x18(%esp)
                                   pg_stack_size);

   dprintf(DEBUG_COL_VMM "[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n" DEBUG_COL_OFF,
           CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c0406998:	a1 c8 38 41 c0       	mov    0xc04138c8,%eax
c040699d:	c1 e0 0c             	shl    $0xc,%eax

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   dprintf(DEBUG_COL_VMM "[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n" DEBUG_COL_OFF,
c04069a0:	89 c1                	mov    %eax,%ecx
c04069a2:	c1 e9 14             	shr    $0x14,%ecx
c04069a5:	8b 15 c8 38 41 c0    	mov    0xc04138c8,%edx
           CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c04069ab:	a0 f0 38 41 c0       	mov    0xc04138f0,%al

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   dprintf(DEBUG_COL_VMM "[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n" DEBUG_COL_OFF,
c04069b0:	3c 01                	cmp    $0x1,%al
c04069b2:	76 0c                	jbe    c04069c0 <vmm_initialise+0x1c9>
           CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c04069b4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04069b9:	8b 00                	mov    (%eax),%eax

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   dprintf(DEBUG_COL_VMM "[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n" DEBUG_COL_OFF,
c04069bb:	c1 e8 18             	shr    $0x18,%eax
c04069be:	eb 08                	jmp    c04069c8 <vmm_initialise+0x1d1>
c04069c0:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04069c5:	0f b6 c0             	movzbl %al,%eax
c04069c8:	83 ec 0c             	sub    $0xc,%esp
c04069cb:	ff 74 24 20          	pushl  0x20(%esp)
c04069cf:	51                   	push   %ecx
c04069d0:	52                   	push   %edx
c04069d1:	50                   	push   %eax
c04069d2:	68 a0 ed 40 c0       	push   $0xc040eda0
c04069d7:	e8 7a 6a 00 00       	call   c040d456 <debug_printf>
c04069dc:	83 c4 20             	add    $0x20,%esp
           CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
           pg_stack_size);
	
	/* check to make sure we have enough memory to function */
	if((phys_pg_count * MEM_PGSIZE) < (KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE))
c04069df:	a1 c8 38 41 c0       	mov    0xc04138c8,%eax
c04069e4:	c1 e0 0c             	shl    $0xc,%eax
c04069e7:	3d ff ff 7f 00       	cmp    $0x7fffff,%eax
c04069ec:	77 1f                	ja     c0406a0d <vmm_initialise+0x216>
	{
		dprintf("*** Not enough memory present, must have at least %i bytes available.\n" DEBUG_COL_OFF,
c04069ee:	83 ec 08             	sub    $0x8,%esp
c04069f1:	68 00 00 80 00       	push   $0x800000
c04069f6:	68 e0 ed 40 c0       	push   $0xc040ede0
c04069fb:	e8 56 6a 00 00       	call   c040d456 <debug_printf>
c0406a00:	83 c4 10             	add    $0x10,%esp
				  KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE);
		return e_failure;
c0406a03:	b8 01 00 00 00       	mov    $0x1,%eax
c0406a08:	e9 d4 02 00 00       	jmp    c0406ce1 <vmm_initialise+0x4ea>
	}
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] page stack: lo base %p hi base: %p top: %p aligned top: %p\n" DEBUG_COL_OFF,
           CPU_ID, phys_pg_stack_low_base, phys_pg_stack_high_base,
			  pg_stack_top, MEM_PGALIGN(pg_stack_top)); 
c0406a0d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406a11:	25 00 f0 ff ff       	and    $0xfffff000,%eax
		dprintf("*** Not enough memory present, must have at least %i bytes available.\n" DEBUG_COL_OFF,
				  KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE);
		return e_failure;
	}
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] page stack: lo base %p hi base: %p top: %p aligned top: %p\n" DEBUG_COL_OFF,
c0406a16:	89 c3                	mov    %eax,%ebx
c0406a18:	8b 0d 4c 10 41 c0    	mov    0xc041104c,%ecx
c0406a1e:	8b 15 48 10 41 c0    	mov    0xc0411048,%edx
           CPU_ID, phys_pg_stack_low_base, phys_pg_stack_high_base,
c0406a24:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
		dprintf("*** Not enough memory present, must have at least %i bytes available.\n" DEBUG_COL_OFF,
				  KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE);
		return e_failure;
	}
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] page stack: lo base %p hi base: %p top: %p aligned top: %p\n" DEBUG_COL_OFF,
c0406a29:	3c 01                	cmp    $0x1,%al
c0406a2b:	76 0c                	jbe    c0406a39 <vmm_initialise+0x242>
           CPU_ID, phys_pg_stack_low_base, phys_pg_stack_high_base,
c0406a2d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406a32:	8b 00                	mov    (%eax),%eax
		dprintf("*** Not enough memory present, must have at least %i bytes available.\n" DEBUG_COL_OFF,
				  KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE);
		return e_failure;
	}
	
   dprintf(DEBUG_COL_VMM "[vmm:%i] page stack: lo base %p hi base: %p top: %p aligned top: %p\n" DEBUG_COL_OFF,
c0406a34:	c1 e8 18             	shr    $0x18,%eax
c0406a37:	eb 08                	jmp    c0406a41 <vmm_initialise+0x24a>
c0406a39:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406a3e:	0f b6 c0             	movzbl %al,%eax
c0406a41:	83 ec 08             	sub    $0x8,%esp
c0406a44:	53                   	push   %ebx
c0406a45:	ff 74 24 24          	pushl  0x24(%esp)
c0406a49:	51                   	push   %ecx
c0406a4a:	52                   	push   %edx
c0406a4b:	50                   	push   %eax
c0406a4c:	68 28 ee 40 c0       	push   $0xc040ee28
c0406a51:	e8 00 6a 00 00       	call   c040d456 <debug_printf>
c0406a56:	83 c4 20             	add    $0x20,%esp
			  pg_stack_top, MEM_PGALIGN(pg_stack_top)); 

   /* the stack may not end on a page boundary, so round down - this is so
	   that we can make sure the pages holding the stacks don't end up on
	   the list of available physical page frames */
   pg_stack_top = MEM_PGALIGN(pg_stack_top);
c0406a59:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406a5d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0406a62:	89 44 24 18          	mov    %eax,0x18(%esp)

   /* run through the memory areas found by the bootloader and build up
      physical page stacks */
   region = (mb_memory_map_t *)mbd->mmap_addr;
c0406a66:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406a6a:	8b 40 30             	mov    0x30(%eax),%eax
c0406a6d:	89 44 24 10          	mov    %eax,0x10(%esp)
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c0406a71:	e9 f1 01 00 00       	jmp    c0406c67 <vmm_initialise+0x470>
   {
      unsigned int pg_loop;
      unsigned int pg_count_lo = 0;
c0406a76:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0406a7d:	00 
      unsigned int pg_count_hi = 0;
c0406a7e:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0406a85:	00 
      unsigned int pg_skip = 0;
c0406a86:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
c0406a8d:	00 
      unsigned int max_addr = region->base_addr_low + region->length_low;
c0406a8e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406a92:	8b 50 04             	mov    0x4(%eax),%edx
c0406a95:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406a99:	8b 40 0c             	mov    0xc(%eax),%eax
c0406a9c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0406a9f:	89 44 24 2c          	mov    %eax,0x2c(%esp)

      dprintf(DEBUG_COL_VMM "[vmm:%i] mem region: start %x length %i type %x\n" DEBUG_COL_OFF,
c0406aa3:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406aa7:	8b 58 14             	mov    0x14(%eax),%ebx
c0406aaa:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406aae:	8b 48 0c             	mov    0xc(%eax),%ecx
c0406ab1:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406ab5:	8b 50 04             	mov    0x4(%eax),%edx
               CPU_ID, region->base_addr_low, region->length_low, region->type);
c0406ab8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
      unsigned int pg_count_lo = 0;
      unsigned int pg_count_hi = 0;
      unsigned int pg_skip = 0;
      unsigned int max_addr = region->base_addr_low + region->length_low;

      dprintf(DEBUG_COL_VMM "[vmm:%i] mem region: start %x length %i type %x\n" DEBUG_COL_OFF,
c0406abd:	3c 01                	cmp    $0x1,%al
c0406abf:	76 0c                	jbe    c0406acd <vmm_initialise+0x2d6>
               CPU_ID, region->base_addr_low, region->length_low, region->type);
c0406ac1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406ac6:	8b 00                	mov    (%eax),%eax
      unsigned int pg_count_lo = 0;
      unsigned int pg_count_hi = 0;
      unsigned int pg_skip = 0;
      unsigned int max_addr = region->base_addr_low + region->length_low;

      dprintf(DEBUG_COL_VMM "[vmm:%i] mem region: start %x length %i type %x\n" DEBUG_COL_OFF,
c0406ac8:	c1 e8 18             	shr    $0x18,%eax
c0406acb:	eb 08                	jmp    c0406ad5 <vmm_initialise+0x2de>
c0406acd:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406ad2:	0f b6 c0             	movzbl %al,%eax
c0406ad5:	83 ec 0c             	sub    $0xc,%esp
c0406ad8:	53                   	push   %ebx
c0406ad9:	51                   	push   %ecx
c0406ada:	52                   	push   %edx
c0406adb:	50                   	push   %eax
c0406adc:	68 70 ee 40 c0       	push   $0xc040ee70
c0406ae1:	e8 70 69 00 00       	call   c040d456 <debug_printf>
c0406ae6:	83 c4 20             	add    $0x20,%esp
               CPU_ID, region->base_addr_low, region->length_low, region->type);

		/* is this region present? */
		if(region->type == 1)
c0406ae9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406aed:	8b 40 14             	mov    0x14(%eax),%eax
c0406af0:	83 f8 01             	cmp    $0x1,%eax
c0406af3:	0f 85 5a 01 00 00    	jne    c0406c53 <vmm_initialise+0x45c>
		{
			pg_loop = region->base_addr_low;
c0406af9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406afd:	8b 40 04             	mov    0x4(%eax),%eax
c0406b00:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			while((pg_loop + MEM_PGSIZE) <= max_addr)
c0406b04:	e9 fd 00 00 00       	jmp    c0406c06 <vmm_initialise+0x40f>
			{
				/* skip over kernel in physical mem, otherwise things get messy */
				if((pg_loop >= (unsigned int)KERNEL_PHYSICAL_BASE) &&
c0406b09:	81 7c 24 1c ff ff 3f 	cmpl   $0x3fffff,0x1c(%esp)
c0406b10:	00 
c0406b11:	76 34                	jbe    c0406b47 <vmm_initialise+0x350>
					(pg_loop < (unsigned int)KERNEL_PHYSICAL_END_ALIGNED))
c0406b13:	ba 08 39 41 c0       	mov    $0xc0413908,%edx
c0406b18:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c0406b1d:	89 d1                	mov    %edx,%ecx
c0406b1f:	29 c1                	sub    %eax,%ecx
c0406b21:	89 c8                	mov    %ecx,%eax
c0406b23:	c1 f8 02             	sar    $0x2,%eax
c0406b26:	05 00 10 40 00       	add    $0x401000,%eax
c0406b2b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
		{
			pg_loop = region->base_addr_low;
			while((pg_loop + MEM_PGSIZE) <= max_addr)
			{
				/* skip over kernel in physical mem, otherwise things get messy */
				if((pg_loop >= (unsigned int)KERNEL_PHYSICAL_BASE) &&
c0406b30:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
c0406b34:	73 11                	jae    c0406b47 <vmm_initialise+0x350>
					(pg_loop < (unsigned int)KERNEL_PHYSICAL_END_ALIGNED))
				{
					pg_skip++;
c0406b36:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c0406b3a:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c0406b41:	00 
					continue;
c0406b42:	e9 bf 00 00 00       	jmp    c0406c06 <vmm_initialise+0x40f>
				}

				/* skip over pages that will hold these page frame stacks */
				if((pg_loop < (unsigned int)phys_pg_stack_low_base) &&
c0406b47:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c0406b4c:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c0406b50:	76 1b                	jbe    c0406b6d <vmm_initialise+0x376>
					(pg_loop >= (unsigned int)pg_stack_top))
c0406b52:	8b 44 24 18          	mov    0x18(%esp),%eax
					pg_loop += MEM_PGSIZE;
					continue;
				}

				/* skip over pages that will hold these page frame stacks */
				if((pg_loop < (unsigned int)phys_pg_stack_low_base) &&
c0406b56:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c0406b5a:	77 11                	ja     c0406b6d <vmm_initialise+0x376>
					(pg_loop >= (unsigned int)pg_stack_top))
				{
					pg_skip++;
c0406b5c:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c0406b60:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c0406b67:	00 
					continue;
c0406b68:	e9 99 00 00 00       	jmp    c0406c06 <vmm_initialise+0x40f>
				}

				/* skip over pages holding payload binaries XXX inefficient */
				if(payload_exist_here(pg_loop))
c0406b6d:	83 ec 0c             	sub    $0xc,%esp
c0406b70:	ff 74 24 28          	pushl  0x28(%esp)
c0406b74:	e8 e3 5c 00 00       	call   c040c85c <payload_exist_here>
c0406b79:	83 c4 10             	add    $0x10,%esp
c0406b7c:	85 c0                	test   %eax,%eax
c0406b7e:	74 0e                	je     c0406b8e <vmm_initialise+0x397>
				{
					pg_skip++;
c0406b80:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c0406b84:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c0406b8b:	00 
					continue;
c0406b8c:	eb 78                	jmp    c0406c06 <vmm_initialise+0x40f>
				}

				/* decide which stack to place the page frame in */
				if(pg_loop < MEM_DMA_REGION_MARK)
c0406b8e:	81 7c 24 1c ff ff ff 	cmpl   $0xffffff,0x1c(%esp)
c0406b95:	00 
c0406b96:	77 1e                	ja     c0406bb6 <vmm_initialise+0x3bf>
				{
					*phys_pg_stack_low_ptr = pg_loop;
c0406b98:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406b9d:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0406ba1:	89 10                	mov    %edx,(%eax)
					phys_pg_stack_low_ptr--;
c0406ba3:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406ba8:	83 e8 04             	sub    $0x4,%eax
c0406bab:	a3 94 18 41 c0       	mov    %eax,0xc0411894
					pg_count_lo++;
c0406bb0:	ff 44 24 20          	incl   0x20(%esp)
c0406bb4:	eb 1c                	jmp    c0406bd2 <vmm_initialise+0x3db>
				}
				else
				{
					*phys_pg_stack_high_ptr = pg_loop;
c0406bb6:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406bbb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0406bbf:	89 10                	mov    %edx,(%eax)
					phys_pg_stack_high_ptr--;
c0406bc1:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406bc6:	83 e8 04             	sub    $0x4,%eax
c0406bc9:	a3 8c 18 41 c0       	mov    %eax,0xc041188c
					pg_count_hi++;
c0406bce:	ff 44 24 24          	incl   0x24(%esp)
				}
				
				if(phys_pg_stack_low_ptr < phys_pg_stack_high_base)
c0406bd2:	8b 15 94 18 41 c0    	mov    0xc0411894,%edx
c0406bd8:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c0406bdd:	39 c2                	cmp    %eax,%edx
c0406bdf:	73 1d                	jae    c0406bfe <vmm_initialise+0x407>
				{
					dprintf("*** lomem page stack crashed into himem stack!\n" DEBUG_COL_OFF
c0406be1:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406be6:	ff 74 24 1c          	pushl  0x1c(%esp)
c0406bea:	ff 74 24 24          	pushl  0x24(%esp)
c0406bee:	50                   	push   %eax
c0406bef:	68 a4 ee 40 c0       	push   $0xc040eea4
c0406bf4:	e8 5d 68 00 00       	call   c040d456 <debug_printf>
c0406bf9:	83 c4 10             	add    $0x10,%esp
					        "    ptr %p after %i pages (%x) - halting.\n" DEBUG_COL_OFF,
							  phys_pg_stack_low_ptr, pg_count_lo, pg_loop);
					while(1);
c0406bfc:	eb fe                	jmp    c0406bfc <vmm_initialise+0x405>
				}
				
				pg_loop += MEM_PGSIZE;
c0406bfe:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c0406c05:	00 

		/* is this region present? */
		if(region->type == 1)
		{
			pg_loop = region->base_addr_low;
			while((pg_loop + MEM_PGSIZE) <= max_addr)
c0406c06:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406c0a:	05 00 10 00 00       	add    $0x1000,%eax
c0406c0f:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
c0406c13:	0f 86 f0 fe ff ff    	jbe    c0406b09 <vmm_initialise+0x312>
				
				pg_loop += MEM_PGSIZE;
			}

			dprintf(DEBUG_COL_VMM "[vmm:%i] added phys pages: %i low, %i high (%i reserved)\n" DEBUG_COL_OFF,
					  CPU_ID, pg_count_lo, pg_count_hi, pg_skip);
c0406c19:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
				}
				
				pg_loop += MEM_PGSIZE;
			}

			dprintf(DEBUG_COL_VMM "[vmm:%i] added phys pages: %i low, %i high (%i reserved)\n" DEBUG_COL_OFF,
c0406c1e:	3c 01                	cmp    $0x1,%al
c0406c20:	76 0c                	jbe    c0406c2e <vmm_initialise+0x437>
					  CPU_ID, pg_count_lo, pg_count_hi, pg_skip);
c0406c22:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406c27:	8b 00                	mov    (%eax),%eax
				}
				
				pg_loop += MEM_PGSIZE;
			}

			dprintf(DEBUG_COL_VMM "[vmm:%i] added phys pages: %i low, %i high (%i reserved)\n" DEBUG_COL_OFF,
c0406c29:	c1 e8 18             	shr    $0x18,%eax
c0406c2c:	eb 08                	jmp    c0406c36 <vmm_initialise+0x43f>
c0406c2e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406c33:	0f b6 c0             	movzbl %al,%eax
c0406c36:	83 ec 0c             	sub    $0xc,%esp
c0406c39:	ff 74 24 34          	pushl  0x34(%esp)
c0406c3d:	ff 74 24 34          	pushl  0x34(%esp)
c0406c41:	ff 74 24 34          	pushl  0x34(%esp)
c0406c45:	50                   	push   %eax
c0406c46:	68 00 ef 40 c0       	push   $0xc040ef00
c0406c4b:	e8 06 68 00 00       	call   c040d456 <debug_printf>
c0406c50:	83 c4 20             	add    $0x20,%esp

		}
			
      /* get to the next memory region */
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
c0406c53:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406c57:	8b 10                	mov    (%eax),%edx
c0406c59:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406c5d:	8d 04 02             	lea    (%edx,%eax,1),%eax
					  CPU_ID, pg_count_lo, pg_count_hi, pg_skip);

		}
			
      /* get to the next memory region */
      region = (mb_memory_map_t *)((unsigned int)region +
c0406c60:	83 c0 04             	add    $0x4,%eax
c0406c63:	89 44 24 10          	mov    %eax,0x10(%esp)
   pg_stack_top = MEM_PGALIGN(pg_stack_top);

   /* run through the memory areas found by the bootloader and build up
      physical page stacks */
   region = (mb_memory_map_t *)mbd->mmap_addr;
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c0406c67:	8b 54 24 10          	mov    0x10(%esp),%edx
c0406c6b:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406c6f:	8b 48 30             	mov    0x30(%eax),%ecx
c0406c72:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406c76:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406c79:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0406c7c:	39 c2                	cmp    %eax,%edx
c0406c7e:	0f 82 f2 fd ff ff    	jb     c0406a76 <vmm_initialise+0x27f>
                                   region->size +
                                   sizeof(unsigned int));
   }

   /* set stack limits so we know when we're out of memory */
   phys_pg_stack_low_ptr++; /* adjust ptr to top word */
c0406c84:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406c89:	83 c0 04             	add    $0x4,%eax
c0406c8c:	a3 94 18 41 c0       	mov    %eax,0xc0411894
   phys_pg_stack_high_ptr++; /* adjust ptr to top word */
c0406c91:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406c96:	83 c0 04             	add    $0x4,%eax
c0406c99:	a3 8c 18 41 c0       	mov    %eax,0xc041188c
   phys_pg_stack_low_limit = phys_pg_stack_low_ptr;
c0406c9e:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c0406ca3:	a3 90 18 41 c0       	mov    %eax,0xc0411890
   phys_pg_stack_high_limit = phys_pg_stack_high_ptr;
c0406ca8:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c0406cad:	a3 a8 18 41 c0       	mov    %eax,0xc04118a8
		
   /* now we've got a grip on physical memory, map it all into our virtual
      space using pagination */
   pg_init(); /* non-portable code */
c0406cb2:	e8 e6 34 00 00       	call   c040a19d <pg_init>
	
   /* prime the kernel heap while we still have contiguous space */
   vmm_malloc(&heap_init, KHEAP_INITSIZE);
c0406cb7:	83 ec 08             	sub    $0x8,%esp
c0406cba:	68 00 00 01 00       	push   $0x10000
c0406cbf:	8d 44 24 18          	lea    0x18(%esp),%eax
c0406cc3:	50                   	push   %eax
c0406cc4:	e8 c7 f1 ff ff       	call   c0405e90 <vmm_malloc>
c0406cc9:	83 c4 10             	add    $0x10,%esp
   vmm_free(heap_init);
c0406ccc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406cd0:	83 ec 0c             	sub    $0xc,%esp
c0406cd3:	50                   	push   %eax
c0406cd4:	e8 f9 f5 ff ff       	call   c04062d2 <vmm_free>
c0406cd9:	83 c4 10             	add    $0x10,%esp

   return 0;
c0406cdc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0406ce1:	83 c4 38             	add    $0x38,%esp
c0406ce4:	5b                   	pop    %ebx
c0406ce5:	c3                   	ret    

c0406ce6 <vmm_memset>:
   => addr  = base address to start writing to
      value = byte-wide value to write into each byte
      count = number of bytes to write
*/
void vmm_memset(void *addr, unsigned char value, unsigned int count)
{
c0406ce6:	83 ec 14             	sub    $0x14,%esp
c0406ce9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406ced:	88 04 24             	mov    %al,(%esp)
	unsigned char *ptr = (unsigned char *)addr;
c0406cf0:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406cf4:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int i;
	
	for(i = 0; i < count; i++)
c0406cf8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0406cff:	00 
c0406d00:	eb 13                	jmp    c0406d15 <vmm_memset+0x2f>
		ptr[i] = value;
c0406d02:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406d06:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0406d0a:	01 c2                	add    %eax,%edx
c0406d0c:	8a 04 24             	mov    (%esp),%al
c0406d0f:	88 02                	mov    %al,(%edx)
void vmm_memset(void *addr, unsigned char value, unsigned int count)
{
	unsigned char *ptr = (unsigned char *)addr;
	unsigned int i;
	
	for(i = 0; i < count; i++)
c0406d11:	ff 44 24 10          	incl   0x10(%esp)
c0406d15:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406d19:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0406d1d:	72 e3                	jb     c0406d02 <vmm_memset+0x1c>
		ptr[i] = value;
}
c0406d1f:	83 c4 14             	add    $0x14,%esp
c0406d22:	c3                   	ret    

c0406d23 <vmm_memcpy>:
   => target  = base address to write to
      source = base address to read from 
    	count = number of bytes to write
 */
void vmm_memcpy(void *target, void *source, unsigned int count)
{
c0406d23:	83 ec 10             	sub    $0x10,%esp
	unsigned char *ptr1 = (unsigned char *)target;
c0406d26:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406d2a:	89 44 24 04          	mov    %eax,0x4(%esp)
	unsigned char *ptr2 = (unsigned char *)source;
c0406d2e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406d32:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int i;
	for(i = 0; i < count; i++)
c0406d36:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0406d3d:	00 
c0406d3e:	eb 1d                	jmp    c0406d5d <vmm_memcpy+0x3a>
		ptr1[i] = ptr2[i];
c0406d40:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d44:	8b 54 24 04          	mov    0x4(%esp),%edx
c0406d48:	01 c2                	add    %eax,%edx
c0406d4a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d4e:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0406d52:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0406d55:	8a 00                	mov    (%eax),%al
c0406d57:	88 02                	mov    %al,(%edx)
void vmm_memcpy(void *target, void *source, unsigned int count)
{
	unsigned char *ptr1 = (unsigned char *)target;
	unsigned char *ptr2 = (unsigned char *)source;
	unsigned int i;
	for(i = 0; i < count; i++)
c0406d59:	ff 44 24 0c          	incl   0xc(%esp)
c0406d5d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d61:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c0406d65:	72 d9                	jb     c0406d40 <vmm_memcpy+0x1d>
		ptr1[i] = ptr2[i];
}
c0406d67:	83 c4 10             	add    $0x10,%esp
c0406d6a:	c3                   	ret    

c0406d6b <vmm_memcpyuser>:
	   sproc = source process structure (or NULL for kernel)
      count = number of bytes to write
*/
kresult vmm_memcpyuser(void *target, process *tproc,
						     void *source, process *sproc, unsigned int count)
{
c0406d6b:	83 ec 1c             	sub    $0x1c,%esp
	/* the goal is to resolve the addresses into kernel 
      virtual addresses */
	kresult err = e_failure;
c0406d6e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0406d75:	00 
	unsigned int ktarget, ksource;
	
	if(((unsigned int)target + count) >= KERNEL_SPACE_BASE)
c0406d76:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406d7a:	03 44 24 30          	add    0x30(%esp),%eax
c0406d7e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0406d83:	76 15                	jbe    c0406d9a <vmm_memcpyuser+0x2f>
	{
		/* copying into kernel, tproc must be NULL */
		if(tproc) goto vmm_memcpyuser_wtf;
c0406d85:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0406d8a:	0f 85 94 00 00 00    	jne    c0406e24 <vmm_memcpyuser+0xb9>
		ktarget = (unsigned int)target;
c0406d90:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406d94:	89 44 24 08          	mov    %eax,0x8(%esp)
c0406d98:	eb 24                	jmp    c0406dbe <vmm_memcpyuser+0x53>
	}
	else
	{
		err = pg_user2kernel(&ktarget, (unsigned int)target, tproc);
c0406d9a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406d9e:	83 ec 04             	sub    $0x4,%esp
c0406da1:	ff 74 24 28          	pushl  0x28(%esp)
c0406da5:	50                   	push   %eax
c0406da6:	8d 44 24 14          	lea    0x14(%esp),%eax
c0406daa:	50                   	push   %eax
c0406dab:	e8 ac 30 00 00       	call   c0409e5c <pg_user2kernel>
c0406db0:	83 c4 10             	add    $0x10,%esp
c0406db3:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(err) goto vmm_memcpyuser_wtf;
c0406db7:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0406dbc:	75 69                	jne    c0406e27 <vmm_memcpyuser+0xbc>
	}

	if(((unsigned int)source + count) >= KERNEL_SPACE_BASE)
c0406dbe:	8b 44 24 28          	mov    0x28(%esp),%eax
c0406dc2:	03 44 24 30          	add    0x30(%esp),%eax
c0406dc6:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0406dcb:	76 11                	jbe    c0406dde <vmm_memcpyuser+0x73>
	{
		/* copying from kernel, sproc must be NULL */
		if(sproc) goto vmm_memcpyuser_wtf;
c0406dcd:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0406dd2:	75 56                	jne    c0406e2a <vmm_memcpyuser+0xbf>
		ksource = (unsigned int)source;
c0406dd4:	8b 44 24 28          	mov    0x28(%esp),%eax
c0406dd8:	89 44 24 04          	mov    %eax,0x4(%esp)
c0406ddc:	eb 24                	jmp    c0406e02 <vmm_memcpyuser+0x97>
	}
	else
	{
		err = pg_user2kernel(&ksource, (unsigned int)source, sproc);
c0406dde:	8b 44 24 28          	mov    0x28(%esp),%eax
c0406de2:	83 ec 04             	sub    $0x4,%esp
c0406de5:	ff 74 24 30          	pushl  0x30(%esp)
c0406de9:	50                   	push   %eax
c0406dea:	8d 44 24 10          	lea    0x10(%esp),%eax
c0406dee:	50                   	push   %eax
c0406def:	e8 68 30 00 00       	call   c0409e5c <pg_user2kernel>
c0406df4:	83 c4 10             	add    $0x10,%esp
c0406df7:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(err) goto vmm_memcpyuser_wtf;
c0406dfb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0406e00:	75 2b                	jne    c0406e2d <vmm_memcpyuser+0xc2>
	}
	
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
c0406e02:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406e06:	89 c2                	mov    %eax,%edx
c0406e08:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406e0c:	83 ec 04             	sub    $0x4,%esp
c0406e0f:	ff 74 24 34          	pushl  0x34(%esp)
c0406e13:	52                   	push   %edx
c0406e14:	50                   	push   %eax
c0406e15:	e8 09 ff ff ff       	call   c0406d23 <vmm_memcpy>
c0406e1a:	83 c4 10             	add    $0x10,%esp
	return success;
c0406e1d:	b8 00 00 00 00       	mov    $0x0,%eax
c0406e22:	eb 55                	jmp    c0406e79 <vmm_memcpyuser+0x10e>
	unsigned int ktarget, ksource;
	
	if(((unsigned int)target + count) >= KERNEL_SPACE_BASE)
	{
		/* copying into kernel, tproc must be NULL */
		if(tproc) goto vmm_memcpyuser_wtf;
c0406e24:	90                   	nop
c0406e25:	eb 07                	jmp    c0406e2e <vmm_memcpyuser+0xc3>
		ktarget = (unsigned int)target;
	}
	else
	{
		err = pg_user2kernel(&ktarget, (unsigned int)target, tproc);
		if(err) goto vmm_memcpyuser_wtf;
c0406e27:	90                   	nop
c0406e28:	eb 04                	jmp    c0406e2e <vmm_memcpyuser+0xc3>
	}

	if(((unsigned int)source + count) >= KERNEL_SPACE_BASE)
	{
		/* copying from kernel, sproc must be NULL */
		if(sproc) goto vmm_memcpyuser_wtf;
c0406e2a:	90                   	nop
c0406e2b:	eb 01                	jmp    c0406e2e <vmm_memcpyuser+0xc3>
		ksource = (unsigned int)source;
	}
	else
	{
		err = pg_user2kernel(&ksource, (unsigned int)source, sproc);
		if(err) goto vmm_memcpyuser_wtf;
c0406e2d:	90                   	nop
vmm_memcpyuser_wtf:
	dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n" DEBUG_COL_OFF
			  "              target = %p (proc %p)\n" DEBUG_COL_OFF
			  "              source = %p (proc %p)\n" DEBUG_COL_OFF
			  "              copying: %i bytes\n" DEBUG_COL_OFF,
			  CPU_ID, target, tproc, source, sproc, count);
c0406e2e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
	return success;
	
vmm_memcpyuser_wtf:
	dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n" DEBUG_COL_OFF
c0406e33:	3c 01                	cmp    $0x1,%al
c0406e35:	76 0c                	jbe    c0406e43 <vmm_memcpyuser+0xd8>
			  "              target = %p (proc %p)\n" DEBUG_COL_OFF
			  "              source = %p (proc %p)\n" DEBUG_COL_OFF
			  "              copying: %i bytes\n" DEBUG_COL_OFF,
			  CPU_ID, target, tproc, source, sproc, count);
c0406e37:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0406e3c:	8b 00                	mov    (%eax),%eax
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
	return success;
	
vmm_memcpyuser_wtf:
	dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n" DEBUG_COL_OFF
c0406e3e:	c1 e8 18             	shr    $0x18,%eax
c0406e41:	eb 08                	jmp    c0406e4b <vmm_memcpyuser+0xe0>
c0406e43:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0406e48:	0f b6 c0             	movzbl %al,%eax
c0406e4b:	83 ec 04             	sub    $0x4,%esp
c0406e4e:	ff 74 24 34          	pushl  0x34(%esp)
c0406e52:	ff 74 24 34          	pushl  0x34(%esp)
c0406e56:	ff 74 24 34          	pushl  0x34(%esp)
c0406e5a:	ff 74 24 34          	pushl  0x34(%esp)
c0406e5e:	ff 74 24 34          	pushl  0x34(%esp)
c0406e62:	50                   	push   %eax
c0406e63:	68 3c ef 40 c0       	push   $0xc040ef3c
c0406e68:	e8 e9 65 00 00       	call   c040d456 <debug_printf>
c0406e6d:	83 c4 20             	add    $0x20,%esp
			  "              target = %p (proc %p)\n" DEBUG_COL_OFF
			  "              source = %p (proc %p)\n" DEBUG_COL_OFF
			  "              copying: %i bytes\n" DEBUG_COL_OFF,
			  CPU_ID, target, tproc, source, sproc, count);
	debug_stacktrace();
c0406e70:	e8 fe 5e 00 00       	call   c040cd73 <debug_stacktrace>
	return err;
c0406e75:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0406e79:	83 c4 1c             	add    $0x1c,%esp
c0406e7c:	c3                   	ret    

c0406e7d <sglib___vmm_tree_fix_left_insertion_discrepancy>:
 indicate it's greater than base+size of y */
#define vmm_cmp_vma(x, y) ( (x->area->base) < (y->area->base) ? -1 : ( (x->area->base) >= ((y->area->base) + (y->area->size)) ? 1 : 0 ) )

/* pointers to vmas are stored in a per-process balanced binary tree */
SGLIB_DEFINE_RBTREE_PROTOTYPES(vmm_tree, left, right, colour, vmm_cmp_vma);
SGLIB_DEFINE_RBTREE_FUNCTIONS(vmm_tree, left, right, colour, vmm_cmp_vma);
c0406e7d:	83 ec 30             	sub    $0x30,%esp
c0406e80:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406e84:	8b 00                	mov    (%eax),%eax
c0406e86:	89 44 24 08          	mov    %eax,0x8(%esp)
c0406e8a:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406e8e:	8b 40 04             	mov    0x4(%eax),%eax
c0406e91:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0406e95:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406e99:	8b 40 08             	mov    0x8(%eax),%eax
c0406e9c:	85 c0                	test   %eax,%eax
c0406e9e:	74 7a                	je     c0406f1a <sglib___vmm_tree_fix_left_insertion_discrepancy+0x9d>
c0406ea0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406ea4:	8b 40 08             	mov    0x8(%eax),%eax
c0406ea7:	8a 40 0c             	mov    0xc(%eax),%al
c0406eaa:	3c 01                	cmp    $0x1,%al
c0406eac:	75 6c                	jne    c0406f1a <sglib___vmm_tree_fix_left_insertion_discrepancy+0x9d>
c0406eae:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406eb2:	8a 40 0c             	mov    0xc(%eax),%al
c0406eb5:	3c 01                	cmp    $0x1,%al
c0406eb7:	0f 85 99 01 00 00    	jne    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406ebd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406ec1:	8b 40 04             	mov    0x4(%eax),%eax
c0406ec4:	85 c0                	test   %eax,%eax
c0406ec6:	74 0e                	je     c0406ed6 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x59>
c0406ec8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406ecc:	8b 40 04             	mov    0x4(%eax),%eax
c0406ecf:	8a 40 0c             	mov    0xc(%eax),%al
c0406ed2:	3c 01                	cmp    $0x1,%al
c0406ed4:	74 21                	je     c0406ef7 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x7a>
c0406ed6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406eda:	8b 40 08             	mov    0x8(%eax),%eax
c0406edd:	85 c0                	test   %eax,%eax
c0406edf:	0f 84 71 01 00 00    	je     c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406ee5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406ee9:	8b 40 08             	mov    0x8(%eax),%eax
c0406eec:	8a 40 0c             	mov    0xc(%eax),%al
c0406eef:	3c 01                	cmp    $0x1,%al
c0406ef1:	0f 85 5f 01 00 00    	jne    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406ef7:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406efb:	8b 40 04             	mov    0x4(%eax),%eax
c0406efe:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0406f02:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406f06:	8b 40 08             	mov    0x8(%eax),%eax
c0406f09:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0406f0d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406f11:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0406f15:	e9 3c 01 00 00       	jmp    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406f1a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406f1e:	8a 40 0c             	mov    0xc(%eax),%al
c0406f21:	3c 01                	cmp    $0x1,%al
c0406f23:	0f 85 2d 01 00 00    	jne    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406f29:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406f2d:	8b 40 04             	mov    0x4(%eax),%eax
c0406f30:	85 c0                	test   %eax,%eax
c0406f32:	74 74                	je     c0406fa8 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x12b>
c0406f34:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406f38:	8b 40 04             	mov    0x4(%eax),%eax
c0406f3b:	8a 40 0c             	mov    0xc(%eax),%al
c0406f3e:	3c 01                	cmp    $0x1,%al
c0406f40:	75 66                	jne    c0406fa8 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x12b>
c0406f42:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406f46:	89 44 24 10          	mov    %eax,0x10(%esp)
c0406f4a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406f4e:	89 44 24 14          	mov    %eax,0x14(%esp)
c0406f52:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406f56:	8b 40 04             	mov    0x4(%eax),%eax
c0406f59:	89 44 24 18          	mov    %eax,0x18(%esp)
c0406f5d:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406f61:	8b 40 08             	mov    0x8(%eax),%eax
c0406f64:	89 44 24 24          	mov    %eax,0x24(%esp)
c0406f68:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406f6c:	8b 54 24 24          	mov    0x24(%esp),%edx
c0406f70:	89 50 04             	mov    %edx,0x4(%eax)
c0406f73:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406f77:	8b 54 24 18          	mov    0x18(%esp),%edx
c0406f7b:	89 50 04             	mov    %edx,0x4(%eax)
c0406f7e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406f82:	8b 54 24 10          	mov    0x10(%esp),%edx
c0406f86:	89 50 08             	mov    %edx,0x8(%eax)
c0406f89:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406f8d:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0406f91:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406f95:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0406f99:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406f9d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0406fa1:	89 10                	mov    %edx,(%eax)
c0406fa3:	e9 ae 00 00 00       	jmp    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406fa8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406fac:	8b 40 08             	mov    0x8(%eax),%eax
c0406faf:	85 c0                	test   %eax,%eax
c0406fb1:	0f 84 9f 00 00 00    	je     c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406fb7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406fbb:	8b 40 08             	mov    0x8(%eax),%eax
c0406fbe:	8a 40 0c             	mov    0xc(%eax),%al
c0406fc1:	3c 01                	cmp    $0x1,%al
c0406fc3:	0f 85 8d 00 00 00    	jne    c0407056 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0406fc9:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406fcd:	89 44 24 10          	mov    %eax,0x10(%esp)
c0406fd1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406fd5:	89 44 24 14          	mov    %eax,0x14(%esp)
c0406fd9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406fdd:	8b 40 08             	mov    0x8(%eax),%eax
c0406fe0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0406fe4:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406fe8:	8b 40 04             	mov    0x4(%eax),%eax
c0406feb:	89 44 24 20          	mov    %eax,0x20(%esp)
c0406fef:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406ff3:	8b 40 08             	mov    0x8(%eax),%eax
c0406ff6:	89 44 24 18          	mov    %eax,0x18(%esp)
c0406ffa:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406ffe:	8b 40 04             	mov    0x4(%eax),%eax
c0407001:	89 44 24 28          	mov    %eax,0x28(%esp)
c0407005:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407009:	8b 40 08             	mov    0x8(%eax),%eax
c040700c:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0407010:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407014:	8b 54 24 28          	mov    0x28(%esp),%edx
c0407018:	89 50 08             	mov    %edx,0x8(%eax)
c040701b:	8b 44 24 10          	mov    0x10(%esp),%eax
c040701f:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0407023:	89 50 04             	mov    %edx,0x4(%eax)
c0407026:	8b 44 24 18          	mov    0x18(%esp),%eax
c040702a:	8b 54 24 14          	mov    0x14(%esp),%edx
c040702e:	89 50 04             	mov    %edx,0x4(%eax)
c0407031:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407035:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407039:	89 50 08             	mov    %edx,0x8(%eax)
c040703c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407040:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407044:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407048:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c040704c:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407050:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407054:	89 10                	mov    %edx,(%eax)
c0407056:	83 c4 30             	add    $0x30,%esp
c0407059:	c3                   	ret    

c040705a <sglib___vmm_tree_fix_right_insertion_discrepancy>:
c040705a:	83 ec 30             	sub    $0x30,%esp
c040705d:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407061:	8b 00                	mov    (%eax),%eax
c0407063:	89 44 24 08          	mov    %eax,0x8(%esp)
c0407067:	8b 44 24 08          	mov    0x8(%esp),%eax
c040706b:	8b 40 08             	mov    0x8(%eax),%eax
c040706e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0407072:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407076:	8b 40 04             	mov    0x4(%eax),%eax
c0407079:	85 c0                	test   %eax,%eax
c040707b:	74 7a                	je     c04070f7 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x9d>
c040707d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407081:	8b 40 04             	mov    0x4(%eax),%eax
c0407084:	8a 40 0c             	mov    0xc(%eax),%al
c0407087:	3c 01                	cmp    $0x1,%al
c0407089:	75 6c                	jne    c04070f7 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x9d>
c040708b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040708f:	8a 40 0c             	mov    0xc(%eax),%al
c0407092:	3c 01                	cmp    $0x1,%al
c0407094:	0f 85 99 01 00 00    	jne    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c040709a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040709e:	8b 40 08             	mov    0x8(%eax),%eax
c04070a1:	85 c0                	test   %eax,%eax
c04070a3:	74 0e                	je     c04070b3 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x59>
c04070a5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04070a9:	8b 40 08             	mov    0x8(%eax),%eax
c04070ac:	8a 40 0c             	mov    0xc(%eax),%al
c04070af:	3c 01                	cmp    $0x1,%al
c04070b1:	74 21                	je     c04070d4 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x7a>
c04070b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04070b7:	8b 40 04             	mov    0x4(%eax),%eax
c04070ba:	85 c0                	test   %eax,%eax
c04070bc:	0f 84 71 01 00 00    	je     c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c04070c2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04070c6:	8b 40 04             	mov    0x4(%eax),%eax
c04070c9:	8a 40 0c             	mov    0xc(%eax),%al
c04070cc:	3c 01                	cmp    $0x1,%al
c04070ce:	0f 85 5f 01 00 00    	jne    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c04070d4:	8b 44 24 08          	mov    0x8(%esp),%eax
c04070d8:	8b 40 08             	mov    0x8(%eax),%eax
c04070db:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04070df:	8b 44 24 08          	mov    0x8(%esp),%eax
c04070e3:	8b 40 04             	mov    0x4(%eax),%eax
c04070e6:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04070ea:	8b 44 24 08          	mov    0x8(%esp),%eax
c04070ee:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c04070f2:	e9 3c 01 00 00       	jmp    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c04070f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04070fb:	8a 40 0c             	mov    0xc(%eax),%al
c04070fe:	3c 01                	cmp    $0x1,%al
c0407100:	0f 85 2d 01 00 00    	jne    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0407106:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040710a:	8b 40 08             	mov    0x8(%eax),%eax
c040710d:	85 c0                	test   %eax,%eax
c040710f:	74 74                	je     c0407185 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x12b>
c0407111:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407115:	8b 40 08             	mov    0x8(%eax),%eax
c0407118:	8a 40 0c             	mov    0xc(%eax),%al
c040711b:	3c 01                	cmp    $0x1,%al
c040711d:	75 66                	jne    c0407185 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x12b>
c040711f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407123:	89 44 24 10          	mov    %eax,0x10(%esp)
c0407127:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040712b:	89 44 24 14          	mov    %eax,0x14(%esp)
c040712f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407133:	8b 40 08             	mov    0x8(%eax),%eax
c0407136:	89 44 24 18          	mov    %eax,0x18(%esp)
c040713a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040713e:	8b 40 04             	mov    0x4(%eax),%eax
c0407141:	89 44 24 24          	mov    %eax,0x24(%esp)
c0407145:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407149:	8b 54 24 24          	mov    0x24(%esp),%edx
c040714d:	89 50 08             	mov    %edx,0x8(%eax)
c0407150:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407154:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407158:	89 50 08             	mov    %edx,0x8(%eax)
c040715b:	8b 44 24 14          	mov    0x14(%esp),%eax
c040715f:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407163:	89 50 04             	mov    %edx,0x4(%eax)
c0407166:	8b 44 24 10          	mov    0x10(%esp),%eax
c040716a:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c040716e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407172:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407176:	8b 44 24 34          	mov    0x34(%esp),%eax
c040717a:	8b 54 24 14          	mov    0x14(%esp),%edx
c040717e:	89 10                	mov    %edx,(%eax)
c0407180:	e9 ae 00 00 00       	jmp    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0407185:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407189:	8b 40 04             	mov    0x4(%eax),%eax
c040718c:	85 c0                	test   %eax,%eax
c040718e:	0f 84 9f 00 00 00    	je     c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0407194:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407198:	8b 40 04             	mov    0x4(%eax),%eax
c040719b:	8a 40 0c             	mov    0xc(%eax),%al
c040719e:	3c 01                	cmp    $0x1,%al
c04071a0:	0f 85 8d 00 00 00    	jne    c0407233 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c04071a6:	8b 44 24 08          	mov    0x8(%esp),%eax
c04071aa:	89 44 24 10          	mov    %eax,0x10(%esp)
c04071ae:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04071b2:	89 44 24 14          	mov    %eax,0x14(%esp)
c04071b6:	8b 44 24 10          	mov    0x10(%esp),%eax
c04071ba:	8b 40 04             	mov    0x4(%eax),%eax
c04071bd:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04071c1:	8b 44 24 14          	mov    0x14(%esp),%eax
c04071c5:	8b 40 08             	mov    0x8(%eax),%eax
c04071c8:	89 44 24 20          	mov    %eax,0x20(%esp)
c04071cc:	8b 44 24 14          	mov    0x14(%esp),%eax
c04071d0:	8b 40 04             	mov    0x4(%eax),%eax
c04071d3:	89 44 24 18          	mov    %eax,0x18(%esp)
c04071d7:	8b 44 24 18          	mov    0x18(%esp),%eax
c04071db:	8b 40 08             	mov    0x8(%eax),%eax
c04071de:	89 44 24 28          	mov    %eax,0x28(%esp)
c04071e2:	8b 44 24 18          	mov    0x18(%esp),%eax
c04071e6:	8b 40 04             	mov    0x4(%eax),%eax
c04071e9:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c04071ed:	8b 44 24 14          	mov    0x14(%esp),%eax
c04071f1:	8b 54 24 28          	mov    0x28(%esp),%edx
c04071f5:	89 50 04             	mov    %edx,0x4(%eax)
c04071f8:	8b 44 24 10          	mov    0x10(%esp),%eax
c04071fc:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0407200:	89 50 08             	mov    %edx,0x8(%eax)
c0407203:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407207:	8b 54 24 14          	mov    0x14(%esp),%edx
c040720b:	89 50 08             	mov    %edx,0x8(%eax)
c040720e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407212:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407216:	89 50 04             	mov    %edx,0x4(%eax)
c0407219:	8b 44 24 18          	mov    0x18(%esp),%eax
c040721d:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407221:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407225:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0407229:	8b 44 24 34          	mov    0x34(%esp),%eax
c040722d:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407231:	89 10                	mov    %edx,(%eax)
c0407233:	83 c4 30             	add    $0x30,%esp
c0407236:	c3                   	ret    

c0407237 <sglib___vmm_tree_fix_left_deletion_discrepancy>:
c0407237:	83 ec 4c             	sub    $0x4c,%esp
c040723a:	8b 44 24 50          	mov    0x50(%esp),%eax
c040723e:	8b 00                	mov    (%eax),%eax
c0407240:	89 44 24 14          	mov    %eax,0x14(%esp)
c0407244:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407248:	89 44 24 10          	mov    %eax,0x10(%esp)
c040724c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0407251:	75 1c                	jne    c040726f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x38>
c0407253:	68 1e 03 00 00       	push   $0x31e
c0407258:	68 d5 ef 40 c0       	push   $0xc040efd5
c040725d:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407262:	68 e6 ef 40 c0       	push   $0xc040efe6
c0407267:	e8 f7 5c 00 00       	call   c040cf63 <debug_assert>
c040726c:	83 c4 10             	add    $0x10,%esp
c040726f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407273:	8b 40 04             	mov    0x4(%eax),%eax
c0407276:	89 44 24 24          	mov    %eax,0x24(%esp)
c040727a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040727e:	8b 40 08             	mov    0x8(%eax),%eax
c0407281:	89 44 24 18          	mov    %eax,0x18(%esp)
c0407285:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c040728a:	75 3c                	jne    c04072c8 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x91>
c040728c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407290:	8a 40 0c             	mov    0xc(%eax),%al
c0407293:	3c 01                	cmp    $0x1,%al
c0407295:	74 1c                	je     c04072b3 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x7c>
c0407297:	68 1e 03 00 00       	push   $0x31e
c040729c:	68 d5 ef 40 c0       	push   $0xc040efd5
c04072a1:	68 d5 ef 40 c0       	push   $0xc040efd5
c04072a6:	68 f0 ef 40 c0       	push   $0xc040eff0
c04072ab:	e8 b3 5c 00 00       	call   c040cf63 <debug_assert>
c04072b0:	83 c4 10             	add    $0x10,%esp
c04072b3:	8b 44 24 10          	mov    0x10(%esp),%eax
c04072b7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04072bb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04072c2:	00 
c04072c3:	e9 41 05 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04072c8:	8b 44 24 18          	mov    0x18(%esp),%eax
c04072cc:	8b 40 08             	mov    0x8(%eax),%eax
c04072cf:	89 44 24 28          	mov    %eax,0x28(%esp)
c04072d3:	8b 44 24 18          	mov    0x18(%esp),%eax
c04072d7:	8b 40 04             	mov    0x4(%eax),%eax
c04072da:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c04072de:	8b 44 24 18          	mov    0x18(%esp),%eax
c04072e2:	8a 40 0c             	mov    0xc(%eax),%al
c04072e5:	3c 01                	cmp    $0x1,%al
c04072e7:	0f 85 ae 02 00 00    	jne    c040759b <sglib___vmm_tree_fix_left_deletion_discrepancy+0x364>
c04072ed:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04072f2:	75 35                	jne    c0407329 <sglib___vmm_tree_fix_left_deletion_discrepancy+0xf2>
c04072f4:	8b 44 24 50          	mov    0x50(%esp),%eax
c04072f8:	8b 54 24 18          	mov    0x18(%esp),%edx
c04072fc:	89 10                	mov    %edx,(%eax)
c04072fe:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407302:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407306:	8b 44 24 18          	mov    0x18(%esp),%eax
c040730a:	8b 54 24 14          	mov    0x14(%esp),%edx
c040730e:	89 50 04             	mov    %edx,0x4(%eax)
c0407311:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407315:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0407319:	89 50 08             	mov    %edx,0x8(%eax)
c040731c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407323:	00 
c0407324:	e9 e0 04 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c0407329:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040732d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0407331:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0407336:	74 0b                	je     c0407343 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x10c>
c0407338:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040733c:	8a 40 0c             	mov    0xc(%eax),%al
c040733f:	84 c0                	test   %al,%al
c0407341:	74 1c                	je     c040735f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x128>
c0407343:	68 1e 03 00 00       	push   $0x31e
c0407348:	68 d5 ef 40 c0       	push   $0xc040efd5
c040734d:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407352:	68 10 f0 40 c0       	push   $0xc040f010
c0407357:	e8 07 5c 00 00       	call   c040cf63 <debug_assert>
c040735c:	83 c4 10             	add    $0x10,%esp
c040735f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407363:	8b 40 08             	mov    0x8(%eax),%eax
c0407366:	89 44 24 30          	mov    %eax,0x30(%esp)
c040736a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040736e:	8b 40 04             	mov    0x4(%eax),%eax
c0407371:	89 44 24 34          	mov    %eax,0x34(%esp)
c0407375:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040737a:	74 0b                	je     c0407387 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x150>
c040737c:	8b 44 24 30          	mov    0x30(%esp),%eax
c0407380:	8a 40 0c             	mov    0xc(%eax),%al
c0407383:	84 c0                	test   %al,%al
c0407385:	75 4f                	jne    c04073d6 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x19f>
c0407387:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c040738c:	74 0b                	je     c0407399 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x162>
c040738e:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407392:	8a 40 0c             	mov    0xc(%eax),%al
c0407395:	84 c0                	test   %al,%al
c0407397:	75 3d                	jne    c04073d6 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x19f>
c0407399:	8b 44 24 50          	mov    0x50(%esp),%eax
c040739d:	8b 54 24 18          	mov    0x18(%esp),%edx
c04073a1:	89 10                	mov    %edx,(%eax)
c04073a3:	8b 44 24 18          	mov    0x18(%esp),%eax
c04073a7:	8b 54 24 14          	mov    0x14(%esp),%edx
c04073ab:	89 50 04             	mov    %edx,0x4(%eax)
c04073ae:	8b 44 24 18          	mov    0x18(%esp),%eax
c04073b2:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04073b6:	8b 44 24 14          	mov    0x14(%esp),%eax
c04073ba:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04073be:	89 50 08             	mov    %edx,0x8(%eax)
c04073c1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04073c5:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c04073c9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04073d0:	00 
c04073d1:	e9 33 04 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04073d6:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04073db:	0f 84 e0 00 00 00    	je     c04074c1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x28a>
c04073e1:	8b 44 24 30          	mov    0x30(%esp),%eax
c04073e5:	8a 40 0c             	mov    0xc(%eax),%al
c04073e8:	3c 01                	cmp    $0x1,%al
c04073ea:	0f 85 d1 00 00 00    	jne    c04074c1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x28a>
c04073f0:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04073f5:	74 74                	je     c040746b <sglib___vmm_tree_fix_left_deletion_discrepancy+0x234>
c04073f7:	8b 44 24 34          	mov    0x34(%esp),%eax
c04073fb:	8a 40 0c             	mov    0xc(%eax),%al
c04073fe:	3c 01                	cmp    $0x1,%al
c0407400:	75 69                	jne    c040746b <sglib___vmm_tree_fix_left_deletion_discrepancy+0x234>
c0407402:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407406:	89 44 24 20          	mov    %eax,0x20(%esp)
c040740a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040740e:	8b 40 08             	mov    0x8(%eax),%eax
c0407411:	89 44 24 38          	mov    %eax,0x38(%esp)
c0407415:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407419:	8b 40 04             	mov    0x4(%eax),%eax
c040741c:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0407420:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407424:	8b 54 24 20          	mov    0x20(%esp),%edx
c0407428:	89 10                	mov    %edx,(%eax)
c040742a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040742e:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407432:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407436:	8b 54 24 18          	mov    0x18(%esp),%edx
c040743a:	89 50 08             	mov    %edx,0x8(%eax)
c040743d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407441:	8b 54 24 38          	mov    0x38(%esp),%edx
c0407445:	89 50 04             	mov    %edx,0x4(%eax)
c0407448:	8b 44 24 20          	mov    0x20(%esp),%eax
c040744c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407450:	89 50 04             	mov    %edx,0x4(%eax)
c0407453:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407457:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c040745b:	89 50 08             	mov    %edx,0x8(%eax)
c040745e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407465:	00 
c0407466:	e9 9e 03 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040746b:	8b 44 24 50          	mov    0x50(%esp),%eax
c040746f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407473:	89 10                	mov    %edx,(%eax)
c0407475:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407479:	8b 54 24 18          	mov    0x18(%esp),%edx
c040747d:	89 50 08             	mov    %edx,0x8(%eax)
c0407480:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407484:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407488:	89 50 04             	mov    %edx,0x4(%eax)
c040748b:	8b 44 24 18          	mov    0x18(%esp),%eax
c040748f:	8b 54 24 28          	mov    0x28(%esp),%edx
c0407493:	89 50 08             	mov    %edx,0x8(%eax)
c0407496:	8b 44 24 18          	mov    0x18(%esp),%eax
c040749a:	8b 54 24 30          	mov    0x30(%esp),%edx
c040749e:	89 50 04             	mov    %edx,0x4(%eax)
c04074a1:	8b 44 24 14          	mov    0x14(%esp),%eax
c04074a5:	8b 54 24 34          	mov    0x34(%esp),%edx
c04074a9:	89 50 08             	mov    %edx,0x8(%eax)
c04074ac:	8b 44 24 30          	mov    0x30(%esp),%eax
c04074b0:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04074b4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04074bb:	00 
c04074bc:	e9 48 03 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04074c1:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04074c6:	0f 84 a6 00 00 00    	je     c0407572 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x33b>
c04074cc:	8b 44 24 34          	mov    0x34(%esp),%eax
c04074d0:	8a 40 0c             	mov    0xc(%eax),%al
c04074d3:	3c 01                	cmp    $0x1,%al
c04074d5:	0f 85 97 00 00 00    	jne    c0407572 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x33b>
c04074db:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04074e0:	74 27                	je     c0407509 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x2d2>
c04074e2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04074e6:	8a 40 0c             	mov    0xc(%eax),%al
c04074e9:	84 c0                	test   %al,%al
c04074eb:	74 1c                	je     c0407509 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x2d2>
c04074ed:	68 1e 03 00 00       	push   $0x31e
c04074f2:	68 d5 ef 40 c0       	push   $0xc040efd5
c04074f7:	68 d5 ef 40 c0       	push   $0xc040efd5
c04074fc:	68 3c f0 40 c0       	push   $0xc040f03c
c0407501:	e8 5d 5a 00 00       	call   c040cf63 <debug_assert>
c0407506:	83 c4 10             	add    $0x10,%esp
c0407509:	8b 44 24 34          	mov    0x34(%esp),%eax
c040750d:	89 44 24 20          	mov    %eax,0x20(%esp)
c0407511:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407515:	8b 40 08             	mov    0x8(%eax),%eax
c0407518:	89 44 24 38          	mov    %eax,0x38(%esp)
c040751c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407520:	8b 40 04             	mov    0x4(%eax),%eax
c0407523:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0407527:	8b 44 24 50          	mov    0x50(%esp),%eax
c040752b:	8b 54 24 20          	mov    0x20(%esp),%edx
c040752f:	89 10                	mov    %edx,(%eax)
c0407531:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407535:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407539:	8b 44 24 20          	mov    0x20(%esp),%eax
c040753d:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407541:	89 50 08             	mov    %edx,0x8(%eax)
c0407544:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407548:	8b 54 24 38          	mov    0x38(%esp),%edx
c040754c:	89 50 04             	mov    %edx,0x4(%eax)
c040754f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407553:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407557:	89 50 04             	mov    %edx,0x4(%eax)
c040755a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040755e:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0407562:	89 50 08             	mov    %edx,0x8(%eax)
c0407565:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040756c:	00 
c040756d:	e9 97 02 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c0407572:	68 1e 03 00 00       	push   $0x31e
c0407577:	68 d5 ef 40 c0       	push   $0xc040efd5
c040757c:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407581:	68 69 f0 40 c0       	push   $0xc040f069
c0407586:	e8 d8 59 00 00       	call   c040cf63 <debug_assert>
c040758b:	83 c4 10             	add    $0x10,%esp
c040758e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407595:	00 
c0407596:	e9 6e 02 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040759b:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04075a0:	74 0b                	je     c04075ad <sglib___vmm_tree_fix_left_deletion_discrepancy+0x376>
c04075a2:	8b 44 24 28          	mov    0x28(%esp),%eax
c04075a6:	8a 40 0c             	mov    0xc(%eax),%al
c04075a9:	84 c0                	test   %al,%al
c04075ab:	75 3a                	jne    c04075e7 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3b0>
c04075ad:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04075b2:	74 0b                	je     c04075bf <sglib___vmm_tree_fix_left_deletion_discrepancy+0x388>
c04075b4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04075b8:	8a 40 0c             	mov    0xc(%eax),%al
c04075bb:	84 c0                	test   %al,%al
c04075bd:	75 28                	jne    c04075e7 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3b0>
c04075bf:	8b 44 24 14          	mov    0x14(%esp),%eax
c04075c3:	8a 40 0c             	mov    0xc(%eax),%al
c04075c6:	84 c0                	test   %al,%al
c04075c8:	0f 94 c0             	sete   %al
c04075cb:	0f b6 c0             	movzbl %al,%eax
c04075ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04075d2:	8b 44 24 14          	mov    0x14(%esp),%eax
c04075d6:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04075da:	8b 44 24 18          	mov    0x18(%esp),%eax
c04075de:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c04075e2:	e9 22 02 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04075e7:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04075ec:	0f 84 77 01 00 00    	je     c0407769 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x532>
c04075f2:	8b 44 24 28          	mov    0x28(%esp),%eax
c04075f6:	8a 40 0c             	mov    0xc(%eax),%al
c04075f9:	3c 01                	cmp    $0x1,%al
c04075fb:	0f 85 68 01 00 00    	jne    c0407769 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x532>
c0407601:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407606:	74 0b                	je     c0407613 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3dc>
c0407608:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040760c:	8a 40 0c             	mov    0xc(%eax),%al
c040760f:	84 c0                	test   %al,%al
c0407611:	75 4b                	jne    c040765e <sglib___vmm_tree_fix_left_deletion_discrepancy+0x427>
c0407613:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407617:	8b 54 24 18          	mov    0x18(%esp),%edx
c040761b:	89 10                	mov    %edx,(%eax)
c040761d:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407621:	8a 50 0c             	mov    0xc(%eax),%dl
c0407624:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407628:	88 50 0c             	mov    %dl,0xc(%eax)
c040762b:	8b 44 24 14          	mov    0x14(%esp),%eax
c040762f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407633:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407637:	8b 54 24 14          	mov    0x14(%esp),%edx
c040763b:	89 50 04             	mov    %edx,0x4(%eax)
c040763e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407642:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0407646:	89 50 08             	mov    %edx,0x8(%eax)
c0407649:	8b 44 24 28          	mov    0x28(%esp),%eax
c040764d:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407651:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407658:	00 
c0407659:	e9 ab 01 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040765e:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0407663:	75 1c                	jne    c0407681 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x44a>
c0407665:	68 1e 03 00 00       	push   $0x31e
c040766a:	68 d5 ef 40 c0       	push   $0xc040efd5
c040766f:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407674:	68 6b f0 40 c0       	push   $0xc040f06b
c0407679:	e8 e5 58 00 00       	call   c040cf63 <debug_assert>
c040767e:	83 c4 10             	add    $0x10,%esp
c0407681:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407686:	75 1c                	jne    c04076a4 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x46d>
c0407688:	68 1e 03 00 00       	push   $0x31e
c040768d:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407692:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407697:	68 74 f0 40 c0       	push   $0xc040f074
c040769c:	e8 c2 58 00 00       	call   c040cf63 <debug_assert>
c04076a1:	83 c4 10             	add    $0x10,%esp
c04076a4:	8b 44 24 28          	mov    0x28(%esp),%eax
c04076a8:	8a 40 0c             	mov    0xc(%eax),%al
c04076ab:	3c 01                	cmp    $0x1,%al
c04076ad:	74 1c                	je     c04076cb <sglib___vmm_tree_fix_left_deletion_discrepancy+0x494>
c04076af:	68 1e 03 00 00       	push   $0x31e
c04076b4:	68 d5 ef 40 c0       	push   $0xc040efd5
c04076b9:	68 d5 ef 40 c0       	push   $0xc040efd5
c04076be:	68 80 f0 40 c0       	push   $0xc040f080
c04076c3:	e8 9b 58 00 00       	call   c040cf63 <debug_assert>
c04076c8:	83 c4 10             	add    $0x10,%esp
c04076cb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04076cf:	8a 40 0c             	mov    0xc(%eax),%al
c04076d2:	3c 01                	cmp    $0x1,%al
c04076d4:	74 1c                	je     c04076f2 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x4bb>
c04076d6:	68 1e 03 00 00       	push   $0x31e
c04076db:	68 d5 ef 40 c0       	push   $0xc040efd5
c04076e0:	68 d5 ef 40 c0       	push   $0xc040efd5
c04076e5:	68 a4 f0 40 c0       	push   $0xc040f0a4
c04076ea:	e8 74 58 00 00       	call   c040cf63 <debug_assert>
c04076ef:	83 c4 10             	add    $0x10,%esp
c04076f2:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04076f6:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04076fa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04076fe:	8b 40 08             	mov    0x8(%eax),%eax
c0407701:	89 44 24 30          	mov    %eax,0x30(%esp)
c0407705:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407709:	8b 40 04             	mov    0x4(%eax),%eax
c040770c:	89 44 24 34          	mov    %eax,0x34(%esp)
c0407710:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407714:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407718:	89 10                	mov    %edx,(%eax)
c040771a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040771e:	8a 50 0c             	mov    0xc(%eax),%dl
c0407721:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407725:	88 50 0c             	mov    %dl,0xc(%eax)
c0407728:	8b 44 24 14          	mov    0x14(%esp),%eax
c040772c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407730:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407734:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407738:	89 50 08             	mov    %edx,0x8(%eax)
c040773b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040773f:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407743:	89 50 04             	mov    %edx,0x4(%eax)
c0407746:	8b 44 24 18          	mov    0x18(%esp),%eax
c040774a:	8b 54 24 30          	mov    0x30(%esp),%edx
c040774e:	89 50 04             	mov    %edx,0x4(%eax)
c0407751:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407755:	8b 54 24 34          	mov    0x34(%esp),%edx
c0407759:	89 50 08             	mov    %edx,0x8(%eax)
c040775c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407763:	00 
c0407764:	e9 a0 00 00 00       	jmp    c0407809 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c0407769:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c040776e:	74 0b                	je     c040777b <sglib___vmm_tree_fix_left_deletion_discrepancy+0x544>
c0407770:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407774:	8a 40 0c             	mov    0xc(%eax),%al
c0407777:	3c 01                	cmp    $0x1,%al
c0407779:	74 1c                	je     c0407797 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x560>
c040777b:	68 1e 03 00 00       	push   $0x31e
c0407780:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407785:	68 d5 ef 40 c0       	push   $0xc040efd5
c040778a:	68 c8 f0 40 c0       	push   $0xc040f0c8
c040778f:	e8 cf 57 00 00       	call   c040cf63 <debug_assert>
c0407794:	83 c4 10             	add    $0x10,%esp
c0407797:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040779b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c040779f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077a3:	8b 40 08             	mov    0x8(%eax),%eax
c04077a6:	89 44 24 30          	mov    %eax,0x30(%esp)
c04077aa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077ae:	8b 40 04             	mov    0x4(%eax),%eax
c04077b1:	89 44 24 34          	mov    %eax,0x34(%esp)
c04077b5:	8b 44 24 50          	mov    0x50(%esp),%eax
c04077b9:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04077bd:	89 10                	mov    %edx,(%eax)
c04077bf:	8b 44 24 14          	mov    0x14(%esp),%eax
c04077c3:	8a 50 0c             	mov    0xc(%eax),%dl
c04077c6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077ca:	88 50 0c             	mov    %dl,0xc(%eax)
c04077cd:	8b 44 24 14          	mov    0x14(%esp),%eax
c04077d1:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04077d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077d9:	8b 54 24 18          	mov    0x18(%esp),%edx
c04077dd:	89 50 08             	mov    %edx,0x8(%eax)
c04077e0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077e4:	8b 54 24 14          	mov    0x14(%esp),%edx
c04077e8:	89 50 04             	mov    %edx,0x4(%eax)
c04077eb:	8b 44 24 18          	mov    0x18(%esp),%eax
c04077ef:	8b 54 24 30          	mov    0x30(%esp),%edx
c04077f3:	89 50 04             	mov    %edx,0x4(%eax)
c04077f6:	8b 44 24 14          	mov    0x14(%esp),%eax
c04077fa:	8b 54 24 34          	mov    0x34(%esp),%edx
c04077fe:	89 50 08             	mov    %edx,0x8(%eax)
c0407801:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407808:	00 
c0407809:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040780d:	83 c4 4c             	add    $0x4c,%esp
c0407810:	c3                   	ret    

c0407811 <sglib___vmm_tree_fix_right_deletion_discrepancy>:
c0407811:	83 ec 4c             	sub    $0x4c,%esp
c0407814:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407818:	8b 00                	mov    (%eax),%eax
c040781a:	89 44 24 14          	mov    %eax,0x14(%esp)
c040781e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407822:	89 44 24 10          	mov    %eax,0x10(%esp)
c0407826:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040782b:	75 1c                	jne    c0407849 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x38>
c040782d:	68 1e 03 00 00       	push   $0x31e
c0407832:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407837:	68 d5 ef 40 c0       	push   $0xc040efd5
c040783c:	68 e6 ef 40 c0       	push   $0xc040efe6
c0407841:	e8 1d 57 00 00       	call   c040cf63 <debug_assert>
c0407846:	83 c4 10             	add    $0x10,%esp
c0407849:	8b 44 24 14          	mov    0x14(%esp),%eax
c040784d:	8b 40 08             	mov    0x8(%eax),%eax
c0407850:	89 44 24 24          	mov    %eax,0x24(%esp)
c0407854:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407858:	8b 40 04             	mov    0x4(%eax),%eax
c040785b:	89 44 24 18          	mov    %eax,0x18(%esp)
c040785f:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0407864:	75 3c                	jne    c04078a2 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x91>
c0407866:	8b 44 24 10          	mov    0x10(%esp),%eax
c040786a:	8a 40 0c             	mov    0xc(%eax),%al
c040786d:	3c 01                	cmp    $0x1,%al
c040786f:	74 1c                	je     c040788d <sglib___vmm_tree_fix_right_deletion_discrepancy+0x7c>
c0407871:	68 1e 03 00 00       	push   $0x31e
c0407876:	68 d5 ef 40 c0       	push   $0xc040efd5
c040787b:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407880:	68 f0 ef 40 c0       	push   $0xc040eff0
c0407885:	e8 d9 56 00 00       	call   c040cf63 <debug_assert>
c040788a:	83 c4 10             	add    $0x10,%esp
c040788d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407891:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407895:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040789c:	00 
c040789d:	e9 41 05 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04078a2:	8b 44 24 18          	mov    0x18(%esp),%eax
c04078a6:	8b 40 04             	mov    0x4(%eax),%eax
c04078a9:	89 44 24 28          	mov    %eax,0x28(%esp)
c04078ad:	8b 44 24 18          	mov    0x18(%esp),%eax
c04078b1:	8b 40 08             	mov    0x8(%eax),%eax
c04078b4:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c04078b8:	8b 44 24 18          	mov    0x18(%esp),%eax
c04078bc:	8a 40 0c             	mov    0xc(%eax),%al
c04078bf:	3c 01                	cmp    $0x1,%al
c04078c1:	0f 85 ae 02 00 00    	jne    c0407b75 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x364>
c04078c7:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04078cc:	75 35                	jne    c0407903 <sglib___vmm_tree_fix_right_deletion_discrepancy+0xf2>
c04078ce:	8b 44 24 50          	mov    0x50(%esp),%eax
c04078d2:	8b 54 24 18          	mov    0x18(%esp),%edx
c04078d6:	89 10                	mov    %edx,(%eax)
c04078d8:	8b 44 24 18          	mov    0x18(%esp),%eax
c04078dc:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04078e0:	8b 44 24 18          	mov    0x18(%esp),%eax
c04078e4:	8b 54 24 14          	mov    0x14(%esp),%edx
c04078e8:	89 50 08             	mov    %edx,0x8(%eax)
c04078eb:	8b 44 24 14          	mov    0x14(%esp),%eax
c04078ef:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c04078f3:	89 50 04             	mov    %edx,0x4(%eax)
c04078f6:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04078fd:	00 
c04078fe:	e9 e0 04 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407903:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407907:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c040790b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0407910:	74 0b                	je     c040791d <sglib___vmm_tree_fix_right_deletion_discrepancy+0x10c>
c0407912:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407916:	8a 40 0c             	mov    0xc(%eax),%al
c0407919:	84 c0                	test   %al,%al
c040791b:	74 1c                	je     c0407939 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x128>
c040791d:	68 1e 03 00 00       	push   $0x31e
c0407922:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407927:	68 d5 ef 40 c0       	push   $0xc040efd5
c040792c:	68 10 f0 40 c0       	push   $0xc040f010
c0407931:	e8 2d 56 00 00       	call   c040cf63 <debug_assert>
c0407936:	83 c4 10             	add    $0x10,%esp
c0407939:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040793d:	8b 40 04             	mov    0x4(%eax),%eax
c0407940:	89 44 24 30          	mov    %eax,0x30(%esp)
c0407944:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407948:	8b 40 08             	mov    0x8(%eax),%eax
c040794b:	89 44 24 34          	mov    %eax,0x34(%esp)
c040794f:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0407954:	74 0b                	je     c0407961 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x150>
c0407956:	8b 44 24 30          	mov    0x30(%esp),%eax
c040795a:	8a 40 0c             	mov    0xc(%eax),%al
c040795d:	84 c0                	test   %al,%al
c040795f:	75 4f                	jne    c04079b0 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x19f>
c0407961:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0407966:	74 0b                	je     c0407973 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x162>
c0407968:	8b 44 24 34          	mov    0x34(%esp),%eax
c040796c:	8a 40 0c             	mov    0xc(%eax),%al
c040796f:	84 c0                	test   %al,%al
c0407971:	75 3d                	jne    c04079b0 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x19f>
c0407973:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407977:	8b 54 24 18          	mov    0x18(%esp),%edx
c040797b:	89 10                	mov    %edx,(%eax)
c040797d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407981:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407985:	89 50 08             	mov    %edx,0x8(%eax)
c0407988:	8b 44 24 18          	mov    0x18(%esp),%eax
c040798c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407990:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407994:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407998:	89 50 04             	mov    %edx,0x4(%eax)
c040799b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040799f:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c04079a3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04079aa:	00 
c04079ab:	e9 33 04 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04079b0:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04079b5:	0f 84 e0 00 00 00    	je     c0407a9b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x28a>
c04079bb:	8b 44 24 30          	mov    0x30(%esp),%eax
c04079bf:	8a 40 0c             	mov    0xc(%eax),%al
c04079c2:	3c 01                	cmp    $0x1,%al
c04079c4:	0f 85 d1 00 00 00    	jne    c0407a9b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x28a>
c04079ca:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04079cf:	74 74                	je     c0407a45 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x234>
c04079d1:	8b 44 24 34          	mov    0x34(%esp),%eax
c04079d5:	8a 40 0c             	mov    0xc(%eax),%al
c04079d8:	3c 01                	cmp    $0x1,%al
c04079da:	75 69                	jne    c0407a45 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x234>
c04079dc:	8b 44 24 34          	mov    0x34(%esp),%eax
c04079e0:	89 44 24 20          	mov    %eax,0x20(%esp)
c04079e4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04079e8:	8b 40 04             	mov    0x4(%eax),%eax
c04079eb:	89 44 24 38          	mov    %eax,0x38(%esp)
c04079ef:	8b 44 24 20          	mov    0x20(%esp),%eax
c04079f3:	8b 40 08             	mov    0x8(%eax),%eax
c04079f6:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c04079fa:	8b 44 24 50          	mov    0x50(%esp),%eax
c04079fe:	8b 54 24 20          	mov    0x20(%esp),%edx
c0407a02:	89 10                	mov    %edx,(%eax)
c0407a04:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a08:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407a0c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a10:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407a14:	89 50 04             	mov    %edx,0x4(%eax)
c0407a17:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407a1b:	8b 54 24 38          	mov    0x38(%esp),%edx
c0407a1f:	89 50 08             	mov    %edx,0x8(%eax)
c0407a22:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a26:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407a2a:	89 50 08             	mov    %edx,0x8(%eax)
c0407a2d:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407a31:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0407a35:	89 50 04             	mov    %edx,0x4(%eax)
c0407a38:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407a3f:	00 
c0407a40:	e9 9e 03 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407a45:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407a49:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407a4d:	89 10                	mov    %edx,(%eax)
c0407a4f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407a53:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407a57:	89 50 04             	mov    %edx,0x4(%eax)
c0407a5a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407a5e:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407a62:	89 50 08             	mov    %edx,0x8(%eax)
c0407a65:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407a69:	8b 54 24 28          	mov    0x28(%esp),%edx
c0407a6d:	89 50 04             	mov    %edx,0x4(%eax)
c0407a70:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407a74:	8b 54 24 30          	mov    0x30(%esp),%edx
c0407a78:	89 50 08             	mov    %edx,0x8(%eax)
c0407a7b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407a7f:	8b 54 24 34          	mov    0x34(%esp),%edx
c0407a83:	89 50 04             	mov    %edx,0x4(%eax)
c0407a86:	8b 44 24 30          	mov    0x30(%esp),%eax
c0407a8a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407a8e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407a95:	00 
c0407a96:	e9 48 03 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407a9b:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0407aa0:	0f 84 a6 00 00 00    	je     c0407b4c <sglib___vmm_tree_fix_right_deletion_discrepancy+0x33b>
c0407aa6:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407aaa:	8a 40 0c             	mov    0xc(%eax),%al
c0407aad:	3c 01                	cmp    $0x1,%al
c0407aaf:	0f 85 97 00 00 00    	jne    c0407b4c <sglib___vmm_tree_fix_right_deletion_discrepancy+0x33b>
c0407ab5:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0407aba:	74 27                	je     c0407ae3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x2d2>
c0407abc:	8b 44 24 30          	mov    0x30(%esp),%eax
c0407ac0:	8a 40 0c             	mov    0xc(%eax),%al
c0407ac3:	84 c0                	test   %al,%al
c0407ac5:	74 1c                	je     c0407ae3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x2d2>
c0407ac7:	68 1e 03 00 00       	push   $0x31e
c0407acc:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407ad1:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407ad6:	68 3c f0 40 c0       	push   $0xc040f03c
c0407adb:	e8 83 54 00 00       	call   c040cf63 <debug_assert>
c0407ae0:	83 c4 10             	add    $0x10,%esp
c0407ae3:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407ae7:	89 44 24 20          	mov    %eax,0x20(%esp)
c0407aeb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407aef:	8b 40 04             	mov    0x4(%eax),%eax
c0407af2:	89 44 24 38          	mov    %eax,0x38(%esp)
c0407af6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407afa:	8b 40 08             	mov    0x8(%eax),%eax
c0407afd:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0407b01:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407b05:	8b 54 24 20          	mov    0x20(%esp),%edx
c0407b09:	89 10                	mov    %edx,(%eax)
c0407b0b:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407b0f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407b13:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407b17:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407b1b:	89 50 04             	mov    %edx,0x4(%eax)
c0407b1e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407b22:	8b 54 24 38          	mov    0x38(%esp),%edx
c0407b26:	89 50 08             	mov    %edx,0x8(%eax)
c0407b29:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407b2d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407b31:	89 50 08             	mov    %edx,0x8(%eax)
c0407b34:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407b38:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0407b3c:	89 50 04             	mov    %edx,0x4(%eax)
c0407b3f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407b46:	00 
c0407b47:	e9 97 02 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407b4c:	68 1e 03 00 00       	push   $0x31e
c0407b51:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407b56:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407b5b:	68 69 f0 40 c0       	push   $0xc040f069
c0407b60:	e8 fe 53 00 00       	call   c040cf63 <debug_assert>
c0407b65:	83 c4 10             	add    $0x10,%esp
c0407b68:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407b6f:	00 
c0407b70:	e9 6e 02 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407b75:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0407b7a:	74 0b                	je     c0407b87 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x376>
c0407b7c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0407b80:	8a 40 0c             	mov    0xc(%eax),%al
c0407b83:	84 c0                	test   %al,%al
c0407b85:	75 3a                	jne    c0407bc1 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3b0>
c0407b87:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407b8c:	74 0b                	je     c0407b99 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x388>
c0407b8e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407b92:	8a 40 0c             	mov    0xc(%eax),%al
c0407b95:	84 c0                	test   %al,%al
c0407b97:	75 28                	jne    c0407bc1 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3b0>
c0407b99:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407b9d:	8a 40 0c             	mov    0xc(%eax),%al
c0407ba0:	84 c0                	test   %al,%al
c0407ba2:	0f 94 c0             	sete   %al
c0407ba5:	0f b6 c0             	movzbl %al,%eax
c0407ba8:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0407bac:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407bb0:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407bb4:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407bb8:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0407bbc:	e9 22 02 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407bc1:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0407bc6:	0f 84 77 01 00 00    	je     c0407d43 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x532>
c0407bcc:	8b 44 24 28          	mov    0x28(%esp),%eax
c0407bd0:	8a 40 0c             	mov    0xc(%eax),%al
c0407bd3:	3c 01                	cmp    $0x1,%al
c0407bd5:	0f 85 68 01 00 00    	jne    c0407d43 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x532>
c0407bdb:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407be0:	74 0b                	je     c0407bed <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3dc>
c0407be2:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407be6:	8a 40 0c             	mov    0xc(%eax),%al
c0407be9:	84 c0                	test   %al,%al
c0407beb:	75 4b                	jne    c0407c38 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x427>
c0407bed:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407bf1:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407bf5:	89 10                	mov    %edx,(%eax)
c0407bf7:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407bfb:	8a 50 0c             	mov    0xc(%eax),%dl
c0407bfe:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407c02:	88 50 0c             	mov    %dl,0xc(%eax)
c0407c05:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407c09:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407c0d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407c11:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407c15:	89 50 08             	mov    %edx,0x8(%eax)
c0407c18:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407c1c:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0407c20:	89 50 04             	mov    %edx,0x4(%eax)
c0407c23:	8b 44 24 28          	mov    0x28(%esp),%eax
c0407c27:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407c2b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407c32:	00 
c0407c33:	e9 ab 01 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407c38:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0407c3d:	75 1c                	jne    c0407c5b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x44a>
c0407c3f:	68 1e 03 00 00       	push   $0x31e
c0407c44:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c49:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c4e:	68 6b f0 40 c0       	push   $0xc040f06b
c0407c53:	e8 0b 53 00 00       	call   c040cf63 <debug_assert>
c0407c58:	83 c4 10             	add    $0x10,%esp
c0407c5b:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407c60:	75 1c                	jne    c0407c7e <sglib___vmm_tree_fix_right_deletion_discrepancy+0x46d>
c0407c62:	68 1e 03 00 00       	push   $0x31e
c0407c67:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c6c:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c71:	68 74 f0 40 c0       	push   $0xc040f074
c0407c76:	e8 e8 52 00 00       	call   c040cf63 <debug_assert>
c0407c7b:	83 c4 10             	add    $0x10,%esp
c0407c7e:	8b 44 24 28          	mov    0x28(%esp),%eax
c0407c82:	8a 40 0c             	mov    0xc(%eax),%al
c0407c85:	3c 01                	cmp    $0x1,%al
c0407c87:	74 1c                	je     c0407ca5 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x494>
c0407c89:	68 1e 03 00 00       	push   $0x31e
c0407c8e:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c93:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407c98:	68 80 f0 40 c0       	push   $0xc040f080
c0407c9d:	e8 c1 52 00 00       	call   c040cf63 <debug_assert>
c0407ca2:	83 c4 10             	add    $0x10,%esp
c0407ca5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407ca9:	8a 40 0c             	mov    0xc(%eax),%al
c0407cac:	3c 01                	cmp    $0x1,%al
c0407cae:	74 1c                	je     c0407ccc <sglib___vmm_tree_fix_right_deletion_discrepancy+0x4bb>
c0407cb0:	68 1e 03 00 00       	push   $0x31e
c0407cb5:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407cba:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407cbf:	68 a4 f0 40 c0       	push   $0xc040f0a4
c0407cc4:	e8 9a 52 00 00       	call   c040cf63 <debug_assert>
c0407cc9:	83 c4 10             	add    $0x10,%esp
c0407ccc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407cd0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0407cd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407cd8:	8b 40 04             	mov    0x4(%eax),%eax
c0407cdb:	89 44 24 30          	mov    %eax,0x30(%esp)
c0407cdf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407ce3:	8b 40 08             	mov    0x8(%eax),%eax
c0407ce6:	89 44 24 34          	mov    %eax,0x34(%esp)
c0407cea:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407cee:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407cf2:	89 10                	mov    %edx,(%eax)
c0407cf4:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407cf8:	8a 50 0c             	mov    0xc(%eax),%dl
c0407cfb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407cff:	88 50 0c             	mov    %dl,0xc(%eax)
c0407d02:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407d06:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407d0a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407d0e:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407d12:	89 50 04             	mov    %edx,0x4(%eax)
c0407d15:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407d19:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407d1d:	89 50 08             	mov    %edx,0x8(%eax)
c0407d20:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407d24:	8b 54 24 30          	mov    0x30(%esp),%edx
c0407d28:	89 50 08             	mov    %edx,0x8(%eax)
c0407d2b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407d2f:	8b 54 24 34          	mov    0x34(%esp),%edx
c0407d33:	89 50 04             	mov    %edx,0x4(%eax)
c0407d36:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407d3d:	00 
c0407d3e:	e9 a0 00 00 00       	jmp    c0407de3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0407d43:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0407d48:	74 0b                	je     c0407d55 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x544>
c0407d4a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407d4e:	8a 40 0c             	mov    0xc(%eax),%al
c0407d51:	3c 01                	cmp    $0x1,%al
c0407d53:	74 1c                	je     c0407d71 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x560>
c0407d55:	68 1e 03 00 00       	push   $0x31e
c0407d5a:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407d5f:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407d64:	68 c8 f0 40 c0       	push   $0xc040f0c8
c0407d69:	e8 f5 51 00 00       	call   c040cf63 <debug_assert>
c0407d6e:	83 c4 10             	add    $0x10,%esp
c0407d71:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0407d75:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0407d79:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407d7d:	8b 40 04             	mov    0x4(%eax),%eax
c0407d80:	89 44 24 30          	mov    %eax,0x30(%esp)
c0407d84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407d88:	8b 40 08             	mov    0x8(%eax),%eax
c0407d8b:	89 44 24 34          	mov    %eax,0x34(%esp)
c0407d8f:	8b 44 24 50          	mov    0x50(%esp),%eax
c0407d93:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407d97:	89 10                	mov    %edx,(%eax)
c0407d99:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407d9d:	8a 50 0c             	mov    0xc(%eax),%dl
c0407da0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407da4:	88 50 0c             	mov    %dl,0xc(%eax)
c0407da7:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407dab:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407daf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407db3:	8b 54 24 18          	mov    0x18(%esp),%edx
c0407db7:	89 50 04             	mov    %edx,0x4(%eax)
c0407dba:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407dbe:	8b 54 24 14          	mov    0x14(%esp),%edx
c0407dc2:	89 50 08             	mov    %edx,0x8(%eax)
c0407dc5:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407dc9:	8b 54 24 30          	mov    0x30(%esp),%edx
c0407dcd:	89 50 08             	mov    %edx,0x8(%eax)
c0407dd0:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407dd4:	8b 54 24 34          	mov    0x34(%esp),%edx
c0407dd8:	89 50 04             	mov    %edx,0x4(%eax)
c0407ddb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407de2:	00 
c0407de3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407de7:	83 c4 4c             	add    $0x4c,%esp
c0407dea:	c3                   	ret    

c0407deb <sglib___vmm_tree_add_recursive>:
c0407deb:	83 ec 1c             	sub    $0x1c,%esp
c0407dee:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407df2:	8b 00                	mov    (%eax),%eax
c0407df4:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0407df8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407dfd:	75 17                	jne    c0407e16 <sglib___vmm_tree_add_recursive+0x2b>
c0407dff:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407e03:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0407e07:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407e0b:	8b 54 24 24          	mov    0x24(%esp),%edx
c0407e0f:	89 10                	mov    %edx,(%eax)
c0407e11:	e9 c3 00 00 00       	jmp    c0407ed9 <sglib___vmm_tree_add_recursive+0xee>
c0407e16:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407e1a:	8b 00                	mov    (%eax),%eax
c0407e1c:	8b 50 08             	mov    0x8(%eax),%edx
c0407e1f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407e23:	8b 00                	mov    (%eax),%eax
c0407e25:	8b 40 08             	mov    0x8(%eax),%eax
c0407e28:	39 c2                	cmp    %eax,%edx
c0407e2a:	72 28                	jb     c0407e54 <sglib___vmm_tree_add_recursive+0x69>
c0407e2c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407e30:	8b 00                	mov    (%eax),%eax
c0407e32:	8b 50 08             	mov    0x8(%eax),%edx
c0407e35:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407e39:	8b 00                	mov    (%eax),%eax
c0407e3b:	8b 48 08             	mov    0x8(%eax),%ecx
c0407e3e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407e42:	8b 00                	mov    (%eax),%eax
c0407e44:	8b 40 0c             	mov    0xc(%eax),%eax
c0407e47:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0407e4a:	39 c2                	cmp    %eax,%edx
c0407e4c:	0f 93 c0             	setae  %al
c0407e4f:	0f b6 c0             	movzbl %al,%eax
c0407e52:	eb 05                	jmp    c0407e59 <sglib___vmm_tree_add_recursive+0x6e>
c0407e54:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0407e59:	89 44 24 08          	mov    %eax,0x8(%esp)
c0407e5d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0407e62:	78 11                	js     c0407e75 <sglib___vmm_tree_add_recursive+0x8a>
c0407e64:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0407e69:	75 3d                	jne    c0407ea8 <sglib___vmm_tree_add_recursive+0xbd>
c0407e6b:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407e6f:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0407e73:	73 33                	jae    c0407ea8 <sglib___vmm_tree_add_recursive+0xbd>
c0407e75:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407e79:	83 c0 04             	add    $0x4,%eax
c0407e7c:	83 ec 08             	sub    $0x8,%esp
c0407e7f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407e83:	50                   	push   %eax
c0407e84:	e8 62 ff ff ff       	call   c0407deb <sglib___vmm_tree_add_recursive>
c0407e89:	83 c4 10             	add    $0x10,%esp
c0407e8c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407e90:	8a 40 0c             	mov    0xc(%eax),%al
c0407e93:	84 c0                	test   %al,%al
c0407e95:	75 42                	jne    c0407ed9 <sglib___vmm_tree_add_recursive+0xee>
c0407e97:	83 ec 0c             	sub    $0xc,%esp
c0407e9a:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407e9e:	e8 da ef ff ff       	call   c0406e7d <sglib___vmm_tree_fix_left_insertion_discrepancy>
c0407ea3:	83 c4 10             	add    $0x10,%esp
c0407ea6:	eb 31                	jmp    c0407ed9 <sglib___vmm_tree_add_recursive+0xee>
c0407ea8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407eac:	83 c0 08             	add    $0x8,%eax
c0407eaf:	83 ec 08             	sub    $0x8,%esp
c0407eb2:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407eb6:	50                   	push   %eax
c0407eb7:	e8 2f ff ff ff       	call   c0407deb <sglib___vmm_tree_add_recursive>
c0407ebc:	83 c4 10             	add    $0x10,%esp
c0407ebf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407ec3:	8a 40 0c             	mov    0xc(%eax),%al
c0407ec6:	84 c0                	test   %al,%al
c0407ec8:	75 0f                	jne    c0407ed9 <sglib___vmm_tree_add_recursive+0xee>
c0407eca:	83 ec 0c             	sub    $0xc,%esp
c0407ecd:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407ed1:	e8 84 f1 ff ff       	call   c040705a <sglib___vmm_tree_fix_right_insertion_discrepancy>
c0407ed6:	83 c4 10             	add    $0x10,%esp
c0407ed9:	83 c4 1c             	add    $0x1c,%esp
c0407edc:	c3                   	ret    

c0407edd <sglib___vmm_tree_delete_rightmost_leaf>:
c0407edd:	83 ec 1c             	sub    $0x1c,%esp
c0407ee0:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407ee4:	8b 00                	mov    (%eax),%eax
c0407ee6:	89 44 24 04          	mov    %eax,0x4(%esp)
c0407eea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0407ef1:	00 
c0407ef2:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0407ef7:	75 1c                	jne    c0407f15 <sglib___vmm_tree_delete_rightmost_leaf+0x38>
c0407ef9:	68 1e 03 00 00       	push   $0x31e
c0407efe:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407f03:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407f08:	68 e6 ef 40 c0       	push   $0xc040efe6
c0407f0d:	e8 51 50 00 00       	call   c040cf63 <debug_assert>
c0407f12:	83 c4 10             	add    $0x10,%esp
c0407f15:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f19:	8b 40 08             	mov    0x8(%eax),%eax
c0407f1c:	85 c0                	test   %eax,%eax
c0407f1e:	75 6f                	jne    c0407f8f <sglib___vmm_tree_delete_rightmost_leaf+0xb2>
c0407f20:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407f24:	8b 54 24 04          	mov    0x4(%esp),%edx
c0407f28:	89 10                	mov    %edx,(%eax)
c0407f2a:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f2e:	8b 40 04             	mov    0x4(%eax),%eax
c0407f31:	85 c0                	test   %eax,%eax
c0407f33:	74 3b                	je     c0407f70 <sglib___vmm_tree_delete_rightmost_leaf+0x93>
c0407f35:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f39:	8a 40 0c             	mov    0xc(%eax),%al
c0407f3c:	84 c0                	test   %al,%al
c0407f3e:	75 16                	jne    c0407f56 <sglib___vmm_tree_delete_rightmost_leaf+0x79>
c0407f40:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f44:	8b 40 04             	mov    0x4(%eax),%eax
c0407f47:	8a 40 0c             	mov    0xc(%eax),%al
c0407f4a:	84 c0                	test   %al,%al
c0407f4c:	75 08                	jne    c0407f56 <sglib___vmm_tree_delete_rightmost_leaf+0x79>
c0407f4e:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0407f55:	00 
c0407f56:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f5a:	8b 40 04             	mov    0x4(%eax),%eax
c0407f5d:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0407f61:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f65:	8b 50 04             	mov    0x4(%eax),%edx
c0407f68:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407f6c:	89 10                	mov    %edx,(%eax)
c0407f6e:	eb 54                	jmp    c0407fc4 <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0407f70:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407f74:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0407f7a:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f7e:	8a 40 0c             	mov    0xc(%eax),%al
c0407f81:	84 c0                	test   %al,%al
c0407f83:	0f 94 c0             	sete   %al
c0407f86:	0f b6 c0             	movzbl %al,%eax
c0407f89:	89 44 24 08          	mov    %eax,0x8(%esp)
c0407f8d:	eb 35                	jmp    c0407fc4 <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0407f8f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407f93:	83 c0 08             	add    $0x8,%eax
c0407f96:	83 ec 08             	sub    $0x8,%esp
c0407f99:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407f9d:	50                   	push   %eax
c0407f9e:	e8 3a ff ff ff       	call   c0407edd <sglib___vmm_tree_delete_rightmost_leaf>
c0407fa3:	83 c4 10             	add    $0x10,%esp
c0407fa6:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0407faa:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407faf:	74 13                	je     c0407fc4 <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0407fb1:	83 ec 0c             	sub    $0xc,%esp
c0407fb4:	ff 74 24 2c          	pushl  0x2c(%esp)
c0407fb8:	e8 54 f8 ff ff       	call   c0407811 <sglib___vmm_tree_fix_right_deletion_discrepancy>
c0407fbd:	83 c4 10             	add    $0x10,%esp
c0407fc0:	89 44 24 08          	mov    %eax,0x8(%esp)
c0407fc4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407fc8:	83 c4 1c             	add    $0x1c,%esp
c0407fcb:	c3                   	ret    

c0407fcc <sglib___vmm_tree_delete_recursive>:
c0407fcc:	83 ec 2c             	sub    $0x2c,%esp
c0407fcf:	8b 44 24 30          	mov    0x30(%esp),%eax
c0407fd3:	8b 00                	mov    (%eax),%eax
c0407fd5:	89 44 24 10          	mov    %eax,0x10(%esp)
c0407fd9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0407fe0:	00 
c0407fe1:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0407fe6:	75 21                	jne    c0408009 <sglib___vmm_tree_delete_recursive+0x3d>
c0407fe8:	68 1e 03 00 00       	push   $0x31e
c0407fed:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407ff2:	68 d5 ef 40 c0       	push   $0xc040efd5
c0407ff7:	68 f8 f0 40 c0       	push   $0xc040f0f8
c0407ffc:	e8 62 4f 00 00       	call   c040cf63 <debug_assert>
c0408001:	83 c4 10             	add    $0x10,%esp
c0408004:	e9 f6 01 00 00       	jmp    c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c0408009:	8b 44 24 34          	mov    0x34(%esp),%eax
c040800d:	8b 00                	mov    (%eax),%eax
c040800f:	8b 50 08             	mov    0x8(%eax),%edx
c0408012:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408016:	8b 00                	mov    (%eax),%eax
c0408018:	8b 40 08             	mov    0x8(%eax),%eax
c040801b:	39 c2                	cmp    %eax,%edx
c040801d:	72 28                	jb     c0408047 <sglib___vmm_tree_delete_recursive+0x7b>
c040801f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408023:	8b 00                	mov    (%eax),%eax
c0408025:	8b 50 08             	mov    0x8(%eax),%edx
c0408028:	8b 44 24 10          	mov    0x10(%esp),%eax
c040802c:	8b 00                	mov    (%eax),%eax
c040802e:	8b 48 08             	mov    0x8(%eax),%ecx
c0408031:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408035:	8b 00                	mov    (%eax),%eax
c0408037:	8b 40 0c             	mov    0xc(%eax),%eax
c040803a:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040803d:	39 c2                	cmp    %eax,%edx
c040803f:	0f 93 c0             	setae  %al
c0408042:	0f b6 c0             	movzbl %al,%eax
c0408045:	eb 05                	jmp    c040804c <sglib___vmm_tree_delete_recursive+0x80>
c0408047:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c040804c:	89 44 24 14          	mov    %eax,0x14(%esp)
c0408050:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0408055:	78 11                	js     c0408068 <sglib___vmm_tree_delete_recursive+0x9c>
c0408057:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040805c:	75 48                	jne    c04080a6 <sglib___vmm_tree_delete_recursive+0xda>
c040805e:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408062:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0408066:	73 3e                	jae    c04080a6 <sglib___vmm_tree_delete_recursive+0xda>
c0408068:	8b 44 24 10          	mov    0x10(%esp),%eax
c040806c:	83 c0 04             	add    $0x4,%eax
c040806f:	83 ec 08             	sub    $0x8,%esp
c0408072:	ff 74 24 3c          	pushl  0x3c(%esp)
c0408076:	50                   	push   %eax
c0408077:	e8 50 ff ff ff       	call   c0407fcc <sglib___vmm_tree_delete_recursive>
c040807c:	83 c4 10             	add    $0x10,%esp
c040807f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0408083:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0408088:	0f 84 71 01 00 00    	je     c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c040808e:	83 ec 0c             	sub    $0xc,%esp
c0408091:	ff 74 24 3c          	pushl  0x3c(%esp)
c0408095:	e8 9d f1 ff ff       	call   c0407237 <sglib___vmm_tree_fix_left_deletion_discrepancy>
c040809a:	83 c4 10             	add    $0x10,%esp
c040809d:	89 44 24 18          	mov    %eax,0x18(%esp)
c04080a1:	e9 59 01 00 00       	jmp    c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c04080a6:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c04080ab:	7f 11                	jg     c04080be <sglib___vmm_tree_delete_recursive+0xf2>
c04080ad:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c04080b2:	75 48                	jne    c04080fc <sglib___vmm_tree_delete_recursive+0x130>
c04080b4:	8b 44 24 34          	mov    0x34(%esp),%eax
c04080b8:	3b 44 24 10          	cmp    0x10(%esp),%eax
c04080bc:	76 3e                	jbe    c04080fc <sglib___vmm_tree_delete_recursive+0x130>
c04080be:	8b 44 24 10          	mov    0x10(%esp),%eax
c04080c2:	83 c0 08             	add    $0x8,%eax
c04080c5:	83 ec 08             	sub    $0x8,%esp
c04080c8:	ff 74 24 3c          	pushl  0x3c(%esp)
c04080cc:	50                   	push   %eax
c04080cd:	e8 fa fe ff ff       	call   c0407fcc <sglib___vmm_tree_delete_recursive>
c04080d2:	83 c4 10             	add    $0x10,%esp
c04080d5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04080d9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04080de:	0f 84 1b 01 00 00    	je     c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c04080e4:	83 ec 0c             	sub    $0xc,%esp
c04080e7:	ff 74 24 3c          	pushl  0x3c(%esp)
c04080eb:	e8 21 f7 ff ff       	call   c0407811 <sglib___vmm_tree_fix_right_deletion_discrepancy>
c04080f0:	83 c4 10             	add    $0x10,%esp
c04080f3:	89 44 24 18          	mov    %eax,0x18(%esp)
c04080f7:	e9 03 01 00 00       	jmp    c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c04080fc:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408100:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0408104:	74 1c                	je     c0408122 <sglib___vmm_tree_delete_recursive+0x156>
c0408106:	68 1e 03 00 00       	push   $0x31e
c040810b:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408110:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408115:	68 4c f1 40 c0       	push   $0xc040f14c
c040811a:	e8 44 4e 00 00       	call   c040cf63 <debug_assert>
c040811f:	83 c4 10             	add    $0x10,%esp
c0408122:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408126:	8b 40 04             	mov    0x4(%eax),%eax
c0408129:	85 c0                	test   %eax,%eax
c040812b:	75 68                	jne    c0408195 <sglib___vmm_tree_delete_recursive+0x1c9>
c040812d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408131:	8b 40 08             	mov    0x8(%eax),%eax
c0408134:	85 c0                	test   %eax,%eax
c0408136:	75 22                	jne    c040815a <sglib___vmm_tree_delete_recursive+0x18e>
c0408138:	8b 44 24 30          	mov    0x30(%esp),%eax
c040813c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0408142:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408146:	8a 40 0c             	mov    0xc(%eax),%al
c0408149:	84 c0                	test   %al,%al
c040814b:	0f 94 c0             	sete   %al
c040814e:	0f b6 c0             	movzbl %al,%eax
c0408151:	89 44 24 18          	mov    %eax,0x18(%esp)
c0408155:	e9 a5 00 00 00       	jmp    c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c040815a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040815e:	8a 40 0c             	mov    0xc(%eax),%al
c0408161:	84 c0                	test   %al,%al
c0408163:	75 16                	jne    c040817b <sglib___vmm_tree_delete_recursive+0x1af>
c0408165:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408169:	8b 40 08             	mov    0x8(%eax),%eax
c040816c:	8a 40 0c             	mov    0xc(%eax),%al
c040816f:	84 c0                	test   %al,%al
c0408171:	75 08                	jne    c040817b <sglib___vmm_tree_delete_recursive+0x1af>
c0408173:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c040817a:	00 
c040817b:	8b 44 24 10          	mov    0x10(%esp),%eax
c040817f:	8b 40 08             	mov    0x8(%eax),%eax
c0408182:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0408186:	8b 44 24 10          	mov    0x10(%esp),%eax
c040818a:	8b 50 08             	mov    0x8(%eax),%edx
c040818d:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408191:	89 10                	mov    %edx,(%eax)
c0408193:	eb 6a                	jmp    c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c0408195:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408199:	8d 50 04             	lea    0x4(%eax),%edx
c040819c:	83 ec 08             	sub    $0x8,%esp
c040819f:	8d 44 24 14          	lea    0x14(%esp),%eax
c04081a3:	50                   	push   %eax
c04081a4:	52                   	push   %edx
c04081a5:	e8 33 fd ff ff       	call   c0407edd <sglib___vmm_tree_delete_rightmost_leaf>
c04081aa:	83 c4 10             	add    $0x10,%esp
c04081ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04081b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04081b5:	8b 54 24 10          	mov    0x10(%esp),%edx
c04081b9:	8b 52 04             	mov    0x4(%edx),%edx
c04081bc:	89 50 04             	mov    %edx,0x4(%eax)
c04081bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04081c3:	8b 54 24 10          	mov    0x10(%esp),%edx
c04081c7:	8b 52 08             	mov    0x8(%edx),%edx
c04081ca:	89 50 08             	mov    %edx,0x8(%eax)
c04081cd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04081d1:	8b 54 24 10          	mov    0x10(%esp),%edx
c04081d5:	8a 52 0c             	mov    0xc(%edx),%dl
c04081d8:	88 50 0c             	mov    %dl,0xc(%eax)
c04081db:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04081df:	8b 44 24 30          	mov    0x30(%esp),%eax
c04081e3:	89 10                	mov    %edx,(%eax)
c04081e5:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04081ea:	74 13                	je     c04081ff <sglib___vmm_tree_delete_recursive+0x233>
c04081ec:	83 ec 0c             	sub    $0xc,%esp
c04081ef:	ff 74 24 3c          	pushl  0x3c(%esp)
c04081f3:	e8 3f f0 ff ff       	call   c0407237 <sglib___vmm_tree_fix_left_deletion_discrepancy>
c04081f8:	83 c4 10             	add    $0x10,%esp
c04081fb:	89 44 24 18          	mov    %eax,0x18(%esp)
c04081ff:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408203:	83 c4 2c             	add    $0x2c,%esp
c0408206:	c3                   	ret    

c0408207 <sglib_vmm_tree_add>:
c0408207:	83 ec 0c             	sub    $0xc,%esp
c040820a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040820e:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0408215:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408219:	8b 50 08             	mov    0x8(%eax),%edx
c040821c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408220:	89 50 04             	mov    %edx,0x4(%eax)
c0408223:	83 ec 08             	sub    $0x8,%esp
c0408226:	ff 74 24 1c          	pushl  0x1c(%esp)
c040822a:	ff 74 24 1c          	pushl  0x1c(%esp)
c040822e:	e8 b8 fb ff ff       	call   c0407deb <sglib___vmm_tree_add_recursive>
c0408233:	83 c4 10             	add    $0x10,%esp
c0408236:	8b 44 24 10          	mov    0x10(%esp),%eax
c040823a:	8b 00                	mov    (%eax),%eax
c040823c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0408240:	83 c4 0c             	add    $0xc,%esp
c0408243:	c3                   	ret    

c0408244 <sglib_vmm_tree_delete>:
c0408244:	83 ec 0c             	sub    $0xc,%esp
c0408247:	83 ec 08             	sub    $0x8,%esp
c040824a:	ff 74 24 1c          	pushl  0x1c(%esp)
c040824e:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408252:	e8 75 fd ff ff       	call   c0407fcc <sglib___vmm_tree_delete_recursive>
c0408257:	83 c4 10             	add    $0x10,%esp
c040825a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040825e:	8b 00                	mov    (%eax),%eax
c0408260:	85 c0                	test   %eax,%eax
c0408262:	74 0a                	je     c040826e <sglib_vmm_tree_delete+0x2a>
c0408264:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408268:	8b 00                	mov    (%eax),%eax
c040826a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c040826e:	83 c4 0c             	add    $0xc,%esp
c0408271:	c3                   	ret    

c0408272 <sglib_vmm_tree_find_member>:
c0408272:	83 ec 10             	sub    $0x10,%esp
c0408275:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408279:	89 44 24 08          	mov    %eax,0x8(%esp)
c040827d:	eb 6d                	jmp    c04082ec <sglib_vmm_tree_find_member+0x7a>
c040827f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408283:	8b 00                	mov    (%eax),%eax
c0408285:	8b 50 08             	mov    0x8(%eax),%edx
c0408288:	8b 44 24 08          	mov    0x8(%esp),%eax
c040828c:	8b 00                	mov    (%eax),%eax
c040828e:	8b 40 08             	mov    0x8(%eax),%eax
c0408291:	39 c2                	cmp    %eax,%edx
c0408293:	72 28                	jb     c04082bd <sglib_vmm_tree_find_member+0x4b>
c0408295:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408299:	8b 00                	mov    (%eax),%eax
c040829b:	8b 50 08             	mov    0x8(%eax),%edx
c040829e:	8b 44 24 08          	mov    0x8(%esp),%eax
c04082a2:	8b 00                	mov    (%eax),%eax
c04082a4:	8b 48 08             	mov    0x8(%eax),%ecx
c04082a7:	8b 44 24 08          	mov    0x8(%esp),%eax
c04082ab:	8b 00                	mov    (%eax),%eax
c04082ad:	8b 40 0c             	mov    0xc(%eax),%eax
c04082b0:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04082b3:	39 c2                	cmp    %eax,%edx
c04082b5:	0f 93 c0             	setae  %al
c04082b8:	0f b6 c0             	movzbl %al,%eax
c04082bb:	eb 05                	jmp    c04082c2 <sglib_vmm_tree_find_member+0x50>
c04082bd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c04082c2:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04082c6:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04082cb:	79 0d                	jns    c04082da <sglib_vmm_tree_find_member+0x68>
c04082cd:	8b 44 24 08          	mov    0x8(%esp),%eax
c04082d1:	8b 40 04             	mov    0x4(%eax),%eax
c04082d4:	89 44 24 08          	mov    %eax,0x8(%esp)
c04082d8:	eb 12                	jmp    c04082ec <sglib_vmm_tree_find_member+0x7a>
c04082da:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04082df:	7e 12                	jle    c04082f3 <sglib_vmm_tree_find_member+0x81>
c04082e1:	8b 44 24 08          	mov    0x8(%esp),%eax
c04082e5:	8b 40 08             	mov    0x8(%eax),%eax
c04082e8:	89 44 24 08          	mov    %eax,0x8(%esp)
c04082ec:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c04082f1:	75 8c                	jne    c040827f <sglib_vmm_tree_find_member+0xd>
c04082f3:	8b 44 24 08          	mov    0x8(%esp),%eax
c04082f7:	89 44 24 04          	mov    %eax,0x4(%esp)
c04082fb:	8b 44 24 04          	mov    0x4(%esp),%eax
c04082ff:	83 c4 10             	add    $0x10,%esp
c0408302:	c3                   	ret    

c0408303 <sglib_vmm_tree_is_member>:
c0408303:	83 ec 1c             	sub    $0x1c,%esp
c0408306:	e9 be 00 00 00       	jmp    c04083c9 <sglib_vmm_tree_is_member+0xc6>
c040830b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040830f:	8b 00                	mov    (%eax),%eax
c0408311:	8b 50 08             	mov    0x8(%eax),%edx
c0408314:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408318:	8b 00                	mov    (%eax),%eax
c040831a:	8b 40 08             	mov    0x8(%eax),%eax
c040831d:	39 c2                	cmp    %eax,%edx
c040831f:	72 28                	jb     c0408349 <sglib_vmm_tree_is_member+0x46>
c0408321:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408325:	8b 00                	mov    (%eax),%eax
c0408327:	8b 50 08             	mov    0x8(%eax),%edx
c040832a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040832e:	8b 00                	mov    (%eax),%eax
c0408330:	8b 48 08             	mov    0x8(%eax),%ecx
c0408333:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408337:	8b 00                	mov    (%eax),%eax
c0408339:	8b 40 0c             	mov    0xc(%eax),%eax
c040833c:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040833f:	39 c2                	cmp    %eax,%edx
c0408341:	0f 93 c0             	setae  %al
c0408344:	0f b6 c0             	movzbl %al,%eax
c0408347:	eb 05                	jmp    c040834e <sglib_vmm_tree_is_member+0x4b>
c0408349:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c040834e:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0408352:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0408357:	78 11                	js     c040836a <sglib_vmm_tree_is_member+0x67>
c0408359:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040835e:	75 17                	jne    c0408377 <sglib_vmm_tree_is_member+0x74>
c0408360:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408364:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0408368:	73 0d                	jae    c0408377 <sglib_vmm_tree_is_member+0x74>
c040836a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040836e:	8b 40 04             	mov    0x4(%eax),%eax
c0408371:	89 44 24 20          	mov    %eax,0x20(%esp)
c0408375:	eb 52                	jmp    c04083c9 <sglib_vmm_tree_is_member+0xc6>
c0408377:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040837c:	7f 11                	jg     c040838f <sglib_vmm_tree_is_member+0x8c>
c040837e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0408383:	75 17                	jne    c040839c <sglib_vmm_tree_is_member+0x99>
c0408385:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408389:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040838d:	76 0d                	jbe    c040839c <sglib_vmm_tree_is_member+0x99>
c040838f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408393:	8b 40 08             	mov    0x8(%eax),%eax
c0408396:	89 44 24 20          	mov    %eax,0x20(%esp)
c040839a:	eb 2d                	jmp    c04083c9 <sglib_vmm_tree_is_member+0xc6>
c040839c:	8b 44 24 20          	mov    0x20(%esp),%eax
c04083a0:	3b 44 24 24          	cmp    0x24(%esp),%eax
c04083a4:	74 1c                	je     c04083c2 <sglib_vmm_tree_is_member+0xbf>
c04083a6:	68 1e 03 00 00       	push   $0x31e
c04083ab:	68 d5 ef 40 c0       	push   $0xc040efd5
c04083b0:	68 d5 ef 40 c0       	push   $0xc040efd5
c04083b5:	68 ab f1 40 c0       	push   $0xc040f1ab
c04083ba:	e8 a4 4b 00 00       	call   c040cf63 <debug_assert>
c04083bf:	83 c4 10             	add    $0x10,%esp
c04083c2:	b8 01 00 00 00       	mov    $0x1,%eax
c04083c7:	eb 10                	jmp    c04083d9 <sglib_vmm_tree_is_member+0xd6>
c04083c9:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c04083ce:	0f 85 37 ff ff ff    	jne    c040830b <sglib_vmm_tree_is_member+0x8>
c04083d4:	b8 00 00 00 00       	mov    $0x0,%eax
c04083d9:	83 c4 1c             	add    $0x1c,%esp
c04083dc:	c3                   	ret    

c04083dd <sglib_vmm_tree_delete_if_member>:
c04083dd:	83 ec 0c             	sub    $0xc,%esp
c04083e0:	8b 44 24 10          	mov    0x10(%esp),%eax
c04083e4:	8b 00                	mov    (%eax),%eax
c04083e6:	ff 74 24 14          	pushl  0x14(%esp)
c04083ea:	50                   	push   %eax
c04083eb:	e8 82 fe ff ff       	call   c0408272 <sglib_vmm_tree_find_member>
c04083f0:	83 c4 08             	add    $0x8,%esp
c04083f3:	8b 54 24 18          	mov    0x18(%esp),%edx
c04083f7:	89 02                	mov    %eax,(%edx)
c04083f9:	8b 44 24 18          	mov    0x18(%esp),%eax
c04083fd:	8b 00                	mov    (%eax),%eax
c04083ff:	85 c0                	test   %eax,%eax
c0408401:	74 1d                	je     c0408420 <sglib_vmm_tree_delete_if_member+0x43>
c0408403:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408407:	8b 00                	mov    (%eax),%eax
c0408409:	83 ec 08             	sub    $0x8,%esp
c040840c:	50                   	push   %eax
c040840d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408411:	e8 2e fe ff ff       	call   c0408244 <sglib_vmm_tree_delete>
c0408416:	83 c4 10             	add    $0x10,%esp
c0408419:	b8 01 00 00 00       	mov    $0x1,%eax
c040841e:	eb 05                	jmp    c0408425 <sglib_vmm_tree_delete_if_member+0x48>
c0408420:	b8 00 00 00 00       	mov    $0x0,%eax
c0408425:	83 c4 0c             	add    $0xc,%esp
c0408428:	c3                   	ret    

c0408429 <sglib_vmm_tree_add_if_not_member>:
c0408429:	83 ec 0c             	sub    $0xc,%esp
c040842c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408430:	8b 00                	mov    (%eax),%eax
c0408432:	ff 74 24 14          	pushl  0x14(%esp)
c0408436:	50                   	push   %eax
c0408437:	e8 36 fe ff ff       	call   c0408272 <sglib_vmm_tree_find_member>
c040843c:	83 c4 08             	add    $0x8,%esp
c040843f:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408443:	89 02                	mov    %eax,(%edx)
c0408445:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408449:	8b 00                	mov    (%eax),%eax
c040844b:	85 c0                	test   %eax,%eax
c040844d:	75 1a                	jne    c0408469 <sglib_vmm_tree_add_if_not_member+0x40>
c040844f:	83 ec 08             	sub    $0x8,%esp
c0408452:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408456:	ff 74 24 1c          	pushl  0x1c(%esp)
c040845a:	e8 a8 fd ff ff       	call   c0408207 <sglib_vmm_tree_add>
c040845f:	83 c4 10             	add    $0x10,%esp
c0408462:	b8 01 00 00 00       	mov    $0x1,%eax
c0408467:	eb 05                	jmp    c040846e <sglib_vmm_tree_add_if_not_member+0x45>
c0408469:	b8 00 00 00 00       	mov    $0x0,%eax
c040846e:	83 c4 0c             	add    $0xc,%esp
c0408471:	c3                   	ret    

c0408472 <sglib_vmm_tree_len>:
c0408472:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
c0408478:	c7 84 24 8c 04 00 00 	movl   $0x0,0x48c(%esp)
c040847f:	00 00 00 00 
c0408483:	8b 84 24 b0 04 00 00 	mov    0x4b0(%esp),%eax
c040848a:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c0408491:	c7 84 24 98 04 00 00 	movl   $0x0,0x498(%esp)
c0408498:	00 00 00 00 
c040849c:	e9 11 01 00 00       	jmp    c04085b2 <sglib_vmm_tree_len+0x140>
c04084a1:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04084a8:	8b 94 24 94 04 00 00 	mov    0x494(%esp),%edx
c04084af:	89 94 84 0c 02 00 00 	mov    %edx,0x20c(%esp,%eax,4)
c04084b6:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04084bd:	8b 94 24 94 04 00 00 	mov    0x494(%esp),%edx
c04084c4:	8b 52 08             	mov    0x8(%edx),%edx
c04084c7:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
c04084cb:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04084d2:	c6 84 04 0c 04 00 00 	movb   $0x0,0x40c(%esp,%eax,1)
c04084d9:	00 
c04084da:	8b 84 24 94 04 00 00 	mov    0x494(%esp),%eax
c04084e1:	8b 40 04             	mov    0x4(%eax),%eax
c04084e4:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c04084eb:	ff 84 24 98 04 00 00 	incl   0x498(%esp)
c04084f2:	83 bc 24 98 04 00 00 	cmpl   $0x7f,0x498(%esp)
c04084f9:	7f 
c04084fa:	7e 1c                	jle    c0408518 <sglib_vmm_tree_len+0xa6>
c04084fc:	68 1e 03 00 00       	push   $0x31e
c0408501:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408506:	68 d5 ef 40 c0       	push   $0xc040efd5
c040850b:	68 b8 f1 40 c0       	push   $0xc040f1b8
c0408510:	e8 4e 4a 00 00       	call   c040cf63 <debug_assert>
c0408515:	83 c4 10             	add    $0x10,%esp
c0408518:	83 bc 24 94 04 00 00 	cmpl   $0x0,0x494(%esp)
c040851f:	00 
c0408520:	0f 85 7b ff ff ff    	jne    c04084a1 <sglib_vmm_tree_len+0x2f>
c0408526:	ff 8c 24 98 04 00 00 	decl   0x498(%esp)
c040852d:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0408534:	8a 84 04 0c 04 00 00 	mov    0x40c(%esp,%eax,1),%al
c040853b:	84 c0                	test   %al,%al
c040853d:	75 1c                	jne    c040855b <sglib_vmm_tree_len+0xe9>
c040853f:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0408546:	8b 84 84 0c 02 00 00 	mov    0x20c(%esp,%eax,4),%eax
c040854d:	89 84 24 9c 04 00 00 	mov    %eax,0x49c(%esp)
c0408554:	ff 84 24 8c 04 00 00 	incl   0x48c(%esp)
c040855b:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0408562:	8a 94 04 0c 04 00 00 	mov    0x40c(%esp,%eax,1),%dl
c0408569:	42                   	inc    %edx
c040856a:	88 94 04 0c 04 00 00 	mov    %dl,0x40c(%esp,%eax,1)
c0408571:	83 bc 24 98 04 00 00 	cmpl   $0x0,0x498(%esp)
c0408578:	00 
c0408579:	7e 0f                	jle    c040858a <sglib_vmm_tree_len+0x118>
c040857b:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0408582:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
c0408586:	85 c0                	test   %eax,%eax
c0408588:	74 9c                	je     c0408526 <sglib_vmm_tree_len+0xb4>
c040858a:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0408591:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
c0408595:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c040859c:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04085a3:	c7 44 84 0c 00 00 00 	movl   $0x0,0xc(%esp,%eax,4)
c04085aa:	00 
c04085ab:	ff 84 24 98 04 00 00 	incl   0x498(%esp)
c04085b2:	83 bc 24 94 04 00 00 	cmpl   $0x0,0x494(%esp)
c04085b9:	00 
c04085ba:	0f 85 58 ff ff ff    	jne    c0408518 <sglib_vmm_tree_len+0xa6>
c04085c0:	8b 84 24 8c 04 00 00 	mov    0x48c(%esp),%eax
c04085c7:	81 c4 ac 04 00 00    	add    $0x4ac,%esp
c04085cd:	c3                   	ret    

c04085ce <sglib__vmm_tree_it_compute_current_elem>:
c04085ce:	83 ec 3c             	sub    $0x3c,%esp
c04085d1:	8b 44 24 40          	mov    0x40(%esp),%eax
c04085d5:	8b 80 88 02 00 00    	mov    0x288(%eax),%eax
c04085db:	89 44 24 18          	mov    %eax,0x18(%esp)
c04085df:	8b 44 24 40          	mov    0x40(%esp),%eax
c04085e3:	8b 80 8c 02 00 00    	mov    0x28c(%eax),%eax
c04085e9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04085ed:	8b 44 24 40          	mov    0x40(%esp),%eax
c04085f1:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c04085f7:	e9 2c 02 00 00       	jmp    c0408828 <sglib__vmm_tree_it_compute_current_elem+0x25a>
c04085fc:	8b 44 24 40          	mov    0x40(%esp),%eax
c0408600:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0408606:	98                   	cwtl   
c0408607:	48                   	dec    %eax
c0408608:	89 44 24 08          	mov    %eax,0x8(%esp)
c040860c:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0408611:	0f 88 bb 01 00 00    	js     c04087d2 <sglib__vmm_tree_it_compute_current_elem+0x204>
c0408617:	8b 44 24 08          	mov    0x8(%esp),%eax
c040861b:	8b 54 24 40          	mov    0x40(%esp),%edx
c040861f:	8a 44 02 04          	mov    0x4(%edx,%eax,1),%al
c0408623:	3c 01                	cmp    $0x1,%al
c0408625:	7e 1b                	jle    c0408642 <sglib__vmm_tree_it_compute_current_elem+0x74>
c0408627:	8b 44 24 40          	mov    0x40(%esp),%eax
c040862b:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0408631:	48                   	dec    %eax
c0408632:	8b 54 24 40          	mov    0x40(%esp),%edx
c0408636:	66 89 82 84 02 00 00 	mov    %ax,0x284(%edx)
c040863d:	e9 90 01 00 00       	jmp    c04087d2 <sglib__vmm_tree_it_compute_current_elem+0x204>
c0408642:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408646:	8b 54 24 40          	mov    0x40(%esp),%edx
c040864a:	8a 44 02 04          	mov    0x4(%edx,%eax,1),%al
c040864e:	84 c0                	test   %al,%al
c0408650:	75 18                	jne    c040866a <sglib__vmm_tree_it_compute_current_elem+0x9c>
c0408652:	8b 54 24 08          	mov    0x8(%esp),%edx
c0408656:	8b 44 24 40          	mov    0x40(%esp),%eax
c040865a:	83 c2 20             	add    $0x20,%edx
c040865d:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0408661:	8b 40 04             	mov    0x4(%eax),%eax
c0408664:	89 44 24 14          	mov    %eax,0x14(%esp)
c0408668:	eb 16                	jmp    c0408680 <sglib__vmm_tree_it_compute_current_elem+0xb2>
c040866a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040866e:	8b 44 24 40          	mov    0x40(%esp),%eax
c0408672:	83 c2 20             	add    $0x20,%edx
c0408675:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c0408679:	8b 40 08             	mov    0x8(%eax),%eax
c040867c:	89 44 24 14          	mov    %eax,0x14(%esp)
c0408680:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0408685:	0f 84 ea 00 00 00    	je     c0408775 <sglib__vmm_tree_it_compute_current_elem+0x1a7>
c040868b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0408690:	0f 85 88 00 00 00    	jne    c040871e <sglib__vmm_tree_it_compute_current_elem+0x150>
c0408696:	8b 44 24 14          	mov    0x14(%esp),%eax
c040869a:	89 44 24 20          	mov    %eax,0x20(%esp)
c040869e:	eb 6d                	jmp    c040870d <sglib__vmm_tree_it_compute_current_elem+0x13f>
c04086a0:	8b 44 24 18          	mov    0x18(%esp),%eax
c04086a4:	8b 00                	mov    (%eax),%eax
c04086a6:	8b 50 08             	mov    0x8(%eax),%edx
c04086a9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04086ad:	8b 00                	mov    (%eax),%eax
c04086af:	8b 40 08             	mov    0x8(%eax),%eax
c04086b2:	39 c2                	cmp    %eax,%edx
c04086b4:	72 28                	jb     c04086de <sglib__vmm_tree_it_compute_current_elem+0x110>
c04086b6:	8b 44 24 18          	mov    0x18(%esp),%eax
c04086ba:	8b 00                	mov    (%eax),%eax
c04086bc:	8b 50 08             	mov    0x8(%eax),%edx
c04086bf:	8b 44 24 20          	mov    0x20(%esp),%eax
c04086c3:	8b 00                	mov    (%eax),%eax
c04086c5:	8b 48 08             	mov    0x8(%eax),%ecx
c04086c8:	8b 44 24 20          	mov    0x20(%esp),%eax
c04086cc:	8b 00                	mov    (%eax),%eax
c04086ce:	8b 40 0c             	mov    0xc(%eax),%eax
c04086d1:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04086d4:	39 c2                	cmp    %eax,%edx
c04086d6:	0f 93 c0             	setae  %al
c04086d9:	0f b6 c0             	movzbl %al,%eax
c04086dc:	eb 05                	jmp    c04086e3 <sglib__vmm_tree_it_compute_current_elem+0x115>
c04086de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c04086e3:	89 44 24 24          	mov    %eax,0x24(%esp)
c04086e7:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04086ec:	79 0d                	jns    c04086fb <sglib__vmm_tree_it_compute_current_elem+0x12d>
c04086ee:	8b 44 24 20          	mov    0x20(%esp),%eax
c04086f2:	8b 40 04             	mov    0x4(%eax),%eax
c04086f5:	89 44 24 20          	mov    %eax,0x20(%esp)
c04086f9:	eb 12                	jmp    c040870d <sglib__vmm_tree_it_compute_current_elem+0x13f>
c04086fb:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0408700:	7e 12                	jle    c0408714 <sglib__vmm_tree_it_compute_current_elem+0x146>
c0408702:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408706:	8b 40 08             	mov    0x8(%eax),%eax
c0408709:	89 44 24 20          	mov    %eax,0x20(%esp)
c040870d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0408712:	75 8c                	jne    c04086a0 <sglib__vmm_tree_it_compute_current_elem+0xd2>
c0408714:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408718:	89 44 24 14          	mov    %eax,0x14(%esp)
c040871c:	eb 57                	jmp    c0408775 <sglib__vmm_tree_it_compute_current_elem+0x1a7>
c040871e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408722:	89 44 24 28          	mov    %eax,0x28(%esp)
c0408726:	eb 3e                	jmp    c0408766 <sglib__vmm_tree_it_compute_current_elem+0x198>
c0408728:	83 ec 08             	sub    $0x8,%esp
c040872b:	ff 74 24 30          	pushl  0x30(%esp)
c040872f:	ff 74 24 24          	pushl  0x24(%esp)
c0408733:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0408737:	ff d0                	call   *%eax
c0408739:	83 c4 10             	add    $0x10,%esp
c040873c:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0408740:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0408745:	79 0d                	jns    c0408754 <sglib__vmm_tree_it_compute_current_elem+0x186>
c0408747:	8b 44 24 28          	mov    0x28(%esp),%eax
c040874b:	8b 40 04             	mov    0x4(%eax),%eax
c040874e:	89 44 24 28          	mov    %eax,0x28(%esp)
c0408752:	eb 12                	jmp    c0408766 <sglib__vmm_tree_it_compute_current_elem+0x198>
c0408754:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0408759:	7e 12                	jle    c040876d <sglib__vmm_tree_it_compute_current_elem+0x19f>
c040875b:	8b 44 24 28          	mov    0x28(%esp),%eax
c040875f:	8b 40 08             	mov    0x8(%eax),%eax
c0408762:	89 44 24 28          	mov    %eax,0x28(%esp)
c0408766:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c040876b:	75 bb                	jne    c0408728 <sglib__vmm_tree_it_compute_current_elem+0x15a>
c040876d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0408771:	89 44 24 14          	mov    %eax,0x14(%esp)
c0408775:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040877a:	74 3f                	je     c04087bb <sglib__vmm_tree_it_compute_current_elem+0x1ed>
c040877c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408780:	40                   	inc    %eax
c0408781:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0408785:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408789:	8b 44 24 40          	mov    0x40(%esp),%eax
c040878d:	8d 4a 20             	lea    0x20(%edx),%ecx
c0408790:	8b 54 24 14          	mov    0x14(%esp),%edx
c0408794:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
c0408798:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040879c:	8b 54 24 40          	mov    0x40(%esp),%edx
c04087a0:	c6 44 02 04 00       	movb   $0x0,0x4(%edx,%eax,1)
c04087a5:	8b 44 24 40          	mov    0x40(%esp),%eax
c04087a9:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c04087af:	40                   	inc    %eax
c04087b0:	8b 54 24 40          	mov    0x40(%esp),%edx
c04087b4:	66 89 82 84 02 00 00 	mov    %ax,0x284(%edx)
c04087bb:	8b 44 24 08          	mov    0x8(%esp),%eax
c04087bf:	8b 54 24 40          	mov    0x40(%esp),%edx
c04087c3:	8a 54 02 04          	mov    0x4(%edx,%eax,1),%dl
c04087c7:	8d 4a 01             	lea    0x1(%edx),%ecx
c04087ca:	8b 54 24 40          	mov    0x40(%esp),%edx
c04087ce:	88 4c 02 04          	mov    %cl,0x4(%edx,%eax,1)
c04087d2:	8b 44 24 40          	mov    0x40(%esp),%eax
c04087d6:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c04087dc:	66 85 c0             	test   %ax,%ax
c04087df:	7e 47                	jle    c0408828 <sglib__vmm_tree_it_compute_current_elem+0x25a>
c04087e1:	8b 44 24 40          	mov    0x40(%esp),%eax
c04087e5:	66 8b 90 86 02 00 00 	mov    0x286(%eax),%dx
c04087ec:	8b 44 24 40          	mov    0x40(%esp),%eax
c04087f0:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c04087f6:	98                   	cwtl   
c04087f7:	8d 48 ff             	lea    -0x1(%eax),%ecx
c04087fa:	8b 44 24 40          	mov    0x40(%esp),%eax
c04087fe:	8a 44 08 04          	mov    0x4(%eax,%ecx,1),%al
c0408802:	66 98                	cbtw   
c0408804:	66 39 c2             	cmp    %ax,%dx
c0408807:	75 1f                	jne    c0408828 <sglib__vmm_tree_it_compute_current_elem+0x25a>
c0408809:	8b 44 24 40          	mov    0x40(%esp),%eax
c040880d:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0408813:	98                   	cwtl   
c0408814:	8d 50 ff             	lea    -0x1(%eax),%edx
c0408817:	8b 44 24 40          	mov    0x40(%esp),%eax
c040881b:	83 c2 20             	add    $0x20,%edx
c040881e:	8b 54 90 04          	mov    0x4(%eax,%edx,4),%edx
c0408822:	8b 44 24 40          	mov    0x40(%esp),%eax
c0408826:	89 10                	mov    %edx,(%eax)
c0408828:	8b 44 24 40          	mov    0x40(%esp),%eax
c040882c:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0408832:	66 85 c0             	test   %ax,%ax
c0408835:	7e 0e                	jle    c0408845 <sglib__vmm_tree_it_compute_current_elem+0x277>
c0408837:	8b 44 24 40          	mov    0x40(%esp),%eax
c040883b:	8b 00                	mov    (%eax),%eax
c040883d:	85 c0                	test   %eax,%eax
c040883f:	0f 84 b7 fd ff ff    	je     c04085fc <sglib__vmm_tree_it_compute_current_elem+0x2e>
c0408845:	83 c4 3c             	add    $0x3c,%esp
c0408848:	c3                   	ret    

c0408849 <sglib__vmm_tree_it_init>:
c0408849:	83 ec 2c             	sub    $0x2c,%esp
c040884c:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0408851:	75 1c                	jne    c040886f <sglib__vmm_tree_it_init+0x26>
c0408853:	68 1e 03 00 00       	push   $0x31e
c0408858:	68 d5 ef 40 c0       	push   $0xc040efd5
c040885d:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408862:	68 db f1 40 c0       	push   $0xc040f1db
c0408867:	e8 f7 46 00 00       	call   c040cf63 <debug_assert>
c040886c:	83 c4 10             	add    $0x10,%esp
c040886f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0408873:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408877:	66 89 82 86 02 00 00 	mov    %ax,0x286(%edx)
c040887e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408882:	8b 54 24 40          	mov    0x40(%esp),%edx
c0408886:	89 90 88 02 00 00    	mov    %edx,0x288(%eax)
c040888c:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408890:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0408894:	89 90 8c 02 00 00    	mov    %edx,0x28c(%eax)
c040889a:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c040889f:	75 0d                	jne    c04088ae <sglib__vmm_tree_it_init+0x65>
c04088a1:	8b 44 24 34          	mov    0x34(%esp),%eax
c04088a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04088a9:	e9 ea 00 00 00       	jmp    c0408998 <sglib__vmm_tree_it_init+0x14f>
c04088ae:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
c04088b3:	0f 85 88 00 00 00    	jne    c0408941 <sglib__vmm_tree_it_init+0xf8>
c04088b9:	8b 44 24 34          	mov    0x34(%esp),%eax
c04088bd:	89 44 24 10          	mov    %eax,0x10(%esp)
c04088c1:	eb 6d                	jmp    c0408930 <sglib__vmm_tree_it_init+0xe7>
c04088c3:	8b 44 24 40          	mov    0x40(%esp),%eax
c04088c7:	8b 00                	mov    (%eax),%eax
c04088c9:	8b 50 08             	mov    0x8(%eax),%edx
c04088cc:	8b 44 24 10          	mov    0x10(%esp),%eax
c04088d0:	8b 00                	mov    (%eax),%eax
c04088d2:	8b 40 08             	mov    0x8(%eax),%eax
c04088d5:	39 c2                	cmp    %eax,%edx
c04088d7:	72 28                	jb     c0408901 <sglib__vmm_tree_it_init+0xb8>
c04088d9:	8b 44 24 40          	mov    0x40(%esp),%eax
c04088dd:	8b 00                	mov    (%eax),%eax
c04088df:	8b 50 08             	mov    0x8(%eax),%edx
c04088e2:	8b 44 24 10          	mov    0x10(%esp),%eax
c04088e6:	8b 00                	mov    (%eax),%eax
c04088e8:	8b 48 08             	mov    0x8(%eax),%ecx
c04088eb:	8b 44 24 10          	mov    0x10(%esp),%eax
c04088ef:	8b 00                	mov    (%eax),%eax
c04088f1:	8b 40 0c             	mov    0xc(%eax),%eax
c04088f4:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04088f7:	39 c2                	cmp    %eax,%edx
c04088f9:	0f 93 c0             	setae  %al
c04088fc:	0f b6 c0             	movzbl %al,%eax
c04088ff:	eb 05                	jmp    c0408906 <sglib__vmm_tree_it_init+0xbd>
c0408901:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0408906:	89 44 24 14          	mov    %eax,0x14(%esp)
c040890a:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040890f:	79 0d                	jns    c040891e <sglib__vmm_tree_it_init+0xd5>
c0408911:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408915:	8b 40 04             	mov    0x4(%eax),%eax
c0408918:	89 44 24 10          	mov    %eax,0x10(%esp)
c040891c:	eb 12                	jmp    c0408930 <sglib__vmm_tree_it_init+0xe7>
c040891e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0408923:	7e 12                	jle    c0408937 <sglib__vmm_tree_it_init+0xee>
c0408925:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408929:	8b 40 08             	mov    0x8(%eax),%eax
c040892c:	89 44 24 10          	mov    %eax,0x10(%esp)
c0408930:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0408935:	75 8c                	jne    c04088c3 <sglib__vmm_tree_it_init+0x7a>
c0408937:	8b 44 24 10          	mov    0x10(%esp),%eax
c040893b:	89 44 24 0c          	mov    %eax,0xc(%esp)
c040893f:	eb 57                	jmp    c0408998 <sglib__vmm_tree_it_init+0x14f>
c0408941:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408945:	89 44 24 18          	mov    %eax,0x18(%esp)
c0408949:	eb 3e                	jmp    c0408989 <sglib__vmm_tree_it_init+0x140>
c040894b:	83 ec 08             	sub    $0x8,%esp
c040894e:	ff 74 24 20          	pushl  0x20(%esp)
c0408952:	ff 74 24 4c          	pushl  0x4c(%esp)
c0408956:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c040895a:	ff d0                	call   *%eax
c040895c:	83 c4 10             	add    $0x10,%esp
c040895f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0408963:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0408968:	79 0d                	jns    c0408977 <sglib__vmm_tree_it_init+0x12e>
c040896a:	8b 44 24 18          	mov    0x18(%esp),%eax
c040896e:	8b 40 04             	mov    0x4(%eax),%eax
c0408971:	89 44 24 18          	mov    %eax,0x18(%esp)
c0408975:	eb 12                	jmp    c0408989 <sglib__vmm_tree_it_init+0x140>
c0408977:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040897c:	7e 12                	jle    c0408990 <sglib__vmm_tree_it_init+0x147>
c040897e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408982:	8b 40 08             	mov    0x8(%eax),%eax
c0408985:	89 44 24 18          	mov    %eax,0x18(%esp)
c0408989:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c040898e:	75 bb                	jne    c040894b <sglib__vmm_tree_it_init+0x102>
c0408990:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408994:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0408998:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040899d:	75 19                	jne    c04089b8 <sglib__vmm_tree_it_init+0x16f>
c040899f:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089a3:	66 c7 80 84 02 00 00 	movw   $0x0,0x284(%eax)
c04089aa:	00 00 
c04089ac:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089b0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c04089b6:	eb 45                	jmp    c04089fd <sglib__vmm_tree_it_init+0x1b4>
c04089b8:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089bc:	66 c7 80 84 02 00 00 	movw   $0x1,0x284(%eax)
c04089c3:	01 00 
c04089c5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089c9:	c6 40 04 00          	movb   $0x0,0x4(%eax)
c04089cd:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089d1:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04089d5:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
c04089db:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c04089e0:	75 0c                	jne    c04089ee <sglib__vmm_tree_it_init+0x1a5>
c04089e2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089e6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04089ea:	89 10                	mov    %edx,(%eax)
c04089ec:	eb 0f                	jmp    c04089fd <sglib__vmm_tree_it_init+0x1b4>
c04089ee:	83 ec 0c             	sub    $0xc,%esp
c04089f1:	ff 74 24 3c          	pushl  0x3c(%esp)
c04089f5:	e8 d4 fb ff ff       	call   c04085ce <sglib__vmm_tree_it_compute_current_elem>
c04089fa:	83 c4 10             	add    $0x10,%esp
c04089fd:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a01:	8b 00                	mov    (%eax),%eax
c0408a03:	83 c4 2c             	add    $0x2c,%esp
c0408a06:	c3                   	ret    

c0408a07 <sglib_vmm_tree_it_init>:
c0408a07:	83 ec 0c             	sub    $0xc,%esp
c0408a0a:	83 ec 0c             	sub    $0xc,%esp
c0408a0d:	6a 00                	push   $0x0
c0408a0f:	6a 00                	push   $0x0
c0408a11:	6a 02                	push   $0x2
c0408a13:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a17:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a1b:	e8 29 fe ff ff       	call   c0408849 <sglib__vmm_tree_it_init>
c0408a20:	83 c4 20             	add    $0x20,%esp
c0408a23:	83 c4 0c             	add    $0xc,%esp
c0408a26:	c3                   	ret    

c0408a27 <sglib_vmm_tree_it_init_preorder>:
c0408a27:	83 ec 0c             	sub    $0xc,%esp
c0408a2a:	83 ec 0c             	sub    $0xc,%esp
c0408a2d:	6a 00                	push   $0x0
c0408a2f:	6a 00                	push   $0x0
c0408a31:	6a 00                	push   $0x0
c0408a33:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a37:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a3b:	e8 09 fe ff ff       	call   c0408849 <sglib__vmm_tree_it_init>
c0408a40:	83 c4 20             	add    $0x20,%esp
c0408a43:	83 c4 0c             	add    $0xc,%esp
c0408a46:	c3                   	ret    

c0408a47 <sglib_vmm_tree_it_init_inorder>:
c0408a47:	83 ec 0c             	sub    $0xc,%esp
c0408a4a:	83 ec 0c             	sub    $0xc,%esp
c0408a4d:	6a 00                	push   $0x0
c0408a4f:	6a 00                	push   $0x0
c0408a51:	6a 01                	push   $0x1
c0408a53:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a57:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a5b:	e8 e9 fd ff ff       	call   c0408849 <sglib__vmm_tree_it_init>
c0408a60:	83 c4 20             	add    $0x20,%esp
c0408a63:	83 c4 0c             	add    $0xc,%esp
c0408a66:	c3                   	ret    

c0408a67 <sglib_vmm_tree_it_init_postorder>:
c0408a67:	83 ec 0c             	sub    $0xc,%esp
c0408a6a:	83 ec 0c             	sub    $0xc,%esp
c0408a6d:	6a 00                	push   $0x0
c0408a6f:	6a 00                	push   $0x0
c0408a71:	6a 02                	push   $0x2
c0408a73:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a77:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a7b:	e8 c9 fd ff ff       	call   c0408849 <sglib__vmm_tree_it_init>
c0408a80:	83 c4 20             	add    $0x20,%esp
c0408a83:	83 c4 0c             	add    $0xc,%esp
c0408a86:	c3                   	ret    

c0408a87 <sglib_vmm_tree_it_init_on_equal>:
c0408a87:	83 ec 0c             	sub    $0xc,%esp
c0408a8a:	83 ec 0c             	sub    $0xc,%esp
c0408a8d:	ff 74 24 28          	pushl  0x28(%esp)
c0408a91:	ff 74 24 28          	pushl  0x28(%esp)
c0408a95:	6a 01                	push   $0x1
c0408a97:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a9b:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408a9f:	e8 a5 fd ff ff       	call   c0408849 <sglib__vmm_tree_it_init>
c0408aa4:	83 c4 20             	add    $0x20,%esp
c0408aa7:	83 c4 0c             	add    $0xc,%esp
c0408aaa:	c3                   	ret    

c0408aab <sglib_vmm_tree_it_current>:
c0408aab:	8b 44 24 04          	mov    0x4(%esp),%eax
c0408aaf:	8b 00                	mov    (%eax),%eax
c0408ab1:	c3                   	ret    

c0408ab2 <sglib_vmm_tree_it_next>:
c0408ab2:	83 ec 0c             	sub    $0xc,%esp
c0408ab5:	83 ec 0c             	sub    $0xc,%esp
c0408ab8:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408abc:	e8 0d fb ff ff       	call   c04085ce <sglib__vmm_tree_it_compute_current_elem>
c0408ac1:	83 c4 10             	add    $0x10,%esp
c0408ac4:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408ac8:	8b 00                	mov    (%eax),%eax
c0408aca:	83 c4 0c             	add    $0xc,%esp
c0408acd:	c3                   	ret    

c0408ace <sglib___vmm_tree_consistency_check_recursive>:
c0408ace:	83 ec 0c             	sub    $0xc,%esp
c0408ad1:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0408ad6:	75 4a                	jne    c0408b22 <sglib___vmm_tree_consistency_check_recursive+0x54>
c0408ad8:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408adc:	8b 00                	mov    (%eax),%eax
c0408ade:	85 c0                	test   %eax,%eax
c0408ae0:	79 0f                	jns    c0408af1 <sglib___vmm_tree_consistency_check_recursive+0x23>
c0408ae2:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408ae6:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408aea:	89 10                	mov    %edx,(%eax)
c0408aec:	e9 ed 01 00 00       	jmp    c0408cde <sglib___vmm_tree_consistency_check_recursive+0x210>
c0408af1:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408af5:	8b 00                	mov    (%eax),%eax
c0408af7:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0408afb:	0f 84 dd 01 00 00    	je     c0408cde <sglib___vmm_tree_consistency_check_recursive+0x210>
c0408b01:	68 1e 03 00 00       	push   $0x31e
c0408b06:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408b0b:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408b10:	68 e4 f1 40 c0       	push   $0xc040f1e4
c0408b15:	e8 49 44 00 00       	call   c040cf63 <debug_assert>
c0408b1a:	83 c4 10             	add    $0x10,%esp
c0408b1d:	e9 bc 01 00 00       	jmp    c0408cde <sglib___vmm_tree_consistency_check_recursive+0x210>
c0408b22:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b26:	8b 40 04             	mov    0x4(%eax),%eax
c0408b29:	85 c0                	test   %eax,%eax
c0408b2b:	74 5a                	je     c0408b87 <sglib___vmm_tree_consistency_check_recursive+0xb9>
c0408b2d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b31:	8b 40 04             	mov    0x4(%eax),%eax
c0408b34:	8b 00                	mov    (%eax),%eax
c0408b36:	8b 50 08             	mov    0x8(%eax),%edx
c0408b39:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b3d:	8b 00                	mov    (%eax),%eax
c0408b3f:	8b 40 08             	mov    0x8(%eax),%eax
c0408b42:	39 c2                	cmp    %eax,%edx
c0408b44:	72 41                	jb     c0408b87 <sglib___vmm_tree_consistency_check_recursive+0xb9>
c0408b46:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b4a:	8b 40 04             	mov    0x4(%eax),%eax
c0408b4d:	8b 00                	mov    (%eax),%eax
c0408b4f:	8b 50 08             	mov    0x8(%eax),%edx
c0408b52:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b56:	8b 00                	mov    (%eax),%eax
c0408b58:	8b 48 08             	mov    0x8(%eax),%ecx
c0408b5b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b5f:	8b 00                	mov    (%eax),%eax
c0408b61:	8b 40 0c             	mov    0xc(%eax),%eax
c0408b64:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0408b67:	39 c2                	cmp    %eax,%edx
c0408b69:	72 1c                	jb     c0408b87 <sglib___vmm_tree_consistency_check_recursive+0xb9>
c0408b6b:	68 1e 03 00 00       	push   $0x31e
c0408b70:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408b75:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408b7a:	68 f7 f1 40 c0       	push   $0xc040f1f7
c0408b7f:	e8 df 43 00 00       	call   c040cf63 <debug_assert>
c0408b84:	83 c4 10             	add    $0x10,%esp
c0408b87:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b8b:	8b 40 08             	mov    0x8(%eax),%eax
c0408b8e:	85 c0                	test   %eax,%eax
c0408b90:	74 5d                	je     c0408bef <sglib___vmm_tree_consistency_check_recursive+0x121>
c0408b92:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b96:	8b 00                	mov    (%eax),%eax
c0408b98:	8b 50 08             	mov    0x8(%eax),%edx
c0408b9b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408b9f:	8b 40 08             	mov    0x8(%eax),%eax
c0408ba2:	8b 00                	mov    (%eax),%eax
c0408ba4:	8b 40 08             	mov    0x8(%eax),%eax
c0408ba7:	39 c2                	cmp    %eax,%edx
c0408ba9:	72 44                	jb     c0408bef <sglib___vmm_tree_consistency_check_recursive+0x121>
c0408bab:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408baf:	8b 00                	mov    (%eax),%eax
c0408bb1:	8b 50 08             	mov    0x8(%eax),%edx
c0408bb4:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408bb8:	8b 40 08             	mov    0x8(%eax),%eax
c0408bbb:	8b 00                	mov    (%eax),%eax
c0408bbd:	8b 48 08             	mov    0x8(%eax),%ecx
c0408bc0:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408bc4:	8b 40 08             	mov    0x8(%eax),%eax
c0408bc7:	8b 00                	mov    (%eax),%eax
c0408bc9:	8b 40 0c             	mov    0xc(%eax),%eax
c0408bcc:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0408bcf:	39 c2                	cmp    %eax,%edx
c0408bd1:	72 1c                	jb     c0408bef <sglib___vmm_tree_consistency_check_recursive+0x121>
c0408bd3:	68 1e 03 00 00       	push   $0x31e
c0408bd8:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408bdd:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408be2:	68 14 f2 40 c0       	push   $0xc040f214
c0408be7:	e8 77 43 00 00       	call   c040cf63 <debug_assert>
c0408bec:	83 c4 10             	add    $0x10,%esp
c0408bef:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408bf3:	8a 40 0c             	mov    0xc(%eax),%al
c0408bf6:	3c 01                	cmp    $0x1,%al
c0408bf8:	0f 85 a2 00 00 00    	jne    c0408ca0 <sglib___vmm_tree_consistency_check_recursive+0x1d2>
c0408bfe:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c02:	8b 40 04             	mov    0x4(%eax),%eax
c0408c05:	85 c0                	test   %eax,%eax
c0408c07:	74 2a                	je     c0408c33 <sglib___vmm_tree_consistency_check_recursive+0x165>
c0408c09:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c0d:	8b 40 04             	mov    0x4(%eax),%eax
c0408c10:	8a 40 0c             	mov    0xc(%eax),%al
c0408c13:	84 c0                	test   %al,%al
c0408c15:	74 1c                	je     c0408c33 <sglib___vmm_tree_consistency_check_recursive+0x165>
c0408c17:	68 1e 03 00 00       	push   $0x31e
c0408c1c:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408c21:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408c26:	68 34 f2 40 c0       	push   $0xc040f234
c0408c2b:	e8 33 43 00 00       	call   c040cf63 <debug_assert>
c0408c30:	83 c4 10             	add    $0x10,%esp
c0408c33:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c37:	8b 40 08             	mov    0x8(%eax),%eax
c0408c3a:	85 c0                	test   %eax,%eax
c0408c3c:	74 2a                	je     c0408c68 <sglib___vmm_tree_consistency_check_recursive+0x19a>
c0408c3e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c42:	8b 40 08             	mov    0x8(%eax),%eax
c0408c45:	8a 40 0c             	mov    0xc(%eax),%al
c0408c48:	84 c0                	test   %al,%al
c0408c4a:	74 1c                	je     c0408c68 <sglib___vmm_tree_consistency_check_recursive+0x19a>
c0408c4c:	68 1e 03 00 00       	push   $0x31e
c0408c51:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408c56:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408c5b:	68 70 f2 40 c0       	push   $0xc040f270
c0408c60:	e8 fe 42 00 00       	call   c040cf63 <debug_assert>
c0408c65:	83 c4 10             	add    $0x10,%esp
c0408c68:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c6c:	8b 40 04             	mov    0x4(%eax),%eax
c0408c6f:	83 ec 04             	sub    $0x4,%esp
c0408c72:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408c76:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408c7a:	50                   	push   %eax
c0408c7b:	e8 4e fe ff ff       	call   c0408ace <sglib___vmm_tree_consistency_check_recursive>
c0408c80:	83 c4 10             	add    $0x10,%esp
c0408c83:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408c87:	8b 40 08             	mov    0x8(%eax),%eax
c0408c8a:	83 ec 04             	sub    $0x4,%esp
c0408c8d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408c91:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408c95:	50                   	push   %eax
c0408c96:	e8 33 fe ff ff       	call   c0408ace <sglib___vmm_tree_consistency_check_recursive>
c0408c9b:	83 c4 10             	add    $0x10,%esp
c0408c9e:	eb 3e                	jmp    c0408cde <sglib___vmm_tree_consistency_check_recursive+0x210>
c0408ca0:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408ca4:	8d 50 01             	lea    0x1(%eax),%edx
c0408ca7:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408cab:	8b 40 04             	mov    0x4(%eax),%eax
c0408cae:	83 ec 04             	sub    $0x4,%esp
c0408cb1:	52                   	push   %edx
c0408cb2:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408cb6:	50                   	push   %eax
c0408cb7:	e8 12 fe ff ff       	call   c0408ace <sglib___vmm_tree_consistency_check_recursive>
c0408cbc:	83 c4 10             	add    $0x10,%esp
c0408cbf:	8b 44 24 18          	mov    0x18(%esp),%eax
c0408cc3:	8d 50 01             	lea    0x1(%eax),%edx
c0408cc6:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408cca:	8b 40 08             	mov    0x8(%eax),%eax
c0408ccd:	83 ec 04             	sub    $0x4,%esp
c0408cd0:	52                   	push   %edx
c0408cd1:	ff 74 24 1c          	pushl  0x1c(%esp)
c0408cd5:	50                   	push   %eax
c0408cd6:	e8 f3 fd ff ff       	call   c0408ace <sglib___vmm_tree_consistency_check_recursive>
c0408cdb:	83 c4 10             	add    $0x10,%esp
c0408cde:	83 c4 0c             	add    $0xc,%esp
c0408ce1:	c3                   	ret    

c0408ce2 <sglib___vmm_tree_consistency_check>:
c0408ce2:	83 ec 1c             	sub    $0x1c,%esp
c0408ce5:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0408cea:	74 27                	je     c0408d13 <sglib___vmm_tree_consistency_check+0x31>
c0408cec:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408cf0:	8a 40 0c             	mov    0xc(%eax),%al
c0408cf3:	84 c0                	test   %al,%al
c0408cf5:	74 1c                	je     c0408d13 <sglib___vmm_tree_consistency_check+0x31>
c0408cf7:	68 1e 03 00 00       	push   $0x31e
c0408cfc:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408d01:	68 d5 ef 40 c0       	push   $0xc040efd5
c0408d06:	68 ac f2 40 c0       	push   $0xc040f2ac
c0408d0b:	e8 53 42 00 00       	call   c040cf63 <debug_assert>
c0408d10:	83 c4 10             	add    $0x10,%esp
c0408d13:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0408d1a:	ff 
c0408d1b:	83 ec 04             	sub    $0x4,%esp
c0408d1e:	6a 00                	push   $0x0
c0408d20:	8d 44 24 14          	lea    0x14(%esp),%eax
c0408d24:	50                   	push   %eax
c0408d25:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408d29:	e8 a0 fd ff ff       	call   c0408ace <sglib___vmm_tree_consistency_check_recursive>
c0408d2e:	83 c4 10             	add    $0x10,%esp
c0408d31:	83 c4 1c             	add    $0x1c,%esp
c0408d34:	c3                   	ret    

c0408d35 <vmm_link_vma>:
   => proc = process to link the vma with
      vma = the vma to link
   <= success or a failure code
*/
kresult vmm_link_vma(process *proc, vmm_area *vma)
{
c0408d35:	83 ec 2c             	sub    $0x2c,%esp
	kresult err;
	vmm_tree *new, *existing;
	unsigned int loop;
	
	/* allocate and zero memory for the new tree node */
	err = vmm_malloc((void **)&new, sizeof(vmm_tree));
c0408d38:	8d 44 24 10          	lea    0x10(%esp),%eax
c0408d3c:	83 ec 08             	sub    $0x8,%esp
c0408d3f:	6a 10                	push   $0x10
c0408d41:	50                   	push   %eax
c0408d42:	e8 49 d1 ff ff       	call   c0405e90 <vmm_malloc>
c0408d47:	83 c4 10             	add    $0x10,%esp
c0408d4a:	89 44 24 14          	mov    %eax,0x14(%esp)
	if(err) return err;
c0408d4e:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0408d53:	74 09                	je     c0408d5e <vmm_link_vma+0x29>
c0408d55:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408d59:	e9 0e 02 00 00       	jmp    c0408f6c <vmm_link_vma+0x237>
	vmm_memset(new, 0, sizeof(vmm_tree));
c0408d5e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408d62:	83 ec 04             	sub    $0x4,%esp
c0408d65:	6a 10                	push   $0x10
c0408d67:	6a 00                	push   $0x0
c0408d69:	50                   	push   %eax
c0408d6a:	e8 77 df ff ff       	call   c0406ce6 <vmm_memset>
c0408d6f:	83 c4 10             	add    $0x10,%esp
	
	/* set the area pointer */
	new->area = vma;
c0408d72:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408d76:	8b 54 24 34          	mov    0x34(%esp),%edx
c0408d7a:	89 10                	mov    %edx,(%eax)
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c0408d7c:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408d80:	83 c0 10             	add    $0x10,%eax
c0408d83:	83 ec 08             	sub    $0x8,%esp
c0408d86:	6a 01                	push   $0x1
c0408d88:	50                   	push   %eax
c0408d89:	e8 fd 76 ff ff       	call   c040048b <lock_gate>
c0408d8e:	83 c4 10             	add    $0x10,%esp
	
	/* and try to add to the tree */
	if(sglib_vmm_tree_add_if_not_member(&(proc->mem), new, &existing))
c0408d91:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408d95:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408d99:	8d 4a 48             	lea    0x48(%edx),%ecx
c0408d9c:	83 ec 04             	sub    $0x4,%esp
c0408d9f:	8d 54 24 10          	lea    0x10(%esp),%edx
c0408da3:	52                   	push   %edx
c0408da4:	50                   	push   %eax
c0408da5:	51                   	push   %ecx
c0408da6:	e8 7e f6 ff ff       	call   c0408429 <sglib_vmm_tree_add_if_not_member>
c0408dab:	83 c4 10             	add    $0x10,%esp
c0408dae:	85 c0                	test   %eax,%eax
c0408db0:	0f 84 85 01 00 00    	je     c0408f3b <vmm_link_vma+0x206>
	{
		lock_gate(&(vma->lock), LOCK_WRITE);
c0408db6:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408dba:	83 c0 14             	add    $0x14,%eax
c0408dbd:	83 ec 08             	sub    $0x8,%esp
c0408dc0:	6a 01                	push   $0x1
c0408dc2:	50                   	push   %eax
c0408dc3:	e8 c3 76 ff ff       	call   c040048b <lock_gate>
c0408dc8:	83 c4 10             	add    $0x10,%esp
		
		/* non-zero return for success, so incremement the refcount */
		vma->refcount++;
c0408dcb:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408dcf:	8b 40 04             	mov    0x4(%eax),%eax
c0408dd2:	8d 50 01             	lea    0x1(%eax),%edx
c0408dd5:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408dd9:	89 50 04             	mov    %edx,0x4(%eax)
		err = success;
c0408ddc:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0408de3:	00 
		dprintf(DEBUG_COL_VMM "[vmm:%i] linked vma %p to process %i (%p) via tree node %p\n" DEBUG_COL_OFF,
				  CPU_ID, vma, proc->pid, proc, new);
#endif
		
		/* add the vma to the list of users */
		if(vma->refcount > vma->users_max)
c0408de4:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408de8:	8b 50 04             	mov    0x4(%eax),%edx
c0408deb:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408def:	8b 40 24             	mov    0x24(%eax),%eax
c0408df2:	39 c2                	cmp    %eax,%edx
c0408df4:	0f 86 e0 00 00 00    	jbe    c0408eda <vmm_link_vma+0x1a5>
		{
			process **new_list;
			
			/* we need to grow the list size */
			unsigned int new_size = vma->users_max * 2;
c0408dfa:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408dfe:	8b 40 24             	mov    0x24(%eax),%eax
c0408e01:	d1 e0                	shl    %eax
c0408e03:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			
			if(vmm_malloc((void **)&new_list, new_size * sizeof(process *)))
c0408e07:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0408e0b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0408e12:	8d 44 24 08          	lea    0x8(%esp),%eax
c0408e16:	83 ec 08             	sub    $0x8,%esp
c0408e19:	52                   	push   %edx
c0408e1a:	50                   	push   %eax
c0408e1b:	e8 70 d0 ff ff       	call   c0405e90 <vmm_malloc>
c0408e20:	83 c4 10             	add    $0x10,%esp
c0408e23:	85 c0                	test   %eax,%eax
c0408e25:	74 4d                	je     c0408e74 <vmm_link_vma+0x13f>
			{
				vmm_free(vma);
c0408e27:	83 ec 0c             	sub    $0xc,%esp
c0408e2a:	ff 74 24 40          	pushl  0x40(%esp)
c0408e2e:	e8 9f d4 ff ff       	call   c04062d2 <vmm_free>
c0408e33:	83 c4 10             	add    $0x10,%esp
				new->area = NULL; /* FIXME: and unlink from the tree ?? */
c0408e36:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408e3a:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				unlock_gate(&(vma->lock), LOCK_WRITE);
c0408e40:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408e44:	83 c0 14             	add    $0x14,%eax
c0408e47:	83 ec 08             	sub    $0x8,%esp
c0408e4a:	6a 01                	push   $0x1
c0408e4c:	50                   	push   %eax
c0408e4d:	e8 56 78 ff ff       	call   c04006a8 <unlock_gate>
c0408e52:	83 c4 10             	add    $0x10,%esp
				unlock_gate(&(proc->lock), LOCK_WRITE);
c0408e55:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408e59:	83 c0 10             	add    $0x10,%eax
c0408e5c:	83 ec 08             	sub    $0x8,%esp
c0408e5f:	6a 01                	push   $0x1
c0408e61:	50                   	push   %eax
c0408e62:	e8 41 78 ff ff       	call   c04006a8 <unlock_gate>
c0408e67:	83 c4 10             	add    $0x10,%esp
				return e_failure; /* bail out if the malloc failed! */
c0408e6a:	b8 01 00 00 00       	mov    $0x1,%eax
c0408e6f:	e9 f8 00 00 00       	jmp    c0408f6c <vmm_link_vma+0x237>
			}
			
			vmm_memset(new_list, 0, new_size); /* clean the new list */
c0408e74:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408e78:	83 ec 04             	sub    $0x4,%esp
c0408e7b:	ff 74 24 20          	pushl  0x20(%esp)
c0408e7f:	6a 00                	push   $0x0
c0408e81:	50                   	push   %eax
c0408e82:	e8 5f de ff ff       	call   c0406ce6 <vmm_memset>
c0408e87:	83 c4 10             	add    $0x10,%esp
			
			/* copy over the previous list */
			vmm_memcpy(new_list, vma->users, vma->users_max * sizeof(process *));
c0408e8a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408e8e:	8b 40 24             	mov    0x24(%eax),%eax
c0408e91:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0408e98:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408e9c:	8b 50 2c             	mov    0x2c(%eax),%edx
c0408e9f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408ea3:	83 ec 04             	sub    $0x4,%esp
c0408ea6:	51                   	push   %ecx
c0408ea7:	52                   	push   %edx
c0408ea8:	50                   	push   %eax
c0408ea9:	e8 75 de ff ff       	call   c0406d23 <vmm_memcpy>
c0408eae:	83 c4 10             	add    $0x10,%esp
			vmm_free(vma->users); /* free the old list */
c0408eb1:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408eb5:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408eb8:	83 ec 0c             	sub    $0xc,%esp
c0408ebb:	50                   	push   %eax
c0408ebc:	e8 11 d4 ff ff       	call   c04062d2 <vmm_free>
c0408ec1:	83 c4 10             	add    $0x10,%esp
			
			/* update the list's accounting */
			vma->users = new_list;
c0408ec4:	8b 54 24 08          	mov    0x8(%esp),%edx
c0408ec8:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408ecc:	89 50 2c             	mov    %edx,0x2c(%eax)
			vma->users_max = new_size;
c0408ecf:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408ed3:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0408ed7:	89 50 24             	mov    %edx,0x24(%eax)
		}
		
		/* find an empty slot and insert the new user's pointer */
		for(loop = 0; loop < vma->users_max; loop++)
c0408eda:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0408ee1:	00 
c0408ee2:	eb 33                	jmp    c0408f17 <vmm_link_vma+0x1e2>
			if((vma->users[loop]) == NULL)
c0408ee4:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408ee8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408eeb:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408eef:	c1 e2 02             	shl    $0x2,%edx
c0408ef2:	01 d0                	add    %edx,%eax
c0408ef4:	8b 00                	mov    (%eax),%eax
c0408ef6:	85 c0                	test   %eax,%eax
c0408ef8:	75 19                	jne    c0408f13 <vmm_link_vma+0x1de>
			{
				/* found a free slot */
				vma->users[loop] = proc;
c0408efa:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408efe:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408f01:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408f05:	c1 e2 02             	shl    $0x2,%edx
c0408f08:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0408f0b:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408f0f:	89 02                	mov    %eax,(%edx)
				break;
c0408f11:	eb 11                	jmp    c0408f24 <vmm_link_vma+0x1ef>
			vma->users = new_list;
			vma->users_max = new_size;
		}
		
		/* find an empty slot and insert the new user's pointer */
		for(loop = 0; loop < vma->users_max; loop++)
c0408f13:	ff 44 24 18          	incl   0x18(%esp)
c0408f17:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408f1b:	8b 40 24             	mov    0x24(%eax),%eax
c0408f1e:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0408f22:	77 c0                	ja     c0408ee4 <vmm_link_vma+0x1af>
				/* found a free slot */
				vma->users[loop] = proc;
				break;
			}
		
		unlock_gate(&(vma->lock), LOCK_WRITE);
c0408f24:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408f28:	83 c0 14             	add    $0x14,%eax
c0408f2b:	83 ec 08             	sub    $0x8,%esp
c0408f2e:	6a 01                	push   $0x1
c0408f30:	50                   	push   %eax
c0408f31:	e8 72 77 ff ff       	call   c04006a8 <unlock_gate>
c0408f36:	83 c4 10             	add    $0x10,%esp
c0408f39:	eb 18                	jmp    c0408f53 <vmm_link_vma+0x21e>
	}
	else
	{
		/* the vma already exists or collides with an area */
		err = e_vma_exists;
c0408f3b:	c7 44 24 14 15 00 00 	movl   $0x15,0x14(%esp)
c0408f42:	00 
		vmm_free(new);
c0408f43:	8b 44 24 10          	mov    0x10(%esp),%eax
c0408f47:	83 ec 0c             	sub    $0xc,%esp
c0408f4a:	50                   	push   %eax
c0408f4b:	e8 82 d3 ff ff       	call   c04062d2 <vmm_free>
c0408f50:	83 c4 10             	add    $0x10,%esp
		dprintf(DEBUG_COL_VMM "[vmm:%i] couldn't link vma %p to process %i (%p) - collision with vma %p\n" DEBUG_COL_OFF, 
				  CPU_ID, vma, proc->pid, proc, existing->area);
#endif
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0408f53:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408f57:	83 c0 10             	add    $0x10,%eax
c0408f5a:	83 ec 08             	sub    $0x8,%esp
c0408f5d:	6a 01                	push   $0x1
c0408f5f:	50                   	push   %eax
c0408f60:	e8 43 77 ff ff       	call   c04006a8 <unlock_gate>
c0408f65:	83 c4 10             	add    $0x10,%esp
	
	return err;
c0408f68:	8b 44 24 14          	mov    0x14(%esp),%eax
}
c0408f6c:	83 c4 2c             	add    $0x2c,%esp
c0408f6f:	c3                   	ret    

c0408f70 <vmm_unlink_vma>:
   => owner = process to unlink the vma from
      victim = the vma to unlink
   <= success or a failure code
 */
kresult vmm_unlink_vma(process *owner, vmm_tree *victim)
{
c0408f70:	83 ec 1c             	sub    $0x1c,%esp
	lock_gate(&(owner->lock), LOCK_WRITE);
c0408f73:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f77:	83 c0 10             	add    $0x10,%eax
c0408f7a:	83 ec 08             	sub    $0x8,%esp
c0408f7d:	6a 01                	push   $0x1
c0408f7f:	50                   	push   %eax
c0408f80:	e8 06 75 ff ff       	call   c040048b <lock_gate>
c0408f85:	83 c4 10             	add    $0x10,%esp
	
	unsigned int loop;
	vmm_area *vma = victim->area;
c0408f88:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408f8c:	8b 00                	mov    (%eax),%eax
c0408f8e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	lock_gate(&(vma->lock), LOCK_WRITE);
c0408f92:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408f96:	83 c0 14             	add    $0x14,%eax
c0408f99:	83 ec 08             	sub    $0x8,%esp
c0408f9c:	6a 01                	push   $0x1
c0408f9e:	50                   	push   %eax
c0408f9f:	e8 e7 74 ff ff       	call   c040048b <lock_gate>
c0408fa4:	83 c4 10             	add    $0x10,%esp
	
	/* try to remove from the tree */
	sglib_vmm_tree_delete(&(owner->mem), victim);
c0408fa7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408fab:	83 c0 48             	add    $0x48,%eax
c0408fae:	83 ec 08             	sub    $0x8,%esp
c0408fb1:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408fb5:	50                   	push   %eax
c0408fb6:	e8 89 f2 ff ff       	call   c0408244 <sglib_vmm_tree_delete>
c0408fbb:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(owner->lock), LOCK_WRITE);
c0408fbe:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408fc2:	83 c0 10             	add    $0x10,%eax
c0408fc5:	83 ec 08             	sub    $0x8,%esp
c0408fc8:	6a 01                	push   $0x1
c0408fca:	50                   	push   %eax
c0408fcb:	e8 d8 76 ff ff       	call   c04006a8 <unlock_gate>
c0408fd0:	83 c4 10             	add    $0x10,%esp
	
	/* delete from the vma's users list */
	for(loop = 0; loop < vma->refcount; loop++)
c0408fd3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0408fda:	00 
c0408fdb:	eb 3f                	jmp    c040901c <vmm_unlink_vma+0xac>
	{
		if(vma->users[loop] == owner)
c0408fdd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408fe1:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408fe4:	8b 54 24 08          	mov    0x8(%esp),%edx
c0408fe8:	c1 e2 02             	shl    $0x2,%edx
c0408feb:	01 d0                	add    %edx,%eax
c0408fed:	8b 00                	mov    (%eax),%eax
c0408fef:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0408ff3:	75 23                	jne    c0409018 <vmm_unlink_vma+0xa8>
		{
			vma->users[loop] = NULL;
c0408ff5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408ff9:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408ffc:	8b 54 24 08          	mov    0x8(%esp),%edx
c0409000:	c1 e2 02             	shl    $0x2,%edx
c0409003:	01 d0                	add    %edx,%eax
c0409005:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			vma->users_ptr = loop; /* next free slot is this one */
c040900b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040900f:	8b 54 24 08          	mov    0x8(%esp),%edx
c0409013:	89 50 28             	mov    %edx,0x28(%eax)
			break;
c0409016:	eb 11                	jmp    c0409029 <vmm_unlink_vma+0xb9>
	/* try to remove from the tree */
	sglib_vmm_tree_delete(&(owner->mem), victim);
	unlock_gate(&(owner->lock), LOCK_WRITE);
	
	/* delete from the vma's users list */
	for(loop = 0; loop < vma->refcount; loop++)
c0409018:	ff 44 24 08          	incl   0x8(%esp)
c040901c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409020:	8b 40 04             	mov    0x4(%eax),%eax
c0409023:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0409027:	77 b4                	ja     c0408fdd <vmm_unlink_vma+0x6d>
			break;
		}
	}
	
	/* reduce the refcount and free if zero */
	vma->refcount--;
c0409029:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040902d:	8b 40 04             	mov    0x4(%eax),%eax
c0409030:	8d 50 ff             	lea    -0x1(%eax),%edx
c0409033:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409037:	89 50 04             	mov    %edx,0x4(%eax)
	if(!(vma->refcount))
c040903a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040903e:	8b 40 04             	mov    0x4(%eax),%eax
c0409041:	85 c0                	test   %eax,%eax
c0409043:	75 26                	jne    c040906b <vmm_unlink_vma+0xfb>
	{
		unlock_gate(&(vma->lock), LOCK_WRITE | LOCK_SELFDESTRUCT);
c0409045:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409049:	83 c0 14             	add    $0x14,%eax
c040904c:	83 ec 08             	sub    $0x8,%esp
c040904f:	6a 03                	push   $0x3
c0409051:	50                   	push   %eax
c0409052:	e8 51 76 ff ff       	call   c04006a8 <unlock_gate>
c0409057:	83 c4 10             	add    $0x10,%esp
		vmm_free(vma);
c040905a:	83 ec 0c             	sub    $0xc,%esp
c040905d:	ff 74 24 18          	pushl  0x18(%esp)
c0409061:	e8 6c d2 ff ff       	call   c04062d2 <vmm_free>
c0409066:	83 c4 10             	add    $0x10,%esp
c0409069:	eb 15                	jmp    c0409080 <vmm_unlink_vma+0x110>
	}
	else
		unlock_gate(&(vma->lock), LOCK_WRITE);
c040906b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040906f:	83 c0 14             	add    $0x14,%eax
c0409072:	83 ec 08             	sub    $0x8,%esp
c0409075:	6a 01                	push   $0x1
c0409077:	50                   	push   %eax
c0409078:	e8 2b 76 ff ff       	call   c04006a8 <unlock_gate>
c040907d:	83 c4 10             	add    $0x10,%esp
#ifdef VMM_DEBUG
	dprintf(DEBUG_COL_VMM "[vmm:%i] unlinked vma %p from tree node %p in process %i (%p)\n" DEBUG_COL_OFF,
			  CPU_ID, vma, victim, owner->pid, owner);
#endif
	
	return vmm_free(victim);
c0409080:	83 ec 0c             	sub    $0xc,%esp
c0409083:	ff 74 24 30          	pushl  0x30(%esp)
c0409087:	e8 46 d2 ff ff       	call   c04062d2 <vmm_free>
c040908c:	83 c4 10             	add    $0x10,%esp
}
c040908f:	83 c4 1c             	add    $0x1c,%esp
c0409092:	c3                   	ret    

c0409093 <vmm_add_vma>:
      cookie = a private reference set by the userspace page manager
   <= success or a failure code
*/
kresult vmm_add_vma(process *proc, unsigned int base, unsigned int size,
						  unsigned char flags, unsigned int cookie)
{
c0409093:	83 ec 2c             	sub    $0x2c,%esp
c0409096:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040909a:	88 44 24 0c          	mov    %al,0xc(%esp)
	vmm_area *new;
	kresult err = vmm_malloc((void **)&new, sizeof(vmm_area));
c040909e:	8d 44 24 18          	lea    0x18(%esp),%eax
c04090a2:	83 ec 08             	sub    $0x8,%esp
c04090a5:	6a 30                	push   $0x30
c04090a7:	50                   	push   %eax
c04090a8:	e8 e3 cd ff ff       	call   c0405e90 <vmm_malloc>
c04090ad:	83 c4 10             	add    $0x10,%esp
c04090b0:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err) return err;
c04090b4:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04090b9:	74 09                	je     c04090c4 <vmm_add_vma+0x31>
c04090bb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04090bf:	e9 e1 00 00 00       	jmp    c04091a5 <vmm_add_vma+0x112>
	vmm_memset(new, 0, sizeof(vmm_area)); /* zero the area */
c04090c4:	8b 44 24 18          	mov    0x18(%esp),%eax
c04090c8:	83 ec 04             	sub    $0x4,%esp
c04090cb:	6a 30                	push   $0x30
c04090cd:	6a 00                	push   $0x0
c04090cf:	50                   	push   %eax
c04090d0:	e8 11 dc ff ff       	call   c0406ce6 <vmm_memset>
c04090d5:	83 c4 10             	add    $0x10,%esp
	
	/* fill in the details - ref_count will be updated by the link_vma() call */
	new->flags    = flags;
c04090d8:	8b 44 24 18          	mov    0x18(%esp),%eax
c04090dc:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04090e1:	89 10                	mov    %edx,(%eax)
	new->refcount = 0;
c04090e3:	8b 44 24 18          	mov    0x18(%esp),%eax
c04090e7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	new->base     = base;
c04090ee:	8b 44 24 18          	mov    0x18(%esp),%eax
c04090f2:	8b 54 24 34          	mov    0x34(%esp),%edx
c04090f6:	89 50 08             	mov    %edx,0x8(%eax)
	new->size     = size;
c04090f9:	8b 44 24 18          	mov    0x18(%esp),%eax
c04090fd:	8b 54 24 38          	mov    0x38(%esp),%edx
c0409101:	89 50 0c             	mov    %edx,0xc(%eax)
	new->token    = cookie;
c0409104:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409108:	8b 54 24 40          	mov    0x40(%esp),%edx
c040910c:	89 50 10             	mov    %edx,0x10(%eax)
	
	/* set up an empty amortised list of vma users */
	new->users_max = 4;
c040910f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409113:	c7 40 24 04 00 00 00 	movl   $0x4,0x24(%eax)
	err = vmm_malloc((void **)&(new->users), sizeof(process *) * new->users_max);
c040911a:	8b 44 24 18          	mov    0x18(%esp),%eax
c040911e:	8b 40 24             	mov    0x24(%eax),%eax
c0409121:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0409128:	8b 44 24 18          	mov    0x18(%esp),%eax
c040912c:	83 c0 2c             	add    $0x2c,%eax
c040912f:	83 ec 08             	sub    $0x8,%esp
c0409132:	52                   	push   %edx
c0409133:	50                   	push   %eax
c0409134:	e8 57 cd ff ff       	call   c0405e90 <vmm_malloc>
c0409139:	83 c4 10             	add    $0x10,%esp
c040913c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c0409140:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0409145:	74 16                	je     c040915d <vmm_add_vma+0xca>
	{
		vmm_free(new);
c0409147:	8b 44 24 18          	mov    0x18(%esp),%eax
c040914b:	83 ec 0c             	sub    $0xc,%esp
c040914e:	50                   	push   %eax
c040914f:	e8 7e d1 ff ff       	call   c04062d2 <vmm_free>
c0409154:	83 c4 10             	add    $0x10,%esp
		return err;
c0409157:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040915b:	eb 48                	jmp    c04091a5 <vmm_add_vma+0x112>
	}
	vmm_memset(new->users, 0, sizeof(process *) * new->users_max); /* zero the list */
c040915d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409161:	8b 40 24             	mov    0x24(%eax),%eax
c0409164:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040916b:	8b 44 24 18          	mov    0x18(%esp),%eax
c040916f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409172:	83 ec 04             	sub    $0x4,%esp
c0409175:	52                   	push   %edx
c0409176:	6a 00                	push   $0x0
c0409178:	50                   	push   %eax
c0409179:	e8 68 db ff ff       	call   c0406ce6 <vmm_memset>
c040917e:	83 c4 10             	add    $0x10,%esp
#ifdef VMM_DEBUG
	dprintf(DEBUG_COL_VMM "[vmm:%i] created vma %p for proc %i (%p): base %x size %i flags %x cookie %x\n" DEBUG_COL_OFF,
			  CPU_ID, new, proc->pid, proc, base, size, flags, cookie);
#endif
	
	if(vmm_link_vma(proc, new))
c0409181:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409185:	83 ec 08             	sub    $0x8,%esp
c0409188:	50                   	push   %eax
c0409189:	ff 74 24 3c          	pushl  0x3c(%esp)
c040918d:	e8 a3 fb ff ff       	call   c0408d35 <vmm_link_vma>
c0409192:	83 c4 10             	add    $0x10,%esp
c0409195:	85 c0                	test   %eax,%eax
c0409197:	74 07                	je     c04091a0 <vmm_add_vma+0x10d>
		return e_failure;
c0409199:	b8 01 00 00 00       	mov    $0x1,%eax
c040919e:	eb 05                	jmp    c04091a5 <vmm_add_vma+0x112>
	else
		return success;
c04091a0:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04091a5:	83 c4 2c             	add    $0x2c,%esp
c04091a8:	c3                   	ret    

c04091a9 <vmm_duplicate_vmas>:
   => new = child process
      source = parent process to clone from
   <= success or a failure code
*/
kresult vmm_duplicate_vmas(process *new, process *source)
{
c04091a9:	81 ec ac 02 00 00    	sub    $0x2ac,%esp
	kresult err;
	struct vmm_tree *node;
	struct sglib_vmm_tree_iterator state;
	
	if(!source) return e_failure;
c04091af:	83 bc 24 b4 02 00 00 	cmpl   $0x0,0x2b4(%esp)
c04091b6:	00 
c04091b7:	75 0a                	jne    c04091c3 <vmm_duplicate_vmas+0x1a>
c04091b9:	b8 01 00 00 00       	mov    $0x1,%eax
c04091be:	e9 ac 00 00 00       	jmp    c040926f <vmm_duplicate_vmas+0xc6>
#ifdef VMM_DEBUG
	dprintf(DEBUG_COL_VMM "[vmm:%i] duplicating process map for proc %i (%p) from %i (%p)\n" DEBUG_COL_OFF,
			  CPU_ID, new->pid, new, source->pid, source);
#endif
	
	lock_gate(&(source->lock), LOCK_READ);
c04091c3:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c04091ca:	83 c0 10             	add    $0x10,%eax
c04091cd:	83 ec 08             	sub    $0x8,%esp
c04091d0:	6a 00                	push   $0x0
c04091d2:	50                   	push   %eax
c04091d3:	e8 b3 72 ff ff       	call   c040048b <lock_gate>
c04091d8:	83 c4 10             	add    $0x10,%esp
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
c04091db:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c04091e2:	8b 40 48             	mov    0x48(%eax),%eax
c04091e5:	83 ec 08             	sub    $0x8,%esp
c04091e8:	50                   	push   %eax
c04091e9:	8d 44 24 14          	lea    0x14(%esp),%eax
c04091ed:	50                   	push   %eax
c04091ee:	e8 14 f8 ff ff       	call   c0408a07 <sglib_vmm_tree_it_init>
c04091f3:	83 c4 10             	add    $0x10,%esp
c04091f6:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
c04091fd:	eb 44                	jmp    c0409243 <vmm_duplicate_vmas+0x9a>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_link_vma(new, node->area);
c04091ff:	8b 84 24 9c 02 00 00 	mov    0x29c(%esp),%eax
c0409206:	8b 00                	mov    (%eax),%eax
c0409208:	83 ec 08             	sub    $0x8,%esp
c040920b:	50                   	push   %eax
c040920c:	ff b4 24 bc 02 00 00 	pushl  0x2bc(%esp)
c0409213:	e8 1d fb ff ff       	call   c0408d35 <vmm_link_vma>
c0409218:	83 c4 10             	add    $0x10,%esp
c040921b:	89 84 24 98 02 00 00 	mov    %eax,0x298(%esp)
		if(err != success) break;
c0409222:	83 bc 24 98 02 00 00 	cmpl   $0x0,0x298(%esp)
c0409229:	00 
c040922a:	75 23                	jne    c040924f <vmm_duplicate_vmas+0xa6>
	lock_gate(&(source->lock), LOCK_READ);
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
c040922c:	83 ec 0c             	sub    $0xc,%esp
c040922f:	8d 44 24 14          	lea    0x14(%esp),%eax
c0409233:	50                   	push   %eax
c0409234:	e8 79 f8 ff ff       	call   c0408ab2 <sglib_vmm_tree_it_next>
c0409239:	83 c4 10             	add    $0x10,%esp
c040923c:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
#endif
	
	lock_gate(&(source->lock), LOCK_READ);
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
c0409243:	83 bc 24 9c 02 00 00 	cmpl   $0x0,0x29c(%esp)
c040924a:	00 
c040924b:	75 b2                	jne    c04091ff <vmm_duplicate_vmas+0x56>
c040924d:	eb 01                	jmp    c0409250 <vmm_duplicate_vmas+0xa7>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_link_vma(new, node->area);
		if(err != success) break;
c040924f:	90                   	nop
	}
	
	unlock_gate(&(source->lock), LOCK_READ);
c0409250:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c0409257:	83 c0 10             	add    $0x10,%eax
c040925a:	83 ec 08             	sub    $0x8,%esp
c040925d:	6a 00                	push   $0x0
c040925f:	50                   	push   %eax
c0409260:	e8 43 74 ff ff       	call   c04006a8 <unlock_gate>
c0409265:	83 c4 10             	add    $0x10,%esp
	
	return err;
c0409268:	8b 84 24 98 02 00 00 	mov    0x298(%esp),%eax
}
c040926f:	81 c4 ac 02 00 00    	add    $0x2ac,%esp
c0409275:	c3                   	ret    

c0409276 <vmm_destroy_vmas>:

/* vmm_destroy_vmas
	Tear down the given process's memory tree
   <= success or a failure code */
kresult vmm_destroy_vmas(process *victim)
{
c0409276:	81 ec ac 02 00 00    	sub    $0x2ac,%esp
	kresult err;
	struct vmm_tree *node;
	struct sglib_vmm_tree_iterator state;	
	
	lock_gate(&(victim->lock), LOCK_WRITE);
c040927c:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c0409283:	83 c0 10             	add    $0x10,%eax
c0409286:	83 ec 08             	sub    $0x8,%esp
c0409289:	6a 01                	push   $0x1
c040928b:	50                   	push   %eax
c040928c:	e8 fa 71 ff ff       	call   c040048b <lock_gate>
c0409291:	83 c4 10             	add    $0x10,%esp
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
c0409294:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c040929b:	8b 40 48             	mov    0x48(%eax),%eax
c040929e:	83 ec 08             	sub    $0x8,%esp
c04092a1:	50                   	push   %eax
c04092a2:	8d 44 24 14          	lea    0x14(%esp),%eax
c04092a6:	50                   	push   %eax
c04092a7:	e8 5b f7 ff ff       	call   c0408a07 <sglib_vmm_tree_it_init>
c04092ac:	83 c4 10             	add    $0x10,%esp
c04092af:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
c04092b6:	eb 41                	jmp    c04092f9 <vmm_destroy_vmas+0x83>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_unlink_vma(victim, node);
c04092b8:	83 ec 08             	sub    $0x8,%esp
c04092bb:	ff b4 24 a4 02 00 00 	pushl  0x2a4(%esp)
c04092c2:	ff b4 24 bc 02 00 00 	pushl  0x2bc(%esp)
c04092c9:	e8 a2 fc ff ff       	call   c0408f70 <vmm_unlink_vma>
c04092ce:	83 c4 10             	add    $0x10,%esp
c04092d1:	89 84 24 98 02 00 00 	mov    %eax,0x298(%esp)
		if(err != success) break;
c04092d8:	83 bc 24 98 02 00 00 	cmpl   $0x0,0x298(%esp)
c04092df:	00 
c04092e0:	75 23                	jne    c0409305 <vmm_destroy_vmas+0x8f>
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
c04092e2:	83 ec 0c             	sub    $0xc,%esp
c04092e5:	8d 44 24 14          	lea    0x14(%esp),%eax
c04092e9:	50                   	push   %eax
c04092ea:	e8 c3 f7 ff ff       	call   c0408ab2 <sglib_vmm_tree_it_next>
c04092ef:	83 c4 10             	add    $0x10,%esp
c04092f2:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
	struct sglib_vmm_tree_iterator state;	
	
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
c04092f9:	83 bc 24 9c 02 00 00 	cmpl   $0x0,0x29c(%esp)
c0409300:	00 
c0409301:	75 b5                	jne    c04092b8 <vmm_destroy_vmas+0x42>
c0409303:	eb 01                	jmp    c0409306 <vmm_destroy_vmas+0x90>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_unlink_vma(victim, node);
		if(err != success) break;
c0409305:	90                   	nop
	}
	
	victim->mem = NULL;
c0409306:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c040930d:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	
	unlock_gate(&(victim->lock), LOCK_WRITE);
c0409314:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c040931b:	83 c0 10             	add    $0x10,%eax
c040931e:	83 ec 08             	sub    $0x8,%esp
c0409321:	6a 01                	push   $0x1
c0409323:	50                   	push   %eax
c0409324:	e8 7f 73 ff ff       	call   c04006a8 <unlock_gate>
c0409329:	83 c4 10             	add    $0x10,%esp
	return err;
c040932c:	8b 84 24 98 02 00 00 	mov    0x298(%esp),%eax
}
c0409333:	81 c4 ac 02 00 00    	add    $0x2ac,%esp
c0409339:	c3                   	ret    

c040933a <vmm_find_vma>:
/* vmm_find_vma
	Locate a vma tree node using the given address in the given proc
   <= pointer to tree node or NULL for not found
*/
vmm_tree *vmm_find_vma(process *proc, unsigned int addr)
{
c040933a:	83 ec 5c             	sub    $0x5c,%esp
	vmm_tree node;
	vmm_area area;
	vmm_tree *result;
	
	/* give up now if we're given rubbish pointers */
	if(!proc) return NULL;
c040933d:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c0409342:	75 07                	jne    c040934b <vmm_find_vma+0x11>
c0409344:	b8 00 00 00 00       	mov    $0x0,%eax
c0409349:	eb 62                	jmp    c04093ad <vmm_find_vma+0x73>

	/* mock up a vma and node to search for */
	area.base = addr;
c040934b:	8b 44 24 64          	mov    0x64(%esp),%eax
c040934f:	89 44 24 14          	mov    %eax,0x14(%esp)
	area.size = 1;
c0409353:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c040935a:	00 
	node.area = &area;
c040935b:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040935f:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	
	lock_gate(&(proc->lock), LOCK_READ);
c0409363:	8b 44 24 60          	mov    0x60(%esp),%eax
c0409367:	83 c0 10             	add    $0x10,%eax
c040936a:	83 ec 08             	sub    $0x8,%esp
c040936d:	6a 00                	push   $0x0
c040936f:	50                   	push   %eax
c0409370:	e8 16 71 ff ff       	call   c040048b <lock_gate>
c0409375:	83 c4 10             	add    $0x10,%esp
	result = sglib_vmm_tree_find_member(proc->mem, &node);
c0409378:	8b 44 24 60          	mov    0x60(%esp),%eax
c040937c:	8b 40 48             	mov    0x48(%eax),%eax
c040937f:	83 ec 08             	sub    $0x8,%esp
c0409382:	8d 54 24 44          	lea    0x44(%esp),%edx
c0409386:	52                   	push   %edx
c0409387:	50                   	push   %eax
c0409388:	e8 e5 ee ff ff       	call   c0408272 <sglib_vmm_tree_find_member>
c040938d:	83 c4 10             	add    $0x10,%esp
c0409390:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	unlock_gate(&(proc->lock), LOCK_READ);
c0409394:	8b 44 24 60          	mov    0x60(%esp),%eax
c0409398:	83 c0 10             	add    $0x10,%eax
c040939b:	83 ec 08             	sub    $0x8,%esp
c040939e:	6a 00                	push   $0x0
c04093a0:	50                   	push   %eax
c04093a1:	e8 02 73 ff ff       	call   c04006a8 <unlock_gate>
c04093a6:	83 c4 10             	add    $0x10,%esp
	
	return result;
c04093a9:	8b 44 24 4c          	mov    0x4c(%esp),%eax
}
c04093ad:	83 c4 5c             	add    $0x5c,%esp
c04093b0:	c3                   	ret    

c04093b1 <vmm_fault>:
      addr = virtual address where fault occurred
      flags = type of access attempted using the vma_area flags 
   <= decision code
*/
vmm_decision vmm_fault(process *proc, unsigned int addr, unsigned char flags)
{
c04093b1:	83 ec 3c             	sub    $0x3c,%esp
c04093b4:	8b 44 24 48          	mov    0x48(%esp),%eax
c04093b8:	88 44 24 0c          	mov    %al,0xc(%esp)
	lock_gate(&(proc->lock), LOCK_READ);
c04093bc:	8b 44 24 40          	mov    0x40(%esp),%eax
c04093c0:	83 c0 10             	add    $0x10,%eax
c04093c3:	83 ec 08             	sub    $0x8,%esp
c04093c6:	6a 00                	push   $0x0
c04093c8:	50                   	push   %eax
c04093c9:	e8 bd 70 ff ff       	call   c040048b <lock_gate>
c04093ce:	83 c4 10             	add    $0x10,%esp
	
	vmm_area *vma;
	vmm_tree *found = vmm_find_vma(proc, addr);
c04093d1:	83 ec 08             	sub    $0x8,%esp
c04093d4:	ff 74 24 4c          	pushl  0x4c(%esp)
c04093d8:	ff 74 24 4c          	pushl  0x4c(%esp)
c04093dc:	e8 59 ff ff ff       	call   c040933a <vmm_find_vma>
c04093e1:	83 c4 10             	add    $0x10,%esp
c04093e4:	89 44 24 20          	mov    %eax,0x20(%esp)

	if(!found) return badaccess; /* no vma means no possible access */
c04093e8:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c04093ed:	75 0a                	jne    c04093f9 <vmm_fault+0x48>
c04093ef:	b8 04 00 00 00       	mov    $0x4,%eax
c04093f4:	e9 53 02 00 00       	jmp    c040964c <vmm_fault+0x29b>
	
	vma = found->area;
c04093f9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04093fd:	8b 00                	mov    (%eax),%eax
c04093ff:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	lock_gate(&(vma->lock), LOCK_READ);
c0409403:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409407:	83 c0 14             	add    $0x14,%eax
c040940a:	83 ec 08             	sub    $0x8,%esp
c040940d:	6a 00                	push   $0x0
c040940f:	50                   	push   %eax
c0409410:	e8 76 70 ff ff       	call   c040048b <lock_gate>
c0409415:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(proc->lock), LOCK_READ);
c0409418:	8b 44 24 40          	mov    0x40(%esp),%eax
c040941c:	83 c0 10             	add    $0x10,%eax
c040941f:	83 ec 08             	sub    $0x8,%esp
c0409422:	6a 00                	push   $0x0
c0409424:	50                   	push   %eax
c0409425:	e8 7e 72 ff ff       	call   c04006a8 <unlock_gate>
c040942a:	83 c4 10             	add    $0x10,%esp
	dprintf(DEBUG_COL_VMM "[vmm:%i] fault at %x lies within vma %p (base %x size %i) in process %i\n" DEBUG_COL_OFF,
			  CPU_ID, addr, vma, vma->base, vma->size, proc->pid);
#endif
	
	/* fail this access if it's a write to a non-writeable area */
	if((flags & VMA_WRITEABLE) && !(vma->flags & VMA_WRITEABLE))
c040942d:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0409432:	83 e0 01             	and    $0x1,%eax
c0409435:	84 c0                	test   %al,%al
c0409437:	74 2c                	je     c0409465 <vmm_fault+0xb4>
c0409439:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040943d:	8b 00                	mov    (%eax),%eax
c040943f:	83 e0 01             	and    $0x1,%eax
c0409442:	85 c0                	test   %eax,%eax
c0409444:	75 1f                	jne    c0409465 <vmm_fault+0xb4>
	{
		unlock_gate(&(vma->lock), LOCK_READ);
c0409446:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040944a:	83 c0 14             	add    $0x14,%eax
c040944d:	83 ec 08             	sub    $0x8,%esp
c0409450:	6a 00                	push   $0x0
c0409452:	50                   	push   %eax
c0409453:	e8 50 72 ff ff       	call   c04006a8 <unlock_gate>
c0409458:	83 c4 10             	add    $0x10,%esp
		return badaccess;
c040945b:	b8 04 00 00 00       	mov    $0x4,%eax
c0409460:	e9 e7 01 00 00       	jmp    c040964c <vmm_fault+0x29b>
	}

	/* defer to the userspace page manager if it is managing this vma */
	if(!(vma->flags & VMA_MEMSOURCE))
c0409465:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409469:	8b 00                	mov    (%eax),%eax
c040946b:	83 e0 02             	and    $0x2,%eax
c040946e:	85 c0                	test   %eax,%eax
c0409470:	75 1f                	jne    c0409491 <vmm_fault+0xe0>
	{
		unlock_gate(&(vma->lock), LOCK_READ);
c0409472:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409476:	83 c0 14             	add    $0x14,%eax
c0409479:	83 ec 08             	sub    $0x8,%esp
c040947c:	6a 00                	push   $0x0
c040947e:	50                   	push   %eax
c040947f:	e8 24 72 ff ff       	call   c04006a8 <unlock_gate>
c0409484:	83 c4 10             	add    $0x10,%esp
		return external;
c0409487:	b8 03 00 00 00       	mov    $0x3,%eax
c040948c:	e9 bb 01 00 00       	jmp    c040964c <vmm_fault+0x29b>
	}
	
	/* if it's a linked vma then now's time to copy the page so this
	   process can have its own private copy */
	if(vma->refcount > 1)
c0409491:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409495:	8b 40 04             	mov    0x4(%eax),%eax
c0409498:	83 f8 01             	cmp    $0x1,%eax
c040949b:	0f 86 45 01 00 00    	jbe    c04095e6 <vmm_fault+0x235>
	{
		unsigned int loop, loopmax, thisphys, phys;
		process *search;
		
		/* if there's nothing to copy, then have a new private blank page */
		if(!(flags & VMA_HASPHYS))
c04094a1:	8a 44 24 0c          	mov    0xc(%esp),%al
c04094a5:	84 c0                	test   %al,%al
c04094a7:	78 1f                	js     c04094c8 <vmm_fault+0x117>
		{
			unlock_gate(&(vma->lock), LOCK_READ);
c04094a9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04094ad:	83 c0 14             	add    $0x14,%eax
c04094b0:	83 ec 08             	sub    $0x8,%esp
c04094b3:	6a 00                	push   $0x0
c04094b5:	50                   	push   %eax
c04094b6:	e8 ed 71 ff ff       	call   c04006a8 <unlock_gate>
c04094bb:	83 c4 10             	add    $0x10,%esp
			return newpage;
c04094be:	b8 02 00 00 00       	mov    $0x2,%eax
c04094c3:	e9 84 01 00 00       	jmp    c040964c <vmm_fault+0x29b>
		}
		
		/* to avoid leaking a page of phys mem, only clone if there are two
		   or more processes (including this one) sharing one physical page */
		if(pg_user2phys(&thisphys, proc->pgdir, addr))
c04094c8:	8b 44 24 40          	mov    0x40(%esp),%eax
c04094cc:	8b 40 20             	mov    0x20(%eax),%eax
c04094cf:	83 ec 04             	sub    $0x4,%esp
c04094d2:	ff 74 24 48          	pushl  0x48(%esp)
c04094d6:	50                   	push   %eax
c04094d7:	8d 44 24 24          	lea    0x24(%esp),%eax
c04094db:	50                   	push   %eax
c04094dc:	e8 d4 08 00 00       	call   c0409db5 <pg_user2phys>
c04094e1:	83 c4 10             	add    $0x10,%esp
c04094e4:	85 c0                	test   %eax,%eax
c04094e6:	74 4d                	je     c0409535 <vmm_fault+0x184>
		{
			dprintf(DEBUG_COL_VMM "[vmm:%i] OMGWTF page claimed to have physical memory - but doesn't\n" DEBUG_COL_OFF, CPU_ID);
c04094e8:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04094ed:	3c 01                	cmp    $0x1,%al
c04094ef:	76 0c                	jbe    c04094fd <vmm_fault+0x14c>
c04094f1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04094f6:	8b 00                	mov    (%eax),%eax
c04094f8:	c1 e8 18             	shr    $0x18,%eax
c04094fb:	eb 08                	jmp    c0409505 <vmm_fault+0x154>
c04094fd:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0409502:	0f b6 c0             	movzbl %al,%eax
c0409505:	83 ec 08             	sub    $0x8,%esp
c0409508:	50                   	push   %eax
c0409509:	68 dc f2 40 c0       	push   $0xc040f2dc
c040950e:	e8 43 3f 00 00       	call   c040d456 <debug_printf>
c0409513:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(vma->lock), LOCK_READ);
c0409516:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040951a:	83 c0 14             	add    $0x14,%eax
c040951d:	83 ec 08             	sub    $0x8,%esp
c0409520:	6a 00                	push   $0x0
c0409522:	50                   	push   %eax
c0409523:	e8 80 71 ff ff       	call   c04006a8 <unlock_gate>
c0409528:	83 c4 10             	add    $0x10,%esp
			return badaccess;
c040952b:	b8 04 00 00 00       	mov    $0x4,%eax
c0409530:	e9 17 01 00 00       	jmp    c040964c <vmm_fault+0x29b>
		}
		
		loopmax = vma->refcount;
c0409535:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409539:	8b 40 04             	mov    0x4(%eax),%eax
c040953c:	89 44 24 28          	mov    %eax,0x28(%esp)
		for(loop = 0; loop < loopmax; loop++)
c0409540:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c0409547:	00 
c0409548:	eb 76                	jmp    c04095c0 <vmm_fault+0x20f>
		{
			search = vma->users[loop];
c040954a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040954e:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409551:	8b 54 24 24          	mov    0x24(%esp),%edx
c0409555:	c1 e2 02             	shl    $0x2,%edx
c0409558:	01 d0                	add    %edx,%eax
c040955a:	8b 00                	mov    (%eax),%eax
c040955c:	89 44 24 2c          	mov    %eax,0x2c(%esp)
			if(search)
c0409560:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0409565:	74 55                	je     c04095bc <vmm_fault+0x20b>
				/* this process doesn't count in the search */
				if(search != proc)
c0409567:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040956b:	3b 44 24 40          	cmp    0x40(%esp),%eax
c040956f:	74 4b                	je     c04095bc <vmm_fault+0x20b>
					if(pg_user2phys(&phys, search->pgdir, addr) == success)
c0409571:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0409575:	8b 40 20             	mov    0x20(%eax),%eax
c0409578:	83 ec 04             	sub    $0x4,%esp
c040957b:	ff 74 24 48          	pushl  0x48(%esp)
c040957f:	50                   	push   %eax
c0409580:	8d 44 24 20          	lea    0x20(%esp),%eax
c0409584:	50                   	push   %eax
c0409585:	e8 2b 08 00 00       	call   c0409db5 <pg_user2phys>
c040958a:	83 c4 10             	add    $0x10,%esp
c040958d:	85 c0                	test   %eax,%eax
c040958f:	75 2b                	jne    c04095bc <vmm_fault+0x20b>
						if(phys == thisphys)
c0409591:	8b 54 24 14          	mov    0x14(%esp),%edx
c0409595:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409599:	39 c2                	cmp    %eax,%edx
c040959b:	75 1f                	jne    c04095bc <vmm_fault+0x20b>
						{
							unlock_gate(&(vma->lock), LOCK_READ);
c040959d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04095a1:	83 c0 14             	add    $0x14,%eax
c04095a4:	83 ec 08             	sub    $0x8,%esp
c04095a7:	6a 00                	push   $0x0
c04095a9:	50                   	push   %eax
c04095aa:	e8 f9 70 ff ff       	call   c04006a8 <unlock_gate>
c04095af:	83 c4 10             	add    $0x10,%esp
							return clonepage;
c04095b2:	b8 00 00 00 00       	mov    $0x0,%eax
c04095b7:	e9 90 00 00 00       	jmp    c040964c <vmm_fault+0x29b>
			unlock_gate(&(vma->lock), LOCK_READ);
			return badaccess;
		}
		
		loopmax = vma->refcount;
		for(loop = 0; loop < loopmax; loop++)
c04095bc:	ff 44 24 24          	incl   0x24(%esp)
c04095c0:	8b 44 24 24          	mov    0x24(%esp),%eax
c04095c4:	3b 44 24 28          	cmp    0x28(%esp),%eax
c04095c8:	72 80                	jb     c040954a <vmm_fault+0x199>
							return clonepage;
						}
		}
		
		/* it's writeable, it's present, we're the only ones using it.. */
		unlock_gate(&(vma->lock), LOCK_READ);
c04095ca:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04095ce:	83 c0 14             	add    $0x14,%eax
c04095d1:	83 ec 08             	sub    $0x8,%esp
c04095d4:	6a 00                	push   $0x0
c04095d6:	50                   	push   %eax
c04095d7:	e8 cc 70 ff ff       	call   c04006a8 <unlock_gate>
c04095dc:	83 c4 10             	add    $0x10,%esp
		return makewriteable;
c04095df:	b8 01 00 00 00       	mov    $0x1,%eax
c04095e4:	eb 66                	jmp    c040964c <vmm_fault+0x29b>
	}

	/* if it's single-linked and has its own physical memory and writes are
	   allowed then it's a page left over from a copy-on-write, so just
	   mark it writeable */
	if(vma->refcount == 1)
c04095e6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04095ea:	8b 40 04             	mov    0x4(%eax),%eax
c04095ed:	83 f8 01             	cmp    $0x1,%eax
c04095f0:	75 40                	jne    c0409632 <vmm_fault+0x281>
	{	
		/* but only if there's physical memory to write onto */
		if(flags & VMA_HASPHYS)
c04095f2:	8a 44 24 0c          	mov    0xc(%esp),%al
c04095f6:	84 c0                	test   %al,%al
c04095f8:	79 1c                	jns    c0409616 <vmm_fault+0x265>
		{
			unlock_gate(&(vma->lock), LOCK_READ);
c04095fa:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04095fe:	83 c0 14             	add    $0x14,%eax
c0409601:	83 ec 08             	sub    $0x8,%esp
c0409604:	6a 00                	push   $0x0
c0409606:	50                   	push   %eax
c0409607:	e8 9c 70 ff ff       	call   c04006a8 <unlock_gate>
c040960c:	83 c4 10             	add    $0x10,%esp
			return makewriteable;
c040960f:	b8 01 00 00 00       	mov    $0x1,%eax
c0409614:	eb 36                	jmp    c040964c <vmm_fault+0x29b>
		}
	
		/* but if there's no physical memory and it's single-linked and
		   writes are allowed then allocate some memory for this page */
		unlock_gate(&(vma->lock), LOCK_READ);
c0409616:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040961a:	83 c0 14             	add    $0x14,%eax
c040961d:	83 ec 08             	sub    $0x8,%esp
c0409620:	6a 00                	push   $0x0
c0409622:	50                   	push   %eax
c0409623:	e8 80 70 ff ff       	call   c04006a8 <unlock_gate>
c0409628:	83 c4 10             	add    $0x10,%esp
		return newpage;
c040962b:	b8 02 00 00 00       	mov    $0x2,%eax
c0409630:	eb 1a                	jmp    c040964c <vmm_fault+0x29b>
	}

	/* if this access satisfies no other cases then give up and fail it */
	unlock_gate(&(vma->lock), LOCK_READ);
c0409632:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409636:	83 c0 14             	add    $0x14,%eax
c0409639:	83 ec 08             	sub    $0x8,%esp
c040963c:	6a 00                	push   $0x0
c040963e:	50                   	push   %eax
c040963f:	e8 64 70 ff ff       	call   c04006a8 <unlock_gate>
c0409644:	83 c4 10             	add    $0x10,%esp
	return badaccess;
c0409647:	b8 04 00 00 00       	mov    $0x4,%eax
}
c040964c:	83 c4 3c             	add    $0x3c,%esp
c040964f:	c3                   	ret    

c0409650 <pg_fault>:
   Handle an incoming page fault
   => regs = faulting thread's state
   <= success if the fault was handled or a failure code if it couldn't be
*/
kresult pg_fault(int_registers_block *regs)
{
c0409650:	83 ec 3c             	sub    $0x3c,%esp
	unsigned int *pgtable, pgentry, faultaddr = x86_read_cr2();
c0409653:	e8 25 72 ff ff       	call   c040087d <x86_read_cr2>
c0409658:	89 44 24 14          	mov    %eax,0x14(%esp)
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
c040965c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409660:	c1 e8 16             	shr    $0x16,%eax
c0409663:	89 44 24 18          	mov    %eax,0x18(%esp)
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
c0409667:	8b 44 24 14          	mov    0x14(%esp),%eax
c040966b:	c1 e8 0c             	shr    $0xc,%eax
c040966e:	25 ff 03 00 00       	and    $0x3ff,%eax
c0409673:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	unsigned char errflags;
	
	/* give up if we're in early system initialisation */
	if(!cpu_table) goto pf_fault_bad;
c0409677:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040967c:	85 c0                	test   %eax,%eax
c040967e:	0f 84 a2 02 00 00    	je     c0409926 <pg_fault+0x2d6>
	if(!(cpu_table[CPU_ID].current)) goto pf_fault_bad;
c0409684:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040968a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040968f:	3c 01                	cmp    $0x1,%al
c0409691:	76 0f                	jbe    c04096a2 <pg_fault+0x52>
c0409693:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409698:	8b 00                	mov    (%eax),%eax
c040969a:	c1 e8 18             	shr    $0x18,%eax
c040969d:	c1 e0 06             	shl    $0x6,%eax
c04096a0:	eb 0b                	jmp    c04096ad <pg_fault+0x5d>
c04096a2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04096a7:	0f b6 c0             	movzbl %al,%eax
c04096aa:	c1 e0 06             	shl    $0x6,%eax
c04096ad:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04096b0:	8b 40 04             	mov    0x4(%eax),%eax
c04096b3:	85 c0                	test   %eax,%eax
c04096b5:	0f 84 6e 02 00 00    	je     c0409929 <pg_fault+0x2d9>
	
	process *proc = cpu_table[CPU_ID].current->proc;
c04096bb:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c04096c1:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c04096c6:	3c 01                	cmp    $0x1,%al
c04096c8:	76 0f                	jbe    c04096d9 <pg_fault+0x89>
c04096ca:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04096cf:	8b 00                	mov    (%eax),%eax
c04096d1:	c1 e8 18             	shr    $0x18,%eax
c04096d4:	c1 e0 06             	shl    $0x6,%eax
c04096d7:	eb 0b                	jmp    c04096e4 <pg_fault+0x94>
c04096d9:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c04096de:	0f b6 c0             	movzbl %al,%eax
c04096e1:	c1 e0 06             	shl    $0x6,%eax
c04096e4:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04096e7:	8b 40 04             	mov    0x4(%eax),%eax
c04096ea:	8b 00                	mov    (%eax),%eax
c04096ec:	89 44 24 24          	mov    %eax,0x24(%esp)
	
	/* give up if the user process has tried to access kernel memory */
	if((faultaddr >= KERNEL_SPACE_BASE) && (regs->errcode & PG_FAULT_U))
c04096f0:	81 7c 24 14 ff ff ff 	cmpl   $0xbfffffff,0x14(%esp)
c04096f7:	bf 
c04096f8:	76 12                	jbe    c040970c <pg_fault+0xbc>
c04096fa:	8b 44 24 40          	mov    0x40(%esp),%eax
c04096fe:	8b 40 28             	mov    0x28(%eax),%eax
c0409701:	83 e0 04             	and    $0x4,%eax
c0409704:	85 c0                	test   %eax,%eax
c0409706:	0f 85 20 02 00 00    	jne    c040992c <pg_fault+0x2dc>
		goto pf_fault_bad;

	/* look up the entry for this faulting address in the user page tables */
	pgtable = (unsigned int *)((unsigned int)proc->pgdir[pgdir_index] & PG_4K_MASK);
c040970c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409710:	8b 40 20             	mov    0x20(%eax),%eax
c0409713:	8b 54 24 18          	mov    0x18(%esp),%edx
c0409717:	c1 e2 02             	shl    $0x2,%edx
c040971a:	01 d0                	add    %edx,%eax
c040971c:	8b 00                	mov    (%eax),%eax
c040971e:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409723:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(pgtable)
c0409727:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040972c:	74 20                	je     c040974e <pg_fault+0xfe>
	{
		pgtable = KERNEL_PHYS2LOG(pgtable);
c040972e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409732:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409737:	89 44 24 0c          	mov    %eax,0xc(%esp)
		pgentry = pgtable[pgtable_index];
c040973b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040973f:	c1 e0 02             	shl    $0x2,%eax
c0409742:	03 44 24 0c          	add    0xc(%esp),%eax
c0409746:	8b 00                	mov    (%eax),%eax
c0409748:	89 44 24 10          	mov    %eax,0x10(%esp)
c040974c:	eb 08                	jmp    c0409756 <pg_fault+0x106>
	}
	else
		pgentry = 0;
c040974e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0409755:	00 

	/* inspect the page table flags */
	if(pgentry & PG_EXTERNAL)
c0409756:	8b 44 24 10          	mov    0x10(%esp),%eax
c040975a:	25 00 02 00 00       	and    $0x200,%eax
c040975f:	85 c0                	test   %eax,%eax
c0409761:	0f 85 b4 01 00 00    	jne    c040991b <pg_fault+0x2cb>
		goto pg_fault_external;
	
	/* convert x86 page fault flags into generic vmm flags */
	if(regs->errcode & PG_FAULT_W)
c0409767:	8b 44 24 40          	mov    0x40(%esp),%eax
c040976b:	8b 40 28             	mov    0x28(%eax),%eax
c040976e:	83 e0 02             	and    $0x2,%eax
c0409771:	85 c0                	test   %eax,%eax
c0409773:	74 07                	je     c040977c <pg_fault+0x12c>
		errflags = VMA_WRITEABLE;
c0409775:	c6 44 24 23 01       	movb   $0x1,0x23(%esp)
c040977a:	eb 05                	jmp    c0409781 <pg_fault+0x131>
	else
		errflags = VMA_READABLE;
c040977c:	c6 44 24 23 00       	movb   $0x0,0x23(%esp)
	
	/* hint to the vmm that the page already has physical memory */
	if(pgentry & PG_PRESENT)
c0409781:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409785:	83 e0 01             	and    $0x1,%eax
c0409788:	84 c0                	test   %al,%al
c040978a:	74 05                	je     c0409791 <pg_fault+0x141>
		errflags |= VMA_HASPHYS;
c040978c:	80 4c 24 23 80       	orb    $0x80,0x23(%esp)
	
	/* ask the vmm for a decision */
	switch(vmm_fault(proc, faultaddr, errflags))
c0409791:	0f b6 44 24 23       	movzbl 0x23(%esp),%eax
c0409796:	83 ec 04             	sub    $0x4,%esp
c0409799:	50                   	push   %eax
c040979a:	ff 74 24 1c          	pushl  0x1c(%esp)
c040979e:	ff 74 24 30          	pushl  0x30(%esp)
c04097a2:	e8 0a fc ff ff       	call   c04093b1 <vmm_fault>
c04097a7:	83 c4 10             	add    $0x10,%esp
c04097aa:	83 f8 01             	cmp    $0x1,%eax
c04097ad:	0f 84 1d 01 00 00    	je     c04098d0 <pg_fault+0x280>
c04097b3:	83 f8 01             	cmp    $0x1,%eax
c04097b6:	72 79                	jb     c0409831 <pg_fault+0x1e1>
c04097b8:	83 f8 02             	cmp    $0x2,%eax
c04097bb:	74 0e                	je     c04097cb <pg_fault+0x17b>
c04097bd:	83 f8 03             	cmp    $0x3,%eax
c04097c0:	0f 84 58 01 00 00    	je     c040991e <pg_fault+0x2ce>
			dprintf("[page:%i] can't handle fault at %x for process %i\n",
					  CPU_ID, faultaddr, proc->pid);
#endif
			
		default:
			goto pf_fault_bad;
c04097c6:	e9 62 01 00 00       	jmp    c040992d <pg_fault+0x2dd>
		case newpage:
			{ 
				unsigned int new_phys;
				
				/* grab a new (blank) physical page */
				if(vmm_req_phys_pg((void **)&new_phys, 1))
c04097cb:	8d 44 24 08          	lea    0x8(%esp),%eax
c04097cf:	83 ec 08             	sub    $0x8,%esp
c04097d2:	6a 01                	push   $0x1
c04097d4:	50                   	push   %eax
c04097d5:	e8 39 cc ff ff       	call   c0406413 <vmm_req_phys_pg>
c04097da:	83 c4 10             	add    $0x10,%esp
c04097dd:	85 c0                	test   %eax,%eax
c04097df:	74 0a                	je     c04097eb <pg_fault+0x19b>
					return e_failure; /* bail out if we can't get a phys page */
c04097e1:	b8 01 00 00 00       	mov    $0x1,%eax
c04097e6:	e9 9e 01 00 00       	jmp    c0409989 <pg_fault+0x339>
				
				/* map this new physical page in, remembering to set write access */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c04097eb:	8b 54 24 08          	mov    0x8(%esp),%edx
c04097ef:	8b 44 24 14          	mov    0x14(%esp),%eax
c04097f3:	89 c1                	mov    %eax,%ecx
c04097f5:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c04097fb:	8b 44 24 24          	mov    0x24(%esp),%eax
c04097ff:	8b 40 20             	mov    0x20(%eax),%eax
c0409802:	6a 07                	push   $0x7
c0409804:	52                   	push   %edx
c0409805:	51                   	push   %ecx
c0409806:	50                   	push   %eax
c0409807:	e8 a0 06 00 00       	call   c0409eac <pg_add_4K_mapping>
c040980c:	83 c4 10             	add    $0x10,%esp
										new_phys, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c040980f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409813:	8b 40 20             	mov    0x20(%eax),%eax
c0409816:	05 00 00 00 40       	add    $0x40000000,%eax
c040981b:	83 ec 0c             	sub    $0xc,%esp
c040981e:	50                   	push   %eax
c040981f:	e8 51 70 ff ff       	call   c0400875 <x86_load_cr3>
c0409824:	83 c4 10             	add    $0x10,%esp
#ifdef PAGE_DEBUG
				dprintf("[page:%i] mapped new page for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, new_phys);
#endif
			}
			return success;			
c0409827:	b8 00 00 00 00       	mov    $0x0,%eax
c040982c:	e9 58 01 00 00       	jmp    c0409989 <pg_fault+0x339>
		case clonepage:
			{
				unsigned int new_phys, new_virt, source_virt;
				
				/* grab a new (blank) physical page */
				if(vmm_req_phys_pg((void **)&new_phys, 1))
c0409831:	8d 44 24 04          	lea    0x4(%esp),%eax
c0409835:	83 ec 08             	sub    $0x8,%esp
c0409838:	6a 01                	push   $0x1
c040983a:	50                   	push   %eax
c040983b:	e8 d3 cb ff ff       	call   c0406413 <vmm_req_phys_pg>
c0409840:	83 c4 10             	add    $0x10,%esp
c0409843:	85 c0                	test   %eax,%eax
c0409845:	74 0a                	je     c0409851 <pg_fault+0x201>
					return e_failure; /* bail out if we can't get a phys page */
c0409847:	b8 01 00 00 00       	mov    $0x1,%eax
c040984c:	e9 38 01 00 00       	jmp    c0409989 <pg_fault+0x339>
				
				/* copy physical page to another via kernel virtual addresses */
				new_virt = (unsigned int)KERNEL_PHYS2LOG(new_phys);
c0409851:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409855:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040985a:	89 44 24 28          	mov    %eax,0x28(%esp)
				source_virt = (unsigned int)KERNEL_PHYS2LOG(pgentry & PG_4K_MASK);
c040985e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409862:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409867:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040986c:	89 44 24 2c          	mov    %eax,0x2c(%esp)
				vmm_memcpy((unsigned int *)new_virt, (unsigned int *)source_virt, MEM_PGSIZE);
c0409870:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0409874:	8b 44 24 28          	mov    0x28(%esp),%eax
c0409878:	83 ec 04             	sub    $0x4,%esp
c040987b:	68 00 10 00 00       	push   $0x1000
c0409880:	52                   	push   %edx
c0409881:	50                   	push   %eax
c0409882:	e8 9c d4 ff ff       	call   c0406d23 <vmm_memcpy>
c0409887:	83 c4 10             	add    $0x10,%esp
				
				/* map this new physical page in, remembering to set write access */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c040988a:	8b 54 24 04          	mov    0x4(%esp),%edx
c040988e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409892:	89 c1                	mov    %eax,%ecx
c0409894:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c040989a:	8b 44 24 24          	mov    0x24(%esp),%eax
c040989e:	8b 40 20             	mov    0x20(%eax),%eax
c04098a1:	6a 07                	push   $0x7
c04098a3:	52                   	push   %edx
c04098a4:	51                   	push   %ecx
c04098a5:	50                   	push   %eax
c04098a6:	e8 01 06 00 00       	call   c0409eac <pg_add_4K_mapping>
c04098ab:	83 c4 10             	add    $0x10,%esp
										new_phys, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c04098ae:	8b 44 24 24          	mov    0x24(%esp),%eax
c04098b2:	8b 40 20             	mov    0x20(%eax),%eax
c04098b5:	05 00 00 00 40       	add    $0x40000000,%eax
c04098ba:	83 ec 0c             	sub    $0xc,%esp
c04098bd:	50                   	push   %eax
c04098be:	e8 b2 6f ff ff       	call   c0400875 <x86_load_cr3>
c04098c3:	83 c4 10             	add    $0x10,%esp
#ifdef PAGE_DEBUG
				dprintf("[page:%i] cloned page for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, new_phys);
#endif
			}
			return success;
c04098c6:	b8 00 00 00 00       	mov    $0x0,%eax
c04098cb:	e9 b9 00 00 00       	jmp    c0409989 <pg_fault+0x339>
			
		case makewriteable:
			{				
				/* it's safe to just set write access on this page */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c04098d0:	8b 44 24 10          	mov    0x10(%esp),%eax
c04098d4:	89 c1                	mov    %eax,%ecx
c04098d6:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c04098dc:	8b 44 24 14          	mov    0x14(%esp),%eax
c04098e0:	89 c2                	mov    %eax,%edx
c04098e2:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c04098e8:	8b 44 24 24          	mov    0x24(%esp),%eax
c04098ec:	8b 40 20             	mov    0x20(%eax),%eax
c04098ef:	6a 07                	push   $0x7
c04098f1:	51                   	push   %ecx
c04098f2:	52                   	push   %edx
c04098f3:	50                   	push   %eax
c04098f4:	e8 b3 05 00 00       	call   c0409eac <pg_add_4K_mapping>
c04098f9:	83 c4 10             	add    $0x10,%esp
										pgentry & PG_4K_MASK, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c04098fc:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409900:	8b 40 20             	mov    0x20(%eax),%eax
c0409903:	05 00 00 00 40       	add    $0x40000000,%eax
c0409908:	83 ec 0c             	sub    $0xc,%esp
c040990b:	50                   	push   %eax
c040990c:	e8 64 6f ff ff       	call   c0400875 <x86_load_cr3>
c0409911:	83 c4 10             	add    $0x10,%esp
#ifdef PAGE_DEBUG
				dprintf("[page:%i] made page writeable for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, pgentry & PG_4K_MASK);
#endif
			}
			return success;
c0409914:	b8 00 00 00 00       	mov    $0x0,%eax
c0409919:	eb 6e                	jmp    c0409989 <pg_fault+0x339>
	else
		pgentry = 0;

	/* inspect the page table flags */
	if(pgentry & PG_EXTERNAL)
		goto pg_fault_external;
c040991b:	90                   	nop
c040991c:	eb 01                	jmp    c040991f <pg_fault+0x2cf>
#endif
			}
			return success;

		case external:
			goto pg_fault_external;
c040991e:	90                   	nop
pg_fault_external:
#ifdef PAGE_DEBUG
	dprintf("[page:%i] delegating fault at %x for process %i to userspace page manager\n",
			  CPU_ID, faultaddr, proc->pid);
#endif
	return e_failure;
c040991f:	b8 01 00 00 00       	mov    $0x1,%eax
c0409924:	eb 63                	jmp    c0409989 <pg_fault+0x339>
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned char errflags;
	
	/* give up if we're in early system initialisation */
	if(!cpu_table) goto pf_fault_bad;
c0409926:	90                   	nop
c0409927:	eb 04                	jmp    c040992d <pg_fault+0x2dd>
	if(!(cpu_table[CPU_ID].current)) goto pf_fault_bad;
c0409929:	90                   	nop
c040992a:	eb 01                	jmp    c040992d <pg_fault+0x2dd>
	
	process *proc = cpu_table[CPU_ID].current->proc;
	
	/* give up if the user process has tried to access kernel memory */
	if((faultaddr >= KERNEL_SPACE_BASE) && (regs->errcode & PG_FAULT_U))
		goto pf_fault_bad;
c040992c:	90                   	nop
#endif
	return e_failure;
	
pf_fault_bad:
	/* give up if the kernel's faulting */
	if(regs->eip > KERNEL_SPACE_BASE)
c040992d:	8b 44 24 40          	mov    0x40(%esp),%eax
c0409931:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409934:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c0409939:	76 49                	jbe    c0409984 <pg_fault+0x334>
	{
		/* dump details about the fault */
		if(!page_fatal_flag)
c040993b:	a0 dc 38 41 c0       	mov    0xc04138dc,%al
c0409940:	84 c0                	test   %al,%al
c0409942:	75 2e                	jne    c0409972 <pg_fault+0x322>
		{
			page_fatal_flag = 1;
c0409944:	c6 05 dc 38 41 c0 01 	movb   $0x1,0xc04138dc
			pg_postmortem(regs);
c040994b:	83 ec 0c             	sub    $0xc,%esp
c040994e:	ff 74 24 4c          	pushl  0x4c(%esp)
c0409952:	e8 7c 09 00 00       	call   c040a2d3 <pg_postmortem>
c0409957:	83 c4 10             	add    $0x10,%esp
			pg_dump_pagedir((unsigned int *)(proc->pgdir));
c040995a:	8b 44 24 24          	mov    0x24(%esp),%eax
c040995e:	8b 40 20             	mov    0x20(%eax),%eax
c0409961:	83 ec 0c             	sub    $0xc,%esp
c0409964:	50                   	push   %eax
c0409965:	e8 68 09 00 00       	call   c040a2d2 <pg_dump_pagedir>
c040996a:	83 c4 10             	add    $0x10,%esp
			debug_stacktrace();
c040996d:	e8 01 34 00 00       	call   c040cd73 <debug_stacktrace>
		}
		dprintf("\n*** panic: unhandled serious fault in the kernel. halting.\n");
c0409972:	83 ec 0c             	sub    $0xc,%esp
c0409975:	68 20 f3 40 c0       	push   $0xc040f320
c040997a:	e8 d7 3a 00 00       	call   c040d456 <debug_printf>
c040997f:	83 c4 10             	add    $0x10,%esp
		while(1);
c0409982:	eb fe                	jmp    c0409982 <pg_fault+0x332>
	}	
	
	/* or signal that the process has made a run-time error */
	return e_failure;
c0409984:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0409989:	83 c4 3c             	add    $0x3c,%esp
c040998c:	c3                   	ret    

c040998d <pg_clone_pgdir>:
   maintaining links to read-only data and 
   => source = pointer to page directory array for the pgdir we want to clone
   <= returns pointer to new page directory array, or NULL for failure
 */
unsigned int **pg_clone_pgdir(unsigned int **source)
{
c040998d:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int loop;
	unsigned int **new = NULL;
c0409990:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0409997:	00 

	/* ask the vmm for a physical page */
	if(vmm_req_phys_pg((void **)&new, 1))
c0409998:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040999c:	83 ec 08             	sub    $0x8,%esp
c040999f:	6a 01                	push   $0x1
c04099a1:	50                   	push   %eax
c04099a2:	e8 6c ca ff ff       	call   c0406413 <vmm_req_phys_pg>
c04099a7:	83 c4 10             	add    $0x10,%esp
c04099aa:	85 c0                	test   %eax,%eax
c04099ac:	74 0a                	je     c04099b8 <pg_clone_pgdir+0x2b>
		return NULL; /* bail out if we can't get a phys page */
c04099ae:	b8 00 00 00 00       	mov    $0x0,%eax
c04099b3:	e9 8a 01 00 00       	jmp    c0409b42 <pg_clone_pgdir+0x1b5>
	
	new = (unsigned int **)KERNEL_PHYS2LOG(new);
c04099b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04099bc:	2d 00 00 00 40       	sub    $0x40000000,%eax
c04099c1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* link the kernelspace mappings */
	for(loop = (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop < 1024; loop++)
c04099c5:	c7 44 24 10 00 03 00 	movl   $0x300,0x10(%esp)
c04099cc:	00 
c04099cd:	eb 21                	jmp    c04099f0 <pg_clone_pgdir+0x63>
		new[loop] = source[loop];
c04099cf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04099d3:	8b 54 24 10          	mov    0x10(%esp),%edx
c04099d7:	c1 e2 02             	shl    $0x2,%edx
c04099da:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04099dd:	8b 44 24 10          	mov    0x10(%esp),%eax
c04099e1:	c1 e0 02             	shl    $0x2,%eax
c04099e4:	03 44 24 30          	add    0x30(%esp),%eax
c04099e8:	8b 00                	mov    (%eax),%eax
c04099ea:	89 02                	mov    %eax,(%edx)
		return NULL; /* bail out if we can't get a phys page */
	
	new = (unsigned int **)KERNEL_PHYS2LOG(new);
	
	/* link the kernelspace mappings */
	for(loop = (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop < 1024; loop++)
c04099ec:	ff 44 24 10          	incl   0x10(%esp)
c04099f0:	81 7c 24 10 ff 03 00 	cmpl   $0x3ff,0x10(%esp)
c04099f7:	00 
c04099f8:	76 d5                	jbe    c04099cf <pg_clone_pgdir+0x42>
	
	/* link read-only user areas, link r/w user areas but mark them
	    to copy-on-write and disable the write bit - we'll fault on
	    write and then the fault handler can demand copy the pages.
	    also, it's assumed all userspace pages are handled as 4K entries */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c04099fa:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0409a01:	00 
c0409a02:	e9 29 01 00 00       	jmp    c0409b30 <pg_clone_pgdir+0x1a3>
	{
		if(source[loop])
c0409a07:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409a0b:	c1 e0 02             	shl    $0x2,%eax
c0409a0e:	03 44 24 30          	add    0x30(%esp),%eax
c0409a12:	8b 00                	mov    (%eax),%eax
c0409a14:	85 c0                	test   %eax,%eax
c0409a16:	0f 84 fd 00 00 00    	je     c0409b19 <pg_clone_pgdir+0x18c>
		{
			unsigned *pgtable_phys, *pgtable, *src_table = source[loop];
c0409a1c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409a20:	c1 e0 02             	shl    $0x2,%eax
c0409a23:	03 44 24 30          	add    0x30(%esp),%eax
c0409a27:	8b 00                	mov    (%eax),%eax
c0409a29:	89 44 24 18          	mov    %eax,0x18(%esp)
			unsigned int page;
			
			/* make a new copy of the page table */
			if(vmm_req_phys_pg((void **)&pgtable_phys, 1))
c0409a2d:	8d 44 24 08          	lea    0x8(%esp),%eax
c0409a31:	83 ec 08             	sub    $0x8,%esp
c0409a34:	6a 01                	push   $0x1
c0409a36:	50                   	push   %eax
c0409a37:	e8 d7 c9 ff ff       	call   c0406413 <vmm_req_phys_pg>
c0409a3c:	83 c4 10             	add    $0x10,%esp
c0409a3f:	85 c0                	test   %eax,%eax
c0409a41:	74 0a                	je     c0409a4d <pg_clone_pgdir+0xc0>
				return NULL; /*bail out if we can't get a phys page */
c0409a43:	b8 00 00 00 00       	mov    $0x0,%eax
c0409a48:	e9 f5 00 00 00       	jmp    c0409b42 <pg_clone_pgdir+0x1b5>
		
			/* calc the logical addresses, strip flags and start modifying the new table */
			pgtable = (unsigned int *)(KERNEL_PHYS2LOG(pgtable_phys));
c0409a4d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409a51:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409a56:	89 44 24 14          	mov    %eax,0x14(%esp)
			src_table = (unsigned int *)((unsigned int)KERNEL_PHYS2LOG(src_table) & PG_4K_MASK);
c0409a5a:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409a5e:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409a63:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409a68:	89 44 24 18          	mov    %eax,0x18(%esp)
			
			for(page = 0; page < 1024; page++)
c0409a6c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c0409a73:	00 
c0409a74:	eb 6c                	jmp    c0409ae2 <pg_clone_pgdir+0x155>
			{
				pgtable[page] = src_table[page];
c0409a76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409a7a:	c1 e0 02             	shl    $0x2,%eax
c0409a7d:	03 44 24 14          	add    0x14(%esp),%eax
c0409a81:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0409a85:	c1 e2 02             	shl    $0x2,%edx
c0409a88:	03 54 24 18          	add    0x18(%esp),%edx
c0409a8c:	8b 12                	mov    (%edx),%edx
c0409a8e:	89 10                	mov    %edx,(%eax)
				
				/* if page is writeable, then disable writing so we can later fault and
				   perform the copy-on-write */
				if(pgtable[page] & PG_RW)
c0409a90:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409a94:	c1 e0 02             	shl    $0x2,%eax
c0409a97:	03 44 24 14          	add    0x14(%esp),%eax
c0409a9b:	8b 00                	mov    (%eax),%eax
c0409a9d:	83 e0 02             	and    $0x2,%eax
c0409aa0:	85 c0                	test   %eax,%eax
c0409aa2:	74 3a                	je     c0409ade <pg_clone_pgdir+0x151>
				{
					/* in the child */
					pgtable[page] = pgtable[page] & (~PG_RW); /* clear R/W */
c0409aa4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409aa8:	c1 e0 02             	shl    $0x2,%eax
c0409aab:	03 44 24 14          	add    0x14(%esp),%eax
c0409aaf:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0409ab3:	c1 e2 02             	shl    $0x2,%edx
c0409ab6:	03 54 24 14          	add    0x14(%esp),%edx
c0409aba:	8b 12                	mov    (%edx),%edx
c0409abc:	83 e2 fd             	and    $0xfffffffd,%edx
c0409abf:	89 10                	mov    %edx,(%eax)
					
					/* in the parent */
					src_table[page] = src_table[page] & (~PG_RW); /* clear R/W */
c0409ac1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409ac5:	c1 e0 02             	shl    $0x2,%eax
c0409ac8:	03 44 24 18          	add    0x18(%esp),%eax
c0409acc:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0409ad0:	c1 e2 02             	shl    $0x2,%edx
c0409ad3:	03 54 24 18          	add    0x18(%esp),%edx
c0409ad7:	8b 12                	mov    (%edx),%edx
c0409ad9:	83 e2 fd             	and    $0xfffffffd,%edx
c0409adc:	89 10                	mov    %edx,(%eax)
		
			/* calc the logical addresses, strip flags and start modifying the new table */
			pgtable = (unsigned int *)(KERNEL_PHYS2LOG(pgtable_phys));
			src_table = (unsigned int *)((unsigned int)KERNEL_PHYS2LOG(src_table) & PG_4K_MASK);
			
			for(page = 0; page < 1024; page++)
c0409ade:	ff 44 24 1c          	incl   0x1c(%esp)
c0409ae2:	81 7c 24 1c ff 03 00 	cmpl   $0x3ff,0x1c(%esp)
c0409ae9:	00 
c0409aea:	76 8a                	jbe    c0409a76 <pg_clone_pgdir+0xe9>
					src_table[page] = src_table[page] & (~PG_RW); /* clear R/W */
				}
			}
			
			/* save the phys address into the directory with suitable flags */
			new[loop] = (unsigned int *)((unsigned int)pgtable_phys | ((unsigned int)(source[loop]) & ~PG_4K_MASK));
c0409aec:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409af0:	8b 54 24 10          	mov    0x10(%esp),%edx
c0409af4:	c1 e2 02             	shl    $0x2,%edx
c0409af7:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0409afa:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409afe:	c1 e0 02             	shl    $0x2,%eax
c0409b01:	03 44 24 30          	add    0x30(%esp),%eax
c0409b05:	8b 00                	mov    (%eax),%eax
c0409b07:	89 c1                	mov    %eax,%ecx
c0409b09:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
c0409b0f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409b13:	09 c8                	or     %ecx,%eax
c0409b15:	89 02                	mov    %eax,(%edx)
c0409b17:	eb 13                	jmp    c0409b2c <pg_clone_pgdir+0x19f>
		}
		else
			new[loop] = NULL;
c0409b19:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409b1d:	8b 54 24 10          	mov    0x10(%esp),%edx
c0409b21:	c1 e2 02             	shl    $0x2,%edx
c0409b24:	01 d0                	add    %edx,%eax
c0409b26:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	
	/* link read-only user areas, link r/w user areas but mark them
	    to copy-on-write and disable the write bit - we'll fault on
	    write and then the fault handler can demand copy the pages.
	    also, it's assumed all userspace pages are handled as 4K entries */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0409b2c:	ff 44 24 10          	incl   0x10(%esp)
c0409b30:	81 7c 24 10 ff 02 00 	cmpl   $0x2ff,0x10(%esp)
c0409b37:	00 
c0409b38:	0f 86 c9 fe ff ff    	jbe    c0409a07 <pg_clone_pgdir+0x7a>
		}
		else
			new[loop] = NULL;
	}
	
	return new;
c0409b3e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0409b42:	83 c4 2c             	add    $0x2c,%esp
c0409b45:	c3                   	ret    

c0409b46 <pg_new_process>:
 => new = pointer to process structure
 current = pointer or NULL for initial system processes
 <= 0 for success or an error code
 */
kresult pg_new_process(process *new, process *current)
{
c0409b46:	53                   	push   %ebx
c0409b47:	83 ec 18             	sub    $0x18,%esp
	unsigned int **pgdir;

	lock_gate(&(new->lock), LOCK_WRITE);
c0409b4a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409b4e:	83 c0 10             	add    $0x10,%eax
c0409b51:	83 ec 08             	sub    $0x8,%esp
c0409b54:	6a 01                	push   $0x1
c0409b56:	50                   	push   %eax
c0409b57:	e8 2f 69 ff ff       	call   c040048b <lock_gate>
c0409b5c:	83 c4 10             	add    $0x10,%esp
	
	/* pick the right page directory */
	if(current)
c0409b5f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0409b64:	74 22                	je     c0409b88 <pg_new_process+0x42>
	{
		lock_gate(&(current->lock), LOCK_READ);
c0409b66:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409b6a:	83 c0 10             	add    $0x10,%eax
c0409b6d:	83 ec 08             	sub    $0x8,%esp
c0409b70:	6a 00                	push   $0x0
c0409b72:	50                   	push   %eax
c0409b73:	e8 13 69 ff ff       	call   c040048b <lock_gate>
c0409b78:	83 c4 10             	add    $0x10,%esp
		pgdir = current->pgdir;
c0409b7b:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409b7f:	8b 40 20             	mov    0x20(%eax),%eax
c0409b82:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0409b86:	eb 08                	jmp    c0409b90 <pg_new_process+0x4a>
	}
	else
		pgdir = (unsigned int **)&KernelPageDirectory;
c0409b88:	c7 44 24 0c 00 00 41 	movl   $0xc0410000,0xc(%esp)
c0409b8f:	c0 
	/* grab a copy of the parent page directory or
	 bail out if there's a failure. if there is no
	 parent, we're create new processes from scratch
	 and the kernel's page directory should be empty
	 for userspace... */
	new->pgdir = pg_clone_pgdir(pgdir);
c0409b90:	83 ec 0c             	sub    $0xc,%esp
c0409b93:	ff 74 24 18          	pushl  0x18(%esp)
c0409b97:	e8 f1 fd ff ff       	call   c040998d <pg_clone_pgdir>
c0409b9c:	83 c4 10             	add    $0x10,%esp
c0409b9f:	8b 54 24 20          	mov    0x20(%esp),%edx
c0409ba3:	89 42 20             	mov    %eax,0x20(%edx)
	if(new->pgdir == NULL)
c0409ba6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409baa:	8b 40 20             	mov    0x20(%eax),%eax
c0409bad:	85 c0                	test   %eax,%eax
c0409baf:	75 3b                	jne    c0409bec <pg_new_process+0xa6>
	{
		unlock_gate(&(new->lock), LOCK_WRITE);
c0409bb1:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409bb5:	83 c0 10             	add    $0x10,%eax
c0409bb8:	83 ec 08             	sub    $0x8,%esp
c0409bbb:	6a 01                	push   $0x1
c0409bbd:	50                   	push   %eax
c0409bbe:	e8 e5 6a ff ff       	call   c04006a8 <unlock_gate>
c0409bc3:	83 c4 10             	add    $0x10,%esp
		if(current) unlock_gate(&(current->lock), LOCK_READ);
c0409bc6:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0409bcb:	74 15                	je     c0409be2 <pg_new_process+0x9c>
c0409bcd:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409bd1:	83 c0 10             	add    $0x10,%eax
c0409bd4:	83 ec 08             	sub    $0x8,%esp
c0409bd7:	6a 00                	push   $0x0
c0409bd9:	50                   	push   %eax
c0409bda:	e8 c9 6a ff ff       	call   c04006a8 <unlock_gate>
c0409bdf:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0409be2:	b8 01 00 00 00       	mov    $0x1,%eax
c0409be7:	e9 a5 00 00 00       	jmp    c0409c91 <pg_new_process+0x14b>
	}

	if(current) unlock_gate(&(current->lock), LOCK_READ);
c0409bec:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0409bf1:	74 15                	je     c0409c08 <pg_new_process+0xc2>
c0409bf3:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409bf7:	83 c0 10             	add    $0x10,%eax
c0409bfa:	83 ec 08             	sub    $0x8,%esp
c0409bfd:	6a 00                	push   $0x0
c0409bff:	50                   	push   %eax
c0409c00:	e8 a3 6a ff ff       	call   c04006a8 <unlock_gate>
c0409c05:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(new->lock), LOCK_WRITE);
c0409c08:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c0c:	83 c0 10             	add    $0x10,%eax
c0409c0f:	83 ec 08             	sub    $0x8,%esp
c0409c12:	6a 01                	push   $0x1
c0409c14:	50                   	push   %eax
c0409c15:	e8 8e 6a ff ff       	call   c04006a8 <unlock_gate>
c0409c1a:	83 c4 10             	add    $0x10,%esp
	
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
c0409c1d:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
c0409c22:	85 c0                	test   %eax,%eax
c0409c24:	74 66                	je     c0409c8c <pg_new_process+0x146>
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
c0409c26:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c2a:	8b 10                	mov    (%eax),%edx
c0409c2c:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
c0409c31:	83 ec 04             	sub    $0x4,%esp
c0409c34:	52                   	push   %edx
c0409c35:	6a 21                	push   $0x21
c0409c37:	50                   	push   %eax
c0409c38:	e8 6b a5 ff ff       	call   c04041a8 <msg_send_signal>
c0409c3d:	83 c4 10             	add    $0x10,%esp
c0409c40:	85 c0                	test   %eax,%eax
c0409c42:	74 48                	je     c0409c8c <pg_new_process+0x146>
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409c44:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c48:	8b 18                	mov    (%eax),%ebx
c0409c4a:	8b 0d d8 38 41 c0    	mov    0xc04138d8,%ecx
					  "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409c50:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409c55:	8b 10                	mov    (%eax),%edx
					  "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409c57:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409c5c:	3c 01                	cmp    $0x1,%al
c0409c5e:	76 0c                	jbe    c0409c6c <pg_new_process+0x126>
					  "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409c60:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409c65:	8b 00                	mov    (%eax),%eax
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409c67:	c1 e8 18             	shr    $0x18,%eax
c0409c6a:	eb 08                	jmp    c0409c74 <pg_new_process+0x12e>
c0409c6c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0409c71:	0f b6 c0             	movzbl %al,%eax
c0409c74:	83 ec 08             	sub    $0x8,%esp
c0409c77:	ff 74 24 28          	pushl  0x28(%esp)
c0409c7b:	53                   	push   %ebx
c0409c7c:	51                   	push   %ecx
c0409c7d:	52                   	push   %edx
c0409c7e:	50                   	push   %eax
c0409c7f:	68 60 f3 40 c0       	push   $0xc040f360
c0409c84:	e8 cd 37 00 00       	call   c040d456 <debug_printf>
c0409c89:	83 c4 20             	add    $0x20,%esp
#ifdef PAGE_DEBUG
	dprintf("[page:%i] created new pgdir %p for new process %i\n", 
			  CPU_ID, new->pgdir, new->pid);
#endif
	
	return success;
c0409c8c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409c91:	83 c4 18             	add    $0x18,%esp
c0409c94:	5b                   	pop    %ebx
c0409c95:	c3                   	ret    

c0409c96 <pg_destroy_process>:
   effectively reversing the operation of clonedir()
   => victim = process to tear down
   <= success or e_failure if something went wrong
*/
kresult pg_destroy_process(process *victim)
{
c0409c96:	53                   	push   %ebx
c0409c97:	83 ec 18             	sub    $0x18,%esp
	unsigned int loop;
	unsigned int **pgdir;
	
	lock_gate(&(victim->lock), LOCK_WRITE);
c0409c9a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c9e:	83 c0 10             	add    $0x10,%eax
c0409ca1:	83 ec 08             	sub    $0x8,%esp
c0409ca4:	6a 01                	push   $0x1
c0409ca6:	50                   	push   %eax
c0409ca7:	e8 df 67 ff ff       	call   c040048b <lock_gate>
c0409cac:	83 c4 10             	add    $0x10,%esp
	
	pgdir = victim->pgdir;
c0409caf:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409cb3:	8b 40 20             	mov    0x20(%eax),%eax
c0409cb6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* run through the userspace of the page directory */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0409cba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0409cc1:	00 
c0409cc2:	eb 36                	jmp    c0409cfa <pg_destroy_process+0x64>
	{
		if((unsigned int)(pgdir[loop]) & PG_PRESENT)
c0409cc4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409cc8:	c1 e0 02             	shl    $0x2,%eax
c0409ccb:	03 44 24 0c          	add    0xc(%esp),%eax
c0409ccf:	8b 00                	mov    (%eax),%eax
c0409cd1:	83 e0 01             	and    $0x1,%eax
c0409cd4:	84 c0                	test   %al,%al
c0409cd6:	74 1e                	je     c0409cf6 <pg_destroy_process+0x60>
			/* return the page holding the table */
			vmm_return_phys_pg((unsigned int *)((unsigned int)(pgdir[loop]) & PG_4K_MASK));
c0409cd8:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409cdc:	c1 e0 02             	shl    $0x2,%eax
c0409cdf:	03 44 24 0c          	add    0xc(%esp),%eax
c0409ce3:	8b 00                	mov    (%eax),%eax
c0409ce5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409cea:	83 ec 0c             	sub    $0xc,%esp
c0409ced:	50                   	push   %eax
c0409cee:	e8 0e c8 ff ff       	call   c0406501 <vmm_return_phys_pg>
c0409cf3:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	pgdir = victim->pgdir;
	
	/* run through the userspace of the page directory */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0409cf6:	ff 44 24 08          	incl   0x8(%esp)
c0409cfa:	81 7c 24 08 ff 02 00 	cmpl   $0x2ff,0x8(%esp)
c0409d01:	00 
c0409d02:	76 c0                	jbe    c0409cc4 <pg_destroy_process+0x2e>
			/* return the page holding the table */
			vmm_return_phys_pg((unsigned int *)((unsigned int)(pgdir[loop]) & PG_4K_MASK));
	}
	
	/* return the page dir's page */
	vmm_return_phys_pg(KERNEL_LOG2PHYS(victim->pgdir));
c0409d04:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409d08:	8b 40 20             	mov    0x20(%eax),%eax
c0409d0b:	05 00 00 00 40       	add    $0x40000000,%eax
c0409d10:	83 ec 0c             	sub    $0xc,%esp
c0409d13:	50                   	push   %eax
c0409d14:	e8 e8 c7 ff ff       	call   c0406501 <vmm_return_phys_pg>
c0409d19:	83 c4 10             	add    $0x10,%esp
	victim->pgdir = NULL;
c0409d1c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409d20:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	
	/* bump the userspace page manager */
	if(userspace_page_handler)
c0409d27:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
c0409d2c:	85 c0                	test   %eax,%eax
c0409d2e:	74 66                	je     c0409d96 <pg_destroy_process+0x100>
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
c0409d30:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409d34:	8b 10                	mov    (%eax),%edx
c0409d36:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
c0409d3b:	83 ec 04             	sub    $0x4,%esp
c0409d3e:	52                   	push   %edx
c0409d3f:	6a 20                	push   $0x20
c0409d41:	50                   	push   %eax
c0409d42:	e8 61 a4 ff ff       	call   c04041a8 <msg_send_signal>
c0409d47:	83 c4 10             	add    $0x10,%esp
c0409d4a:	85 c0                	test   %eax,%eax
c0409d4c:	74 48                	je     c0409d96 <pg_destroy_process+0x100>
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409d4e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409d52:	8b 18                	mov    (%eax),%ebx
c0409d54:	8b 0d d8 38 41 c0    	mov    0xc04138d8,%ecx
					  "       tried talking to proc %i (%p) while tearing down %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409d5a:	a1 d8 38 41 c0       	mov    0xc04138d8,%eax
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409d5f:	8b 10                	mov    (%eax),%edx
					  "       tried talking to proc %i (%p) while tearing down %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409d61:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409d66:	3c 01                	cmp    $0x1,%al
c0409d68:	76 0c                	jbe    c0409d76 <pg_destroy_process+0xe0>
					  "       tried talking to proc %i (%p) while tearing down %i (%p)\n",
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0409d6a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409d6f:	8b 00                	mov    (%eax),%eax
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			dprintf("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0409d71:	c1 e8 18             	shr    $0x18,%eax
c0409d74:	eb 08                	jmp    c0409d7e <pg_destroy_process+0xe8>
c0409d76:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0409d7b:	0f b6 c0             	movzbl %al,%eax
c0409d7e:	83 ec 08             	sub    $0x8,%esp
c0409d81:	ff 74 24 28          	pushl  0x28(%esp)
c0409d85:	53                   	push   %ebx
c0409d86:	51                   	push   %ecx
c0409d87:	52                   	push   %edx
c0409d88:	50                   	push   %eax
c0409d89:	68 d8 f3 40 c0       	push   $0xc040f3d8
c0409d8e:	e8 c3 36 00 00       	call   c040d456 <debug_printf>
c0409d93:	83 c4 20             	add    $0x20,%esp
					  CPU_ID, userspace_page_handler->pid, userspace_page_handler,
					  victim->pid, victim);
		}
	}
	
	unlock_gate(&(victim->lock), LOCK_WRITE);
c0409d96:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409d9a:	83 c0 10             	add    $0x10,%eax
c0409d9d:	83 ec 08             	sub    $0x8,%esp
c0409da0:	6a 01                	push   $0x1
c0409da2:	50                   	push   %eax
c0409da3:	e8 00 69 ff ff       	call   c04006a8 <unlock_gate>
c0409da8:	83 c4 10             	add    $0x10,%esp
							
	return success;
c0409dab:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409db0:	83 c4 18             	add    $0x18,%esp
c0409db3:	5b                   	pop    %ebx
c0409db4:	c3                   	ret    

c0409db5 <pg_user2phys>:
      pgdir = pgdir belonging to a process
      virtual = virtual address to translate
   <= success or failure code
*/
kresult pg_user2phys(unsigned int *paddr, unsigned int **pgdir, unsigned int virtual)
{
c0409db5:	83 ec 10             	sub    $0x10,%esp
	unsigned int pgdir_index = (virtual >> PG_DIR_BASE) & PG_INDEX_MASK;
c0409db8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409dbc:	c1 e8 16             	shr    $0x16,%eax
c0409dbf:	89 44 24 04          	mov    %eax,0x4(%esp)
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
c0409dc3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409dc7:	c1 e8 0c             	shr    $0xc,%eax
c0409dca:	25 ff 03 00 00       	and    $0x3ff,%eax
c0409dcf:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int *pgtbl;
	
	if((!pgdir) || (!paddr)) return e_failure;
c0409dd3:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0409dd8:	74 07                	je     c0409de1 <pg_user2phys+0x2c>
c0409dda:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0409ddf:	75 07                	jne    c0409de8 <pg_user2phys+0x33>
c0409de1:	b8 01 00 00 00       	mov    $0x1,%eax
c0409de6:	eb 70                	jmp    c0409e58 <pg_user2phys+0xa3>
	
	pgtbl = (unsigned int *)((unsigned int)pgdir[pgdir_index] & PG_4K_MASK);
c0409de8:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409dec:	c1 e0 02             	shl    $0x2,%eax
c0409def:	03 44 24 18          	add    0x18(%esp),%eax
c0409df3:	8b 00                	mov    (%eax),%eax
c0409df5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409dfa:	89 44 24 0c          	mov    %eax,0xc(%esp)
	pgtbl = KERNEL_PHYS2LOG(pgtbl);
c0409dfe:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409e02:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409e07:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(pgtbl)
c0409e0b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0409e10:	74 41                	je     c0409e53 <pg_user2phys+0x9e>
		if(pgtbl[pgtable_index] & PG_PRESENT)
c0409e12:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409e16:	c1 e0 02             	shl    $0x2,%eax
c0409e19:	03 44 24 0c          	add    0xc(%esp),%eax
c0409e1d:	8b 00                	mov    (%eax),%eax
c0409e1f:	83 e0 01             	and    $0x1,%eax
c0409e22:	84 c0                	test   %al,%al
c0409e24:	74 2d                	je     c0409e53 <pg_user2phys+0x9e>
		{
			*(paddr) = (pgtbl[pgtable_index] & PG_4K_MASK) + (virtual & ~PG_4K_MASK);
c0409e26:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409e2a:	c1 e0 02             	shl    $0x2,%eax
c0409e2d:	03 44 24 0c          	add    0xc(%esp),%eax
c0409e31:	8b 00                	mov    (%eax),%eax
c0409e33:	89 c2                	mov    %eax,%edx
c0409e35:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0409e3b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409e3f:	25 ff 0f 00 00       	and    $0xfff,%eax
c0409e44:	01 c2                	add    %eax,%edx
c0409e46:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409e4a:	89 10                	mov    %edx,(%eax)
			return success;
c0409e4c:	b8 00 00 00 00       	mov    $0x0,%eax
c0409e51:	eb 05                	jmp    c0409e58 <pg_user2phys+0xa3>
		}

	return e_not_found;
c0409e53:	b8 02 00 00 00       	mov    $0x2,%eax
}
c0409e58:	83 c4 10             	add    $0x10,%esp
c0409e5b:	c3                   	ret    

c0409e5c <pg_user2kernel>:
      proc  = process owning the userspace to interrogate
   <= 0 for success or an error code
*/
kresult pg_user2kernel(unsigned int *kaddr, unsigned int uaddr, process *proc)
{
	if((!proc) || (!kaddr)) return e_failure;
c0409e5c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0409e61:	74 07                	je     c0409e6a <pg_user2kernel+0xe>
c0409e63:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0409e68:	75 07                	jne    c0409e71 <pg_user2kernel+0x15>
c0409e6a:	b8 01 00 00 00       	mov    $0x1,%eax
c0409e6f:	eb 3a                	jmp    c0409eab <pg_user2kernel+0x4f>
	
	if(pg_user2phys(kaddr, proc->pgdir, uaddr))
c0409e71:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409e75:	8b 40 20             	mov    0x20(%eax),%eax
c0409e78:	ff 74 24 08          	pushl  0x8(%esp)
c0409e7c:	50                   	push   %eax
c0409e7d:	ff 74 24 0c          	pushl  0xc(%esp)
c0409e81:	e8 2f ff ff ff       	call   c0409db5 <pg_user2phys>
c0409e86:	83 c4 0c             	add    $0xc,%esp
c0409e89:	85 c0                	test   %eax,%eax
c0409e8b:	74 07                	je     c0409e94 <pg_user2kernel+0x38>
		return e_failure;
c0409e8d:	b8 01 00 00 00       	mov    $0x1,%eax
c0409e92:	eb 17                	jmp    c0409eab <pg_user2kernel+0x4f>

	/* got a physical addr, turn it into a kernel virtual address */
	*(kaddr) = (unsigned int)KERNEL_PHYS2LOG((unsigned int *)(*(kaddr)));
c0409e94:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409e98:	8b 00                	mov    (%eax),%eax
c0409e9a:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c0409ea0:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409ea4:	89 10                	mov    %edx,(%eax)
	
	return success;
c0409ea6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409eab:	c3                   	ret    

c0409eac <pg_add_4K_mapping>:
		flags = flag bits to be ORd with the phys addr
   <= 0 for success, anything else is a fail
*/
kresult pg_add_4K_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, 
								  unsigned int flags)
{
c0409eac:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int pgdir_index = (virtual >> PG_DIR_BASE) & PG_INDEX_MASK;
c0409eaf:	8b 44 24 34          	mov    0x34(%esp),%eax
c0409eb3:	c1 e8 16             	shr    $0x16,%eax
c0409eb6:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
c0409eba:	8b 44 24 34          	mov    0x34(%esp),%eax
c0409ebe:	c1 e8 0c             	shr    $0xc,%eax
c0409ec1:	25 ff 03 00 00       	and    $0x3ff,%eax
c0409ec6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
c0409eca:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0409ecf:	74 0b                	je     c0409edc <pg_add_4K_mapping+0x30>
c0409ed1:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409ed5:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0409eda:	77 52                	ja     c0409f2e <pg_add_4K_mapping+0x82>
	{
		dprintf("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
				  "              pgdir %p virtual %x physical %x flags %i\n"
				  "              pgdir_index %i pgtable_index %i\n",
				  CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
c0409edc:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
	{
		dprintf("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
c0409ee1:	3c 01                	cmp    $0x1,%al
c0409ee3:	76 0c                	jbe    c0409ef1 <pg_add_4K_mapping+0x45>
				  "              pgdir %p virtual %x physical %x flags %i\n"
				  "              pgdir_index %i pgtable_index %i\n",
				  CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
c0409ee5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409eea:	8b 00                	mov    (%eax),%eax
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
	{
		dprintf("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
c0409eec:	c1 e8 18             	shr    $0x18,%eax
c0409eef:	eb 08                	jmp    c0409ef9 <pg_add_4K_mapping+0x4d>
c0409ef1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c0409ef6:	0f b6 c0             	movzbl %al,%eax
c0409ef9:	ff 74 24 0c          	pushl  0xc(%esp)
c0409efd:	ff 74 24 0c          	pushl  0xc(%esp)
c0409f01:	ff 74 24 44          	pushl  0x44(%esp)
c0409f05:	ff 74 24 44          	pushl  0x44(%esp)
c0409f09:	ff 74 24 44          	pushl  0x44(%esp)
c0409f0d:	ff 74 24 44          	pushl  0x44(%esp)
c0409f11:	50                   	push   %eax
c0409f12:	68 50 f4 40 c0       	push   $0xc040f450
c0409f17:	e8 3a 35 00 00       	call   c040d456 <debug_printf>
c0409f1c:	83 c4 20             	add    $0x20,%esp
				  "              pgdir %p virtual %x physical %x flags %i\n"
				  "              pgdir_index %i pgtable_index %i\n",
				  CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
		debug_stacktrace();
c0409f1f:	e8 4f 2e 00 00       	call   c040cd73 <debug_stacktrace>
		return e_failure; /* bail out now if we get a bad pointer */
c0409f24:	b8 01 00 00 00       	mov    $0x1,%eax
c0409f29:	e9 ec 00 00 00       	jmp    c040a01a <pg_add_4K_mapping+0x16e>
	}
	
	/* if a 4M mapping already exists for this virtual address then bail out */
	if((unsigned int)(pgdir[pgdir_index]) & PG_SIZE)
c0409f2e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409f32:	c1 e0 02             	shl    $0x2,%eax
c0409f35:	03 44 24 30          	add    0x30(%esp),%eax
c0409f39:	8b 00                	mov    (%eax),%eax
c0409f3b:	25 80 00 00 00       	and    $0x80,%eax
c0409f40:	85 c0                	test   %eax,%eax
c0409f42:	74 0a                	je     c0409f4e <pg_add_4K_mapping+0xa2>
		return success;
c0409f44:	b8 00 00 00 00       	mov    $0x0,%eax
c0409f49:	e9 cc 00 00 00       	jmp    c040a01a <pg_add_4K_mapping+0x16e>

	/* find the entry in the page directory for the page table for this 4K page and
		allocate a page table if it doesn't exist */
	if(!(pgdir[pgdir_index]))
c0409f4e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409f52:	c1 e0 02             	shl    $0x2,%eax
c0409f55:	03 44 24 30          	add    0x30(%esp),%eax
c0409f59:	8b 00                	mov    (%eax),%eax
c0409f5b:	85 c0                	test   %eax,%eax
c0409f5d:	75 74                	jne    c0409fd3 <pg_add_4K_mapping+0x127>
	{
		unsigned int loop;
		unsigned int *newtable, *cleantable;
		
		kresult err = vmm_req_phys_pg((void **)&newtable, 1);
c0409f5f:	8d 44 24 04          	lea    0x4(%esp),%eax
c0409f63:	83 ec 08             	sub    $0x8,%esp
c0409f66:	6a 01                	push   $0x1
c0409f68:	50                   	push   %eax
c0409f69:	e8 a5 c4 ff ff       	call   c0406413 <vmm_req_phys_pg>
c0409f6e:	83 c4 10             	add    $0x10,%esp
c0409f71:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if(err) return err; /* failed */
c0409f75:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0409f7a:	74 09                	je     c0409f85 <pg_add_4K_mapping+0xd9>
c0409f7c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409f80:	e9 95 00 00 00       	jmp    c040a01a <pg_add_4K_mapping+0x16e>

		/* PLEASE PLEASE don't forget that all kernel addresses are
		   logical! So you must convert phys to log before accessing
		   the referenced memory */
		/* zero the new page table */
		cleantable = (unsigned int *)KERNEL_PHYS2LOG(newtable);
c0409f85:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409f89:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409f8e:	89 44 24 18          	mov    %eax,0x18(%esp)
		for(loop = 0; loop < 1024; loop++)
c0409f92:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0409f99:	00 
c0409f9a:	eb 15                	jmp    c0409fb1 <pg_add_4K_mapping+0x105>
			cleantable[loop] = 0;
c0409f9c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409fa0:	c1 e0 02             	shl    $0x2,%eax
c0409fa3:	03 44 24 18          	add    0x18(%esp),%eax
c0409fa7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/* PLEASE PLEASE don't forget that all kernel addresses are
		   logical! So you must convert phys to log before accessing
		   the referenced memory */
		/* zero the new page table */
		cleantable = (unsigned int *)KERNEL_PHYS2LOG(newtable);
		for(loop = 0; loop < 1024; loop++)
c0409fad:	ff 44 24 14          	incl   0x14(%esp)
c0409fb1:	81 7c 24 14 ff 03 00 	cmpl   $0x3ff,0x14(%esp)
c0409fb8:	00 
c0409fb9:	76 e1                	jbe    c0409f9c <pg_add_4K_mapping+0xf0>
			cleantable[loop] = 0;
		
		/* write into the page directory entry the new tbl addr and flags */
		/* force the r/w bit high so that if a particular page is marked read-only
			the whole directory entry isn't */
		pgdir[pgdir_index] = (unsigned int *)((unsigned int)newtable | PG_RW | flags);
c0409fbb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409fbf:	c1 e0 02             	shl    $0x2,%eax
c0409fc2:	03 44 24 30          	add    0x30(%esp),%eax
c0409fc6:	8b 54 24 04          	mov    0x4(%esp),%edx
c0409fca:	0b 54 24 3c          	or     0x3c(%esp),%edx
c0409fce:	83 ca 02             	or     $0x2,%edx
c0409fd1:	89 10                	mov    %edx,(%eax)
	}
	
	/* align address and clean lower bits */
	physical = physical & PG_4K_MASK;
c0409fd3:	81 64 24 38 00 f0 ff 	andl   $0xfffff000,0x38(%esp)
c0409fda:	ff 
	dprintf("[page:%i] mapping 4K: %x -> %x (%x) dir index %x table index %x table base %p (%x)\n", 
			  CPU_ID, virtual, physical, flags, pgdir_index, pgtable_index,
			  pgdir[pgdir_index], KERNEL_PHYS2LOG(pgdir[pgdir_index]));
#endif	
	
	pgtbl = (unsigned int *)KERNEL_PHYS2LOG(pgdir[pgdir_index]);
c0409fdb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409fdf:	c1 e0 02             	shl    $0x2,%eax
c0409fe2:	03 44 24 30          	add    0x30(%esp),%eax
c0409fe6:	8b 00                	mov    (%eax),%eax
c0409fe8:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0409fed:	89 44 24 10          	mov    %eax,0x10(%esp)
	pgtbl = (unsigned int *)((unsigned int)pgtbl & PG_TBL_MASK); /* clean out lower bits */
c0409ff1:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409ff5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0409ffa:	89 44 24 10          	mov    %eax,0x10(%esp)
	
	pgtbl[pgtable_index] = physical | flags;
c0409ffe:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a002:	c1 e0 02             	shl    $0x2,%eax
c040a005:	03 44 24 10          	add    0x10(%esp),%eax
c040a009:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c040a00d:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c040a011:	09 ca                	or     %ecx,%edx
c040a013:	89 10                	mov    %edx,(%eax)
	
	return 0;
c040a015:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040a01a:	83 c4 2c             	add    $0x2c,%esp
c040a01d:	c3                   	ret    

c040a01e <pg_add_4M_mapping>:
    flags = flag bits to be ORd with the phys addr
 <= 0 for success, anything else is a fail
 */
kresult pg_add_4M_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, 
								  unsigned int flags)
{	
c040a01e:	83 ec 10             	sub    $0x10,%esp
#ifdef PAGE_DEBUG
	dprintf("[page:%i] mapping 4M: %x -> %x (%x) dir index %x\n", 
			  CPU_ID, virtual, physical, flags, virtual >> PG_DIR_BASE);
#endif
	
	virtual = virtual & PG_4M_MASK;
c040a021:	81 64 24 18 00 00 c0 	andl   $0xffc00000,0x18(%esp)
c040a028:	ff 
	physical = physical & PG_4M_MASK;
c040a029:	81 64 24 1c 00 00 c0 	andl   $0xffc00000,0x1c(%esp)
c040a030:	ff 
	
	/* create 4MB entry, read+write for kernel-only */
	if((virtual >> PG_DIR_BASE) < 1024)
c040a031:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a035:	c1 e8 16             	shr    $0x16,%eax
c040a038:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040a03d:	77 53                	ja     c040a092 <pg_add_4M_mapping+0x74>
	{
		unsigned int entry = (unsigned int)(pgdir[(virtual >> PG_DIR_BASE)]);
c040a03f:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a043:	c1 e8 16             	shr    $0x16,%eax
c040a046:	c1 e0 02             	shl    $0x2,%eax
c040a049:	03 44 24 14          	add    0x14(%esp),%eax
c040a04d:	8b 00                	mov    (%eax),%eax
c040a04f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		
		/* give up if this entry is taken by a 4K mapping entry */
		if(entry != 0)
c040a053:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040a058:	74 14                	je     c040a06e <pg_add_4M_mapping+0x50>
			if((entry & PG_SIZE) == 0)
c040a05a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a05e:	25 80 00 00 00       	and    $0x80,%eax
c040a063:	85 c0                	test   %eax,%eax
c040a065:	75 07                	jne    c040a06e <pg_add_4M_mapping+0x50>
				return e_failure;
c040a067:	b8 01 00 00 00       	mov    $0x1,%eax
c040a06c:	eb 29                	jmp    c040a097 <pg_add_4M_mapping+0x79>
		
		pgdir[(virtual >> PG_DIR_BASE)] = (unsigned int *)(physical | PG_SIZE | flags);
c040a06e:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a072:	c1 e8 16             	shr    $0x16,%eax
c040a075:	c1 e0 02             	shl    $0x2,%eax
c040a078:	03 44 24 14          	add    0x14(%esp),%eax
c040a07c:	8b 54 24 20          	mov    0x20(%esp),%edx
c040a080:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c040a084:	09 ca                	or     %ecx,%edx
c040a086:	80 ca 80             	or     $0x80,%dl
c040a089:	89 10                	mov    %edx,(%eax)
		return success;
c040a08b:	b8 00 00 00 00       	mov    $0x0,%eax
c040a090:	eb 05                	jmp    c040a097 <pg_add_4M_mapping+0x79>
	}
	
	/* fall through to failure */
	return e_failure;
c040a092:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040a097:	83 c4 10             	add    $0x10,%esp
c040a09a:	c3                   	ret    

c040a09b <pg_map_phys_to_kernel_space>:
   => base = base of descending stack
      top = last entry in stack
      granularity = 0 to add 4KB page entries, 1 to add 4M page entries
*/
void pg_map_phys_to_kernel_space(unsigned int *base, unsigned int *top, unsigned char granularity)
{
c040a09b:	83 ec 3c             	sub    $0x3c,%esp
c040a09e:	8b 44 24 48          	mov    0x48(%esp),%eax
c040a0a2:	88 44 24 0c          	mov    %al,0xc(%esp)
   unsigned int **pg_dir = (unsigned int **)&KernelPageDirectory; /* from start.s */
c040a0a6:	c7 44 24 1c 00 00 41 	movl   $0xc0410000,0x1c(%esp)
c040a0ad:	c0 

   /* we must assume the physical page stacks are full - ie: no one has
      popped any stack frames off them. and we have to assume for now that
      the frames are in ascending order. scan through the stacks and map
      frames into the kernel's virtual space. */
   while(base >= top)
c040a0ae:	e9 d8 00 00 00       	jmp    c040a18b <pg_map_phys_to_kernel_space+0xf0>
   {
		unsigned int addr, logical_addr;
		unsigned char this_granularity = granularity;
c040a0b3:	8a 44 24 0c          	mov    0xc(%esp),%al
c040a0b7:	88 44 24 2f          	mov    %al,0x2f(%esp)
		
		if(this_granularity == 1)
c040a0bb:	80 7c 24 2f 01       	cmpb   $0x1,0x2f(%esp)
c040a0c0:	75 11                	jne    c040a0d3 <pg_map_phys_to_kernel_space+0x38>
			addr = *base & PG_4M_MASK;
c040a0c2:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a0c6:	8b 00                	mov    (%eax),%eax
c040a0c8:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c040a0cd:	89 44 24 24          	mov    %eax,0x24(%esp)
c040a0d1:	eb 0f                	jmp    c040a0e2 <pg_map_phys_to_kernel_space+0x47>
		else
			addr = *base & PG_4K_MASK; 
c040a0d3:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a0d7:	8b 00                	mov    (%eax),%eax
c040a0d9:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c040a0de:	89 44 24 24          	mov    %eax,0x24(%esp)

		/* perform the page table scribbling */
		if(this_granularity == 1)
c040a0e2:	80 7c 24 2f 01       	cmpb   $0x1,0x2f(%esp)
c040a0e7:	75 47                	jne    c040a130 <pg_map_phys_to_kernel_space+0x95>
		{
			logical_addr = (unsigned int)KERNEL_PHYS2LOG((unsigned int)addr);
c040a0e9:	8b 44 24 24          	mov    0x24(%esp),%eax
c040a0ed:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040a0f2:	89 44 24 28          	mov    %eax,0x28(%esp)
			dprintf("[page:%i] mapped to kernel 4M, page dir[%i] = %x (%x) (%x)\n",
					  CPU_ID, (logical_addr >> PG_DIR_BASE), addr, logical_addr, pg_dir);
#endif
			
			/* create 4MB entry, read+write for kernel-only */
			pg_add_4M_mapping(pg_dir, logical_addr, addr, PG_PRESENT | PG_RW);
c040a0f6:	6a 03                	push   $0x3
c040a0f8:	ff 74 24 28          	pushl  0x28(%esp)
c040a0fc:	ff 74 24 30          	pushl  0x30(%esp)
c040a100:	ff 74 24 28          	pushl  0x28(%esp)
c040a104:	e8 15 ff ff ff       	call   c040a01e <pg_add_4M_mapping>
c040a109:	83 c4 10             	add    $0x10,%esp
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
c040a10c:	eb 16                	jmp    c040a124 <pg_map_phys_to_kernel_space+0x89>
			{
				base--;
c040a10e:	83 6c 24 40 04       	subl   $0x4,0x40(%esp)
				if((*base & PG_4M_MASK) != addr) break;
c040a113:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a117:	8b 00                	mov    (%eax),%eax
c040a119:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c040a11e:	3b 44 24 24          	cmp    0x24(%esp),%eax
c040a122:	75 66                	jne    c040a18a <pg_map_phys_to_kernel_space+0xef>
			
			/* create 4MB entry, read+write for kernel-only */
			pg_add_4M_mapping(pg_dir, logical_addr, addr, PG_PRESENT | PG_RW);
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
c040a124:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a128:	3b 44 24 44          	cmp    0x44(%esp),%eax
c040a12c:	73 e0                	jae    c040a10e <pg_map_phys_to_kernel_space+0x73>
c040a12e:	eb 5b                	jmp    c040a18b <pg_map_phys_to_kernel_space+0xf0>
			dprintf("[page:%i] mapped to kernel 4K, phys %x log %x (%x)\n",
					  CPU_ID, *base, KERNEL_PHYS2LOG(*base), pg_dir);
#endif
							
			/* create a 4KB entry, read+write for kernel-only */
			err = pg_add_4K_mapping((unsigned int **)pg_dir, (unsigned int)KERNEL_PHYS2LOG(*base),
c040a130:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a134:	8b 00                	mov    (%eax),%eax
c040a136:	8b 54 24 40          	mov    0x40(%esp),%edx
c040a13a:	8b 12                	mov    (%edx),%edx
c040a13c:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
c040a142:	6a 03                	push   $0x3
c040a144:	50                   	push   %eax
c040a145:	52                   	push   %edx
c040a146:	ff 74 24 28          	pushl  0x28(%esp)
c040a14a:	e8 5d fd ff ff       	call   c0409eac <pg_add_4K_mapping>
c040a14f:	83 c4 10             	add    $0x10,%esp
c040a152:	89 44 24 20          	mov    %eax,0x20(%esp)
											*base, PG_PRESENT | PG_RW);
			 if(err)
c040a156:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040a15b:	74 26                	je     c040a183 <pg_map_phys_to_kernel_space+0xe8>
			 {
				 dprintf("*** failed to map virtual %x to physical %x into kernel! halting.",
c040a15d:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a161:	8b 00                	mov    (%eax),%eax
							(unsigned int)KERNEL_PHYS2LOG(*base), *base);
c040a163:	8b 54 24 40          	mov    0x40(%esp),%edx
c040a167:	8b 12                	mov    (%edx),%edx
			/* create a 4KB entry, read+write for kernel-only */
			err = pg_add_4K_mapping((unsigned int **)pg_dir, (unsigned int)KERNEL_PHYS2LOG(*base),
											*base, PG_PRESENT | PG_RW);
			 if(err)
			 {
				 dprintf("*** failed to map virtual %x to physical %x into kernel! halting.",
c040a169:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
c040a16f:	83 ec 04             	sub    $0x4,%esp
c040a172:	50                   	push   %eax
c040a173:	52                   	push   %edx
c040a174:	68 f8 f4 40 c0       	push   $0xc040f4f8
c040a179:	e8 d8 32 00 00       	call   c040d456 <debug_printf>
c040a17e:	83 c4 10             	add    $0x10,%esp
							(unsigned int)KERNEL_PHYS2LOG(*base), *base);
				 while(1);
c040a181:	eb fe                	jmp    c040a181 <pg_map_phys_to_kernel_space+0xe6>
			 }

			base--;
c040a183:	83 6c 24 40 04       	subl   $0x4,0x40(%esp)
c040a188:	eb 01                	jmp    c040a18b <pg_map_phys_to_kernel_space+0xf0>
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
			{
				base--;
				if((*base & PG_4M_MASK) != addr) break;
c040a18a:	90                   	nop

   /* we must assume the physical page stacks are full - ie: no one has
      popped any stack frames off them. and we have to assume for now that
      the frames are in ascending order. scan through the stacks and map
      frames into the kernel's virtual space. */
   while(base >= top)
c040a18b:	8b 44 24 40          	mov    0x40(%esp),%eax
c040a18f:	3b 44 24 44          	cmp    0x44(%esp),%eax
c040a193:	0f 83 1a ff ff ff    	jae    c040a0b3 <pg_map_phys_to_kernel_space+0x18>
			 }

			base--;
		}
   }
}
c040a199:	83 c4 3c             	add    $0x3c,%esp
c040a19c:	c3                   	ret    

c040a19d <pg_init>:
/* pg_init
   Start up the underlying pagination system for the vmm. This includes
   mapping as much physical ram into the kernel's virtual space as possible.
*/
void pg_init(void)
{
c040a19d:	83 ec 2c             	sub    $0x2c,%esp
	/* grab a copy of the physical page stack limits because calls to
	   pg_map_phys_to_kernel_space() will modify these global variables */
	unsigned int *low_base = phys_pg_stack_low_base;
c040a1a0:	a1 48 10 41 c0       	mov    0xc0411048,%eax
c040a1a5:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int *low_ptr = phys_pg_stack_low_ptr;
c040a1a9:	a1 94 18 41 c0       	mov    0xc0411894,%eax
c040a1ae:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int *high_base = phys_pg_stack_high_base;
c040a1b2:	a1 4c 10 41 c0       	mov    0xc041104c,%eax
c040a1b7:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int *high_ptr = phys_pg_stack_high_ptr;
c040a1bb:	a1 8c 18 41 c0       	mov    0xc041188c,%eax
c040a1c0:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	unsigned int loop;
	unsigned int **kernel_dir = (unsigned int **)&KernelPageDirectory;
c040a1c4:	c7 44 24 1c 00 00 41 	movl   $0xc0410000,0x1c(%esp)
c040a1cb:	c0 
	
   dprintf("[page:%i] initialising.. kernel page dir %x\n", CPU_ID, &KernelPageDirectory);
c040a1cc:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040a1d1:	3c 01                	cmp    $0x1,%al
c040a1d3:	76 0c                	jbe    c040a1e1 <pg_init+0x44>
c040a1d5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a1da:	8b 00                	mov    (%eax),%eax
c040a1dc:	c1 e8 18             	shr    $0x18,%eax
c040a1df:	eb 08                	jmp    c040a1e9 <pg_init+0x4c>
c040a1e1:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040a1e6:	0f b6 c0             	movzbl %al,%eax
c040a1e9:	83 ec 04             	sub    $0x4,%esp
c040a1ec:	68 00 00 41 c0       	push   $0xc0410000
c040a1f1:	50                   	push   %eax
c040a1f2:	68 3c f5 40 c0       	push   $0xc040f53c
c040a1f7:	e8 5a 32 00 00       	call   c040d456 <debug_printf>
c040a1fc:	83 c4 10             	add    $0x10,%esp

	/* clear out all non-kernelspace entries to start again */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c040a1ff:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c040a206:	00 
c040a207:	eb 15                	jmp    c040a21e <pg_init+0x81>
		kernel_dir[loop] = NULL;
c040a209:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a20d:	c1 e0 02             	shl    $0x2,%eax
c040a210:	03 44 24 1c          	add    0x1c(%esp),%eax
c040a214:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	unsigned int **kernel_dir = (unsigned int **)&KernelPageDirectory;
	
   dprintf("[page:%i] initialising.. kernel page dir %x\n", CPU_ID, &KernelPageDirectory);

	/* clear out all non-kernelspace entries to start again */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c040a21a:	ff 44 24 18          	incl   0x18(%esp)
c040a21e:	81 7c 24 18 ff 02 00 	cmpl   $0x2ff,0x18(%esp)
c040a225:	00 
c040a226:	76 e1                	jbe    c040a209 <pg_init+0x6c>
	    will have to be found and written in. The physical pages holding these
	    tables are unlikely to be mapped in unless we process the upper
	    memory first, which are mapped in as 4M pages requiring no separate
	    tables */
	/* map most of memory into 4M pages */
   pg_map_phys_to_kernel_space(high_base, high_ptr, 1);
c040a228:	83 ec 04             	sub    $0x4,%esp
c040a22b:	6a 01                	push   $0x1
c040a22d:	ff 74 24 1c          	pushl  0x1c(%esp)
c040a231:	ff 74 24 1c          	pushl  0x1c(%esp)
c040a235:	e8 61 fe ff ff       	call   c040a09b <pg_map_phys_to_kernel_space>
c040a23a:	83 c4 10             	add    $0x10,%esp
	
	/* ensure the kernel critical area is mapped in - we use 4M pages to 
	   maximise TLB performance */
	for(loop = KERNEL_CRITICAL_BASE; loop < KERNEL_CRITICAL_END; loop += MEM_4M_PGSIZE)
c040a23d:	c7 44 24 18 00 00 40 	movl   $0x400000,0x18(%esp)
c040a244:	00 
c040a245:	eb 24                	jmp    c040a26b <pg_init+0xce>
		pg_add_4M_mapping(kernel_dir, (unsigned int)KERNEL_PHYS2LOG(loop), loop, PG_PRESENT | PG_RW);
c040a247:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a24b:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040a250:	6a 03                	push   $0x3
c040a252:	ff 74 24 1c          	pushl  0x1c(%esp)
c040a256:	50                   	push   %eax
c040a257:	ff 74 24 28          	pushl  0x28(%esp)
c040a25b:	e8 be fd ff ff       	call   c040a01e <pg_add_4M_mapping>
c040a260:	83 c4 10             	add    $0x10,%esp
	/* map most of memory into 4M pages */
   pg_map_phys_to_kernel_space(high_base, high_ptr, 1);
	
	/* ensure the kernel critical area is mapped in - we use 4M pages to 
	   maximise TLB performance */
	for(loop = KERNEL_CRITICAL_BASE; loop < KERNEL_CRITICAL_END; loop += MEM_4M_PGSIZE)
c040a263:	81 44 24 18 00 00 40 	addl   $0x400000,0x18(%esp)
c040a26a:	00 
c040a26b:	81 7c 24 18 ff ff bf 	cmpl   $0xbfffff,0x18(%esp)
c040a272:	00 
c040a273:	76 d2                	jbe    c040a247 <pg_init+0xaa>
		pg_add_4M_mapping(kernel_dir, (unsigned int)KERNEL_PHYS2LOG(loop), loop, PG_PRESENT | PG_RW);
	
	/* map the rest of the lowest 16M in 4K pages */
   pg_map_phys_to_kernel_space(low_base, low_ptr, 0);
c040a275:	83 ec 04             	sub    $0x4,%esp
c040a278:	6a 00                	push   $0x0
c040a27a:	ff 74 24 14          	pushl  0x14(%esp)
c040a27e:	ff 74 24 14          	pushl  0x14(%esp)
c040a282:	e8 14 fe ff ff       	call   c040a09b <pg_map_phys_to_kernel_space>
c040a287:	83 c4 10             	add    $0x10,%esp
	
	/* notify cpu of change in kernel directory */
   x86_load_cr3(KERNEL_LOG2PHYS(&KernelPageDirectory));
c040a28a:	b8 00 00 41 c0       	mov    $0xc0410000,%eax
c040a28f:	05 00 00 00 40       	add    $0x40000000,%eax
c040a294:	83 ec 0c             	sub    $0xc,%esp
c040a297:	50                   	push   %eax
c040a298:	e8 d8 65 ff ff       	call   c0400875 <x86_load_cr3>
c040a29d:	83 c4 10             	add    $0x10,%esp
   dprintf("[page:%i] vmm initialised\n", CPU_ID);
c040a2a0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040a2a5:	3c 01                	cmp    $0x1,%al
c040a2a7:	76 0c                	jbe    c040a2b5 <pg_init+0x118>
c040a2a9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a2ae:	8b 00                	mov    (%eax),%eax
c040a2b0:	c1 e8 18             	shr    $0x18,%eax
c040a2b3:	eb 08                	jmp    c040a2bd <pg_init+0x120>
c040a2b5:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040a2ba:	0f b6 c0             	movzbl %al,%eax
c040a2bd:	83 ec 08             	sub    $0x8,%esp
c040a2c0:	50                   	push   %eax
c040a2c1:	68 69 f5 40 c0       	push   $0xc040f569
c040a2c6:	e8 8b 31 00 00       	call   c040d456 <debug_printf>
c040a2cb:	83 c4 10             	add    $0x10,%esp
}
c040a2ce:	83 c4 2c             	add    $0x2c,%esp
c040a2d1:	c3                   	ret    

c040a2d2 <pg_dump_pagedir>:
		if(pgdir[i])
		{
			dprintf("       kernel_dir[%i] = %x\n", i, pgdir[i]);
		}
#endif
}
c040a2d2:	c3                   	ret    

c040a2d3 <pg_postmortem>:

/* pg_postmortem
 Perform a diagnostic dump if a page fault can't be handled */
void pg_postmortem(int_registers_block *regs)
{
c040a2d3:	55                   	push   %ebp
c040a2d4:	57                   	push   %edi
c040a2d5:	56                   	push   %esi
c040a2d6:	53                   	push   %ebx
c040a2d7:	83 ec 6c             	sub    $0x6c,%esp
	unsigned int faultaddr = x86_read_cr2();
c040a2da:	e8 9e 65 ff ff       	call   c040087d <x86_read_cr2>
c040a2df:	89 44 24 48          	mov    %eax,0x48(%esp)
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
c040a2e3:	8b 44 24 48          	mov    0x48(%esp),%eax
c040a2e7:	c1 e8 16             	shr    $0x16,%eax
c040a2ea:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
c040a2ee:	8b 44 24 48          	mov    0x48(%esp),%eax
c040a2f2:	c1 e8 0c             	shr    $0xc,%eax
c040a2f5:	25 ff 03 00 00       	and    $0x3ff,%eax
c040a2fa:	89 44 24 50          	mov    %eax,0x50(%esp)
	unsigned int *pgtable; 
	thread *running = cpu_table[CPU_ID].current;
c040a2fe:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040a304:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040a309:	3c 01                	cmp    $0x1,%al
c040a30b:	76 0f                	jbe    c040a31c <pg_postmortem+0x49>
c040a30d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a312:	8b 00                	mov    (%eax),%eax
c040a314:	c1 e8 18             	shr    $0x18,%eax
c040a317:	c1 e0 06             	shl    $0x6,%eax
c040a31a:	eb 0b                	jmp    c040a327 <pg_postmortem+0x54>
c040a31c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040a321:	0f b6 c0             	movzbl %al,%eax
c040a324:	c1 e0 06             	shl    $0x6,%eax
c040a327:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040a32a:	8b 40 04             	mov    0x4(%eax),%eax
c040a32d:	89 44 24 58          	mov    %eax,0x58(%esp)
	process *proc;
	char func[32];
	unsigned int sym_base = 0;
c040a331:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c040a338:	00 

	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
c040a339:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a340:	8b 40 2c             	mov    0x2c(%eax),%eax
c040a343:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c040a348:	76 4f                	jbe    c040a399 <pg_postmortem+0xc6>
c040a34a:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a351:	8b 40 2c             	mov    0x2c(%eax),%eax
c040a354:	b9 08 39 41 c0       	mov    $0xc0413908,%ecx
c040a359:	ba 00 00 40 c0       	mov    $0xc0400000,%edx
c040a35e:	89 cb                	mov    %ecx,%ebx
c040a360:	29 d3                	sub    %edx,%ebx
c040a362:	89 da                	mov    %ebx,%edx
c040a364:	c1 fa 02             	sar    $0x2,%edx
c040a367:	81 ea 00 00 c0 3f    	sub    $0x3fc00000,%edx
c040a36d:	39 d0                	cmp    %edx,%eax
c040a36f:	73 28                	jae    c040a399 <pg_postmortem+0xc6>
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
c040a371:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a378:	8b 40 2c             	mov    0x2c(%eax),%eax
c040a37b:	8d 54 24 24          	lea    0x24(%esp),%edx
c040a37f:	52                   	push   %edx
c040a380:	6a 20                	push   $0x20
c040a382:	8d 54 24 30          	lea    0x30(%esp),%edx
c040a386:	52                   	push   %edx
c040a387:	50                   	push   %eax
c040a388:	e8 7d 33 00 00       	call   c040d70a <debug_lookup_symbol>
c040a38d:	83 c4 10             	add    $0x10,%esp
c040a390:	85 c0                	test   %eax,%eax
c040a392:	74 05                	je     c040a399 <pg_postmortem+0xc6>
			func[0] = NULL; /* or not.. */
c040a394:	c6 44 24 28 00       	movb   $0x0,0x28(%esp)
	
	dprintf("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c040a399:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3a0:	8b 70 3c             	mov    0x3c(%eax),%esi
c040a3a3:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3aa:	8b 68 38             	mov    0x38(%eax),%ebp
c040a3ad:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3b4:	8b 40 34             	mov    0x34(%eax),%eax
c040a3b7:	89 44 24 04          	mov    %eax,0x4(%esp)
c040a3bb:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3c2:	8b 40 30             	mov    0x30(%eax),%eax
c040a3c5:	89 44 24 08          	mov    %eax,0x8(%esp)
c040a3c9:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3d0:	8b 40 20             	mov    0x20(%eax),%eax
c040a3d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
c040a3d7:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3de:	8b 40 10             	mov    0x10(%eax),%eax
c040a3e1:	89 44 24 10          	mov    %eax,0x10(%esp)
c040a3e5:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3ec:	8b 40 0c             	mov    0xc(%eax),%eax
c040a3ef:	89 44 24 14          	mov    %eax,0x14(%esp)
c040a3f3:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a3fa:	8b 40 04             	mov    0x4(%eax),%eax
c040a3fd:	89 44 24 18          	mov    %eax,0x18(%esp)
c040a401:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a408:	8b 00                	mov    (%eax),%eax
c040a40a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c040a40e:	8b 7c 24 24          	mov    0x24(%esp),%edi
c040a412:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a419:	8b 58 2c             	mov    0x2c(%eax),%ebx
c040a41c:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a423:	8b 48 28             	mov    0x28(%eax),%ecx
			  "      ds %x edi %x ebp %x esp %x\n"
			  "      eax %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
c040a426:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
			func[0] = NULL; /* or not.. */
	
	dprintf("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c040a42b:	3c 01                	cmp    $0x1,%al
c040a42d:	76 0e                	jbe    c040a43d <pg_postmortem+0x16a>
			  "      ds %x edi %x ebp %x esp %x\n"
			  "      eax %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
c040a42f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a434:	8b 00                	mov    (%eax),%eax
	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
			func[0] = NULL; /* or not.. */
	
	dprintf("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c040a436:	89 c2                	mov    %eax,%edx
c040a438:	c1 ea 18             	shr    $0x18,%edx
c040a43b:	eb 08                	jmp    c040a445 <pg_postmortem+0x172>
c040a43d:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040a442:	0f b6 d0             	movzbl %al,%edx
c040a445:	56                   	push   %esi
c040a446:	55                   	push   %ebp
c040a447:	ff 74 24 0c          	pushl  0xc(%esp)
c040a44b:	ff 74 24 14          	pushl  0x14(%esp)
c040a44f:	ff 74 24 1c          	pushl  0x1c(%esp)
c040a453:	ff 74 24 24          	pushl  0x24(%esp)
c040a457:	ff 74 24 2c          	pushl  0x2c(%esp)
c040a45b:	ff 74 24 34          	pushl  0x34(%esp)
c040a45f:	ff 74 24 3c          	pushl  0x3c(%esp)
c040a463:	ff 74 24 6c          	pushl  0x6c(%esp)
c040a467:	8d 44 24 50          	lea    0x50(%esp),%eax
c040a46b:	50                   	push   %eax
c040a46c:	57                   	push   %edi
c040a46d:	53                   	push   %ebx
c040a46e:	51                   	push   %ecx
c040a46f:	52                   	push   %edx
c040a470:	68 84 f5 40 c0       	push   $0xc040f584
c040a475:	e8 dc 2f 00 00       	call   c040d456 <debug_printf>
c040a47a:	83 c4 40             	add    $0x40,%esp
			  "      eax %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
			  regs->ds, regs->edi, regs->ebp, regs->esp,
			  regs->eax, regs->cs, regs->eflags, regs->useresp, regs->ss);
	
	dprintf("      Reason: ");
c040a47d:	83 ec 0c             	sub    $0xc,%esp
c040a480:	68 08 f6 40 c0       	push   $0xc040f608
c040a485:	e8 cc 2f 00 00       	call   c040d456 <debug_printf>
c040a48a:	83 c4 10             	add    $0x10,%esp
	if(regs->errcode & PG_FAULT_P)
c040a48d:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a494:	8b 40 28             	mov    0x28(%eax),%eax
c040a497:	83 e0 01             	and    $0x1,%eax
c040a49a:	84 c0                	test   %al,%al
c040a49c:	74 12                	je     c040a4b0 <pg_postmortem+0x1dd>
	{
		dprintf("AccessViolation ");
c040a49e:	83 ec 0c             	sub    $0xc,%esp
c040a4a1:	68 17 f6 40 c0       	push   $0xc040f617
c040a4a6:	e8 ab 2f 00 00       	call   c040d456 <debug_printf>
c040a4ab:	83 c4 10             	add    $0x10,%esp
c040a4ae:	eb 10                	jmp    c040a4c0 <pg_postmortem+0x1ed>
	}
	else
	{
		dprintf("NotPresent ");
c040a4b0:	83 ec 0c             	sub    $0xc,%esp
c040a4b3:	68 28 f6 40 c0       	push   $0xc040f628
c040a4b8:	e8 99 2f 00 00       	call   c040d456 <debug_printf>
c040a4bd:	83 c4 10             	add    $0x10,%esp
	}
	
	if(regs->errcode & PG_FAULT_W)
c040a4c0:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a4c7:	8b 40 28             	mov    0x28(%eax),%eax
c040a4ca:	83 e0 02             	and    $0x2,%eax
c040a4cd:	85 c0                	test   %eax,%eax
c040a4cf:	74 12                	je     c040a4e3 <pg_postmortem+0x210>
	{
		dprintf("Write ");
c040a4d1:	83 ec 0c             	sub    $0xc,%esp
c040a4d4:	68 34 f6 40 c0       	push   $0xc040f634
c040a4d9:	e8 78 2f 00 00       	call   c040d456 <debug_printf>
c040a4de:	83 c4 10             	add    $0x10,%esp
c040a4e1:	eb 10                	jmp    c040a4f3 <pg_postmortem+0x220>
	}
	else
	{
		dprintf("Read ");
c040a4e3:	83 ec 0c             	sub    $0xc,%esp
c040a4e6:	68 3b f6 40 c0       	push   $0xc040f63b
c040a4eb:	e8 66 2f 00 00       	call   c040d456 <debug_printf>
c040a4f0:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_U)
c040a4f3:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a4fa:	8b 40 28             	mov    0x28(%eax),%eax
c040a4fd:	83 e0 04             	and    $0x4,%eax
c040a500:	85 c0                	test   %eax,%eax
c040a502:	74 12                	je     c040a516 <pg_postmortem+0x243>
	{
		dprintf("User ");
c040a504:	83 ec 0c             	sub    $0xc,%esp
c040a507:	68 41 f6 40 c0       	push   $0xc040f641
c040a50c:	e8 45 2f 00 00       	call   c040d456 <debug_printf>
c040a511:	83 c4 10             	add    $0x10,%esp
c040a514:	eb 10                	jmp    c040a526 <pg_postmortem+0x253>
	}
	else
	{
		dprintf("Kernel ");
c040a516:	83 ec 0c             	sub    $0xc,%esp
c040a519:	68 47 f6 40 c0       	push   $0xc040f647
c040a51e:	e8 33 2f 00 00       	call   c040d456 <debug_printf>
c040a523:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_R)
c040a526:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a52d:	8b 40 28             	mov    0x28(%eax),%eax
c040a530:	83 e0 08             	and    $0x8,%eax
c040a533:	85 c0                	test   %eax,%eax
c040a535:	74 10                	je     c040a547 <pg_postmortem+0x274>
	{
		dprintf("Reserved ");
c040a537:	83 ec 0c             	sub    $0xc,%esp
c040a53a:	68 4f f6 40 c0       	push   $0xc040f64f
c040a53f:	e8 12 2f 00 00       	call   c040d456 <debug_printf>
c040a544:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_I)
c040a547:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040a54e:	8b 40 28             	mov    0x28(%eax),%eax
c040a551:	83 e0 10             	and    $0x10,%eax
c040a554:	85 c0                	test   %eax,%eax
c040a556:	74 10                	je     c040a568 <pg_postmortem+0x295>
	{
		dprintf("NoExecute ");
c040a558:	83 ec 0c             	sub    $0xc,%esp
c040a55b:	68 59 f6 40 c0       	push   $0xc040f659
c040a560:	e8 f1 2e 00 00       	call   c040d456 <debug_printf>
c040a565:	83 c4 10             	add    $0x10,%esp
	}
	dprintf("\n");
c040a568:	83 ec 0c             	sub    $0xc,%esp
c040a56b:	68 64 f6 40 c0       	push   $0xc040f664
c040a570:	e8 e1 2e 00 00       	call   c040d456 <debug_printf>
c040a575:	83 c4 10             	add    $0x10,%esp
	
	if(running)
c040a578:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
c040a57d:	0f 84 bb 00 00 00    	je     c040a63e <pg_postmortem+0x36b>
	{
		proc = running->proc;
c040a583:	8b 44 24 58          	mov    0x58(%esp),%eax
c040a587:	8b 00                	mov    (%eax),%eax
c040a589:	89 44 24 5c          	mov    %eax,0x5c(%esp)
		
		dprintf("      Faulting thread: %i (%p) in process %i (%p) with pg dir %p\n",
c040a58d:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040a591:	8b 48 20             	mov    0x20(%eax),%ecx
c040a594:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040a598:	8b 10                	mov    (%eax),%edx
c040a59a:	8b 44 24 58          	mov    0x58(%esp),%eax
c040a59e:	8b 40 04             	mov    0x4(%eax),%eax
c040a5a1:	83 ec 08             	sub    $0x8,%esp
c040a5a4:	51                   	push   %ecx
c040a5a5:	ff 74 24 68          	pushl  0x68(%esp)
c040a5a9:	52                   	push   %edx
c040a5aa:	ff 74 24 6c          	pushl  0x6c(%esp)
c040a5ae:	50                   	push   %eax
c040a5af:	68 68 f6 40 c0       	push   $0xc040f668
c040a5b4:	e8 9d 2e 00 00       	call   c040d456 <debug_printf>
c040a5b9:	83 c4 20             	add    $0x20,%esp
				  running->tid, running, proc->pid, proc, proc->pgdir);
		
		dprintf("      Page directory entry %x = %x\n", pgdir_index, proc->pgdir[pgdir_index]);
c040a5bc:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040a5c0:	8b 40 20             	mov    0x20(%eax),%eax
c040a5c3:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c040a5c7:	c1 e2 02             	shl    $0x2,%edx
c040a5ca:	01 d0                	add    %edx,%eax
c040a5cc:	8b 00                	mov    (%eax),%eax
c040a5ce:	83 ec 04             	sub    $0x4,%esp
c040a5d1:	50                   	push   %eax
c040a5d2:	ff 74 24 54          	pushl  0x54(%esp)
c040a5d6:	68 ac f6 40 c0       	push   $0xc040f6ac
c040a5db:	e8 76 2e 00 00       	call   c040d456 <debug_printf>
c040a5e0:	83 c4 10             	add    $0x10,%esp
		pgtable = (unsigned int *)((unsigned int)proc->pgdir[pgdir_index] & PG_4K_MASK);
c040a5e3:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040a5e7:	8b 40 20             	mov    0x20(%eax),%eax
c040a5ea:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c040a5ee:	c1 e2 02             	shl    $0x2,%edx
c040a5f1:	01 d0                	add    %edx,%eax
c040a5f3:	8b 00                	mov    (%eax),%eax
c040a5f5:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c040a5fa:	89 44 24 54          	mov    %eax,0x54(%esp)
		pgtable = KERNEL_PHYS2LOG(pgtable);
c040a5fe:	8b 44 24 54          	mov    0x54(%esp),%eax
c040a602:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040a607:	89 44 24 54          	mov    %eax,0x54(%esp)
		if(pgtable && (faultaddr < KERNEL_SPACE_BASE))
c040a60b:	83 7c 24 54 00       	cmpl   $0x0,0x54(%esp)
c040a610:	74 2c                	je     c040a63e <pg_postmortem+0x36b>
c040a612:	81 7c 24 48 ff ff ff 	cmpl   $0xbfffffff,0x48(%esp)
c040a619:	bf 
c040a61a:	77 22                	ja     c040a63e <pg_postmortem+0x36b>
		{
			dprintf("      Page table entry %x = %x\n", pgtable_index, pgtable[pgtable_index]);
c040a61c:	8b 44 24 50          	mov    0x50(%esp),%eax
c040a620:	c1 e0 02             	shl    $0x2,%eax
c040a623:	03 44 24 54          	add    0x54(%esp),%eax
c040a627:	8b 00                	mov    (%eax),%eax
c040a629:	83 ec 04             	sub    $0x4,%esp
c040a62c:	50                   	push   %eax
c040a62d:	ff 74 24 58          	pushl  0x58(%esp)
c040a631:	68 d0 f6 40 c0       	push   $0xc040f6d0
c040a636:	e8 1b 2e 00 00       	call   c040d456 <debug_printf>
c040a63b:	83 c4 10             	add    $0x10,%esp
		}
	}
}
c040a63e:	83 c4 6c             	add    $0x6c,%esp
c040a641:	5b                   	pop    %ebx
c040a642:	5e                   	pop    %esi
c040a643:	5f                   	pop    %edi
c040a644:	5d                   	pop    %ebp
c040a645:	c3                   	ret    
	...

c040a648 <thread_find_thread>:

/* thread_find_thread
	<= return a pointer to a thread that matches the given tid owned by the
      given process, or NULL for failure */
thread *thread_find_thread(process *proc, unsigned int tid)
{
c040a648:	83 ec 1c             	sub    $0x1c,%esp
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;
c040a64b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040a64f:	83 e0 3f             	and    $0x3f,%eax
c040a652:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!tid || !proc)
c040a656:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040a65b:	74 07                	je     c040a664 <thread_find_thread+0x1c>
c040a65d:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040a662:	75 3d                	jne    c040a6a1 <thread_find_thread+0x59>
	{
		dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n" DEBUG_COL_OFF
				  "            process %p tid %i\n" DEBUG_COL_OFF, CPU_ID, proc, tid);
c040a664:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;

	if(!tid || !proc)
	{
		dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n" DEBUG_COL_OFF
c040a669:	3c 01                	cmp    $0x1,%al
c040a66b:	76 0c                	jbe    c040a679 <thread_find_thread+0x31>
				  "            process %p tid %i\n" DEBUG_COL_OFF, CPU_ID, proc, tid);
c040a66d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a672:	8b 00                	mov    (%eax),%eax
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;

	if(!tid || !proc)
	{
		dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n" DEBUG_COL_OFF
c040a674:	c1 e8 18             	shr    $0x18,%eax
c040a677:	eb 08                	jmp    c040a681 <thread_find_thread+0x39>
c040a679:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040a67e:	0f b6 c0             	movzbl %al,%eax
c040a681:	ff 74 24 24          	pushl  0x24(%esp)
c040a685:	ff 74 24 24          	pushl  0x24(%esp)
c040a689:	50                   	push   %eax
c040a68a:	68 f0 f6 40 c0       	push   $0xc040f6f0
c040a68f:	e8 c2 2d 00 00       	call   c040d456 <debug_printf>
c040a694:	83 c4 10             	add    $0x10,%esp
				  "            process %p tid %i\n" DEBUG_COL_OFF, CPU_ID, proc, tid);
		return NULL;
c040a697:	b8 00 00 00 00       	mov    $0x0,%eax
c040a69c:	e9 95 00 00 00       	jmp    c040a736 <thread_find_thread+0xee>
	}

	if(lock_gate(&(proc->lock), LOCK_READ))
c040a6a1:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a6a5:	83 c0 10             	add    $0x10,%eax
c040a6a8:	83 ec 08             	sub    $0x8,%esp
c040a6ab:	6a 00                	push   $0x0
c040a6ad:	50                   	push   %eax
c040a6ae:	e8 d8 5d ff ff       	call   c040048b <lock_gate>
c040a6b3:	83 c4 10             	add    $0x10,%esp
c040a6b6:	85 c0                	test   %eax,%eax
c040a6b8:	74 07                	je     c040a6c1 <thread_find_thread+0x79>
		return NULL;
c040a6ba:	b8 00 00 00 00       	mov    $0x0,%eax
c040a6bf:	eb 75                	jmp    c040a736 <thread_find_thread+0xee>
	
	table = proc->threads;
c040a6c1:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a6c5:	8b 40 38             	mov    0x38(%eax),%eax
c040a6c8:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	search = table[hash];
c040a6cc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a6d0:	c1 e0 02             	shl    $0x2,%eax
c040a6d3:	03 44 24 08          	add    0x8(%esp),%eax
c040a6d7:	8b 00                	mov    (%eax),%eax
c040a6d9:	89 44 24 04          	mov    %eax,0x4(%esp)
	while(search)
c040a6dd:	eb 36                	jmp    c040a715 <thread_find_thread+0xcd>
	{
		if(search->tid == tid)
c040a6df:	8b 44 24 04          	mov    0x4(%esp),%eax
c040a6e3:	8b 40 04             	mov    0x4(%eax),%eax
c040a6e6:	3b 44 24 24          	cmp    0x24(%esp),%eax
c040a6ea:	75 1b                	jne    c040a707 <thread_find_thread+0xbf>
		{
			unlock_gate(&(proc->lock), LOCK_READ);
c040a6ec:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a6f0:	83 c0 10             	add    $0x10,%eax
c040a6f3:	83 ec 08             	sub    $0x8,%esp
c040a6f6:	6a 00                	push   $0x0
c040a6f8:	50                   	push   %eax
c040a6f9:	e8 aa 5f ff ff       	call   c04006a8 <unlock_gate>
c040a6fe:	83 c4 10             	add    $0x10,%esp
			return search; /* foundya */
c040a701:	8b 44 24 04          	mov    0x4(%esp),%eax
c040a705:	eb 2f                	jmp    c040a736 <thread_find_thread+0xee>
		}
		
		search = search->hash_next;
c040a707:	8b 44 24 04          	mov    0x4(%esp),%eax
c040a70b:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040a711:	89 44 24 04          	mov    %eax,0x4(%esp)
		return NULL;
	
	table = proc->threads;
	
	search = table[hash];
	while(search)
c040a715:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c040a71a:	75 c3                	jne    c040a6df <thread_find_thread+0x97>
		}
		
		search = search->hash_next;
	}
	
	unlock_gate(&(proc->lock), LOCK_READ);
c040a71c:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a720:	83 c0 10             	add    $0x10,%eax
c040a723:	83 ec 08             	sub    $0x8,%esp
c040a726:	6a 00                	push   $0x0
c040a728:	50                   	push   %eax
c040a729:	e8 7a 5f ff ff       	call   c04006a8 <unlock_gate>
c040a72e:	83 c4 10             	add    $0x10,%esp
	return NULL; /* not found! */
c040a731:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040a736:	83 c4 1c             	add    $0x1c,%esp
c040a739:	c3                   	ret    

c040a73a <thread_duplicate>:
   => proc = process to create new thread for
      source = original thread to clone
   <= returns pointer to new thread or NULL for failure
*/
thread *thread_duplicate(process *proc, thread *source)
{
c040a73a:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int kstack, hash;
	thread *new, **threads;
	
	if(lock_gate(&(proc->lock), LOCK_WRITE))
c040a73d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a741:	83 c0 10             	add    $0x10,%eax
c040a744:	83 ec 08             	sub    $0x8,%esp
c040a747:	6a 01                	push   $0x1
c040a749:	50                   	push   %eax
c040a74a:	e8 3c 5d ff ff       	call   c040048b <lock_gate>
c040a74f:	83 c4 10             	add    $0x10,%esp
c040a752:	85 c0                	test   %eax,%eax
c040a754:	74 0a                	je     c040a760 <thread_duplicate+0x26>
		return NULL;
c040a756:	b8 00 00 00 00       	mov    $0x0,%eax
c040a75b:	e9 e9 02 00 00       	jmp    c040aa49 <thread_duplicate+0x30f>
	if(lock_gate(&(source->lock), LOCK_READ))
c040a760:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a764:	83 c0 1c             	add    $0x1c,%eax
c040a767:	83 ec 08             	sub    $0x8,%esp
c040a76a:	6a 00                	push   $0x0
c040a76c:	50                   	push   %eax
c040a76d:	e8 19 5d ff ff       	call   c040048b <lock_gate>
c040a772:	83 c4 10             	add    $0x10,%esp
c040a775:	85 c0                	test   %eax,%eax
c040a777:	74 1f                	je     c040a798 <thread_duplicate+0x5e>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040a779:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a77d:	83 c0 10             	add    $0x10,%eax
c040a780:	83 ec 08             	sub    $0x8,%esp
c040a783:	6a 01                	push   $0x1
c040a785:	50                   	push   %eax
c040a786:	e8 1d 5f ff ff       	call   c04006a8 <unlock_gate>
c040a78b:	83 c4 10             	add    $0x10,%esp
		return NULL;
c040a78e:	b8 00 00 00 00       	mov    $0x0,%eax
c040a793:	e9 b1 02 00 00       	jmp    c040aa49 <thread_duplicate+0x30f>
	}
	
	/* grab memory and zero it now to store details of new thread */
	kresult err = vmm_malloc((void **)&new, sizeof(thread));
c040a798:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040a79c:	83 ec 08             	sub    $0x8,%esp
c040a79f:	68 f0 00 00 00       	push   $0xf0
c040a7a4:	50                   	push   %eax
c040a7a5:	e8 e6 b6 ff ff       	call   c0405e90 <vmm_malloc>
c040a7aa:	83 c4 10             	add    $0x10,%esp
c040a7ad:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c040a7b1:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040a7b6:	74 34                	je     c040a7ec <thread_duplicate+0xb2>
	{
		unlock_gate(&(source->lock), LOCK_READ);
c040a7b8:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a7bc:	83 c0 1c             	add    $0x1c,%eax
c040a7bf:	83 ec 08             	sub    $0x8,%esp
c040a7c2:	6a 00                	push   $0x0
c040a7c4:	50                   	push   %eax
c040a7c5:	e8 de 5e ff ff       	call   c04006a8 <unlock_gate>
c040a7ca:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040a7cd:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a7d1:	83 c0 10             	add    $0x10,%eax
c040a7d4:	83 ec 08             	sub    $0x8,%esp
c040a7d7:	6a 01                	push   $0x1
c040a7d9:	50                   	push   %eax
c040a7da:	e8 c9 5e ff ff       	call   c04006a8 <unlock_gate>
c040a7df:	83 c4 10             	add    $0x10,%esp
		return NULL; /* fail if we can't alloc a new thread */
c040a7e2:	b8 00 00 00 00       	mov    $0x0,%eax
c040a7e7:	e9 5d 02 00 00       	jmp    c040aa49 <thread_duplicate+0x30f>
	}
	vmm_memset(new, 0, sizeof(thread));
c040a7ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a7f0:	83 ec 04             	sub    $0x4,%esp
c040a7f3:	68 f0 00 00 00       	push   $0xf0
c040a7f8:	6a 00                	push   $0x0
c040a7fa:	50                   	push   %eax
c040a7fb:	e8 e6 c4 ff ff       	call   c0406ce6 <vmm_memset>
c040a800:	83 c4 10             	add    $0x10,%esp
	
	/* initialise thread hash table if required */
	if(!(proc->threads))
c040a803:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a807:	8b 40 38             	mov    0x38(%eax),%eax
c040a80a:	85 c0                	test   %eax,%eax
c040a80c:	75 5e                	jne    c040a86c <thread_duplicate+0x132>
	{
		thread_new_hash(proc);
c040a80e:	83 ec 0c             	sub    $0xc,%esp
c040a811:	ff 74 24 3c          	pushl  0x3c(%esp)
c040a815:	e8 33 02 00 00       	call   c040aa4d <thread_new_hash>
c040a81a:	83 c4 10             	add    $0x10,%esp
		if(!(proc->threads))
c040a81d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a821:	8b 40 38             	mov    0x38(%eax),%eax
c040a824:	85 c0                	test   %eax,%eax
c040a826:	75 44                	jne    c040a86c <thread_duplicate+0x132>
		{
			vmm_free(new);
c040a828:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a82c:	83 ec 0c             	sub    $0xc,%esp
c040a82f:	50                   	push   %eax
c040a830:	e8 9d ba ff ff       	call   c04062d2 <vmm_free>
c040a835:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(source->lock), LOCK_READ);
c040a838:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a83c:	83 c0 1c             	add    $0x1c,%eax
c040a83f:	83 ec 08             	sub    $0x8,%esp
c040a842:	6a 00                	push   $0x0
c040a844:	50                   	push   %eax
c040a845:	e8 5e 5e ff ff       	call   c04006a8 <unlock_gate>
c040a84a:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(proc->lock), LOCK_WRITE);
c040a84d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a851:	83 c0 10             	add    $0x10,%eax
c040a854:	83 ec 08             	sub    $0x8,%esp
c040a857:	6a 01                	push   $0x1
c040a859:	50                   	push   %eax
c040a85a:	e8 49 5e ff ff       	call   c04006a8 <unlock_gate>
c040a85f:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040a862:	b8 00 00 00 00       	mov    $0x0,%eax
c040a867:	e9 dd 01 00 00       	jmp    c040aa49 <thread_duplicate+0x30f>
		}
	}
	threads = proc->threads;
c040a86c:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a870:	8b 40 38             	mov    0x38(%eax),%eax
c040a873:	89 44 24 18          	mov    %eax,0x18(%esp)
	
	new->proc          = proc;
c040a877:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a87b:	8b 54 24 30          	mov    0x30(%esp),%edx
c040a87f:	89 10                	mov    %edx,(%eax)
	new->tid           = source->tid;
c040a881:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a885:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a889:	8b 52 04             	mov    0x4(%edx),%edx
c040a88c:	89 50 04             	mov    %edx,0x4(%eax)
	new->flags         = source->flags;
c040a88f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a893:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a897:	8a 52 0c             	mov    0xc(%edx),%dl
c040a89a:	88 50 0c             	mov    %dl,0xc(%eax)
	new->timeslice     = source->timeslice;
c040a89d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8a1:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a8a5:	8a 52 0d             	mov    0xd(%edx),%dl
c040a8a8:	88 50 0d             	mov    %dl,0xd(%eax)
	new->priority      = source->priority;
c040a8ab:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8af:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a8b3:	8a 52 0e             	mov    0xe(%edx),%dl
c040a8b6:	88 50 0e             	mov    %dl,0xe(%eax)
	new->prev_priority = source->prev_priority;
c040a8b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8bd:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a8c1:	8a 52 0f             	mov    0xf(%edx),%dl
c040a8c4:	88 50 0f             	mov    %dl,0xf(%eax)
	new->stackbase		 = source->stackbase;
c040a8c7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8cb:	8b 54 24 34          	mov    0x34(%esp),%edx
c040a8cf:	8b 52 2c             	mov    0x2c(%edx),%edx
c040a8d2:	89 50 2c             	mov    %edx,0x2c(%eax)

	/* the new thread is asleep and due to be scheduled */
	new->state = sleeping;
c040a8d5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8d9:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	
	/* clone the source thread's tss FIXME not very portable? :( */
	vmm_memcpy(&(new->tss), &(source->tss), sizeof(tss_descr));
c040a8e0:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a8e4:	8d 50 38             	lea    0x38(%eax),%edx
c040a8e7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a8eb:	83 c0 38             	add    $0x38,%eax
c040a8ee:	83 ec 04             	sub    $0x4,%esp
c040a8f1:	6a 68                	push   $0x68
c040a8f3:	52                   	push   %edx
c040a8f4:	50                   	push   %eax
c040a8f5:	e8 29 c4 ff ff       	call   c0406d23 <vmm_memcpy>
c040a8fa:	83 c4 10             	add    $0x10,%esp
	
	/* clone the source thread's kernel stack for this new thread */
	err = vmm_malloc((void **)&kstack, MEM_PGSIZE);
c040a8fd:	8d 44 24 10          	lea    0x10(%esp),%eax
c040a901:	83 ec 08             	sub    $0x8,%esp
c040a904:	68 00 10 00 00       	push   $0x1000
c040a909:	50                   	push   %eax
c040a90a:	e8 81 b5 ff ff       	call   c0405e90 <vmm_malloc>
c040a90f:	83 c4 10             	add    $0x10,%esp
c040a912:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c040a916:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040a91b:	74 44                	je     c040a961 <thread_duplicate+0x227>
	{
		unlock_gate(&(source->lock), LOCK_READ);
c040a91d:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a921:	83 c0 1c             	add    $0x1c,%eax
c040a924:	83 ec 08             	sub    $0x8,%esp
c040a927:	6a 00                	push   $0x0
c040a929:	50                   	push   %eax
c040a92a:	e8 79 5d ff ff       	call   c04006a8 <unlock_gate>
c040a92f:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040a932:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a936:	83 c0 10             	add    $0x10,%eax
c040a939:	83 ec 08             	sub    $0x8,%esp
c040a93c:	6a 01                	push   $0x1
c040a93e:	50                   	push   %eax
c040a93f:	e8 64 5d ff ff       	call   c04006a8 <unlock_gate>
c040a944:	83 c4 10             	add    $0x10,%esp
		vmm_free(new);
c040a947:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a94b:	83 ec 0c             	sub    $0xc,%esp
c040a94e:	50                   	push   %eax
c040a94f:	e8 7e b9 ff ff       	call   c04062d2 <vmm_free>
c040a954:	83 c4 10             	add    $0x10,%esp
		return NULL; /* something went wrong */
c040a957:	b8 00 00 00 00       	mov    $0x0,%eax
c040a95c:	e9 e8 00 00 00       	jmp    c040aa49 <thread_duplicate+0x30f>
	}
	
	/* stacks grow down, hence pushing base up */
	new->kstackblk = kstack;
c040a961:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a965:	8b 54 24 10          	mov    0x10(%esp),%edx
c040a969:	89 50 34             	mov    %edx,0x34(%eax)
	new->kstackbase = kstack + MEM_PGSIZE;
c040a96c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a970:	8b 54 24 10          	mov    0x10(%esp),%edx
c040a974:	81 c2 00 10 00 00    	add    $0x1000,%edx
c040a97a:	89 50 30             	mov    %edx,0x30(%eax)
	
	/* copy thread state FIXME not very portable :( */
	vmm_memcpy(&(new->regs), &(source->regs), sizeof(int_registers_block));
c040a97d:	8b 44 24 34          	mov    0x34(%esp),%eax
c040a981:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c040a987:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a98b:	05 a0 00 00 00       	add    $0xa0,%eax
c040a990:	83 ec 04             	sub    $0x4,%esp
c040a993:	6a 40                	push   $0x40
c040a995:	52                   	push   %edx
c040a996:	50                   	push   %eax
c040a997:	e8 87 c3 ff ff       	call   c0406d23 <vmm_memcpy>
c040a99c:	83 c4 10             	add    $0x10,%esp
	
	hash = new->tid % THREAD_HASH_BUCKETS;
c040a99f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a9a3:	8b 40 04             	mov    0x4(%eax),%eax
c040a9a6:	83 e0 3f             	and    $0x3f,%eax
c040a9a9:	89 44 24 14          	mov    %eax,0x14(%esp)
	if(threads[hash])
c040a9ad:	8b 44 24 14          	mov    0x14(%esp),%eax
c040a9b1:	c1 e0 02             	shl    $0x2,%eax
c040a9b4:	03 44 24 18          	add    0x18(%esp),%eax
c040a9b8:	8b 00                	mov    (%eax),%eax
c040a9ba:	85 c0                	test   %eax,%eax
c040a9bc:	74 30                	je     c040a9ee <thread_duplicate+0x2b4>
	{ 
		threads[hash]->hash_prev = new;
c040a9be:	8b 44 24 14          	mov    0x14(%esp),%eax
c040a9c2:	c1 e0 02             	shl    $0x2,%eax
c040a9c5:	03 44 24 18          	add    0x18(%esp),%eax
c040a9c9:	8b 00                	mov    (%eax),%eax
c040a9cb:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040a9cf:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
		new->hash_next = threads[hash];
c040a9d5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a9d9:	8b 54 24 14          	mov    0x14(%esp),%edx
c040a9dd:	c1 e2 02             	shl    $0x2,%edx
c040a9e0:	03 54 24 18          	add    0x18(%esp),%edx
c040a9e4:	8b 12                	mov    (%edx),%edx
c040a9e6:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c040a9ec:	eb 0e                	jmp    c040a9fc <thread_duplicate+0x2c2>
	}
	else
	{
		new->hash_next = NULL;
c040a9ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a9f2:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
c040a9f9:	00 00 00 
	}
	threads[hash] = new;
c040a9fc:	8b 44 24 14          	mov    0x14(%esp),%eax
c040aa00:	c1 e0 02             	shl    $0x2,%eax
c040aa03:	03 44 24 18          	add    0x18(%esp),%eax
c040aa07:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040aa0b:	89 10                	mov    %edx,(%eax)
	new->hash_prev = NULL;	
c040aa0d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040aa11:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
c040aa18:	00 00 00 
	
	unlock_gate(&(source->lock), LOCK_READ);
c040aa1b:	8b 44 24 34          	mov    0x34(%esp),%eax
c040aa1f:	83 c0 1c             	add    $0x1c,%eax
c040aa22:	83 ec 08             	sub    $0x8,%esp
c040aa25:	6a 00                	push   $0x0
c040aa27:	50                   	push   %eax
c040aa28:	e8 7b 5c ff ff       	call   c04006a8 <unlock_gate>
c040aa2d:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(proc->lock), LOCK_WRITE);
c040aa30:	8b 44 24 30          	mov    0x30(%esp),%eax
c040aa34:	83 c0 10             	add    $0x10,%eax
c040aa37:	83 ec 08             	sub    $0x8,%esp
c040aa3a:	6a 01                	push   $0x1
c040aa3c:	50                   	push   %eax
c040aa3d:	e8 66 5c ff ff       	call   c04006a8 <unlock_gate>
c040aa42:	83 c4 10             	add    $0x10,%esp
#ifdef THREAD_DEBUG
	dprintf(DEBUG_COL_THREAD "[thread:%i] cloned thread %i of process %i for process %i (%p) (kstack %p)\n" DEBUG_COL_OFF,
			  CPU_ID, source->tid, source->proc->pid, proc->pid, new, new->kstackbase);
#endif
	
	return new;
c040aa45:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040aa49:	83 c4 2c             	add    $0x2c,%esp
c040aa4c:	c3                   	ret    

c040aa4d <thread_new_hash>:
/* thread_new_hash
	Create a new hash table for threads in the given process
   <= returns 0 for success, anything else is failure
*/
kresult thread_new_hash(process *proc)
{
c040aa4d:	83 ec 1c             	sub    $0x1c,%esp
	kresult err;
	thread **threads;
	
	if(lock_gate(&(proc->lock), LOCK_WRITE))
c040aa50:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aa54:	83 c0 10             	add    $0x10,%eax
c040aa57:	83 ec 08             	sub    $0x8,%esp
c040aa5a:	6a 01                	push   $0x1
c040aa5c:	50                   	push   %eax
c040aa5d:	e8 29 5a ff ff       	call   c040048b <lock_gate>
c040aa62:	83 c4 10             	add    $0x10,%esp
c040aa65:	85 c0                	test   %eax,%eax
c040aa67:	74 0a                	je     c040aa73 <thread_new_hash+0x26>
		return e_failure;
c040aa69:	b8 01 00 00 00       	mov    $0x1,%eax
c040aa6e:	e9 9e 00 00 00       	jmp    c040ab11 <thread_new_hash+0xc4>
	
	if(proc->threads)
c040aa73:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aa77:	8b 40 38             	mov    0x38(%eax),%eax
c040aa7a:	85 c0                	test   %eax,%eax
c040aa7c:	74 1c                	je     c040aa9a <thread_new_hash+0x4d>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040aa7e:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aa82:	83 c0 10             	add    $0x10,%eax
c040aa85:	83 ec 08             	sub    $0x8,%esp
c040aa88:	6a 01                	push   $0x1
c040aa8a:	50                   	push   %eax
c040aa8b:	e8 18 5c ff ff       	call   c04006a8 <unlock_gate>
c040aa90:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040aa93:	b8 01 00 00 00       	mov    $0x1,%eax
c040aa98:	eb 77                	jmp    c040ab11 <thread_new_hash+0xc4>
	}
	
	err = vmm_malloc((void **)&threads, sizeof(thread *) * THREAD_HASH_BUCKETS);
c040aa9a:	8d 44 24 08          	lea    0x8(%esp),%eax
c040aa9e:	83 ec 08             	sub    $0x8,%esp
c040aaa1:	68 00 01 00 00       	push   $0x100
c040aaa6:	50                   	push   %eax
c040aaa7:	e8 e4 b3 ff ff       	call   c0405e90 <vmm_malloc>
c040aaac:	83 c4 10             	add    $0x10,%esp
c040aaaf:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(err)
c040aab3:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040aab8:	74 1b                	je     c040aad5 <thread_new_hash+0x88>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040aaba:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aabe:	83 c0 10             	add    $0x10,%eax
c040aac1:	83 ec 08             	sub    $0x8,%esp
c040aac4:	6a 01                	push   $0x1
c040aac6:	50                   	push   %eax
c040aac7:	e8 dc 5b ff ff       	call   c04006a8 <unlock_gate>
c040aacc:	83 c4 10             	add    $0x10,%esp
		return err;
c040aacf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040aad3:	eb 3c                	jmp    c040ab11 <thread_new_hash+0xc4>
	}
	
	vmm_memset(threads, 0, sizeof(thread *) * THREAD_HASH_BUCKETS);
c040aad5:	8b 44 24 08          	mov    0x8(%esp),%eax
c040aad9:	83 ec 04             	sub    $0x4,%esp
c040aadc:	68 00 01 00 00       	push   $0x100
c040aae1:	6a 00                	push   $0x0
c040aae3:	50                   	push   %eax
c040aae4:	e8 fd c1 ff ff       	call   c0406ce6 <vmm_memset>
c040aae9:	83 c4 10             	add    $0x10,%esp
	proc->threads = threads;
c040aaec:	8b 54 24 08          	mov    0x8(%esp),%edx
c040aaf0:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aaf4:	89 50 38             	mov    %edx,0x38(%eax)
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c040aaf7:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aafb:	83 c0 10             	add    $0x10,%eax
c040aafe:	83 ec 08             	sub    $0x8,%esp
c040ab01:	6a 01                	push   $0x1
c040ab03:	50                   	push   %eax
c040ab04:	e8 9f 5b ff ff       	call   c04006a8 <unlock_gate>
c040ab09:	83 c4 10             	add    $0x10,%esp
#ifdef THREAD_DEBUG
	dprintf(DEBUG_COL_THREAD "[thread:%i] created thread hash table %p for process %i\n" DEBUG_COL_OFF,
			  CPU_ID, threads, proc->pid);
#endif

	return success;
c040ab0c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040ab11:	83 c4 1c             	add    $0x1c,%esp
c040ab14:	c3                   	ret    

c040ab15 <thread_new>:
	Create a new thread inside a process
   => proc = pointer to process owning the thread
 <= pointer to new thread structure, or NULL for failure
*/
thread *thread_new(process *proc)
{
c040ab15:	83 ec 2c             	sub    $0x2c,%esp
	kresult err;
	unsigned int tid_free = 0, hash, stackbase;
c040ab18:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c040ab1f:	00 
	thread *new;
	unsigned int kstack;
	
	if(!proc) return NULL; /* give up now if we get a bad pointer */
c040ab20:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040ab25:	75 0a                	jne    c040ab31 <thread_new+0x1c>
c040ab27:	b8 00 00 00 00       	mov    $0x0,%eax
c040ab2c:	e9 1f 03 00 00       	jmp    c040ae50 <thread_new+0x33b>
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c040ab31:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ab35:	83 c0 10             	add    $0x10,%eax
c040ab38:	83 ec 08             	sub    $0x8,%esp
c040ab3b:	6a 01                	push   $0x1
c040ab3d:	50                   	push   %eax
c040ab3e:	e8 48 59 ff ff       	call   c040048b <lock_gate>
c040ab43:	83 c4 10             	add    $0x10,%esp
	
	/* give up now if we have too many threads */
	if(proc->thread_count > THREAD_MAX_NR)
c040ab46:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ab4a:	8b 40 3c             	mov    0x3c(%eax),%eax
c040ab4d:	3d 00 04 00 00       	cmp    $0x400,%eax
c040ab52:	76 1f                	jbe    c040ab73 <thread_new+0x5e>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040ab54:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ab58:	83 c0 10             	add    $0x10,%eax
c040ab5b:	83 ec 08             	sub    $0x8,%esp
c040ab5e:	6a 01                	push   $0x1
c040ab60:	50                   	push   %eax
c040ab61:	e8 42 5b ff ff       	call   c04006a8 <unlock_gate>
c040ab66:	83 c4 10             	add    $0x10,%esp
		return NULL;
c040ab69:	b8 00 00 00 00       	mov    $0x0,%eax
c040ab6e:	e9 dd 02 00 00       	jmp    c040ae50 <thread_new+0x33b>
	}

	/* grab memory now to store details of new thread */
	err = vmm_malloc((void **)&new, sizeof(thread));
c040ab73:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040ab77:	83 ec 08             	sub    $0x8,%esp
c040ab7a:	68 f0 00 00 00       	push   $0xf0
c040ab7f:	50                   	push   %eax
c040ab80:	e8 0b b3 ff ff       	call   c0405e90 <vmm_malloc>
c040ab85:	83 c4 10             	add    $0x10,%esp
c040ab88:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(err)
c040ab8c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040ab91:	74 1f                	je     c040abb2 <thread_new+0x9d>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040ab93:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ab97:	83 c0 10             	add    $0x10,%eax
c040ab9a:	83 ec 08             	sub    $0x8,%esp
c040ab9d:	6a 01                	push   $0x1
c040ab9f:	50                   	push   %eax
c040aba0:	e8 03 5b ff ff       	call   c04006a8 <unlock_gate>
c040aba5:	83 c4 10             	add    $0x10,%esp
		return NULL; /* fail if we can't alloc a new thread */
c040aba8:	b8 00 00 00 00       	mov    $0x0,%eax
c040abad:	e9 9e 02 00 00       	jmp    c040ae50 <thread_new+0x33b>
	}
	vmm_memset(new, 0, sizeof(thread));
c040abb2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040abb6:	83 ec 04             	sub    $0x4,%esp
c040abb9:	68 f0 00 00 00       	push   $0xf0
c040abbe:	6a 00                	push   $0x0
c040abc0:	50                   	push   %eax
c040abc1:	e8 20 c1 ff ff       	call   c0406ce6 <vmm_memset>
c040abc6:	83 c4 10             	add    $0x10,%esp
	
	/* kernel stack initialisation - just 4K per thread for now */
	err = vmm_malloc((void **)&kstack, MEM_PGSIZE);
c040abc9:	8d 44 24 08          	lea    0x8(%esp),%eax
c040abcd:	83 ec 08             	sub    $0x8,%esp
c040abd0:	68 00 10 00 00       	push   $0x1000
c040abd5:	50                   	push   %eax
c040abd6:	e8 b5 b2 ff ff       	call   c0405e90 <vmm_malloc>
c040abdb:	83 c4 10             	add    $0x10,%esp
c040abde:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(err)
c040abe2:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040abe7:	74 2f                	je     c040ac18 <thread_new+0x103>
	{
		vmm_free(new);
c040abe9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040abed:	83 ec 0c             	sub    $0xc,%esp
c040abf0:	50                   	push   %eax
c040abf1:	e8 dc b6 ff ff       	call   c04062d2 <vmm_free>
c040abf6:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040abf9:	8b 44 24 30          	mov    0x30(%esp),%eax
c040abfd:	83 c0 10             	add    $0x10,%eax
c040ac00:	83 ec 08             	sub    $0x8,%esp
c040ac03:	6a 01                	push   $0x1
c040ac05:	50                   	push   %eax
c040ac06:	e8 9d 5a ff ff       	call   c04006a8 <unlock_gate>
c040ac0b:	83 c4 10             	add    $0x10,%esp
		return NULL; /* FIXME should really do some clean up if this fails */
c040ac0e:	b8 00 00 00 00       	mov    $0x0,%eax
c040ac13:	e9 38 02 00 00       	jmp    c040ae50 <thread_new+0x33b>
	}
	vmm_memset((void *)kstack, 0, MEM_PGSIZE);
c040ac18:	8b 44 24 08          	mov    0x8(%esp),%eax
c040ac1c:	83 ec 04             	sub    $0x4,%esp
c040ac1f:	68 00 10 00 00       	push   $0x1000
c040ac24:	6a 00                	push   $0x0
c040ac26:	50                   	push   %eax
c040ac27:	e8 ba c0 ff ff       	call   c0406ce6 <vmm_memset>
c040ac2c:	83 c4 10             	add    $0x10,%esp
	
	/* initialise thread hash table if required */
	if(!(proc->threads))
c040ac2f:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ac33:	8b 40 38             	mov    0x38(%eax),%eax
c040ac36:	85 c0                	test   %eax,%eax
c040ac38:	0f 85 ac 00 00 00    	jne    c040acea <thread_new+0x1d5>
	{
		thread_new_hash(proc);
c040ac3e:	83 ec 0c             	sub    $0xc,%esp
c040ac41:	ff 74 24 3c          	pushl  0x3c(%esp)
c040ac45:	e8 03 fe ff ff       	call   c040aa4d <thread_new_hash>
c040ac4a:	83 c4 10             	add    $0x10,%esp
		if(!(proc->threads))
c040ac4d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ac51:	8b 40 38             	mov    0x38(%eax),%eax
c040ac54:	85 c0                	test   %eax,%eax
c040ac56:	0f 85 8e 00 00 00    	jne    c040acea <thread_new+0x1d5>
		{
			vmm_free((void *)kstack);
c040ac5c:	8b 44 24 08          	mov    0x8(%esp),%eax
c040ac60:	83 ec 0c             	sub    $0xc,%esp
c040ac63:	50                   	push   %eax
c040ac64:	e8 69 b6 ff ff       	call   c04062d2 <vmm_free>
c040ac69:	83 c4 10             	add    $0x10,%esp
			vmm_free(new);
c040ac6c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ac70:	83 ec 0c             	sub    $0xc,%esp
c040ac73:	50                   	push   %eax
c040ac74:	e8 59 b6 ff ff       	call   c04062d2 <vmm_free>
c040ac79:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(proc->lock), LOCK_WRITE);
c040ac7c:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ac80:	83 c0 10             	add    $0x10,%eax
c040ac83:	83 ec 08             	sub    $0x8,%esp
c040ac86:	6a 01                	push   $0x1
c040ac88:	50                   	push   %eax
c040ac89:	e8 1a 5a ff ff       	call   c04006a8 <unlock_gate>
c040ac8e:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040ac91:	b8 00 00 00 00       	mov    $0x0,%eax
c040ac96:	e9 b5 01 00 00       	jmp    c040ae50 <thread_new+0x33b>
	}

	/* search for an available thread id */
	while(!tid_free)
	{
		if(thread_find_thread(proc, proc->next_tid) == NULL)
c040ac9b:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ac9f:	8b 40 40             	mov    0x40(%eax),%eax
c040aca2:	83 ec 08             	sub    $0x8,%esp
c040aca5:	50                   	push   %eax
c040aca6:	ff 74 24 3c          	pushl  0x3c(%esp)
c040acaa:	e8 99 f9 ff ff       	call   c040a648 <thread_find_thread>
c040acaf:	83 c4 10             	add    $0x10,%esp
c040acb2:	85 c0                	test   %eax,%eax
c040acb4:	75 0a                	jne    c040acc0 <thread_new+0x1ab>
			tid_free = 1;
c040acb6:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
c040acbd:	00 
c040acbe:	eb 2a                	jmp    c040acea <thread_new+0x1d5>
		else
		{
			proc->next_tid++;
c040acc0:	8b 44 24 30          	mov    0x30(%esp),%eax
c040acc4:	8b 40 40             	mov    0x40(%eax),%eax
c040acc7:	8d 50 01             	lea    0x1(%eax),%edx
c040acca:	8b 44 24 30          	mov    0x30(%esp),%eax
c040acce:	89 50 40             	mov    %edx,0x40(%eax)
			if(proc->next_tid >= THREAD_MAX_NR)
c040acd1:	8b 44 24 30          	mov    0x30(%esp),%eax
c040acd5:	8b 40 40             	mov    0x40(%eax),%eax
c040acd8:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040acdd:	76 0b                	jbe    c040acea <thread_new+0x1d5>
				proc->next_tid = FIRST_TID;
c040acdf:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ace3:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)
			return NULL;
		}
	}

	/* search for an available thread id */
	while(!tid_free)
c040acea:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040acef:	74 aa                	je     c040ac9b <thread_new+0x186>
				proc->next_tid = FIRST_TID;
		}
	}

	/* assign our new TID */
	new->tid = proc->next_tid;
c040acf1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040acf5:	8b 54 24 30          	mov    0x30(%esp),%edx
c040acf9:	8b 52 40             	mov    0x40(%edx),%edx
c040acfc:	89 50 04             	mov    %edx,0x4(%eax)
	proc->next_tid++;
c040acff:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad03:	8b 40 40             	mov    0x40(%eax),%eax
c040ad06:	8d 50 01             	lea    0x1(%eax),%edx
c040ad09:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad0d:	89 50 40             	mov    %edx,0x40(%eax)
	if(proc->next_tid >= THREAD_MAX_NR)
c040ad10:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad14:	8b 40 40             	mov    0x40(%eax),%eax
c040ad17:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040ad1c:	76 0b                	jbe    c040ad29 <thread_new+0x214>
		proc->next_tid = FIRST_TID;
c040ad1e:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad22:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)

	/* add it to the tid hash table of threads for this process */
	hash = new->tid % THREAD_HASH_BUCKETS;
c040ad29:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ad2d:	8b 40 04             	mov    0x4(%eax),%eax
c040ad30:	83 e0 3f             	and    $0x3f,%eax
c040ad33:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(proc->threads[hash])
c040ad37:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad3b:	8b 40 38             	mov    0x38(%eax),%eax
c040ad3e:	8b 54 24 18          	mov    0x18(%esp),%edx
c040ad42:	c1 e2 02             	shl    $0x2,%edx
c040ad45:	01 d0                	add    %edx,%eax
c040ad47:	8b 00                	mov    (%eax),%eax
c040ad49:	85 c0                	test   %eax,%eax
c040ad4b:	74 3a                	je     c040ad87 <thread_new+0x272>
	{
		proc->threads[hash]->hash_prev = new;
c040ad4d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad51:	8b 40 38             	mov    0x38(%eax),%eax
c040ad54:	8b 54 24 18          	mov    0x18(%esp),%edx
c040ad58:	c1 e2 02             	shl    $0x2,%edx
c040ad5b:	01 d0                	add    %edx,%eax
c040ad5d:	8b 00                	mov    (%eax),%eax
c040ad5f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040ad63:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
		new->hash_next = proc->threads[hash];
c040ad69:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ad6d:	8b 54 24 30          	mov    0x30(%esp),%edx
c040ad71:	8b 52 38             	mov    0x38(%edx),%edx
c040ad74:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c040ad78:	c1 e1 02             	shl    $0x2,%ecx
c040ad7b:	01 ca                	add    %ecx,%edx
c040ad7d:	8b 12                	mov    (%edx),%edx
c040ad7f:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c040ad85:	eb 0e                	jmp    c040ad95 <thread_new+0x280>
	}
	else
	{
		new->hash_next = NULL;
c040ad87:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ad8b:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
c040ad92:	00 00 00 
	}
	proc->threads[hash] = new;
c040ad95:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ad99:	8b 40 38             	mov    0x38(%eax),%eax
c040ad9c:	8b 54 24 18          	mov    0x18(%esp),%edx
c040ada0:	c1 e2 02             	shl    $0x2,%edx
c040ada3:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040ada6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040adaa:	89 02                	mov    %eax,(%edx)
	new->hash_prev = NULL;
c040adac:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040adb0:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
c040adb7:	00 00 00 

	/* fill in more details */
	new->proc = proc;
c040adba:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040adbe:	8b 54 24 30          	mov    0x30(%esp),%edx
c040adc2:	89 10                	mov    %edx,(%eax)
	proc->thread_count++;
c040adc4:	8b 44 24 30          	mov    0x30(%esp),%eax
c040adc8:	8b 40 3c             	mov    0x3c(%eax),%eax
c040adcb:	8d 50 01             	lea    0x1(%eax),%edx
c040adce:	8b 44 24 30          	mov    0x30(%esp),%eax
c040add2:	89 50 3c             	mov    %edx,0x3c(%eax)

	/* create a vma for the thread's user stack - don't forget stacks grow down */
	stackbase = KERNEL_SPACE_BASE - (THREAD_MAX_STACK * MEM_PGSIZE * new->tid);
c040add5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040add9:	8b 40 04             	mov    0x4(%eax),%eax
c040addc:	ba 00 00 03 00       	mov    $0x30000,%edx
c040ade1:	89 d1                	mov    %edx,%ecx
c040ade3:	29 c1                	sub    %eax,%ecx
c040ade5:	89 c8                	mov    %ecx,%eax
c040ade7:	c1 e0 0e             	shl    $0xe,%eax
c040adea:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	vmm_add_vma(proc, stackbase - (THREAD_MAX_STACK * MEM_PGSIZE), (THREAD_MAX_STACK * MEM_PGSIZE),
c040adee:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040adf2:	2d 00 40 00 00       	sub    $0x4000,%eax
c040adf7:	83 ec 0c             	sub    $0xc,%esp
c040adfa:	6a 00                	push   $0x0
c040adfc:	6a 03                	push   $0x3
c040adfe:	68 00 40 00 00       	push   $0x4000
c040ae03:	50                   	push   %eax
c040ae04:	ff 74 24 4c          	pushl  0x4c(%esp)
c040ae08:	e8 86 e2 ff ff       	call   c0409093 <vmm_add_vma>
c040ae0d:	83 c4 20             	add    $0x20,%esp
					VMA_READABLE | VMA_WRITEABLE | VMA_MEMSOURCE, 0);
	new->stackbase = stackbase;
c040ae10:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ae14:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c040ae18:	89 50 2c             	mov    %edx,0x2c(%eax)

	/* stacks grow down... */
	new->kstackblk = kstack;
c040ae1b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ae1f:	8b 54 24 08          	mov    0x8(%esp),%edx
c040ae23:	89 50 34             	mov    %edx,0x34(%eax)
	new->kstackbase = (kstack + MEM_PGSIZE);
c040ae26:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040ae2a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040ae2e:	81 c2 00 10 00 00    	add    $0x1000,%edx
c040ae34:	89 50 30             	mov    %edx,0x30(%eax)

	unlock_gate(&(proc->lock), LOCK_WRITE);
c040ae37:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ae3b:	83 c0 10             	add    $0x10,%eax
c040ae3e:	83 ec 08             	sub    $0x8,%esp
c040ae41:	6a 01                	push   $0x1
c040ae43:	50                   	push   %eax
c040ae44:	e8 5f 58 ff ff       	call   c04006a8 <unlock_gate>
c040ae49:	83 c4 10             	add    $0x10,%esp
#ifdef THREAD_DEBUG
	dprintf(DEBUG_COL_THREAD "[thread:%i] created thread %p tid %i (ustack %p kstack %p) for process %i\n" DEBUG_COL_OFF,
			  CPU_ID, new, new->tid, new->stackbase, new->kstackbase, proc->pid);
#endif

	return new;
c040ae4c:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040ae50:	83 c4 2c             	add    $0x2c,%esp
c040ae53:	c3                   	ret    

c040ae54 <thread_kill>:
   => owner = process holding the thread
      victim = thread to kill or NULL for all threads - ONLY call on process shutdown
   <= success or e_failure if something went wrong
*/
kresult thread_kill(process *owner, thread *victim)
{
c040ae54:	56                   	push   %esi
c040ae55:	53                   	push   %ebx
c040ae56:	83 ec 14             	sub    $0x14,%esp
	unsigned int physaddr;
	
	if(!owner) return e_failure;
c040ae59:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040ae5e:	75 0a                	jne    c040ae6a <thread_kill+0x16>
c040ae60:	b8 01 00 00 00       	mov    $0x1,%eax
c040ae65:	e9 8f 02 00 00       	jmp    c040b0f9 <thread_kill+0x2a5>
		
	if(victim)
c040ae6a:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040ae6f:	0f 84 ed 01 00 00    	je     c040b062 <thread_kill+0x20e>
	{
		if(victim->proc != owner) return e_failure;
c040ae75:	8b 44 24 24          	mov    0x24(%esp),%eax
c040ae79:	8b 00                	mov    (%eax),%eax
c040ae7b:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040ae7f:	74 0a                	je     c040ae8b <thread_kill+0x37>
c040ae81:	b8 01 00 00 00       	mov    $0x1,%eax
c040ae86:	e9 6e 02 00 00       	jmp    c040b0f9 <thread_kill+0x2a5>
		
		/* stop this thread from running and lock it */
		if(lock_gate(&(victim->lock), LOCK_WRITE | LOCK_SELFDESTRUCT))
c040ae8b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040ae8f:	83 c0 1c             	add    $0x1c,%eax
c040ae92:	83 ec 08             	sub    $0x8,%esp
c040ae95:	6a 03                	push   $0x3
c040ae97:	50                   	push   %eax
c040ae98:	e8 ee 55 ff ff       	call   c040048b <lock_gate>
c040ae9d:	83 c4 10             	add    $0x10,%esp
c040aea0:	85 c0                	test   %eax,%eax
c040aea2:	74 0a                	je     c040aeae <thread_kill+0x5a>
			return e_failure;
c040aea4:	b8 01 00 00 00       	mov    $0x1,%eax
c040aea9:	e9 4b 02 00 00       	jmp    c040b0f9 <thread_kill+0x2a5>
		
		/* if we can't lock then assume it's this thread that's dying */
		if(sched_lock_thread(victim)) sched_remove(victim, dead);
c040aeae:	83 ec 0c             	sub    $0xc,%esp
c040aeb1:	ff 74 24 30          	pushl  0x30(%esp)
c040aeb5:	e8 58 9b ff ff       	call   c0404a12 <sched_lock_thread>
c040aeba:	83 c4 10             	add    $0x10,%esp
c040aebd:	85 c0                	test   %eax,%eax
c040aebf:	74 11                	je     c040aed2 <thread_kill+0x7e>
c040aec1:	83 ec 08             	sub    $0x8,%esp
c040aec4:	6a 06                	push   $0x6
c040aec6:	ff 74 24 30          	pushl  0x30(%esp)
c040aeca:	e8 72 ab ff ff       	call   c0405a41 <sched_remove>
c040aecf:	83 c4 10             	add    $0x10,%esp
		
		/* free the thread's user stack' physical pages and unset the table entries */
		if(pg_user2phys(&physaddr, owner->pgdir, victim->stackbase - MEM_PGSIZE) == success)
c040aed2:	8b 44 24 24          	mov    0x24(%esp),%eax
c040aed6:	8b 40 2c             	mov    0x2c(%eax),%eax
c040aed9:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
c040aedf:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aee3:	8b 40 20             	mov    0x20(%eax),%eax
c040aee6:	83 ec 04             	sub    $0x4,%esp
c040aee9:	52                   	push   %edx
c040aeea:	50                   	push   %eax
c040aeeb:	8d 44 24 14          	lea    0x14(%esp),%eax
c040aeef:	50                   	push   %eax
c040aef0:	e8 c0 ee ff ff       	call   c0409db5 <pg_user2phys>
c040aef5:	83 c4 10             	add    $0x10,%esp
c040aef8:	85 c0                	test   %eax,%eax
c040aefa:	0f 85 8c 00 00 00    	jne    c040af8c <thread_kill+0x138>
		{
			if(vmm_return_phys_pg((unsigned int *)physaddr) == success)
c040af00:	8b 44 24 08          	mov    0x8(%esp),%eax
c040af04:	83 ec 0c             	sub    $0xc,%esp
c040af07:	50                   	push   %eax
c040af08:	e8 f4 b5 ff ff       	call   c0406501 <vmm_return_phys_pg>
c040af0d:	83 c4 10             	add    $0x10,%esp
c040af10:	85 c0                	test   %eax,%eax
c040af12:	75 24                	jne    c040af38 <thread_kill+0xe4>
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
c040af14:	8b 44 24 24          	mov    0x24(%esp),%eax
c040af18:	8b 40 2c             	mov    0x2c(%eax),%eax
c040af1b:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
c040af21:	8b 44 24 20          	mov    0x20(%esp),%eax
c040af25:	8b 40 20             	mov    0x20(%eax),%eax
c040af28:	6a 00                	push   $0x0
c040af2a:	6a 00                	push   $0x0
c040af2c:	52                   	push   %edx
c040af2d:	50                   	push   %eax
c040af2e:	e8 79 ef ff ff       	call   c0409eac <pg_add_4K_mapping>
c040af33:	83 c4 10             	add    $0x10,%esp
c040af36:	eb 54                	jmp    c040af8c <thread_kill+0x138>
			}
			else
			{
				dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n" DEBUG_COL_OFF
c040af38:	8b 74 24 08          	mov    0x8(%esp),%esi
c040af3c:	8b 44 24 24          	mov    0x24(%esp),%eax
c040af40:	8b 58 2c             	mov    0x2c(%eax),%ebx
c040af43:	8b 44 24 20          	mov    0x20(%esp),%eax
c040af47:	8b 08                	mov    (%eax),%ecx
c040af49:	8b 44 24 24          	mov    0x24(%esp),%eax
c040af4d:	8b 50 04             	mov    0x4(%eax),%edx
						  "            thread %i (%p) process %i (%p) usr %x phys %x\n" DEBUG_COL_OFF,
						  CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
c040af50:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
			}
			else
			{
				dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n" DEBUG_COL_OFF
c040af55:	3c 01                	cmp    $0x1,%al
c040af57:	76 0c                	jbe    c040af65 <thread_kill+0x111>
						  "            thread %i (%p) process %i (%p) usr %x phys %x\n" DEBUG_COL_OFF,
						  CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
c040af59:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040af5e:	8b 00                	mov    (%eax),%eax
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
			}
			else
			{
				dprintf(DEBUG_COL_THREAD "[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n" DEBUG_COL_OFF
c040af60:	c1 e8 18             	shr    $0x18,%eax
c040af63:	eb 08                	jmp    c040af6d <thread_kill+0x119>
c040af65:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040af6a:	0f b6 c0             	movzbl %al,%eax
c040af6d:	56                   	push   %esi
c040af6e:	53                   	push   %ebx
c040af6f:	ff 74 24 28          	pushl  0x28(%esp)
c040af73:	51                   	push   %ecx
c040af74:	ff 74 24 34          	pushl  0x34(%esp)
c040af78:	52                   	push   %edx
c040af79:	50                   	push   %eax
c040af7a:	68 50 f7 40 c0       	push   $0xc040f750
c040af7f:	e8 d2 24 00 00       	call   c040d456 <debug_printf>
c040af84:	83 c4 20             	add    $0x20,%esp
						  "            thread %i (%p) process %i (%p) usr %x phys %x\n" DEBUG_COL_OFF,
						  CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
				debug_stacktrace();
c040af87:	e8 e7 1d 00 00       	call   c040cd73 <debug_stacktrace>
			}
		}

		/* unlink thread from the process's thread hash table */
	  lock_gate(&(owner->lock), LOCK_WRITE);
c040af8c:	8b 44 24 20          	mov    0x20(%esp),%eax
c040af90:	83 c0 10             	add    $0x10,%eax
c040af93:	83 ec 08             	sub    $0x8,%esp
c040af96:	6a 01                	push   $0x1
c040af98:	50                   	push   %eax
c040af99:	e8 ed 54 ff ff       	call   c040048b <lock_gate>
c040af9e:	83 c4 10             	add    $0x10,%esp
					  
	  if(victim->hash_next)
c040afa1:	8b 44 24 24          	mov    0x24(%esp),%eax
c040afa5:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040afab:	85 c0                	test   %eax,%eax
c040afad:	74 1a                	je     c040afc9 <thread_kill+0x175>
			victim->hash_next->hash_prev = victim->hash_prev;
c040afaf:	8b 44 24 24          	mov    0x24(%esp),%eax
c040afb3:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040afb9:	8b 54 24 24          	mov    0x24(%esp),%edx
c040afbd:	8b 92 e8 00 00 00    	mov    0xe8(%edx),%edx
c040afc3:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
	  if(victim->hash_prev)
c040afc9:	8b 44 24 24          	mov    0x24(%esp),%eax
c040afcd:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
c040afd3:	85 c0                	test   %eax,%eax
c040afd5:	74 1c                	je     c040aff3 <thread_kill+0x19f>
			victim->hash_prev->hash_next = victim->hash_next;
c040afd7:	8b 44 24 24          	mov    0x24(%esp),%eax
c040afdb:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
c040afe1:	8b 54 24 24          	mov    0x24(%esp),%edx
c040afe5:	8b 92 ec 00 00 00    	mov    0xec(%edx),%edx
c040afeb:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c040aff1:	eb 22                	jmp    c040b015 <thread_kill+0x1c1>
	  else
	  /* we were the hash table entry head, so fixup table */
			owner->threads[victim->tid % THREAD_HASH_BUCKETS] = victim->hash_next;
c040aff3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040aff7:	8b 50 38             	mov    0x38(%eax),%edx
c040affa:	8b 44 24 24          	mov    0x24(%esp),%eax
c040affe:	8b 40 04             	mov    0x4(%eax),%eax
c040b001:	83 e0 3f             	and    $0x3f,%eax
c040b004:	c1 e0 02             	shl    $0x2,%eax
c040b007:	01 c2                	add    %eax,%edx
c040b009:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b00d:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040b013:	89 02                	mov    %eax,(%edx)

		owner->thread_count--;
c040b015:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b019:	8b 40 3c             	mov    0x3c(%eax),%eax
c040b01c:	8d 50 ff             	lea    -0x1(%eax),%edx
c040b01f:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b023:	89 50 3c             	mov    %edx,0x3c(%eax)
		unlock_gate(&(owner->lock), LOCK_WRITE);
c040b026:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b02a:	83 c0 10             	add    $0x10,%eax
c040b02d:	83 ec 08             	sub    $0x8,%esp
c040b030:	6a 01                	push   $0x1
c040b032:	50                   	push   %eax
c040b033:	e8 70 56 ff ff       	call   c04006a8 <unlock_gate>
c040b038:	83 c4 10             	add    $0x10,%esp
		
		/* free up resources */
		vmm_free((void *)(victim->kstackblk));
c040b03b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b03f:	8b 40 34             	mov    0x34(%eax),%eax
c040b042:	83 ec 0c             	sub    $0xc,%esp
c040b045:	50                   	push   %eax
c040b046:	e8 87 b2 ff ff       	call   c04062d2 <vmm_free>
c040b04b:	83 c4 10             	add    $0x10,%esp
		vmm_free(victim);
c040b04e:	83 ec 0c             	sub    $0xc,%esp
c040b051:	ff 74 24 30          	pushl  0x30(%esp)
c040b055:	e8 78 b2 ff ff       	call   c04062d2 <vmm_free>
c040b05a:	83 c4 10             	add    $0x10,%esp
c040b05d:	e9 92 00 00 00       	jmp    c040b0f4 <thread_kill+0x2a0>
	else
	{
		/* destroy all threads one-by-one */
		unsigned int loop;
		
		lock_gate(&(owner->lock), LOCK_WRITE);
c040b062:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b066:	83 c0 10             	add    $0x10,%eax
c040b069:	83 ec 08             	sub    $0x8,%esp
c040b06c:	6a 01                	push   $0x1
c040b06e:	50                   	push   %eax
c040b06f:	e8 17 54 ff ff       	call   c040048b <lock_gate>
c040b074:	83 c4 10             	add    $0x10,%esp
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c040b077:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b07e:	00 
c040b07f:	eb 44                	jmp    c040b0c5 <thread_kill+0x271>
		{
			victim = owner->threads[loop];
c040b081:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b085:	8b 40 38             	mov    0x38(%eax),%eax
c040b088:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b08c:	c1 e2 02             	shl    $0x2,%edx
c040b08f:	01 d0                	add    %edx,%eax
c040b091:	8b 00                	mov    (%eax),%eax
c040b093:	89 44 24 24          	mov    %eax,0x24(%esp)
			
			while(victim)
c040b097:	eb 21                	jmp    c040b0ba <thread_kill+0x266>
			{
				thread_kill(owner, victim);
c040b099:	83 ec 08             	sub    $0x8,%esp
c040b09c:	ff 74 24 2c          	pushl  0x2c(%esp)
c040b0a0:	ff 74 24 2c          	pushl  0x2c(%esp)
c040b0a4:	e8 ab fd ff ff       	call   c040ae54 <thread_kill>
c040b0a9:	83 c4 10             	add    $0x10,%esp
				victim = victim->hash_next;
c040b0ac:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b0b0:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c040b0b6:	89 44 24 24          	mov    %eax,0x24(%esp)
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
		{
			victim = owner->threads[loop];
			
			while(victim)
c040b0ba:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040b0bf:	75 d8                	jne    c040b099 <thread_kill+0x245>
		/* destroy all threads one-by-one */
		unsigned int loop;
		
		lock_gate(&(owner->lock), LOCK_WRITE);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c040b0c1:	ff 44 24 0c          	incl   0xc(%esp)
c040b0c5:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
c040b0ca:	76 b5                	jbe    c040b081 <thread_kill+0x22d>
				victim = victim->hash_next;
			}
		}
		
		/* release the thread hash table */
		vmm_free(owner->threads);
c040b0cc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b0d0:	8b 40 38             	mov    0x38(%eax),%eax
c040b0d3:	83 ec 0c             	sub    $0xc,%esp
c040b0d6:	50                   	push   %eax
c040b0d7:	e8 f6 b1 ff ff       	call   c04062d2 <vmm_free>
c040b0dc:	83 c4 10             	add    $0x10,%esp
		
		unlock_gate(&(owner->lock), LOCK_WRITE);
c040b0df:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b0e3:	83 c0 10             	add    $0x10,%eax
c040b0e6:	83 ec 08             	sub    $0x8,%esp
c040b0e9:	6a 01                	push   $0x1
c040b0eb:	50                   	push   %eax
c040b0ec:	e8 b7 55 ff ff       	call   c04006a8 <unlock_gate>
c040b0f1:	83 c4 10             	add    $0x10,%esp
	}
	
	return success;
c040b0f4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b0f9:	83 c4 14             	add    $0x14,%esp
c040b0fc:	5b                   	pop    %ebx
c040b0fd:	5e                   	pop    %esi
c040b0fe:	c3                   	ret    
	...

c040b100 <proc_find_proc>:
rw_gate proc_lock;

/* proc_find_proc
	<= return a pointer to a process that matches the given pid, or NULL for failure */
process *proc_find_proc(unsigned int pid)
{
c040b100:	83 ec 1c             	sub    $0x1c,%esp
	process *search;
	unsigned int hash = pid % PROC_HASH_BUCKETS;
c040b103:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b107:	83 e0 7f             	and    $0x7f,%eax
c040b10a:	89 44 24 0c          	mov    %eax,0xc(%esp)

	lock_gate(&proc_lock, LOCK_READ);
c040b10e:	83 ec 08             	sub    $0x8,%esp
c040b111:	6a 00                	push   $0x0
c040b113:	68 ac 18 41 c0       	push   $0xc04118ac
c040b118:	e8 6e 53 ff ff       	call   c040048b <lock_gate>
c040b11d:	83 c4 10             	add    $0x10,%esp
	
	search = proc_table[hash];
c040b120:	a1 e0 38 41 c0       	mov    0xc04138e0,%eax
c040b125:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b129:	c1 e2 02             	shl    $0x2,%edx
c040b12c:	01 d0                	add    %edx,%eax
c040b12e:	8b 00                	mov    (%eax),%eax
c040b130:	89 44 24 08          	mov    %eax,0x8(%esp)
	while(search)
c040b134:	eb 2f                	jmp    c040b165 <proc_find_proc+0x65>
	{
		if(search->pid == pid)
c040b136:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b13a:	8b 00                	mov    (%eax),%eax
c040b13c:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040b140:	75 18                	jne    c040b15a <proc_find_proc+0x5a>
		{
			unlock_gate(&proc_lock, LOCK_READ);
c040b142:	83 ec 08             	sub    $0x8,%esp
c040b145:	6a 00                	push   $0x0
c040b147:	68 ac 18 41 c0       	push   $0xc04118ac
c040b14c:	e8 57 55 ff ff       	call   c04006a8 <unlock_gate>
c040b151:	83 c4 10             	add    $0x10,%esp
			return search; /* foundya */
c040b154:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b158:	eb 29                	jmp    c040b183 <proc_find_proc+0x83>
		}
			
		search = search->hash_next;
c040b15a:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b15e:	8b 40 28             	mov    0x28(%eax),%eax
c040b161:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int hash = pid % PROC_HASH_BUCKETS;

	lock_gate(&proc_lock, LOCK_READ);
	
	search = proc_table[hash];
	while(search)
c040b165:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c040b16a:	75 ca                	jne    c040b136 <proc_find_proc+0x36>
		}
			
		search = search->hash_next;
	}

	unlock_gate(&proc_lock, LOCK_READ);
c040b16c:	83 ec 08             	sub    $0x8,%esp
c040b16f:	6a 00                	push   $0x0
c040b171:	68 ac 18 41 c0       	push   $0xc04118ac
c040b176:	e8 2d 55 ff ff       	call   c04006a8 <unlock_gate>
c040b17b:	83 c4 10             	add    $0x10,%esp
	return NULL; /* not found! */
c040b17e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b183:	83 c4 1c             	add    $0x1c,%esp
c040b186:	c3                   	ret    

c040b187 <proc_is_child>:
   <= success if child is a descdenant of parent
		e_not_found if the child couldn't be found
      e_failure if parameters are invalid
*/
kresult proc_is_child(process *parent, process *child)
{
c040b187:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int loop;
	
	/* sanity check.. */
	if(!parent || !child) return e_failure;
c040b18a:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040b18f:	74 07                	je     c040b198 <proc_is_child+0x11>
c040b191:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040b196:	75 0a                	jne    c040b1a2 <proc_is_child+0x1b>
c040b198:	b8 01 00 00 00       	mov    $0x1,%eax
c040b19d:	e9 89 00 00 00       	jmp    c040b22b <proc_is_child+0xa4>
	
	if(lock_gate(&(parent->lock), LOCK_READ))
c040b1a2:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b1a6:	83 c0 10             	add    $0x10,%eax
c040b1a9:	83 ec 08             	sub    $0x8,%esp
c040b1ac:	6a 00                	push   $0x0
c040b1ae:	50                   	push   %eax
c040b1af:	e8 d7 52 ff ff       	call   c040048b <lock_gate>
c040b1b4:	83 c4 10             	add    $0x10,%esp
c040b1b7:	85 c0                	test   %eax,%eax
c040b1b9:	74 07                	je     c040b1c2 <proc_is_child+0x3b>
		return e_failure;
c040b1bb:	b8 01 00 00 00       	mov    $0x1,%eax
c040b1c0:	eb 69                	jmp    c040b22b <proc_is_child+0xa4>
	
	/* check the child on the parent's child list */
	for(loop = 0; loop < parent->child_list_size; loop++)
c040b1c2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b1c9:	00 
c040b1ca:	eb 38                	jmp    c040b204 <proc_is_child+0x7d>
		if(parent->children[loop] == child)
c040b1cc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b1d0:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b1d3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b1d7:	c1 e2 02             	shl    $0x2,%edx
c040b1da:	01 d0                	add    %edx,%eax
c040b1dc:	8b 00                	mov    (%eax),%eax
c040b1de:	3b 44 24 24          	cmp    0x24(%esp),%eax
c040b1e2:	75 1c                	jne    c040b200 <proc_is_child+0x79>
		{
			unlock_gate(&(parent->lock), LOCK_READ);
c040b1e4:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b1e8:	83 c0 10             	add    $0x10,%eax
c040b1eb:	83 ec 08             	sub    $0x8,%esp
c040b1ee:	6a 00                	push   $0x0
c040b1f0:	50                   	push   %eax
c040b1f1:	e8 b2 54 ff ff       	call   c04006a8 <unlock_gate>
c040b1f6:	83 c4 10             	add    $0x10,%esp
			return success;
c040b1f9:	b8 00 00 00 00       	mov    $0x0,%eax
c040b1fe:	eb 2b                	jmp    c040b22b <proc_is_child+0xa4>
	
	if(lock_gate(&(parent->lock), LOCK_READ))
		return e_failure;
	
	/* check the child on the parent's child list */
	for(loop = 0; loop < parent->child_list_size; loop++)
c040b200:	ff 44 24 0c          	incl   0xc(%esp)
c040b204:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b208:	8b 40 30             	mov    0x30(%eax),%eax
c040b20b:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040b20f:	77 bb                	ja     c040b1cc <proc_is_child+0x45>
		{
			unlock_gate(&(parent->lock), LOCK_READ);
			return success;
		}

	unlock_gate(&(parent->lock), LOCK_READ);
c040b211:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b215:	83 c0 10             	add    $0x10,%eax
c040b218:	83 ec 08             	sub    $0x8,%esp
c040b21b:	6a 00                	push   $0x0
c040b21d:	50                   	push   %eax
c040b21e:	e8 85 54 ff ff       	call   c04006a8 <unlock_gate>
c040b223:	83 c4 10             	add    $0x10,%esp
	return e_not_found;
c040b226:	b8 02 00 00 00       	mov    $0x2,%eax
}
c040b22b:	83 c4 1c             	add    $0x1c,%esp
c040b22e:	c3                   	ret    

c040b22f <proc_attach_child>:
   Add a child process to a parent's table
   => parent and child = pointers to relevant process structures
   <= success or e_failure if something went wrong
*/
kresult proc_attach_child(process *parent, process *child)
{
c040b22f:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int child_loop;
	
	if(lock_gate(&(parent->lock), LOCK_WRITE))
c040b232:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b236:	83 c0 10             	add    $0x10,%eax
c040b239:	83 ec 08             	sub    $0x8,%esp
c040b23c:	6a 01                	push   $0x1
c040b23e:	50                   	push   %eax
c040b23f:	e8 47 52 ff ff       	call   c040048b <lock_gate>
c040b244:	83 c4 10             	add    $0x10,%esp
c040b247:	85 c0                	test   %eax,%eax
c040b249:	74 0a                	je     c040b255 <proc_attach_child+0x26>
		return e_failure;
c040b24b:	b8 01 00 00 00       	mov    $0x1,%eax
c040b250:	e9 c6 01 00 00       	jmp    c040b41b <proc_attach_child+0x1ec>
	if(lock_gate(&(child->lock), LOCK_READ))
c040b255:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b259:	83 c0 10             	add    $0x10,%eax
c040b25c:	83 ec 08             	sub    $0x8,%esp
c040b25f:	6a 00                	push   $0x0
c040b261:	50                   	push   %eax
c040b262:	e8 24 52 ff ff       	call   c040048b <lock_gate>
c040b267:	83 c4 10             	add    $0x10,%esp
c040b26a:	85 c0                	test   %eax,%eax
c040b26c:	74 1f                	je     c040b28d <proc_attach_child+0x5e>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
c040b26e:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b272:	83 c0 10             	add    $0x10,%eax
c040b275:	83 ec 08             	sub    $0x8,%esp
c040b278:	6a 01                	push   $0x1
c040b27a:	50                   	push   %eax
c040b27b:	e8 28 54 ff ff       	call   c04006a8 <unlock_gate>
c040b280:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040b283:	b8 01 00 00 00       	mov    $0x1,%eax
c040b288:	e9 8e 01 00 00       	jmp    c040b41b <proc_attach_child+0x1ec>
	}
	
	/* add to the list of children - is the list big enough? */
	if(parent->child_count >= parent->child_list_size)
c040b28d:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b291:	8b 50 34             	mov    0x34(%eax),%edx
c040b294:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b298:	8b 40 30             	mov    0x30(%eax),%eax
c040b29b:	39 c2                	cmp    %eax,%edx
c040b29d:	0f 82 e1 00 00 00    	jb     c040b384 <proc_attach_child+0x155>
	{
		process **new_list;
		/* we need to grow the list size */
		unsigned int new_size = parent->child_list_size * 2;
c040b2a3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b2a7:	8b 40 30             	mov    0x30(%eax),%eax
c040b2aa:	d1 e0                	shl    %eax
c040b2ac:	89 44 24 0c          	mov    %eax,0xc(%esp)
		
		if(!new_size) new_size = 64; /* initial size */
c040b2b0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040b2b5:	75 08                	jne    c040b2bf <proc_attach_child+0x90>
c040b2b7:	c7 44 24 0c 40 00 00 	movl   $0x40,0xc(%esp)
c040b2be:	00 
		if(vmm_malloc((void **)&new_list, new_size * sizeof(process *)))
c040b2bf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040b2c3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040b2ca:	8d 44 24 04          	lea    0x4(%esp),%eax
c040b2ce:	83 ec 08             	sub    $0x8,%esp
c040b2d1:	52                   	push   %edx
c040b2d2:	50                   	push   %eax
c040b2d3:	e8 b8 ab ff ff       	call   c0405e90 <vmm_malloc>
c040b2d8:	83 c4 10             	add    $0x10,%esp
c040b2db:	85 c0                	test   %eax,%eax
c040b2dd:	74 34                	je     c040b313 <proc_attach_child+0xe4>
		{
			unlock_gate(&(child->lock), LOCK_READ);
c040b2df:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b2e3:	83 c0 10             	add    $0x10,%eax
c040b2e6:	83 ec 08             	sub    $0x8,%esp
c040b2e9:	6a 00                	push   $0x0
c040b2eb:	50                   	push   %eax
c040b2ec:	e8 b7 53 ff ff       	call   c04006a8 <unlock_gate>
c040b2f1:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(parent->lock), LOCK_WRITE);
c040b2f4:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b2f8:	83 c0 10             	add    $0x10,%eax
c040b2fb:	83 ec 08             	sub    $0x8,%esp
c040b2fe:	6a 01                	push   $0x1
c040b300:	50                   	push   %eax
c040b301:	e8 a2 53 ff ff       	call   c04006a8 <unlock_gate>
c040b306:	83 c4 10             	add    $0x10,%esp
			return e_failure; /* bail out of malloc fails! */
c040b309:	b8 01 00 00 00       	mov    $0x1,%eax
c040b30e:	e9 08 01 00 00       	jmp    c040b41b <proc_attach_child+0x1ec>
		}
		
		vmm_memset(new_list, 0, new_size); /* clean the new list */
c040b313:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b317:	83 ec 04             	sub    $0x4,%esp
c040b31a:	ff 74 24 10          	pushl  0x10(%esp)
c040b31e:	6a 00                	push   $0x0
c040b320:	50                   	push   %eax
c040b321:	e8 c0 b9 ff ff       	call   c0406ce6 <vmm_memset>
c040b326:	83 c4 10             	add    $0x10,%esp
		
		if(parent->children)
c040b329:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b32d:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b330:	85 c0                	test   %eax,%eax
c040b332:	74 3a                	je     c040b36e <proc_attach_child+0x13f>
		{
			/* copy over the previous list */
			vmm_memcpy(new_list, parent->children, 
c040b334:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b338:	8b 40 30             	mov    0x30(%eax),%eax
						  parent->child_list_size * sizeof(process *));
c040b33b:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
		vmm_memset(new_list, 0, new_size); /* clean the new list */
		
		if(parent->children)
		{
			/* copy over the previous list */
			vmm_memcpy(new_list, parent->children, 
c040b342:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b346:	8b 50 2c             	mov    0x2c(%eax),%edx
c040b349:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b34d:	83 ec 04             	sub    $0x4,%esp
c040b350:	51                   	push   %ecx
c040b351:	52                   	push   %edx
c040b352:	50                   	push   %eax
c040b353:	e8 cb b9 ff ff       	call   c0406d23 <vmm_memcpy>
c040b358:	83 c4 10             	add    $0x10,%esp
						  parent->child_list_size * sizeof(process *));
			vmm_free(parent->children); /* free the old list */
c040b35b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b35f:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b362:	83 ec 0c             	sub    $0xc,%esp
c040b365:	50                   	push   %eax
c040b366:	e8 67 af ff ff       	call   c04062d2 <vmm_free>
c040b36b:	83 c4 10             	add    $0x10,%esp
		}
		
		/* update the list's accounting */
		parent->children = new_list;
c040b36e:	8b 54 24 04          	mov    0x4(%esp),%edx
c040b372:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b376:	89 50 2c             	mov    %edx,0x2c(%eax)
		parent->child_list_size = new_size;
c040b379:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b37d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b381:	89 50 30             	mov    %edx,0x30(%eax)
	}
	
	/* find an empty slot and insert the new child's pointer */
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c040b384:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040b38b:	00 
c040b38c:	eb 51                	jmp    c040b3df <proc_attach_child+0x1b0>
		if(parent->children[child_loop] == NULL)
c040b38e:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b392:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b395:	8b 54 24 08          	mov    0x8(%esp),%edx
c040b399:	c1 e2 02             	shl    $0x2,%edx
c040b39c:	01 d0                	add    %edx,%eax
c040b39e:	8b 00                	mov    (%eax),%eax
c040b3a0:	85 c0                	test   %eax,%eax
c040b3a2:	75 37                	jne    c040b3db <proc_attach_child+0x1ac>
		{
			/* found a free slot, write in the new child's pointer */
			parent->children[child_loop] = child;
c040b3a4:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3a8:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b3ab:	8b 54 24 08          	mov    0x8(%esp),%edx
c040b3af:	c1 e2 02             	shl    $0x2,%edx
c040b3b2:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040b3b5:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b3b9:	89 02                	mov    %eax,(%edx)
			parent->child_count++;
c040b3bb:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3bf:	8b 40 34             	mov    0x34(%eax),%eax
c040b3c2:	8d 50 01             	lea    0x1(%eax),%edx
c040b3c5:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3c9:	89 50 34             	mov    %edx,0x34(%eax)
			child->parentpid = parent->pid;
c040b3cc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3d0:	8b 10                	mov    (%eax),%edx
c040b3d2:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b3d6:	89 50 04             	mov    %edx,0x4(%eax)
			break;
c040b3d9:	eb 11                	jmp    c040b3ec <proc_attach_child+0x1bd>
		parent->children = new_list;
		parent->child_list_size = new_size;
	}
	
	/* find an empty slot and insert the new child's pointer */
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c040b3db:	ff 44 24 08          	incl   0x8(%esp)
c040b3df:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3e3:	8b 40 30             	mov    0x30(%eax),%eax
c040b3e6:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040b3ea:	77 a2                	ja     c040b38e <proc_attach_child+0x15f>
			parent->child_count++;
			child->parentpid = parent->pid;
			break;
		}
	
	unlock_gate(&(child->lock), LOCK_READ);
c040b3ec:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b3f0:	83 c0 10             	add    $0x10,%eax
c040b3f3:	83 ec 08             	sub    $0x8,%esp
c040b3f6:	6a 00                	push   $0x0
c040b3f8:	50                   	push   %eax
c040b3f9:	e8 aa 52 ff ff       	call   c04006a8 <unlock_gate>
c040b3fe:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(parent->lock), LOCK_WRITE);
c040b401:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b405:	83 c0 10             	add    $0x10,%eax
c040b408:	83 ec 08             	sub    $0x8,%esp
c040b40b:	6a 01                	push   $0x1
c040b40d:	50                   	push   %eax
c040b40e:	e8 95 52 ff ff       	call   c04006a8 <unlock_gate>
c040b413:	83 c4 10             	add    $0x10,%esp
	return success;
c040b416:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b41b:	83 c4 1c             	add    $0x1c,%esp
c040b41e:	c3                   	ret    

c040b41f <proc_remove_child>:

/* proc_remove_child
	Take a child off a process's list */
kresult proc_remove_child(process *parent, process *child)
{
c040b41f:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int child_loop;
	
	if(lock_gate(&(parent->lock), LOCK_WRITE))
c040b422:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b426:	83 c0 10             	add    $0x10,%eax
c040b429:	83 ec 08             	sub    $0x8,%esp
c040b42c:	6a 01                	push   $0x1
c040b42e:	50                   	push   %eax
c040b42f:	e8 57 50 ff ff       	call   c040048b <lock_gate>
c040b434:	83 c4 10             	add    $0x10,%esp
c040b437:	85 c0                	test   %eax,%eax
c040b439:	74 0a                	je     c040b445 <proc_remove_child+0x26>
		return e_failure;
c040b43b:	b8 01 00 00 00       	mov    $0x1,%eax
c040b440:	e9 ce 00 00 00       	jmp    c040b513 <proc_remove_child+0xf4>
	if(lock_gate(&(child->lock), LOCK_READ))
c040b445:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b449:	83 c0 10             	add    $0x10,%eax
c040b44c:	83 ec 08             	sub    $0x8,%esp
c040b44f:	6a 00                	push   $0x0
c040b451:	50                   	push   %eax
c040b452:	e8 34 50 ff ff       	call   c040048b <lock_gate>
c040b457:	83 c4 10             	add    $0x10,%esp
c040b45a:	85 c0                	test   %eax,%eax
c040b45c:	74 1f                	je     c040b47d <proc_remove_child+0x5e>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
c040b45e:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b462:	83 c0 10             	add    $0x10,%eax
c040b465:	83 ec 08             	sub    $0x8,%esp
c040b468:	6a 01                	push   $0x1
c040b46a:	50                   	push   %eax
c040b46b:	e8 38 52 ff ff       	call   c04006a8 <unlock_gate>
c040b470:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040b473:	b8 01 00 00 00       	mov    $0x1,%eax
c040b478:	e9 96 00 00 00       	jmp    c040b513 <proc_remove_child+0xf4>
	}
	
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c040b47d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b484:	00 
c040b485:	eb 50                	jmp    c040b4d7 <proc_remove_child+0xb8>
		if(parent->children[child_loop] == child)
c040b487:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b48b:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b48e:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b492:	c1 e2 02             	shl    $0x2,%edx
c040b495:	01 d0                	add    %edx,%eax
c040b497:	8b 00                	mov    (%eax),%eax
c040b499:	3b 44 24 24          	cmp    0x24(%esp),%eax
c040b49d:	75 34                	jne    c040b4d3 <proc_remove_child+0xb4>
		{
			/* found a free slot, write in the new child's pointer */
			parent->children[child_loop] = NULL;
c040b49f:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b4a3:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b4a6:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040b4aa:	c1 e2 02             	shl    $0x2,%edx
c040b4ad:	01 d0                	add    %edx,%eax
c040b4af:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			parent->child_count--;
c040b4b5:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b4b9:	8b 40 34             	mov    0x34(%eax),%eax
c040b4bc:	8d 50 ff             	lea    -0x1(%eax),%edx
c040b4bf:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b4c3:	89 50 34             	mov    %edx,0x34(%eax)
			child->parentpid = 0;
c040b4c6:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b4ca:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			break;
c040b4d1:	eb 11                	jmp    c040b4e4 <proc_remove_child+0xc5>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
		return e_failure;
	}
	
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c040b4d3:	ff 44 24 0c          	incl   0xc(%esp)
c040b4d7:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b4db:	8b 40 30             	mov    0x30(%eax),%eax
c040b4de:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040b4e2:	77 a3                	ja     c040b487 <proc_remove_child+0x68>
			parent->child_count--;
			child->parentpid = 0;
			break;
		}
	
	unlock_gate(&(child->lock), LOCK_READ);
c040b4e4:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b4e8:	83 c0 10             	add    $0x10,%eax
c040b4eb:	83 ec 08             	sub    $0x8,%esp
c040b4ee:	6a 00                	push   $0x0
c040b4f0:	50                   	push   %eax
c040b4f1:	e8 b2 51 ff ff       	call   c04006a8 <unlock_gate>
c040b4f6:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(parent->lock), LOCK_WRITE);
c040b4f9:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b4fd:	83 c0 10             	add    $0x10,%eax
c040b500:	83 ec 08             	sub    $0x8,%esp
c040b503:	6a 01                	push   $0x1
c040b505:	50                   	push   %eax
c040b506:	e8 9d 51 ff ff       	call   c04006a8 <unlock_gate>
c040b50b:	83 c4 10             	add    $0x10,%esp
	return success;
c040b50e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b513:	83 c4 1c             	add    $0x1c,%esp
c040b516:	c3                   	ret    

c040b517 <proc_new>:
		caller = thread that invoked this function or NULL if
               the kernel called to generate a new process
 <= pointer to new process structure, or NULL for failure
*/
process *proc_new(process *current, thread *caller)
{
c040b517:	83 ec 2c             	sub    $0x2c,%esp
	unsigned char pid_free = 0;
c040b51a:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
	process *new = NULL;
c040b51f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040b526:	00 
	unsigned int hash;
	thread *newthread = NULL;
c040b527:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c040b52e:	00 
	kresult err;
	
	/* grab memory to hold the process structure and zero-fill it */
	err = vmm_malloc((void **)&new, sizeof(process));
c040b52f:	8d 44 24 08          	lea    0x8(%esp),%eax
c040b533:	83 ec 08             	sub    $0x8,%esp
c040b536:	6a 60                	push   $0x60
c040b538:	50                   	push   %eax
c040b539:	e8 52 a9 ff ff       	call   c0405e90 <vmm_malloc>
c040b53e:	83 c4 10             	add    $0x10,%esp
c040b541:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(err) return NULL; /* fail if we can't even alloc a process */
c040b545:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c040b54a:	74 0a                	je     c040b556 <proc_new+0x3f>
c040b54c:	b8 00 00 00 00       	mov    $0x0,%eax
c040b551:	e9 7d 03 00 00       	jmp    c040b8d3 <proc_new+0x3bc>

	vmm_memset(new, 0, sizeof(process));
c040b556:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b55a:	83 ec 04             	sub    $0x4,%esp
c040b55d:	6a 60                	push   $0x60
c040b55f:	6a 00                	push   $0x0
c040b561:	50                   	push   %eax
c040b562:	e8 7f b7 ff ff       	call   c0406ce6 <vmm_memset>
c040b567:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&proc_lock, LOCK_WRITE);
c040b56a:	83 ec 08             	sub    $0x8,%esp
c040b56d:	6a 01                	push   $0x1
c040b56f:	68 ac 18 41 c0       	push   $0xc04118ac
c040b574:	e8 12 4f ff ff       	call   c040048b <lock_gate>
c040b579:	83 c4 10             	add    $0x10,%esp
	
	/* give up now if we have too many processes */
	if(proc_count >= PROC_MAX_NR)
c040b57c:	a1 ec 38 41 c0       	mov    0xc04138ec,%eax
c040b581:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040b586:	76 69                	jbe    c040b5f1 <proc_new+0xda>
	{
		unlock_gate(&proc_lock, LOCK_WRITE);
c040b588:	83 ec 08             	sub    $0x8,%esp
c040b58b:	6a 01                	push   $0x1
c040b58d:	68 ac 18 41 c0       	push   $0xc04118ac
c040b592:	e8 11 51 ff ff       	call   c04006a8 <unlock_gate>
c040b597:	83 c4 10             	add    $0x10,%esp
		vmm_free(new);
c040b59a:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b59e:	83 ec 0c             	sub    $0xc,%esp
c040b5a1:	50                   	push   %eax
c040b5a2:	e8 2b ad ff ff       	call   c04062d2 <vmm_free>
c040b5a7:	83 c4 10             	add    $0x10,%esp
		return NULL;
c040b5aa:	b8 00 00 00 00       	mov    $0x0,%eax
c040b5af:	e9 1f 03 00 00       	jmp    c040b8d3 <proc_new+0x3bc>
	}

	/* search for an available PID */
	while(!pid_free)
	{
		if(proc_find_proc(next_pid) == NULL)
c040b5b4:	a1 50 10 41 c0       	mov    0xc0411050,%eax
c040b5b9:	83 ec 0c             	sub    $0xc,%esp
c040b5bc:	50                   	push   %eax
c040b5bd:	e8 3e fb ff ff       	call   c040b100 <proc_find_proc>
c040b5c2:	83 c4 10             	add    $0x10,%esp
c040b5c5:	85 c0                	test   %eax,%eax
c040b5c7:	75 07                	jne    c040b5d0 <proc_new+0xb9>
			pid_free = 1;
c040b5c9:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
c040b5ce:	eb 21                	jmp    c040b5f1 <proc_new+0xda>
		else
		{
			next_pid++;
c040b5d0:	a1 50 10 41 c0       	mov    0xc0411050,%eax
c040b5d5:	40                   	inc    %eax
c040b5d6:	a3 50 10 41 c0       	mov    %eax,0xc0411050
			if(next_pid >= PROC_MAX_NR)
c040b5db:	a1 50 10 41 c0       	mov    0xc0411050,%eax
c040b5e0:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040b5e5:	76 0a                	jbe    c040b5f1 <proc_new+0xda>
				next_pid = FIRST_PID;
c040b5e7:	c7 05 50 10 41 c0 01 	movl   $0x1,0xc0411050
c040b5ee:	00 00 00 
		vmm_free(new);
		return NULL;
	}

	/* search for an available PID */
	while(!pid_free)
c040b5f1:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040b5f6:	74 bc                	je     c040b5b4 <proc_new+0x9d>
				next_pid = FIRST_PID;
		}
	}
		
	/* assign our new PID */
	new->pid = next_pid;
c040b5f8:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b5fc:	8b 15 50 10 41 c0    	mov    0xc0411050,%edx
c040b602:	89 10                	mov    %edx,(%eax)
	next_pid++;
c040b604:	a1 50 10 41 c0       	mov    0xc0411050,%eax
c040b609:	40                   	inc    %eax
c040b60a:	a3 50 10 41 c0       	mov    %eax,0xc0411050
	if(next_pid >= PROC_MAX_NR)
c040b60f:	a1 50 10 41 c0       	mov    0xc0411050,%eax
c040b614:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040b619:	76 0a                	jbe    c040b625 <proc_new+0x10e>
		next_pid = FIRST_PID;
c040b61b:	c7 05 50 10 41 c0 01 	movl   $0x1,0xc0411050
c040b622:	00 00 00 
	
	unlock_gate(&proc_lock, LOCK_WRITE);
c040b625:	83 ec 08             	sub    $0x8,%esp
c040b628:	6a 01                	push   $0x1
c040b62a:	68 ac 18 41 c0       	push   $0xc04118ac
c040b62f:	e8 74 50 ff ff       	call   c04006a8 <unlock_gate>
c040b634:	83 c4 10             	add    $0x10,%esp
	
	/* call the port-specific process creation code, with current=NULL to indicate
	   if we're calling from before userspace has been set up */
	pg_new_process(new, current);	
c040b637:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b63b:	83 ec 08             	sub    $0x8,%esp
c040b63e:	ff 74 24 38          	pushl  0x38(%esp)
c040b642:	50                   	push   %eax
c040b643:	e8 fe e4 ff ff       	call   c0409b46 <pg_new_process>
c040b648:	83 c4 10             	add    $0x10,%esp
	vmm_duplicate_vmas(new, current); /* and clone the vmas */
c040b64b:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b64f:	83 ec 08             	sub    $0x8,%esp
c040b652:	ff 74 24 38          	pushl  0x38(%esp)
c040b656:	50                   	push   %eax
c040b657:	e8 4d db ff ff       	call   c04091a9 <vmm_duplicate_vmas>
c040b65c:	83 c4 10             	add    $0x10,%esp
	
	/* inherit status/details from the parent process */
	if(current)
c040b65f:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040b664:	0f 84 9a 01 00 00    	je     c040b804 <proc_new+0x2ed>
	{
		thread *dupthread;
	
		if(lock_gate(&(current->lock), LOCK_WRITE))
c040b66a:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b66e:	83 c0 10             	add    $0x10,%eax
c040b671:	83 ec 08             	sub    $0x8,%esp
c040b674:	6a 01                	push   $0x1
c040b676:	50                   	push   %eax
c040b677:	e8 0f 4e ff ff       	call   c040048b <lock_gate>
c040b67c:	83 c4 10             	add    $0x10,%esp
c040b67f:	85 c0                	test   %eax,%eax
c040b681:	74 1a                	je     c040b69d <proc_new+0x186>
		{
			vmm_free(new);
c040b683:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b687:	83 ec 0c             	sub    $0xc,%esp
c040b68a:	50                   	push   %eax
c040b68b:	e8 42 ac ff ff       	call   c04062d2 <vmm_free>
c040b690:	83 c4 10             	add    $0x10,%esp
			return NULL;			
c040b693:	b8 00 00 00 00       	mov    $0x0,%eax
c040b698:	e9 36 02 00 00       	jmp    c040b8d3 <proc_new+0x3bc>
		}
		
		new->parentpid   = current->pid;
c040b69d:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6a1:	8b 54 24 30          	mov    0x30(%esp),%edx
c040b6a5:	8b 12                	mov    (%edx),%edx
c040b6a7:	89 50 04             	mov    %edx,0x4(%eax)
		new->flags       = current->flags;
c040b6aa:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6ae:	8b 54 24 30          	mov    0x30(%esp),%edx
c040b6b2:	8a 52 0d             	mov    0xd(%edx),%dl
c040b6b5:	88 50 0d             	mov    %dl,0xd(%eax)
		new->cpu         = current->cpu;
c040b6b8:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6bc:	8b 54 24 30          	mov    0x30(%esp),%edx
c040b6c0:	8a 52 0c             	mov    0xc(%edx),%dl
c040b6c3:	88 50 0c             	mov    %dl,0xc(%eax)
		new->layer		  = current->layer;
c040b6c6:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6ca:	8b 54 24 30          	mov    0x30(%esp),%edx
c040b6ce:	8a 52 50             	mov    0x50(%edx),%dl
c040b6d1:	88 50 50             	mov    %dl,0x50(%eax)
		new->rights		  = current->rights;
c040b6d4:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6d8:	8b 54 24 30          	mov    0x30(%esp),%edx
c040b6dc:	8b 52 4c             	mov    0x4c(%edx),%edx
c040b6df:	89 50 4c             	mov    %edx,0x4c(%eax)
		
		if(proc_attach_child(current, new))
c040b6e2:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b6e6:	83 ec 08             	sub    $0x8,%esp
c040b6e9:	50                   	push   %eax
c040b6ea:	ff 74 24 3c          	pushl  0x3c(%esp)
c040b6ee:	e8 3c fb ff ff       	call   c040b22f <proc_attach_child>
c040b6f3:	83 c4 10             	add    $0x10,%esp
c040b6f6:	85 c0                	test   %eax,%eax
c040b6f8:	74 2f                	je     c040b729 <proc_new+0x212>
		{
			unlock_gate(&(current->lock), LOCK_WRITE);
c040b6fa:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b6fe:	83 c0 10             	add    $0x10,%eax
c040b701:	83 ec 08             	sub    $0x8,%esp
c040b704:	6a 01                	push   $0x1
c040b706:	50                   	push   %eax
c040b707:	e8 9c 4f ff ff       	call   c04006a8 <unlock_gate>
c040b70c:	83 c4 10             	add    $0x10,%esp
			vmm_free(new);
c040b70f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b713:	83 ec 0c             	sub    $0xc,%esp
c040b716:	50                   	push   %eax
c040b717:	e8 b6 ab ff ff       	call   c04062d2 <vmm_free>
c040b71c:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040b71f:	b8 00 00 00 00       	mov    $0x0,%eax
c040b724:	e9 aa 01 00 00       	jmp    c040b8d3 <proc_new+0x3bc>
		}
		
		/* duplicate the running thread */
		if(thread_new_hash(new))
c040b729:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b72d:	83 ec 0c             	sub    $0xc,%esp
c040b730:	50                   	push   %eax
c040b731:	e8 17 f3 ff ff       	call   c040aa4d <thread_new_hash>
c040b736:	83 c4 10             	add    $0x10,%esp
c040b739:	85 c0                	test   %eax,%eax
c040b73b:	74 43                	je     c040b780 <proc_new+0x269>
		{
			proc_remove_child(current, new);
c040b73d:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b741:	83 ec 08             	sub    $0x8,%esp
c040b744:	50                   	push   %eax
c040b745:	ff 74 24 3c          	pushl  0x3c(%esp)
c040b749:	e8 d1 fc ff ff       	call   c040b41f <proc_remove_child>
c040b74e:	83 c4 10             	add    $0x10,%esp
			vmm_free(new); /* tidy up */
c040b751:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b755:	83 ec 0c             	sub    $0xc,%esp
c040b758:	50                   	push   %eax
c040b759:	e8 74 ab ff ff       	call   c04062d2 <vmm_free>
c040b75e:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(current->lock), LOCK_WRITE);
c040b761:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b765:	83 c0 10             	add    $0x10,%eax
c040b768:	83 ec 08             	sub    $0x8,%esp
c040b76b:	6a 01                	push   $0x1
c040b76d:	50                   	push   %eax
c040b76e:	e8 35 4f ff ff       	call   c04006a8 <unlock_gate>
c040b773:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040b776:	b8 00 00 00 00       	mov    $0x0,%eax
c040b77b:	e9 53 01 00 00       	jmp    c040b8d3 <proc_new+0x3bc>
		}
		
		dupthread = thread_duplicate(new, caller);
c040b780:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b784:	83 ec 08             	sub    $0x8,%esp
c040b787:	ff 74 24 3c          	pushl  0x3c(%esp)
c040b78b:	50                   	push   %eax
c040b78c:	e8 a9 ef ff ff       	call   c040a73a <thread_duplicate>
c040b791:	83 c4 10             	add    $0x10,%esp
c040b794:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if(!dupthread)
c040b798:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040b79d:	75 43                	jne    c040b7e2 <proc_new+0x2cb>
		{
			proc_remove_child(current, new);
c040b79f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b7a3:	83 ec 08             	sub    $0x8,%esp
c040b7a6:	50                   	push   %eax
c040b7a7:	ff 74 24 3c          	pushl  0x3c(%esp)
c040b7ab:	e8 6f fc ff ff       	call   c040b41f <proc_remove_child>
c040b7b0:	83 c4 10             	add    $0x10,%esp
			vmm_free(new); /* tidy up */
c040b7b3:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b7b7:	83 ec 0c             	sub    $0xc,%esp
c040b7ba:	50                   	push   %eax
c040b7bb:	e8 12 ab ff ff       	call   c04062d2 <vmm_free>
c040b7c0:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(current->lock), LOCK_WRITE);
c040b7c3:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b7c7:	83 c0 10             	add    $0x10,%eax
c040b7ca:	83 ec 08             	sub    $0x8,%esp
c040b7cd:	6a 01                	push   $0x1
c040b7cf:	50                   	push   %eax
c040b7d0:	e8 d3 4e ff ff       	call   c04006a8 <unlock_gate>
c040b7d5:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040b7d8:	b8 00 00 00 00       	mov    $0x0,%eax
c040b7dd:	e9 f1 00 00 00       	jmp    c040b8d3 <proc_new+0x3bc>
		}
		new->thread_count = 1;
c040b7e2:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b7e6:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		
		unlock_gate(&(current->lock), LOCK_WRITE);
c040b7ed:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b7f1:	83 c0 10             	add    $0x10,%eax
c040b7f4:	83 ec 08             	sub    $0x8,%esp
c040b7f7:	6a 01                	push   $0x1
c040b7f9:	50                   	push   %eax
c040b7fa:	e8 a9 4e ff ff       	call   c04006a8 <unlock_gate>
c040b7ff:	83 c4 10             	add    $0x10,%esp
c040b802:	eb 1f                	jmp    c040b823 <proc_new+0x30c>
	}
	else
	{
		/* initialise the process's hash table of threads and 
		 create a new thread for execution */
		new->next_tid = FIRST_TID;
c040b804:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b808:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)
		newthread = thread_new(new);
c040b80f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b813:	83 ec 0c             	sub    $0xc,%esp
c040b816:	50                   	push   %eax
c040b817:	e8 f9 f2 ff ff       	call   c040ab15 <thread_new>
c040b81c:	83 c4 10             	add    $0x10,%esp
c040b81f:	89 44 24 14          	mov    %eax,0x14(%esp)
	}
	
	/* add the new process to the pid hash table */
	lock_gate(&proc_lock, LOCK_WRITE);
c040b823:	83 ec 08             	sub    $0x8,%esp
c040b826:	6a 01                	push   $0x1
c040b828:	68 ac 18 41 c0       	push   $0xc04118ac
c040b82d:	e8 59 4c ff ff       	call   c040048b <lock_gate>
c040b832:	83 c4 10             	add    $0x10,%esp
	
	hash = new->pid % PROC_HASH_BUCKETS;
c040b835:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b839:	8b 00                	mov    (%eax),%eax
c040b83b:	83 e0 7f             	and    $0x7f,%eax
c040b83e:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(proc_table[hash])
c040b842:	a1 e0 38 41 c0       	mov    0xc04138e0,%eax
c040b847:	8b 54 24 10          	mov    0x10(%esp),%edx
c040b84b:	c1 e2 02             	shl    $0x2,%edx
c040b84e:	01 d0                	add    %edx,%eax
c040b850:	8b 00                	mov    (%eax),%eax
c040b852:	85 c0                	test   %eax,%eax
c040b854:	74 31                	je     c040b887 <proc_new+0x370>
	{
		proc_table[hash]->hash_prev = new;
c040b856:	a1 e0 38 41 c0       	mov    0xc04138e0,%eax
c040b85b:	8b 54 24 10          	mov    0x10(%esp),%edx
c040b85f:	c1 e2 02             	shl    $0x2,%edx
c040b862:	01 d0                	add    %edx,%eax
c040b864:	8b 00                	mov    (%eax),%eax
c040b866:	8b 54 24 08          	mov    0x8(%esp),%edx
c040b86a:	89 50 24             	mov    %edx,0x24(%eax)
		new->hash_next = proc_table[hash];
c040b86d:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b871:	8b 15 e0 38 41 c0    	mov    0xc04138e0,%edx
c040b877:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c040b87b:	c1 e1 02             	shl    $0x2,%ecx
c040b87e:	01 ca                	add    %ecx,%edx
c040b880:	8b 12                	mov    (%edx),%edx
c040b882:	89 50 28             	mov    %edx,0x28(%eax)
c040b885:	eb 0b                	jmp    c040b892 <proc_new+0x37b>
	}
	else
	{
		new->hash_next = NULL;
c040b887:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b88b:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	}
	proc_table[hash] = new;
c040b892:	a1 e0 38 41 c0       	mov    0xc04138e0,%eax
c040b897:	8b 54 24 10          	mov    0x10(%esp),%edx
c040b89b:	c1 e2 02             	shl    $0x2,%edx
c040b89e:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040b8a1:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b8a5:	89 02                	mov    %eax,(%edx)
	new->hash_prev = NULL;
c040b8a7:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b8ab:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	proc_count++;
c040b8b2:	a1 ec 38 41 c0       	mov    0xc04138ec,%eax
c040b8b7:	40                   	inc    %eax
c040b8b8:	a3 ec 38 41 c0       	mov    %eax,0xc04138ec
	unlock_gate(&proc_lock, LOCK_WRITE);
c040b8bd:	83 ec 08             	sub    $0x8,%esp
c040b8c0:	6a 01                	push   $0x1
c040b8c2:	68 ac 18 41 c0       	push   $0xc04118ac
c040b8c7:	e8 dc 4d ff ff       	call   c04006a8 <unlock_gate>
c040b8cc:	83 c4 10             	add    $0x10,%esp
	
#ifdef PROC_DEBUG
	dprintf(DEBUG_COL_PROC "[proc:%i] created new process %i (%p)\n" DEBUG_COL_OFF, CPU_ID, new->pid, new);
#endif
	
	return new;
c040b8cf:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c040b8d3:	83 c4 2c             	add    $0x2c,%esp
c040b8d6:	c3                   	ret    

c040b8d7 <proc_kill>:
   Request to kill the given process
   => victimpid = PID of process to destroy (USER-SUPPLIED)
      slayer    = pointer to process making the request
   <= 0 for success or an error code */
kresult proc_kill(unsigned int victimpid, process *slayer)
{
c040b8d7:	83 ec 1c             	sub    $0x1c,%esp
	process *victim, *parent;
	unsigned int loop;
	
	/* sanity checks */
	if((victimpid > PROC_MAX_NR) || !slayer) return e_failure;
c040b8da:	81 7c 24 20 00 04 00 	cmpl   $0x400,0x20(%esp)
c040b8e1:	00 
c040b8e2:	77 07                	ja     c040b8eb <proc_kill+0x14>
c040b8e4:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c040b8e9:	75 0a                	jne    c040b8f5 <proc_kill+0x1e>
c040b8eb:	b8 01 00 00 00       	mov    $0x1,%eax
c040b8f0:	e9 55 02 00 00       	jmp    c040bb4a <proc_kill+0x273>
	victim = proc_find_proc(victimpid);
c040b8f5:	83 ec 0c             	sub    $0xc,%esp
c040b8f8:	ff 74 24 2c          	pushl  0x2c(%esp)
c040b8fc:	e8 ff f7 ff ff       	call   c040b100 <proc_find_proc>
c040b901:	83 c4 10             	add    $0x10,%esp
c040b904:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(!victim) return e_failure;
c040b908:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c040b90d:	75 0a                	jne    c040b919 <proc_kill+0x42>
c040b90f:	b8 01 00 00 00       	mov    $0x1,%eax
c040b914:	e9 31 02 00 00       	jmp    c040bb4a <proc_kill+0x273>
	
	lock_gate(&(slayer->lock), LOCK_READ);
c040b919:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b91d:	83 c0 10             	add    $0x10,%eax
c040b920:	83 ec 08             	sub    $0x8,%esp
c040b923:	6a 00                	push   $0x0
c040b925:	50                   	push   %eax
c040b926:	e8 60 4b ff ff       	call   c040048b <lock_gate>
c040b92b:	83 c4 10             	add    $0x10,%esp
	
	/* rights checks */
	if(victim->layer > slayer->layer) goto do_proc_kill;
c040b92e:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b932:	8a 50 50             	mov    0x50(%eax),%dl
c040b935:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b939:	8a 40 50             	mov    0x50(%eax),%al
c040b93c:	38 c2                	cmp    %al,%dl
c040b93e:	77 36                	ja     c040b976 <proc_kill+0x9f>
	if(proc_is_child(slayer, victim) != success) goto do_proc_kill;
c040b940:	83 ec 08             	sub    $0x8,%esp
c040b943:	ff 74 24 0c          	pushl  0xc(%esp)
c040b947:	ff 74 24 30          	pushl  0x30(%esp)
c040b94b:	e8 37 f8 ff ff       	call   c040b187 <proc_is_child>
c040b950:	83 c4 10             	add    $0x10,%esp
c040b953:	85 c0                	test   %eax,%eax
c040b955:	75 22                	jne    c040b979 <proc_kill+0xa2>
	
	/* failed to possess the correct rights to kill this victim */
	unlock_gate(&(slayer->lock), LOCK_READ);
c040b957:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b95b:	83 c0 10             	add    $0x10,%eax
c040b95e:	83 ec 08             	sub    $0x8,%esp
c040b961:	6a 00                	push   $0x0
c040b963:	50                   	push   %eax
c040b964:	e8 3f 4d ff ff       	call   c04006a8 <unlock_gate>
c040b969:	83 c4 10             	add    $0x10,%esp
	return e_no_rights;
c040b96c:	b8 06 00 00 00       	mov    $0x6,%eax
c040b971:	e9 d4 01 00 00       	jmp    c040bb4a <proc_kill+0x273>
	if(!victim) return e_failure;
	
	lock_gate(&(slayer->lock), LOCK_READ);
	
	/* rights checks */
	if(victim->layer > slayer->layer) goto do_proc_kill;
c040b976:	90                   	nop
c040b977:	eb 01                	jmp    c040b97a <proc_kill+0xa3>
	if(proc_is_child(slayer, victim) != success) goto do_proc_kill;
c040b979:	90                   	nop
	/* failed to possess the correct rights to kill this victim */
	unlock_gate(&(slayer->lock), LOCK_READ);
	return e_no_rights;
	
do_proc_kill:
	unlock_gate(&(slayer->lock), LOCK_READ);
c040b97a:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b97e:	83 c0 10             	add    $0x10,%eax
c040b981:	83 ec 08             	sub    $0x8,%esp
c040b984:	6a 00                	push   $0x0
c040b986:	50                   	push   %eax
c040b987:	e8 1c 4d ff ff       	call   c04006a8 <unlock_gate>
c040b98c:	83 c4 10             	add    $0x10,%esp
	
	/* we have a green light, so reverse the process creation
	   routines in proc_new() */
	parent = proc_find_proc(victim->parentpid);
c040b98f:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b993:	8b 40 04             	mov    0x4(%eax),%eax
c040b996:	83 ec 0c             	sub    $0xc,%esp
c040b999:	50                   	push   %eax
c040b99a:	e8 61 f7 ff ff       	call   c040b100 <proc_find_proc>
c040b99f:	83 c4 10             	add    $0x10,%esp
c040b9a2:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	/* stop it from running but remember, there's no point
	   unblocking the process we're about to slay */
	if(lock_gate(&(victim->lock), LOCK_WRITE | LOCK_SELFDESTRUCT))
c040b9a6:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b9aa:	83 c0 10             	add    $0x10,%eax
c040b9ad:	83 ec 08             	sub    $0x8,%esp
c040b9b0:	6a 03                	push   $0x3
c040b9b2:	50                   	push   %eax
c040b9b3:	e8 d3 4a ff ff       	call   c040048b <lock_gate>
c040b9b8:	83 c4 10             	add    $0x10,%esp
c040b9bb:	85 c0                	test   %eax,%eax
c040b9bd:	74 0a                	je     c040b9c9 <proc_kill+0xf2>
		return e_failure;
c040b9bf:	b8 01 00 00 00       	mov    $0x1,%eax
c040b9c4:	e9 81 01 00 00       	jmp    c040bb4a <proc_kill+0x273>
	sched_lock_proc(victim);
c040b9c9:	83 ec 0c             	sub    $0xc,%esp
c040b9cc:	ff 74 24 10          	pushl  0x10(%esp)
c040b9d0:	e8 3e 91 ff ff       	call   c0404b13 <sched_lock_proc>
c040b9d5:	83 c4 10             	add    $0x10,%esp
	
	/* victim process is now effectively dead to the system */
	
	/* unlink it from the process table */
	lock_gate(&proc_lock, LOCK_WRITE);
c040b9d8:	83 ec 08             	sub    $0x8,%esp
c040b9db:	6a 01                	push   $0x1
c040b9dd:	68 ac 18 41 c0       	push   $0xc04118ac
c040b9e2:	e8 a4 4a ff ff       	call   c040048b <lock_gate>
c040b9e7:	83 c4 10             	add    $0x10,%esp
	if(victim->hash_next)
c040b9ea:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b9ee:	8b 40 28             	mov    0x28(%eax),%eax
c040b9f1:	85 c0                	test   %eax,%eax
c040b9f3:	74 11                	je     c040ba06 <proc_kill+0x12f>
		victim->hash_next->hash_prev = victim->hash_prev;
c040b9f5:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b9f9:	8b 40 28             	mov    0x28(%eax),%eax
c040b9fc:	8b 54 24 04          	mov    0x4(%esp),%edx
c040ba00:	8b 52 24             	mov    0x24(%edx),%edx
c040ba03:	89 50 24             	mov    %edx,0x24(%eax)
	if(victim->hash_prev)
c040ba06:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba0a:	8b 40 24             	mov    0x24(%eax),%eax
c040ba0d:	85 c0                	test   %eax,%eax
c040ba0f:	74 13                	je     c040ba24 <proc_kill+0x14d>
		victim->hash_prev->hash_next = victim->hash_next;
c040ba11:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba15:	8b 40 24             	mov    0x24(%eax),%eax
c040ba18:	8b 54 24 04          	mov    0x4(%esp),%edx
c040ba1c:	8b 52 28             	mov    0x28(%edx),%edx
c040ba1f:	89 50 28             	mov    %edx,0x28(%eax)
c040ba22:	eb 1d                	jmp    c040ba41 <proc_kill+0x16a>
	else
		/* we were the hash table entry head, so fixup table */
		proc_table[victim->pid % PROC_HASH_BUCKETS] = victim->hash_next;
c040ba24:	8b 15 e0 38 41 c0    	mov    0xc04138e0,%edx
c040ba2a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba2e:	8b 00                	mov    (%eax),%eax
c040ba30:	83 e0 7f             	and    $0x7f,%eax
c040ba33:	c1 e0 02             	shl    $0x2,%eax
c040ba36:	01 c2                	add    %eax,%edx
c040ba38:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba3c:	8b 40 28             	mov    0x28(%eax),%eax
c040ba3f:	89 02                	mov    %eax,(%edx)
	lock_gate(&proc_lock, LOCK_WRITE);
c040ba41:	83 ec 08             	sub    $0x8,%esp
c040ba44:	6a 01                	push   $0x1
c040ba46:	68 ac 18 41 c0       	push   $0xc04118ac
c040ba4b:	e8 3b 4a ff ff       	call   c040048b <lock_gate>
c040ba50:	83 c4 10             	add    $0x10,%esp
	
	/* destroy the threads */
	thread_kill(victim, NULL);
c040ba53:	83 ec 08             	sub    $0x8,%esp
c040ba56:	6a 00                	push   $0x0
c040ba58:	ff 74 24 10          	pushl  0x10(%esp)
c040ba5c:	e8 f3 f3 ff ff       	call   c040ae54 <thread_kill>
c040ba61:	83 c4 10             	add    $0x10,%esp
	
	/* won't someone think of the children? */
	if(victim->children)
c040ba64:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba68:	8b 40 2c             	mov    0x2c(%eax),%eax
c040ba6b:	85 c0                	test   %eax,%eax
c040ba6d:	0f 84 92 00 00 00    	je     c040bb05 <proc_kill+0x22e>
	{
		/* attach the to-be-orphaned children to the system executive process */
		for(loop = 0; loop < victim->child_list_size; loop++)
c040ba73:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040ba7a:	00 
c040ba7b:	eb 68                	jmp    c040bae5 <proc_kill+0x20e>
		{
			if(victim->children[loop])
c040ba7d:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba81:	8b 40 2c             	mov    0x2c(%eax),%eax
c040ba84:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040ba88:	c1 e2 02             	shl    $0x2,%edx
c040ba8b:	01 d0                	add    %edx,%eax
c040ba8d:	8b 00                	mov    (%eax),%eax
c040ba8f:	85 c0                	test   %eax,%eax
c040ba91:	74 4e                	je     c040bae1 <proc_kill+0x20a>
			{
				victim->children[loop]->prevparentpid = victim->children[loop]->parentpid;
c040ba93:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ba97:	8b 40 2c             	mov    0x2c(%eax),%eax
c040ba9a:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040ba9e:	c1 e2 02             	shl    $0x2,%edx
c040baa1:	01 d0                	add    %edx,%eax
c040baa3:	8b 00                	mov    (%eax),%eax
c040baa5:	8b 54 24 04          	mov    0x4(%esp),%edx
c040baa9:	8b 52 2c             	mov    0x2c(%edx),%edx
c040baac:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040bab0:	c1 e1 02             	shl    $0x2,%ecx
c040bab3:	01 ca                	add    %ecx,%edx
c040bab5:	8b 12                	mov    (%edx),%edx
c040bab7:	8b 52 04             	mov    0x4(%edx),%edx
c040baba:	89 50 08             	mov    %edx,0x8(%eax)
				proc_attach_child(proc_sys_executive, victim->children[loop]);
c040babd:	8b 44 24 04          	mov    0x4(%esp),%eax
c040bac1:	8b 40 2c             	mov    0x2c(%eax),%eax
c040bac4:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040bac8:	c1 e2 02             	shl    $0x2,%edx
c040bacb:	01 d0                	add    %edx,%eax
c040bacd:	8b 10                	mov    (%eax),%edx
c040bacf:	a1 e8 38 41 c0       	mov    0xc04138e8,%eax
c040bad4:	83 ec 08             	sub    $0x8,%esp
c040bad7:	52                   	push   %edx
c040bad8:	50                   	push   %eax
c040bad9:	e8 51 f7 ff ff       	call   c040b22f <proc_attach_child>
c040bade:	83 c4 10             	add    $0x10,%esp
	
	/* won't someone think of the children? */
	if(victim->children)
	{
		/* attach the to-be-orphaned children to the system executive process */
		for(loop = 0; loop < victim->child_list_size; loop++)
c040bae1:	ff 44 24 0c          	incl   0xc(%esp)
c040bae5:	8b 44 24 04          	mov    0x4(%esp),%eax
c040bae9:	8b 40 30             	mov    0x30(%eax),%eax
c040baec:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040baf0:	77 8b                	ja     c040ba7d <proc_kill+0x1a6>
				proc_attach_child(proc_sys_executive, victim->children[loop]);
			}
		}
		
		/* and free the table */
		vmm_free(victim->children);
c040baf2:	8b 44 24 04          	mov    0x4(%esp),%eax
c040baf6:	8b 40 2c             	mov    0x2c(%eax),%eax
c040baf9:	83 ec 0c             	sub    $0xc,%esp
c040bafc:	50                   	push   %eax
c040bafd:	e8 d0 a7 ff ff       	call   c04062d2 <vmm_free>
c040bb02:	83 c4 10             	add    $0x10,%esp
	}
	
	/* destroy the architecture-specific part of the process */
	vmm_destroy_vmas(victim); /* unlink the vmas */
c040bb05:	83 ec 0c             	sub    $0xc,%esp
c040bb08:	ff 74 24 10          	pushl  0x10(%esp)
c040bb0c:	e8 65 d7 ff ff       	call   c0409276 <vmm_destroy_vmas>
c040bb11:	83 c4 10             	add    $0x10,%esp
	pg_destroy_process(victim);
c040bb14:	83 ec 0c             	sub    $0xc,%esp
c040bb17:	ff 74 24 10          	pushl  0x10(%esp)
c040bb1b:	e8 76 e1 ff ff       	call   c0409c96 <pg_destroy_process>
c040bb20:	83 c4 10             	add    $0x10,%esp
	
	/* give up the space held by the process structure */
	vmm_free(victim);
c040bb23:	83 ec 0c             	sub    $0xc,%esp
c040bb26:	ff 74 24 10          	pushl  0x10(%esp)
c040bb2a:	e8 a3 a7 ff ff       	call   c04062d2 <vmm_free>
c040bb2f:	83 c4 10             	add    $0x10,%esp
	
	/* don't forget to dispatch a signal to the parent and
	   don't fret if the parent shuns its moment of mourning */
	msg_send_signal(parent, SIGCHLD, 0);
c040bb32:	83 ec 04             	sub    $0x4,%esp
c040bb35:	6a 00                	push   $0x0
c040bb37:	6a 14                	push   $0x14
c040bb39:	ff 74 24 14          	pushl  0x14(%esp)
c040bb3d:	e8 66 86 ff ff       	call   c04041a8 <msg_send_signal>
c040bb42:	83 c4 10             	add    $0x10,%esp
	
#ifdef PROC_DEBUG
	dprintf(DEBUG_COL_PROC "[proc:%i] killed process %i (%p)\n" DEBUG_COL_OFF, CPU_ID, victim->pid, victim);
#endif
	
	return success;
c040bb45:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040bb4a:	83 c4 1c             	add    $0x1c,%esp
c040bb4d:	c3                   	ret    

c040bb4e <proc_initialise>:

kresult proc_initialise(void)
{
c040bb4e:	57                   	push   %edi
c040bb4f:	56                   	push   %esi
c040bb50:	53                   	push   %ebx
c040bb51:	83 ec 60             	sub    $0x60,%esp
   payload_descr payload;
   mb_module_t *module = NULL;
c040bb54:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c040bb5b:	00 
	kresult err;
	unsigned int loop, module_loop;

	/* initialise critical section lock */
	vmm_memset(&proc_lock, 0, sizeof(rw_gate));
c040bb5c:	83 ec 04             	sub    $0x4,%esp
c040bb5f:	6a 10                	push   $0x10
c040bb61:	6a 00                	push   $0x0
c040bb63:	68 ac 18 41 c0       	push   $0xc04118ac
c040bb68:	e8 79 b1 ff ff       	call   c0406ce6 <vmm_memset>
c040bb6d:	83 c4 10             	add    $0x10,%esp
	
	/* initialise proc hash table */
	err = vmm_malloc((void **)&proc_table, sizeof(process *) * PROC_HASH_BUCKETS);
c040bb70:	b8 e0 38 41 c0       	mov    $0xc04138e0,%eax
c040bb75:	83 ec 08             	sub    $0x8,%esp
c040bb78:	68 00 02 00 00       	push   $0x200
c040bb7d:	50                   	push   %eax
c040bb7e:	e8 0d a3 ff ff       	call   c0405e90 <vmm_malloc>
c040bb83:	83 c4 10             	add    $0x10,%esp
c040bb86:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if(err) return err; /* fail if we can't even alloc a process hash table */
c040bb8a:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
c040bb8f:	74 09                	je     c040bb9a <proc_initialise+0x4c>
c040bb91:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040bb95:	e9 9d 03 00 00       	jmp    c040bf37 <proc_initialise+0x3e9>
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
c040bb9a:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
c040bba1:	00 
c040bba2:	eb 18                	jmp    c040bbbc <proc_initialise+0x6e>
		proc_table[loop] = NULL;
c040bba4:	a1 e0 38 41 c0       	mov    0xc04138e0,%eax
c040bba9:	8b 54 24 40          	mov    0x40(%esp),%edx
c040bbad:	c1 e2 02             	shl    $0x2,%edx
c040bbb0:	01 d0                	add    %edx,%eax
c040bbb2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	
	/* initialise proc hash table */
	err = vmm_malloc((void **)&proc_table, sizeof(process *) * PROC_HASH_BUCKETS);
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
c040bbb8:	ff 44 24 40          	incl   0x40(%esp)
c040bbbc:	83 7c 24 40 7f       	cmpl   $0x7f,0x40(%esp)
c040bbc1:	76 e1                	jbe    c040bba4 <proc_initialise+0x56>
		proc_table[loop] = NULL;
	
	dprintf(DEBUG_COL_PROC "[proc:%i] initialised process hash table %p... %i buckets %i max procs\n" DEBUG_COL_OFF,
c040bbc3:	8b 15 e0 38 41 c0    	mov    0xc04138e0,%edx
			  CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
c040bbc9:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
		proc_table[loop] = NULL;
	
	dprintf(DEBUG_COL_PROC "[proc:%i] initialised process hash table %p... %i buckets %i max procs\n" DEBUG_COL_OFF,
c040bbce:	3c 01                	cmp    $0x1,%al
c040bbd0:	76 0c                	jbe    c040bbde <proc_initialise+0x90>
			  CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
c040bbd2:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040bbd7:	8b 00                	mov    (%eax),%eax
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
		proc_table[loop] = NULL;
	
	dprintf(DEBUG_COL_PROC "[proc:%i] initialised process hash table %p... %i buckets %i max procs\n" DEBUG_COL_OFF,
c040bbd9:	c1 e8 18             	shr    $0x18,%eax
c040bbdc:	eb 08                	jmp    c040bbe6 <proc_initialise+0x98>
c040bbde:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040bbe3:	0f b6 c0             	movzbl %al,%eax
c040bbe6:	83 ec 0c             	sub    $0xc,%esp
c040bbe9:	68 00 04 00 00       	push   $0x400
c040bbee:	68 80 00 00 00       	push   $0x80
c040bbf3:	52                   	push   %edx
c040bbf4:	50                   	push   %eax
c040bbf5:	68 d8 f7 40 c0       	push   $0xc040f7d8
c040bbfa:	e8 57 18 00 00       	call   c040d456 <debug_printf>
c040bbff:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
	
	/* get the lowlevel layer initialised before we start the operating system */
	lowlevel_proc_preinit();
c040bc02:	e8 7d 59 ff ff       	call   c0401584 <lowlevel_proc_preinit>
	
   /* turn loaded modules into processes ready to run */
   for(module_loop = 0; module_loop < payload_modulemax; module_loop++)
c040bc07:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
c040bc0e:	00 
c040bc0f:	e9 0f 03 00 00       	jmp    c040bf23 <proc_initialise+0x3d5>
   {		
		process *new = NULL;
c040bc14:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
c040bc1b:	00 
		unsigned int virtual, virtual_top, physical;
		payload_type type;
		
		module = payload_readmodule(module_loop);
c040bc1c:	83 ec 0c             	sub    $0xc,%esp
c040bc1f:	ff 74 24 50          	pushl  0x50(%esp)
c040bc23:	e8 94 0c 00 00       	call   c040c8bc <payload_readmodule>
c040bc28:	83 c4 10             	add    $0x10,%esp
c040bc2b:	89 44 24 38          	mov    %eax,0x38(%esp)
		
		type = payload_parsemodule(module, &payload);
c040bc2f:	83 ec 08             	sub    $0x8,%esp
c040bc32:	8d 44 24 10          	lea    0x10(%esp),%eax
c040bc36:	50                   	push   %eax
c040bc37:	ff 74 24 44          	pushl  0x44(%esp)
c040bc3b:	e8 c5 0c 00 00       	call   c040c905 <payload_parsemodule>
c040bc40:	83 c4 10             	add    $0x10,%esp
c040bc43:	89 44 24 58          	mov    %eax,0x58(%esp)
		
		/* give up if malformed binaries are in the payload */
		if(type == payload_bad)
c040bc47:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
c040bc4c:	75 3c                	jne    c040bc8a <proc_initialise+0x13c>
		{
         dprintf(DEBUG_COL_PROC "[proc:%i] failed to parse payload module at %x !\n" DEBUG_COL_OFF, CPU_ID, module);
c040bc4e:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040bc53:	3c 01                	cmp    $0x1,%al
c040bc55:	76 0c                	jbe    c040bc63 <proc_initialise+0x115>
c040bc57:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040bc5c:	8b 00                	mov    (%eax),%eax
c040bc5e:	c1 e8 18             	shr    $0x18,%eax
c040bc61:	eb 08                	jmp    c040bc6b <proc_initialise+0x11d>
c040bc63:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040bc68:	0f b6 c0             	movzbl %al,%eax
c040bc6b:	83 ec 04             	sub    $0x4,%esp
c040bc6e:	ff 74 24 3c          	pushl  0x3c(%esp)
c040bc72:	50                   	push   %eax
c040bc73:	68 20 f8 40 c0       	push   $0xc040f820
c040bc78:	e8 d9 17 00 00       	call   c040d456 <debug_printf>
c040bc7d:	83 c4 10             	add    $0x10,%esp
			return e_failure;
c040bc80:	b8 01 00 00 00       	mov    $0x1,%eax
c040bc85:	e9 ad 02 00 00       	jmp    c040bf37 <proc_initialise+0x3e9>
		}

		/* create a bare-bones process for an executable in the payload */
		if(type == payload_exe)
c040bc8a:	83 7c 24 58 01       	cmpl   $0x1,0x58(%esp)
c040bc8f:	0f 85 8a 02 00 00    	jne    c040bf1f <proc_initialise+0x3d1>
		{
			new = proc_new(NULL, NULL);
c040bc95:	83 ec 08             	sub    $0x8,%esp
c040bc98:	6a 00                	push   $0x0
c040bc9a:	6a 00                	push   $0x0
c040bc9c:	e8 76 f8 ff ff       	call   c040b517 <proc_new>
c040bca1:	83 c4 10             	add    $0x10,%esp
c040bca4:	89 44 24 48          	mov    %eax,0x48(%esp)
			if(!new) return e_failure; /* bail if we can't start up our modules */
c040bca8:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c040bcad:	75 0a                	jne    c040bcb9 <proc_initialise+0x16b>
c040bcaf:	b8 01 00 00 00       	mov    $0x1,%eax
c040bcb4:	e9 7e 02 00 00       	jmp    c040bf37 <proc_initialise+0x3e9>
			
			/* build page tables for this module */
			dprintf(DEBUG_COL_PROC "[proc:%i] preparing system process '%s'...\n" DEBUG_COL_OFF, CPU_ID, payload.name);
c040bcb9:	8b 54 24 34          	mov    0x34(%esp),%edx
c040bcbd:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040bcc2:	3c 01                	cmp    $0x1,%al
c040bcc4:	76 0c                	jbe    c040bcd2 <proc_initialise+0x184>
c040bcc6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040bccb:	8b 00                	mov    (%eax),%eax
c040bccd:	c1 e8 18             	shr    $0x18,%eax
c040bcd0:	eb 08                	jmp    c040bcda <proc_initialise+0x18c>
c040bcd2:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040bcd7:	0f b6 c0             	movzbl %al,%eax
c040bcda:	83 ec 04             	sub    $0x4,%esp
c040bcdd:	52                   	push   %edx
c040bcde:	50                   	push   %eax
c040bcdf:	68 54 f8 40 c0       	push   $0xc040f854
c040bce4:	e8 6d 17 00 00       	call   c040d456 <debug_printf>
c040bce9:	83 c4 10             	add    $0x10,%esp
			
			if(payload.areas[PAYLOAD_CODE].flags & (PAYLOAD_READ | PAYLOAD_EXECUTE))
c040bcec:	8b 44 24 18          	mov    0x18(%esp),%eax
c040bcf0:	83 e0 03             	and    $0x3,%eax
c040bcf3:	85 c0                	test   %eax,%eax
c040bcf5:	0f 84 a2 00 00 00    	je     c040bd9d <proc_initialise+0x24f>
			{			
				dprintf("       code: entry %p virt %p phys %p size %u memsize %u flags %u\n" DEBUG_COL_OFF, 
c040bcfb:	8b 7c 24 18          	mov    0x18(%esp),%edi
c040bcff:	8b 74 24 14          	mov    0x14(%esp),%esi
c040bd03:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c040bd07:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040bd0b:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bd0f:	8b 44 24 30          	mov    0x30(%esp),%eax
c040bd13:	83 ec 04             	sub    $0x4,%esp
c040bd16:	57                   	push   %edi
c040bd17:	56                   	push   %esi
c040bd18:	53                   	push   %ebx
c040bd19:	51                   	push   %ecx
c040bd1a:	52                   	push   %edx
c040bd1b:	50                   	push   %eax
c040bd1c:	68 80 f8 40 c0       	push   $0xc040f880
c040bd21:	e8 30 17 00 00       	call   c040d456 <debug_printf>
c040bd26:	83 c4 20             	add    $0x20,%esp
						  payload.entry,
						  payload.areas[PAYLOAD_CODE].virtual, payload.areas[PAYLOAD_CODE].physical,
						  payload.areas[PAYLOAD_CODE].size, payload.areas[PAYLOAD_CODE].memsize,
						  payload.areas[PAYLOAD_CODE].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_CODE].virtual;
c040bd29:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bd2d:	89 44 24 4c          	mov    %eax,0x4c(%esp)
				virtual_top = virtual + payload.areas[PAYLOAD_CODE].memsize;
c040bd31:	8b 44 24 14          	mov    0x14(%esp),%eax
c040bd35:	03 44 24 4c          	add    0x4c(%esp),%eax
c040bd39:	89 44 24 50          	mov    %eax,0x50(%esp)
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_CODE].physical);
c040bd3d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040bd41:	05 00 00 00 40       	add    $0x40000000,%eax
c040bd46:	89 44 24 54          	mov    %eax,0x54(%esp)
				while(virtual < virtual_top)
c040bd4a:	eb 2a                	jmp    c040bd76 <proc_initialise+0x228>
				{
					pg_add_4K_mapping(new->pgdir, virtual, physical, PG_PRESENT | PG_PRIVLVL);
c040bd4c:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bd50:	8b 40 20             	mov    0x20(%eax),%eax
c040bd53:	6a 05                	push   $0x5
c040bd55:	ff 74 24 58          	pushl  0x58(%esp)
c040bd59:	ff 74 24 54          	pushl  0x54(%esp)
c040bd5d:	50                   	push   %eax
c040bd5e:	e8 49 e1 ff ff       	call   c0409eac <pg_add_4K_mapping>
c040bd63:	83 c4 10             	add    $0x10,%esp
					virtual += MEM_PGSIZE;
c040bd66:	81 44 24 4c 00 10 00 	addl   $0x1000,0x4c(%esp)
c040bd6d:	00 
					physical += MEM_PGSIZE;
c040bd6e:	81 44 24 54 00 10 00 	addl   $0x1000,0x54(%esp)
c040bd75:	00 
						  payload.areas[PAYLOAD_CODE].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_CODE].virtual;
				virtual_top = virtual + payload.areas[PAYLOAD_CODE].memsize;
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_CODE].physical);
				while(virtual < virtual_top)
c040bd76:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c040bd7a:	3b 44 24 50          	cmp    0x50(%esp),%eax
c040bd7e:	72 cc                	jb     c040bd4c <proc_initialise+0x1fe>
					pg_add_4K_mapping(new->pgdir, virtual, physical, PG_PRESENT | PG_PRIVLVL);
					virtual += MEM_PGSIZE;
					physical += MEM_PGSIZE;
				}
				
				vmm_add_vma(new, (unsigned int)payload.areas[PAYLOAD_CODE].virtual,
c040bd80:	8b 54 24 14          	mov    0x14(%esp),%edx
c040bd84:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bd88:	83 ec 0c             	sub    $0xc,%esp
c040bd8b:	6a 00                	push   $0x0
c040bd8d:	6a 00                	push   $0x0
c040bd8f:	52                   	push   %edx
c040bd90:	50                   	push   %eax
c040bd91:	ff 74 24 64          	pushl  0x64(%esp)
c040bd95:	e8 f9 d2 ff ff       	call   c0409093 <vmm_add_vma>
c040bd9a:	83 c4 20             	add    $0x20,%esp
								payload.areas[PAYLOAD_CODE].memsize, VMA_READABLE, 0);
			}
			if(payload.areas[PAYLOAD_DATA].flags & (PAYLOAD_READ))
c040bd9d:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040bda1:	83 e0 02             	and    $0x2,%eax
c040bda4:	85 c0                	test   %eax,%eax
c040bda6:	0f 84 b7 00 00 00    	je     c040be63 <proc_initialise+0x315>
			{
				unsigned int flags = PG_PRESENT | PG_PRIVLVL;
c040bdac:	c7 44 24 5c 05 00 00 	movl   $0x5,0x5c(%esp)
c040bdb3:	00 
				
				if(payload.areas[PAYLOAD_DATA].flags & PAYLOAD_WRITE)
c040bdb4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040bdb8:	83 e0 04             	and    $0x4,%eax
c040bdbb:	85 c0                	test   %eax,%eax
c040bdbd:	74 05                	je     c040bdc4 <proc_initialise+0x276>
					flags = flags | PG_RW;
c040bdbf:	83 4c 24 5c 02       	orl    $0x2,0x5c(%esp)
				
				dprintf("       data:          virt %p phys %p size %u memsize %u flags %u\n" DEBUG_COL_OFF, 
c040bdc4:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c040bdc8:	8b 5c 24 28          	mov    0x28(%esp),%ebx
c040bdcc:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c040bdd0:	8b 54 24 20          	mov    0x20(%esp),%edx
c040bdd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040bdd8:	83 ec 08             	sub    $0x8,%esp
c040bddb:	56                   	push   %esi
c040bddc:	53                   	push   %ebx
c040bddd:	51                   	push   %ecx
c040bdde:	52                   	push   %edx
c040bddf:	50                   	push   %eax
c040bde0:	68 c4 f8 40 c0       	push   $0xc040f8c4
c040bde5:	e8 6c 16 00 00       	call   c040d456 <debug_printf>
c040bdea:	83 c4 20             	add    $0x20,%esp
						  payload.areas[PAYLOAD_DATA].virtual, payload.areas[PAYLOAD_DATA].physical,
						  payload.areas[PAYLOAD_DATA].size, payload.areas[PAYLOAD_DATA].memsize,
						  payload.areas[PAYLOAD_DATA].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_DATA].virtual;
c040bded:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040bdf1:	89 44 24 4c          	mov    %eax,0x4c(%esp)
				virtual_top = virtual + payload.areas[PAYLOAD_DATA].memsize;
c040bdf5:	8b 44 24 28          	mov    0x28(%esp),%eax
c040bdf9:	03 44 24 4c          	add    0x4c(%esp),%eax
c040bdfd:	89 44 24 50          	mov    %eax,0x50(%esp)
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_DATA].physical);
c040be01:	8b 44 24 20          	mov    0x20(%esp),%eax
c040be05:	05 00 00 00 40       	add    $0x40000000,%eax
c040be0a:	89 44 24 54          	mov    %eax,0x54(%esp)
				while(virtual < virtual_top)
c040be0e:	eb 2c                	jmp    c040be3c <proc_initialise+0x2ee>
				{
					pg_add_4K_mapping(new->pgdir, virtual, physical, flags);
c040be10:	8b 44 24 48          	mov    0x48(%esp),%eax
c040be14:	8b 40 20             	mov    0x20(%eax),%eax
c040be17:	ff 74 24 5c          	pushl  0x5c(%esp)
c040be1b:	ff 74 24 58          	pushl  0x58(%esp)
c040be1f:	ff 74 24 54          	pushl  0x54(%esp)
c040be23:	50                   	push   %eax
c040be24:	e8 83 e0 ff ff       	call   c0409eac <pg_add_4K_mapping>
c040be29:	83 c4 10             	add    $0x10,%esp
					virtual += MEM_PGSIZE;
c040be2c:	81 44 24 4c 00 10 00 	addl   $0x1000,0x4c(%esp)
c040be33:	00 
					physical += MEM_PGSIZE;
c040be34:	81 44 24 54 00 10 00 	addl   $0x1000,0x54(%esp)
c040be3b:	00 
						  payload.areas[PAYLOAD_DATA].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_DATA].virtual;
				virtual_top = virtual + payload.areas[PAYLOAD_DATA].memsize;
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_DATA].physical);
				while(virtual < virtual_top)
c040be3c:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c040be40:	3b 44 24 50          	cmp    0x50(%esp),%eax
c040be44:	72 ca                	jb     c040be10 <proc_initialise+0x2c2>
					pg_add_4K_mapping(new->pgdir, virtual, physical, flags);
					virtual += MEM_PGSIZE;
					physical += MEM_PGSIZE;
				}
				
				vmm_add_vma(new, (unsigned int)payload.areas[PAYLOAD_DATA].virtual,
c040be46:	8b 54 24 28          	mov    0x28(%esp),%edx
c040be4a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040be4e:	83 ec 0c             	sub    $0xc,%esp
c040be51:	6a 00                	push   $0x0
c040be53:	6a 01                	push   $0x1
c040be55:	52                   	push   %edx
c040be56:	50                   	push   %eax
c040be57:	ff 74 24 64          	pushl  0x64(%esp)
c040be5b:	e8 33 d2 ff ff       	call   c0409093 <vmm_add_vma>
c040be60:	83 c4 20             	add    $0x20,%esp
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
c040be63:	8b 44 24 48          	mov    0x48(%esp),%eax
c040be67:	8b 40 38             	mov    0x38(%eax),%eax
c040be6a:	83 c0 04             	add    $0x4,%eax
c040be6d:	8b 00                	mov    (%eax),%eax
c040be6f:	85 c0                	test   %eax,%eax
c040be71:	75 48                	jne    c040bebb <proc_initialise+0x36d>
			{
				dprintf(DEBUG_COL_PROC "[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n" DEBUG_COL_OFF,
c040be73:	8b 44 24 48          	mov    0x48(%esp),%eax
c040be77:	8b 10                	mov    (%eax),%edx
						  CPU_ID, new->pid, new);
c040be79:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
			{
				dprintf(DEBUG_COL_PROC "[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n" DEBUG_COL_OFF,
c040be7e:	3c 01                	cmp    $0x1,%al
c040be80:	76 0c                	jbe    c040be8e <proc_initialise+0x340>
						  CPU_ID, new->pid, new);
c040be82:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040be87:	8b 00                	mov    (%eax),%eax
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
			{
				dprintf(DEBUG_COL_PROC "[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n" DEBUG_COL_OFF,
c040be89:	c1 e8 18             	shr    $0x18,%eax
c040be8c:	eb 08                	jmp    c040be96 <proc_initialise+0x348>
c040be8e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040be93:	0f b6 c0             	movzbl %al,%eax
c040be96:	ff 74 24 48          	pushl  0x48(%esp)
c040be9a:	52                   	push   %edx
c040be9b:	50                   	push   %eax
c040be9c:	68 08 f9 40 c0       	push   $0xc040f908
c040bea1:	e8 b0 15 00 00       	call   c040d456 <debug_printf>
c040bea6:	83 c4 10             	add    $0x10,%esp
						  CPU_ID, new->pid, new);
				dprintf("*** halting.\n" DEBUG_COL_OFF);
c040bea9:	83 ec 0c             	sub    $0xc,%esp
c040beac:	68 49 f9 40 c0       	push   $0xc040f949
c040beb1:	e8 a0 15 00 00       	call   c040d456 <debug_printf>
c040beb6:	83 c4 10             	add    $0x10,%esp
				while(1);
c040beb9:	eb fe                	jmp    c040beb9 <proc_initialise+0x36b>
			}
			
			/* kernel payload binaries start in the executive layer */
			new->layer  = LAYER_EXECUTIVE;
c040bebb:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bebf:	c6 40 50 01          	movb   $0x1,0x50(%eax)
			new->rights = RIGHTS_EXECUTIVE;
c040bec3:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bec7:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
			proc_sys_executive = new;
c040bece:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bed2:	a3 e8 38 41 c0       	mov    %eax,0xc04138e8
			
			/* set the entry program counter and get ready to run it */
			new->entry = (unsigned int)payload.entry;
c040bed7:	8b 44 24 30          	mov    0x30(%esp),%eax
c040bedb:	89 c2                	mov    %eax,%edx
c040bedd:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bee1:	89 50 44             	mov    %edx,0x44(%eax)
			sched_add(CPU_ID, 1, new->threads[FIRST_TID]);
c040bee4:	8b 44 24 48          	mov    0x48(%esp),%eax
c040bee8:	8b 40 38             	mov    0x38(%eax),%eax
c040beeb:	83 c0 04             	add    $0x4,%eax
c040beee:	8b 10                	mov    (%eax),%edx
c040bef0:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040bef5:	3c 01                	cmp    $0x1,%al
c040bef7:	76 0f                	jbe    c040bf08 <proc_initialise+0x3ba>
c040bef9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040befe:	8b 00                	mov    (%eax),%eax
c040bf00:	c1 e8 18             	shr    $0x18,%eax
c040bf03:	0f b6 c0             	movzbl %al,%eax
c040bf06:	eb 08                	jmp    c040bf10 <proc_initialise+0x3c2>
c040bf08:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040bf0d:	0f b6 c0             	movzbl %al,%eax
c040bf10:	83 ec 04             	sub    $0x4,%esp
c040bf13:	52                   	push   %edx
c040bf14:	6a 01                	push   $0x1
c040bf16:	50                   	push   %eax
c040bf17:	e8 03 99 ff ff       	call   c040581f <sched_add>
c040bf1c:	83 c4 10             	add    $0x10,%esp
	
	/* get the lowlevel layer initialised before we start the operating system */
	lowlevel_proc_preinit();
	
   /* turn loaded modules into processes ready to run */
   for(module_loop = 0; module_loop < payload_modulemax; module_loop++)
c040bf1f:	ff 44 24 44          	incl   0x44(%esp)
c040bf23:	a1 f4 38 41 c0       	mov    0xc04138f4,%eax
c040bf28:	39 44 24 44          	cmp    %eax,0x44(%esp)
c040bf2c:	0f 82 e2 fc ff ff    	jb     c040bc14 <proc_initialise+0xc6>
			new->entry = (unsigned int)payload.entry;
			sched_add(CPU_ID, 1, new->threads[FIRST_TID]);
		}
   }

   return success;
c040bf32:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040bf37:	83 c4 60             	add    $0x60,%esp
c040bf3a:	5b                   	pop    %ebx
c040bf3b:	5e                   	pop    %esi
c040bf3c:	5f                   	pop    %edi
c040bf3d:	c3                   	ret    
	...

c040bf40 <_mp_catch_ap>:
volatile unsigned char mp_ap_ready = 0;

/* mp_catch_ap
   This is the point where an application processor joins the kernel proper */
void _mp_catch_ap(void)
{
c040bf40:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int me = CPU_ID;
c040bf43:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040bf48:	3c 01                	cmp    $0x1,%al
c040bf4a:	76 0c                	jbe    c040bf58 <_mp_catch_ap+0x18>
c040bf4c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040bf51:	8b 00                	mov    (%eax),%eax
c040bf53:	c1 e8 18             	shr    $0x18,%eax
c040bf56:	eb 08                	jmp    c040bf60 <_mp_catch_ap+0x20>
c040bf58:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040bf5d:	0f b6 c0             	movzbl %al,%eax
c040bf60:	89 44 24 0c          	mov    %eax,0xc(%esp)
#ifdef MP_DEBUG
	dprintf("[mp:%i] I'm alive! application processor waiting for work\n", me);
#endif
	
	/* signal that we're done */
	mp_ap_ready = 1;
c040bf64:	c6 05 f3 38 41 c0 01 	movb   $0x1,0xc04138f3
	
	/* don't forget to initialise interrupts for this cpu */
	int_initialise_mproc(0); /* 0 = not boot processor */
c040bf6b:	83 ec 0c             	sub    $0xc,%esp
c040bf6e:	6a 00                	push   $0x0
c040bf70:	e8 6d 6a ff ff       	call   c04029e2 <int_initialise_mproc>
c040bf75:	83 c4 10             	add    $0x10,%esp
c040bf78:	eb 01                	jmp    c040bf7b <_mp_catch_ap+0x3b>
	/* loop waiting for the first thread to run */
	while(1)
	{		
		/* we've got one! */
		if((volatile unsigned int)(cpu_table[me].queue_head)) lowlevel_kickstart();
	}
c040bf7a:	90                   	nop
		
	/* loop waiting for the first thread to run */
	while(1)
	{		
		/* we've got one! */
		if((volatile unsigned int)(cpu_table[me].queue_head)) lowlevel_kickstart();
c040bf7b:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040bf80:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040bf84:	c1 e2 06             	shl    $0x6,%edx
c040bf87:	01 d0                	add    %edx,%eax
c040bf89:	8b 40 18             	mov    0x18(%eax),%eax
c040bf8c:	85 c0                	test   %eax,%eax
c040bf8e:	74 ea                	je     c040bf7a <_mp_catch_ap+0x3a>
c040bf90:	e8 fb 55 ff ff       	call   c0401590 <lowlevel_kickstart>
	}
c040bf95:	eb e4                	jmp    c040bf7b <_mp_catch_ap+0x3b>

c040bf97 <mp_delay>:

/* mp_delay
   Cause the processor to pause for a few cycles - the length of a normal
   scheduling quantum */
void mp_delay(void)
{	
c040bf97:	83 ec 0c             	sub    $0xc,%esp
	/* put the local APIC timer into one-shot mode and wait for it to hit zero */
	int_apic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER);
c040bf9a:	83 ec 08             	sub    $0x8,%esp
c040bf9d:	6a 30                	push   $0x30
c040bf9f:	68 20 03 e0 fe       	push   $0xfee00320
c040bfa4:	e8 d1 67 ff ff       	call   c040277a <int_apic_write>
c040bfa9:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040bfac:	83 ec 08             	sub    $0x8,%esp
c040bfaf:	6a 0a                	push   $0xa
c040bfb1:	68 e0 03 e0 fe       	push   $0xfee003e0
c040bfb6:	e8 bf 67 ff ff       	call   c040277a <int_apic_write>
c040bfbb:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERINIT, *(LAPIC_TIMERINIT));
c040bfbe:	b8 80 03 e0 fe       	mov    $0xfee00380,%eax
c040bfc3:	8b 00                	mov    (%eax),%eax
c040bfc5:	83 ec 08             	sub    $0x8,%esp
c040bfc8:	50                   	push   %eax
c040bfc9:	68 80 03 e0 fe       	push   $0xfee00380
c040bfce:	e8 a7 67 ff ff       	call   c040277a <int_apic_write>
c040bfd3:	83 c4 10             	add    $0x10,%esp

	while(*(LAPIC_TIMERNOW)) __asm__ __volatile__("pause");
c040bfd6:	eb 02                	jmp    c040bfda <mp_delay+0x43>
c040bfd8:	f3 90                	pause  
c040bfda:	b8 90 03 e0 fe       	mov    $0xfee00390,%eax
c040bfdf:	8b 00                	mov    (%eax),%eax
c040bfe1:	85 c0                	test   %eax,%eax
c040bfe3:	75 f3                	jne    c040bfd8 <mp_delay+0x41>
			
	/* restore the local APIC timer settings */
	int_apic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER | LAPIC_TIMER_TP);
c040bfe5:	83 ec 08             	sub    $0x8,%esp
c040bfe8:	68 30 00 02 00       	push   $0x20030
c040bfed:	68 20 03 e0 fe       	push   $0xfee00320
c040bff2:	e8 83 67 ff ff       	call   c040277a <int_apic_write>
c040bff7:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040bffa:	83 ec 08             	sub    $0x8,%esp
c040bffd:	6a 0a                	push   $0xa
c040bfff:	68 e0 03 e0 fe       	push   $0xfee003e0
c040c004:	e8 71 67 ff ff       	call   c040277a <int_apic_write>
c040c009:	83 c4 10             	add    $0x10,%esp
	int_apic_write(LAPIC_TIMERINIT, *(LAPIC_TIMERINIT));
c040c00c:	b8 80 03 e0 fe       	mov    $0xfee00380,%eax
c040c011:	8b 00                	mov    (%eax),%eax
c040c013:	83 ec 08             	sub    $0x8,%esp
c040c016:	50                   	push   %eax
c040c017:	68 80 03 e0 fe       	push   $0xfee00380
c040c01c:	e8 59 67 ff ff       	call   c040277a <int_apic_write>
c040c021:	83 c4 10             	add    $0x10,%esp
}
c040c024:	83 c4 0c             	add    $0xc,%esp
c040c027:	c3                   	ret    

c040c028 <mp_init_ap>:
/* mp_init_ap
   Initialise and start up an application processor
   => id = target CPU's local APIC ID
*/
kresult mp_init_ap(unsigned int id)
{
c040c028:	83 ec 2c             	sub    $0x2c,%esp
	volatile unsigned int ap_timeout = 0xffffff; /* sufficiently crude timeout */
c040c02b:	c7 44 24 14 ff ff ff 	movl   $0xffffff,0x14(%esp)
c040c032:	00 
	unsigned int apstack_top, gdtsize, newgdt, is_not_82489dx;
	
	/* determine APIC version - if a 82489dx is present (external APIC)
	   then the APIC version byte will be 0 */
	is_not_82489dx = (*LAPIC_VER_REG) & 0xff;
c040c033:	b8 30 00 e0 fe       	mov    $0xfee00030,%eax
c040c038:	8b 00                	mov    (%eax),%eax
c040c03a:	25 ff 00 00 00       	and    $0xff,%eax
c040c03f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	
	/* allocate about 1K memory for the ap boot stack to stash away */
	if(vmm_malloc((void **)&apstack_top, MP_AP_START_STACK_SIZE))
c040c043:	8d 44 24 10          	lea    0x10(%esp),%eax
c040c047:	83 ec 08             	sub    $0x8,%esp
c040c04a:	68 00 04 00 00       	push   $0x400
c040c04f:	50                   	push   %eax
c040c050:	e8 3b 9e ff ff       	call   c0405e90 <vmm_malloc>
c040c055:	83 c4 10             	add    $0x10,%esp
c040c058:	85 c0                	test   %eax,%eax
c040c05a:	74 3c                	je     c040c098 <mp_init_ap+0x70>
	{
		dprintf("[mp:%i] unable to allocate boot stack for AP %i\n", CPU_ID, id);
c040c05c:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c061:	3c 01                	cmp    $0x1,%al
c040c063:	76 0c                	jbe    c040c071 <mp_init_ap+0x49>
c040c065:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c06a:	8b 00                	mov    (%eax),%eax
c040c06c:	c1 e8 18             	shr    $0x18,%eax
c040c06f:	eb 08                	jmp    c040c079 <mp_init_ap+0x51>
c040c071:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c076:	0f b6 c0             	movzbl %al,%eax
c040c079:	83 ec 04             	sub    $0x4,%esp
c040c07c:	ff 74 24 34          	pushl  0x34(%esp)
c040c080:	50                   	push   %eax
c040c081:	68 58 f9 40 c0       	push   $0xc040f958
c040c086:	e8 cb 13 00 00       	call   c040d456 <debug_printf>
c040c08b:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040c08e:	b8 01 00 00 00       	mov    $0x1,%eax
c040c093:	e9 bc 01 00 00       	jmp    c040c254 <mp_init_ap+0x22c>
	}
	
	/* duplicate the BSP's GDT */
	gdtsize = (unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT;
c040c098:	ba 38 10 41 c0       	mov    $0xc0411038,%edx
c040c09d:	b8 00 10 41 c0       	mov    $0xc0411000,%eax
c040c0a2:	89 d1                	mov    %edx,%ecx
c040c0a4:	29 c1                	sub    %eax,%ecx
c040c0a6:	89 c8                	mov    %ecx,%eax
c040c0a8:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(vmm_malloc((void **)&newgdt, gdtsize))
c040c0ac:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040c0b0:	83 ec 08             	sub    $0x8,%esp
c040c0b3:	ff 74 24 20          	pushl  0x20(%esp)
c040c0b7:	50                   	push   %eax
c040c0b8:	e8 d3 9d ff ff       	call   c0405e90 <vmm_malloc>
c040c0bd:	83 c4 10             	add    $0x10,%esp
c040c0c0:	85 c0                	test   %eax,%eax
c040c0c2:	74 4c                	je     c040c110 <mp_init_ap+0xe8>
	{
		dprintf("[mp:%i] unable to allocate fresh GDT for AP %i\n", CPU_ID, id);
c040c0c4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c0c9:	3c 01                	cmp    $0x1,%al
c040c0cb:	76 0c                	jbe    c040c0d9 <mp_init_ap+0xb1>
c040c0cd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c0d2:	8b 00                	mov    (%eax),%eax
c040c0d4:	c1 e8 18             	shr    $0x18,%eax
c040c0d7:	eb 08                	jmp    c040c0e1 <mp_init_ap+0xb9>
c040c0d9:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c0de:	0f b6 c0             	movzbl %al,%eax
c040c0e1:	83 ec 04             	sub    $0x4,%esp
c040c0e4:	ff 74 24 34          	pushl  0x34(%esp)
c040c0e8:	50                   	push   %eax
c040c0e9:	68 8c f9 40 c0       	push   $0xc040f98c
c040c0ee:	e8 63 13 00 00       	call   c040d456 <debug_printf>
c040c0f3:	83 c4 10             	add    $0x10,%esp
		vmm_free((void *)apstack_top);
c040c0f6:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c0fa:	83 ec 0c             	sub    $0xc,%esp
c040c0fd:	50                   	push   %eax
c040c0fe:	e8 cf a1 ff ff       	call   c04062d2 <vmm_free>
c040c103:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040c106:	b8 01 00 00 00       	mov    $0x1,%eax
c040c10b:	e9 44 01 00 00       	jmp    c040c254 <mp_init_ap+0x22c>
	}
	vmm_memcpy((void *)newgdt, &KernelGDT, gdtsize);
c040c110:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c114:	83 ec 04             	sub    $0x4,%esp
c040c117:	ff 74 24 1c          	pushl  0x1c(%esp)
c040c11b:	68 00 10 41 c0       	push   $0xc0411000
c040c120:	50                   	push   %eax
c040c121:	e8 fd ab ff ff       	call   c0406d23 <vmm_memcpy>
c040c126:	83 c4 10             	add    $0x10,%esp
	
	/* set up the GDT pointers for the cpu */
	cpu_table[id].gdtptr.size = gdtsize - 1;
c040c129:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c12e:	8b 54 24 30          	mov    0x30(%esp),%edx
c040c132:	c1 e2 06             	shl    $0x6,%edx
c040c135:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040c138:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c13c:	48                   	dec    %eax
c040c13d:	66 89 42 34          	mov    %ax,0x34(%edx)
	cpu_table[id].gdtptr.ptr = newgdt;
c040c141:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c146:	8b 54 24 30          	mov    0x30(%esp),%edx
c040c14a:	c1 e2 06             	shl    $0x6,%edx
c040c14d:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040c150:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c154:	89 42 36             	mov    %eax,0x36(%edx)
	/* TSS selector is in the final selector slot in the GDT.. */
	cpu_table[id].tssentry = (gdt_entry *)((newgdt + gdtsize) - sizeof(gdt_entry));
c040c157:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c15c:	8b 54 24 30          	mov    0x30(%esp),%edx
c040c160:	c1 e2 06             	shl    $0x6,%edx
c040c163:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040c166:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c16a:	03 44 24 18          	add    0x18(%esp),%eax
c040c16e:	83 e8 08             	sub    $0x8,%eax
c040c171:	89 42 3c             	mov    %eax,0x3c(%edx)
	
	/* update the word holding the stack pointer */
	apstack_top += MP_AP_START_STACK_SIZE; /* stacks grow down.. */
c040c174:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c178:	05 00 04 00 00       	add    $0x400,%eax
c040c17d:	89 44 24 10          	mov    %eax,0x10(%esp)
	*((volatile unsigned int *)&APStack) = apstack_top;
c040c181:	b8 3e 10 41 c0       	mov    $0xc041103e,%eax
c040c186:	8b 54 24 10          	mov    0x10(%esp),%edx
c040c18a:	89 10                	mov    %edx,(%eax)
#ifdef MP_DEBUG
	dprintf("[mp:%i] initialising AP %i: GDT %x boot stack %x APIC version %x...\n",
			  CPU_ID, id, newgdt, apstack_top, is_not_82489dx);
#endif
	
	mp_ap_ready = 0; /* the AP will set this flag when it's done initialising */
c040c18c:	c6 05 f3 38 41 c0 00 	movb   $0x0,0xc04138f3

	/* following the intel MP spec docs.. */
	int_ipi_send_init(id); /* send INIT IPI to the AP */
c040c193:	83 ec 0c             	sub    $0xc,%esp
c040c196:	ff 74 24 3c          	pushl  0x3c(%esp)
c040c19a:	e8 fb 65 ff ff       	call   c040279a <int_ipi_send_init>
c040c19f:	83 c4 10             	add    $0x10,%esp
	mp_delay();
c040c1a2:	e8 f0 fd ff ff       	call   c040bf97 <mp_delay>
	if(is_not_82489dx)
c040c1a7:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040c1ac:	74 4a                	je     c040c1f8 <mp_init_ap+0x1d0>
#ifdef MP_DEBUG
		dprintf("[mp:%i] sending startup IPI..\n", CPU_ID);
#endif

		/* pulse startup IPIs until it wakes up */
		int_ipi_send_startup(id, MP_AP_START_VECTOR);
c040c1ae:	83 ec 08             	sub    $0x8,%esp
c040c1b1:	68 80 00 00 00       	push   $0x80
c040c1b6:	ff 74 24 3c          	pushl  0x3c(%esp)
c040c1ba:	e8 5d 66 ff ff       	call   c040281c <int_ipi_send_startup>
c040c1bf:	83 c4 10             	add    $0x10,%esp
		mp_delay();
c040c1c2:	e8 d0 fd ff ff       	call   c040bf97 <mp_delay>
		if(!mp_ap_ready)
c040c1c7:	a0 f3 38 41 c0       	mov    0xc04138f3,%al
c040c1cc:	84 c0                	test   %al,%al
c040c1ce:	75 2b                	jne    c040c1fb <mp_init_ap+0x1d3>
		{
			int_ipi_send_startup(id, MP_AP_START_VECTOR);
c040c1d0:	83 ec 08             	sub    $0x8,%esp
c040c1d3:	68 80 00 00 00       	push   $0x80
c040c1d8:	ff 74 24 3c          	pushl  0x3c(%esp)
c040c1dc:	e8 3b 66 ff ff       	call   c040281c <int_ipi_send_startup>
c040c1e1:	83 c4 10             	add    $0x10,%esp
			mp_delay();
c040c1e4:	e8 ae fd ff ff       	call   c040bf97 <mp_delay>
#ifdef MP_DEBUG
	dprintf("[mp:%i] waiting for AP %i to wake up..\n", CPU_ID, id);
#endif	
	
	/* wait for AP to signal it's done initialising or give up waiting */
	while(!mp_ap_ready && ap_timeout)
c040c1e9:	eb 11                	jmp    c040c1fc <mp_init_ap+0x1d4>
	{
		ap_timeout--;
c040c1eb:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c1ef:	48                   	dec    %eax
c040c1f0:	89 44 24 14          	mov    %eax,0x14(%esp)
		__asm__ __volatile__("pause");
c040c1f4:	f3 90                	pause  
c040c1f6:	eb 04                	jmp    c040c1fc <mp_init_ap+0x1d4>
#ifdef MP_DEBUG
	dprintf("[mp:%i] waiting for AP %i to wake up..\n", CPU_ID, id);
#endif	
	
	/* wait for AP to signal it's done initialising or give up waiting */
	while(!mp_ap_ready && ap_timeout)
c040c1f8:	90                   	nop
c040c1f9:	eb 01                	jmp    c040c1fc <mp_init_ap+0x1d4>
c040c1fb:	90                   	nop
c040c1fc:	a0 f3 38 41 c0       	mov    0xc04138f3,%al
c040c201:	84 c0                	test   %al,%al
c040c203:	75 08                	jne    c040c20d <mp_init_ap+0x1e5>
c040c205:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c209:	85 c0                	test   %eax,%eax
c040c20b:	75 de                	jne    c040c1eb <mp_init_ap+0x1c3>
	{
		ap_timeout--;
		__asm__ __volatile__("pause");
	}
	
	if(mp_ap_ready)
c040c20d:	a0 f3 38 41 c0       	mov    0xc04138f3,%al
c040c212:	84 c0                	test   %al,%al
c040c214:	74 07                	je     c040c21d <mp_init_ap+0x1f5>
	{
#ifdef MP_DEBUG
		dprintf("[mp:%i] AP %i is cooking on gas\n", CPU_ID, id);
#endif
		return success;
c040c216:	b8 00 00 00 00       	mov    $0x0,%eax
c040c21b:	eb 37                	jmp    c040c254 <mp_init_ap+0x22c>
	}

	dprintf("[mp:%i] initialisation of AP %i timed out\n", CPU_ID, id);
c040c21d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c222:	3c 01                	cmp    $0x1,%al
c040c224:	76 0c                	jbe    c040c232 <mp_init_ap+0x20a>
c040c226:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c22b:	8b 00                	mov    (%eax),%eax
c040c22d:	c1 e8 18             	shr    $0x18,%eax
c040c230:	eb 08                	jmp    c040c23a <mp_init_ap+0x212>
c040c232:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c237:	0f b6 c0             	movzbl %al,%eax
c040c23a:	83 ec 04             	sub    $0x4,%esp
c040c23d:	ff 74 24 34          	pushl  0x34(%esp)
c040c241:	50                   	push   %eax
c040c242:	68 bc f9 40 c0       	push   $0xc040f9bc
c040c247:	e8 0a 12 00 00       	call   c040d456 <debug_printf>
c040c24c:	83 c4 10             	add    $0x10,%esp
	return e_failure;
c040c24f:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040c254:	83 c4 2c             	add    $0x2c,%esp
c040c257:	c3                   	ret    

c040c258 <mp_init_cpu_table>:

/* mp_init_cpu_table
   Initialise the table of present cpus and prepare the slave cpu launch trampoline */
void mp_init_cpu_table(void)
{
c040c258:	83 ec 0c             	sub    $0xc,%esp
	if(vmm_malloc((void **)&cpu_table, sizeof(proc_cpu) * mp_cpus))
c040c25b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c260:	0f b6 c0             	movzbl %al,%eax
c040c263:	89 c2                	mov    %eax,%edx
c040c265:	c1 e2 06             	shl    $0x6,%edx
c040c268:	b8 e4 38 41 c0       	mov    $0xc04138e4,%eax
c040c26d:	83 ec 08             	sub    $0x8,%esp
c040c270:	52                   	push   %edx
c040c271:	50                   	push   %eax
c040c272:	e8 19 9c ff ff       	call   c0405e90 <vmm_malloc>
c040c277:	83 c4 10             	add    $0x10,%esp
c040c27a:	85 c0                	test   %eax,%eax
c040c27c:	74 12                	je     c040c290 <mp_init_cpu_table+0x38>
	{
		dprintf("[mp:%i] can't allocate cpu table! halting...\n");
c040c27e:	83 ec 0c             	sub    $0xc,%esp
c040c281:	68 e8 f9 40 c0       	push   $0xc040f9e8
c040c286:	e8 cb 11 00 00       	call   c040d456 <debug_printf>
c040c28b:	83 c4 10             	add    $0x10,%esp
		while(1);
c040c28e:	eb fe                	jmp    c040c28e <mp_init_cpu_table+0x36>
	}
	vmm_memset((void *)cpu_table, 0, sizeof(proc_cpu) * mp_cpus);
c040c290:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c295:	0f b6 c0             	movzbl %al,%eax
c040c298:	89 c2                	mov    %eax,%edx
c040c29a:	c1 e2 06             	shl    $0x6,%edx
c040c29d:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c2a2:	83 ec 04             	sub    $0x4,%esp
c040c2a5:	52                   	push   %edx
c040c2a6:	6a 00                	push   $0x0
c040c2a8:	50                   	push   %eax
c040c2a9:	e8 38 aa ff ff       	call   c0406ce6 <vmm_memset>
c040c2ae:	83 c4 10             	add    $0x10,%esp
	
	dprintf("[mp:%i] initialised run-time cpu table %p (%i cpus)\n", CPU_ID, cpu_table, mp_cpus);
c040c2b1:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c2b6:	0f b6 c8             	movzbl %al,%ecx
c040c2b9:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040c2bf:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c2c4:	3c 01                	cmp    $0x1,%al
c040c2c6:	76 0c                	jbe    c040c2d4 <mp_init_cpu_table+0x7c>
c040c2c8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c2cd:	8b 00                	mov    (%eax),%eax
c040c2cf:	c1 e8 18             	shr    $0x18,%eax
c040c2d2:	eb 08                	jmp    c040c2dc <mp_init_cpu_table+0x84>
c040c2d4:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c2d9:	0f b6 c0             	movzbl %al,%eax
c040c2dc:	51                   	push   %ecx
c040c2dd:	52                   	push   %edx
c040c2de:	50                   	push   %eax
c040c2df:	68 18 fa 40 c0       	push   $0xc040fa18
c040c2e4:	e8 6d 11 00 00       	call   c040d456 <debug_printf>
c040c2e9:	83 c4 10             	add    $0x10,%esp
}
c040c2ec:	83 c4 0c             	add    $0xc,%esp
c040c2ef:	c3                   	ret    

c040c2f0 <mp_post_initialise>:

/* mp_post_initialise
	Bring up processors prior to running the first processes */
void mp_post_initialise(void)
{
c040c2f0:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int ap_loop, wokenup = 0;
c040c2f3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040c2fa:	00 
	unsigned int *kaddr, phys_gdt, phys_gdtptr, phys_pgdir;
	gdtptr_descr gdtptr;
	
	/* get the processors ready to run */
	mp_init_cpu_table();
c040c2fb:	e8 58 ff ff ff       	call   c040c258 <mp_init_cpu_table>
	
	if(mp_cpus < 2) return; /* uniproc machines need not apply for the rest */
c040c300:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c305:	3c 01                	cmp    $0x1,%al
c040c307:	0f 86 c9 01 00 00    	jbe    c040c4d6 <mp_post_initialise+0x1e6>

	/* calculate address to copy the trampoline code into */
	kaddr = KERNEL_PHYS2LOG(MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT);
c040c30d:	c7 44 24 10 00 00 08 	movl   $0xc0080000,0x10(%esp)
c040c314:	c0 

	/* copy trampoline code into a low physical page */
	vmm_memcpy(kaddr, &x86_start_ap, (unsigned int)&x86_start_ap_end - (unsigned int)&x86_start_ap);
c040c315:	ba d7 00 40 c0       	mov    $0xc04000d7,%edx
c040c31a:	b8 60 00 40 c0       	mov    $0xc0400060,%eax
c040c31f:	89 d1                	mov    %edx,%ecx
c040c321:	29 c1                	sub    %eax,%ecx
c040c323:	89 c8                	mov    %ecx,%eax
c040c325:	83 ec 04             	sub    $0x4,%esp
c040c328:	50                   	push   %eax
c040c329:	68 60 00 40 c0       	push   $0xc0400060
c040c32e:	ff 74 24 1c          	pushl  0x1c(%esp)
c040c332:	e8 ec a9 ff ff       	call   c0406d23 <vmm_memcpy>
c040c337:	83 c4 10             	add    $0x10,%esp
	
	/* stash the kernel's GDT ptr into the base of the physical page above the trampoline code
	   plus the actual boot GDT into the base of the page above that and a copy of the kernel's
	   boot page directory in the page above that */
	phys_gdtptr = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + MEM_PGSIZE;
c040c33a:	c7 44 24 18 00 10 08 	movl   $0x81000,0x18(%esp)
c040c341:	00 
	phys_gdt    = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + (2 * MEM_PGSIZE);
c040c342:	c7 44 24 14 00 20 08 	movl   $0x82000,0x14(%esp)
c040c349:	00 
	phys_pgdir  = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + (3 * MEM_PGSIZE);
c040c34a:	c7 44 24 1c 00 30 08 	movl   $0x83000,0x1c(%esp)
c040c351:	00 
	gdtptr.size = (unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT;
c040c352:	b8 38 10 41 c0       	mov    $0xc0411038,%eax
c040c357:	89 c2                	mov    %eax,%edx
c040c359:	b8 00 10 41 c0       	mov    $0xc0411000,%eax
c040c35e:	89 d1                	mov    %edx,%ecx
c040c360:	66 29 c1             	sub    %ax,%cx
c040c363:	89 c8                	mov    %ecx,%eax
c040c365:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	gdtptr.ptr = phys_gdt;
c040c36a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c36e:	89 44 24 04          	mov    %eax,0x4(%esp)
	
	/* copy the gdtptr into the base of the page above the trampoline and the GDT into the
	   second page above the trampoline */
	vmm_memcpy(KERNEL_PHYS2LOG(phys_gdtptr), &gdtptr, sizeof(gdtptr_descr));
c040c372:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c376:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c37b:	83 ec 04             	sub    $0x4,%esp
c040c37e:	6a 06                	push   $0x6
c040c380:	8d 54 24 0a          	lea    0xa(%esp),%edx
c040c384:	52                   	push   %edx
c040c385:	50                   	push   %eax
c040c386:	e8 98 a9 ff ff       	call   c0406d23 <vmm_memcpy>
c040c38b:	83 c4 10             	add    $0x10,%esp
	vmm_memcpy(KERNEL_PHYS2LOG(phys_gdt), &KernelGDT, gdtptr.size);
c040c38e:	66 8b 44 24 02       	mov    0x2(%esp),%ax
c040c393:	0f b7 d0             	movzwl %ax,%edx
c040c396:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c39a:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c39f:	83 ec 04             	sub    $0x4,%esp
c040c3a2:	52                   	push   %edx
c040c3a3:	68 00 10 41 c0       	push   $0xc0411000
c040c3a8:	50                   	push   %eax
c040c3a9:	e8 75 a9 ff ff       	call   c0406d23 <vmm_memcpy>
c040c3ae:	83 c4 10             	add    $0x10,%esp
	vmm_memcpy(KERNEL_PHYS2LOG(phys_pgdir), &KernelPageDirectory, 1024 * sizeof(unsigned int));
c040c3b1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040c3b5:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c3ba:	83 ec 04             	sub    $0x4,%esp
c040c3bd:	68 00 10 00 00       	push   $0x1000
c040c3c2:	68 00 00 41 c0       	push   $0xc0410000
c040c3c7:	50                   	push   %eax
c040c3c8:	e8 56 a9 ff ff       	call   c0406d23 <vmm_memcpy>
c040c3cd:	83 c4 10             	add    $0x10,%esp
			  phys_gdt, phys_gdtptr, gdtptr.size, phys_pgdir);
#endif
	
	/* an init'd AP will reboot and jump to 0x467 (40:67) for a start address
	   if we set the warm-boot flag */
	*(volatile unsigned int *)KERNEL_PHYS2LOG(0x467) = MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT;	
c040c3d0:	b8 67 04 00 c0       	mov    $0xc0000467,%eax
c040c3d5:	c7 00 00 00 08 00    	movl   $0x80000,(%eax)

	/* program the BIOS CMOS for a warm reset - see: http://wiki.osdev.org/CMOS */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_WARM);	
c040c3db:	83 ec 08             	sub    $0x8,%esp
c040c3de:	6a 0a                	push   $0xa
c040c3e0:	68 f0 00 00 00       	push   $0xf0
c040c3e5:	e8 e3 43 ff ff       	call   c04007cd <x86_cmos_write>
c040c3ea:	83 c4 10             	add    $0x10,%esp
	
	/* and let's do battle.. */
	for(ap_loop = 0; ap_loop < mp_cpus; ap_loop++)
c040c3ed:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040c3f4:	00 
c040c3f5:	eb 7e                	jmp    c040c475 <mp_post_initialise+0x185>
	{
		/* don't boot the already running bootstrap cpu */
		if(ap_loop != CPU_ID)
c040c3f7:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c3fc:	3c 01                	cmp    $0x1,%al
c040c3fe:	76 0c                	jbe    c040c40c <mp_post_initialise+0x11c>
c040c400:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c405:	8b 00                	mov    (%eax),%eax
c040c407:	c1 e8 18             	shr    $0x18,%eax
c040c40a:	eb 08                	jmp    c040c414 <mp_post_initialise+0x124>
c040c40c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c411:	0f b6 c0             	movzbl %al,%eax
c040c414:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040c418:	74 43                	je     c040c45d <mp_post_initialise+0x16d>
		{
			if(mp_init_ap(ap_loop) == success)
c040c41a:	83 ec 0c             	sub    $0xc,%esp
c040c41d:	ff 74 24 14          	pushl  0x14(%esp)
c040c421:	e8 02 fc ff ff       	call   c040c028 <mp_init_ap>
c040c426:	83 c4 10             	add    $0x10,%esp
c040c429:	85 c0                	test   %eax,%eax
c040c42b:	75 1a                	jne    c040c447 <mp_post_initialise+0x157>
			{
				wokenup++;
c040c42d:	ff 44 24 0c          	incl   0xc(%esp)
				cpu_table[ap_loop].state = enabled;
c040c431:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c436:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c43a:	c1 e2 06             	shl    $0x6,%edx
c040c43d:	01 d0                	add    %edx,%eax
c040c43f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			}
			else
				/* stop the scheduler from using APs that haven't been started up */
				cpu_table[ap_loop].state = disabled;
c040c445:	eb 2a                	jmp    c040c471 <mp_post_initialise+0x181>
c040c447:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c44c:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c450:	c1 e2 06             	shl    $0x6,%edx
c040c453:	01 d0                	add    %edx,%eax
c040c455:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c040c45b:	eb 14                	jmp    c040c471 <mp_post_initialise+0x181>
		}
		else
			cpu_table[ap_loop].state = enabled; /* enabled boot processor is enabled */
c040c45d:	a1 e4 38 41 c0       	mov    0xc04138e4,%eax
c040c462:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c466:	c1 e2 06             	shl    $0x6,%edx
c040c469:	01 d0                	add    %edx,%eax
c040c46b:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	/* program the BIOS CMOS for a warm reset - see: http://wiki.osdev.org/CMOS */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_WARM);	
	
	/* and let's do battle.. */
	for(ap_loop = 0; ap_loop < mp_cpus; ap_loop++)
c040c471:	ff 44 24 08          	incl   0x8(%esp)
c040c475:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c47a:	0f b6 c0             	movzbl %al,%eax
c040c47d:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040c481:	0f 87 70 ff ff ff    	ja     c040c3f7 <mp_post_initialise+0x107>
		}
		else
			cpu_table[ap_loop].state = enabled; /* enabled boot processor is enabled */
	}

	dprintf("[mp:%i] woke up %i application processor(s) out of %i\n", CPU_ID, wokenup, mp_cpus - 1);
c040c487:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c48c:	0f b6 c0             	movzbl %al,%eax
c040c48f:	8d 50 ff             	lea    -0x1(%eax),%edx
c040c492:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c497:	3c 01                	cmp    $0x1,%al
c040c499:	76 0c                	jbe    c040c4a7 <mp_post_initialise+0x1b7>
c040c49b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c4a0:	8b 00                	mov    (%eax),%eax
c040c4a2:	c1 e8 18             	shr    $0x18,%eax
c040c4a5:	eb 08                	jmp    c040c4af <mp_post_initialise+0x1bf>
c040c4a7:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c4ac:	0f b6 c0             	movzbl %al,%eax
c040c4af:	52                   	push   %edx
c040c4b0:	ff 74 24 10          	pushl  0x10(%esp)
c040c4b4:	50                   	push   %eax
c040c4b5:	68 50 fa 40 c0       	push   $0xc040fa50
c040c4ba:	e8 97 0f 00 00       	call   c040d456 <debug_printf>
c040c4bf:	83 c4 10             	add    $0x10,%esp
	
	/* put the CMOS byte back to normal */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_COLD);
c040c4c2:	83 ec 08             	sub    $0x8,%esp
c040c4c5:	6a 00                	push   $0x0
c040c4c7:	68 f0 00 00 00       	push   $0xf0
c040c4cc:	e8 fc 42 ff ff       	call   c04007cd <x86_cmos_write>
c040c4d1:	83 c4 10             	add    $0x10,%esp
c040c4d4:	eb 01                	jmp    c040c4d7 <mp_post_initialise+0x1e7>
	gdtptr_descr gdtptr;
	
	/* get the processors ready to run */
	mp_init_cpu_table();
	
	if(mp_cpus < 2) return; /* uniproc machines need not apply for the rest */
c040c4d6:	90                   	nop

	dprintf("[mp:%i] woke up %i application processor(s) out of %i\n", CPU_ID, wokenup, mp_cpus - 1);
	
	/* put the CMOS byte back to normal */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_COLD);
}
c040c4d7:	83 c4 2c             	add    $0x2c,%esp
c040c4da:	c3                   	ret    

c040c4db <mp_initialise>:

kresult mp_initialise(void)
{
c040c4db:	83 ec 2c             	sub    $0x2c,%esp
	unsigned char i;
	unsigned int search;
	unsigned char mp_found = 0;
c040c4de:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
	mp_header_block *mp_header= NULL;
c040c4e3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c040c4ea:	00 
	mp_config_block *mp_config = NULL;
c040c4eb:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c040c4f2:	00 
	
	/* start with the extended BIOS data area (128K - 0xA0000) */
#ifdef MP_DEBUG
	dprintf("[mp] searching for multiprocessor info in EBDA...\n");
#endif
	for(search = MP_EBDA_START; search < MP_EBDA_END; search += sizeof(mp_header_block *))
c040c4f3:	c7 44 24 08 00 00 08 	movl   $0x80000,0x8(%esp)
c040c4fa:	00 
c040c4fb:	eb 21                	jmp    c040c51e <mp_initialise+0x43>
	{
		mp_header = (mp_header_block *)search;
c040c4fd:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c501:	89 44 24 10          	mov    %eax,0x10(%esp)
		if(mp_header->signature == MP_MAGIC_SIG)
c040c505:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c509:	8b 00                	mov    (%eax),%eax
c040c50b:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040c510:	75 07                	jne    c040c519 <mp_initialise+0x3e>
		{
			mp_found = 1;
c040c512:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
			break;
c040c517:	eb 0f                	jmp    c040c528 <mp_initialise+0x4d>
	
	/* start with the extended BIOS data area (128K - 0xA0000) */
#ifdef MP_DEBUG
	dprintf("[mp] searching for multiprocessor info in EBDA...\n");
#endif
	for(search = MP_EBDA_START; search < MP_EBDA_END; search += sizeof(mp_header_block *))
c040c519:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040c51e:	81 7c 24 08 ff ff 08 	cmpl   $0x8ffff,0x8(%esp)
c040c525:	00 
c040c526:	76 d5                	jbe    c040c4fd <mp_initialise+0x22>
			mp_found = 1;
			break;
		}
	}
	
	if(!mp_found)
c040c528:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040c52d:	75 35                	jne    c040c564 <mp_initialise+0x89>
	{
		/* search the last 1024 bytes of base memory (ends at 640K) */
#ifdef MP_DEBUG
		dprintf("[mp] searching for multiprocessor info in top of base memory...\n");
#endif
		for(search = MP_LASTK_START; search < MP_LASTK_END; search += sizeof(mp_header_block *))
c040c52f:	c7 44 24 08 00 fc 09 	movl   $0x9fc00,0x8(%esp)
c040c536:	00 
c040c537:	eb 21                	jmp    c040c55a <mp_initialise+0x7f>
		{
			mp_header = (mp_header_block *)search;
c040c539:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c53d:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(mp_header->signature == MP_MAGIC_SIG)
c040c541:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c545:	8b 00                	mov    (%eax),%eax
c040c547:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040c54c:	75 07                	jne    c040c555 <mp_initialise+0x7a>
			{
				mp_found = 1;
c040c54e:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
				break;
c040c553:	eb 0f                	jmp    c040c564 <mp_initialise+0x89>
	{
		/* search the last 1024 bytes of base memory (ends at 640K) */
#ifdef MP_DEBUG
		dprintf("[mp] searching for multiprocessor info in top of base memory...\n");
#endif
		for(search = MP_LASTK_START; search < MP_LASTK_END; search += sizeof(mp_header_block *))
c040c555:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040c55a:	81 7c 24 08 ff ff 09 	cmpl   $0x9ffff,0x8(%esp)
c040c561:	00 
c040c562:	76 d5                	jbe    c040c539 <mp_initialise+0x5e>
				break;
			}
		}
	}

	if(!mp_found)
c040c564:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040c569:	75 35                	jne    c040c5a0 <mp_initialise+0xc5>
	{
		/* search the BIOS ROM space */
#ifdef MP_DEBUG
		dprintf("[mp] searching for multiprocessor info in the BIOS...\n");	
#endif
		for(search = MP_ROM_START; search < MP_ROM_END; search += sizeof(mp_header_block *))
c040c56b:	c7 44 24 08 00 00 0f 	movl   $0xf0000,0x8(%esp)
c040c572:	00 
c040c573:	eb 21                	jmp    c040c596 <mp_initialise+0xbb>
		{
			mp_header = (mp_header_block *)search;
c040c575:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c579:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(mp_header->signature == MP_MAGIC_SIG)
c040c57d:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c581:	8b 00                	mov    (%eax),%eax
c040c583:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040c588:	75 07                	jne    c040c591 <mp_initialise+0xb6>
			{
				mp_found = 1;
c040c58a:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
				break;
c040c58f:	eb 0f                	jmp    c040c5a0 <mp_initialise+0xc5>
	{
		/* search the BIOS ROM space */
#ifdef MP_DEBUG
		dprintf("[mp] searching for multiprocessor info in the BIOS...\n");	
#endif
		for(search = MP_ROM_START; search < MP_ROM_END; search += sizeof(mp_header_block *))
c040c591:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040c596:	81 7c 24 08 fe ff 0f 	cmpl   $0xffffe,0x8(%esp)
c040c59d:	00 
c040c59e:	76 d5                	jbe    c040c575 <mp_initialise+0x9a>
			}
		}
	}
	
	/* must be a single processor system if we can't find the signature :( */
	if(!mp_found)
c040c5a0:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040c5a5:	75 2d                	jne    c040c5d4 <mp_initialise+0xf9>
	{
		dprintf("[mp] assuming uniprocessor machine\n");
c040c5a7:	83 ec 0c             	sub    $0xc,%esp
c040c5aa:	68 88 fa 40 c0       	push   $0xc040fa88
c040c5af:	e8 a2 0e 00 00       	call   c040d456 <debug_printf>
c040c5b4:	83 c4 10             	add    $0x10,%esp
		mp_cpus = 1;
c040c5b7:	c6 05 f0 38 41 c0 01 	movb   $0x1,0xc04138f0
		mp_boot_cpu = 0;
c040c5be:	c6 05 f1 38 41 c0 00 	movb   $0x0,0xc04138f1
		int_initialise_uniproc();
c040c5c5:	e8 7e 6c ff ff       	call   c0403248 <int_initialise_uniproc>
		return success;
c040c5ca:	b8 00 00 00 00       	mov    $0x0,%eax
c040c5cf:	e9 e4 01 00 00       	jmp    c040c7b8 <mp_initialise+0x2dd>
	}

	/* we're in multiprocessor territory now */
	
	dprintf("[mp] multiprocessor machine detected\n");
c040c5d4:	83 ec 0c             	sub    $0xc,%esp
c040c5d7:	68 ac fa 40 c0       	push   $0xc040faac
c040c5dc:	e8 75 0e 00 00       	call   c040d456 <debug_printf>
c040c5e1:	83 c4 10             	add    $0x10,%esp
	
	/* start pulling apart system info */
	mp_config = mp_header->configptr;
c040c5e4:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c5e8:	8b 40 04             	mov    0x4(%eax),%eax
c040c5eb:	89 44 24 14          	mov    %eax,0x14(%esp)
	dprintf("[mp] system: ");
c040c5ef:	83 ec 0c             	sub    $0xc,%esp
c040c5f2:	68 d2 fa 40 c0       	push   $0xc040fad2
c040c5f7:	e8 5a 0e 00 00       	call   c040d456 <debug_printf>
c040c5fc:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 8; i++)
c040c5ff:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040c604:	eb 25                	jmp    c040c62b <mp_initialise+0x150>
		dprintf("%c", mp_config->oemid[i]);
c040c606:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c040c60b:	8b 54 24 14          	mov    0x14(%esp),%edx
c040c60f:	8a 44 02 08          	mov    0x8(%edx,%eax,1),%al
c040c613:	0f b6 c0             	movzbl %al,%eax
c040c616:	83 ec 08             	sub    $0x8,%esp
c040c619:	50                   	push   %eax
c040c61a:	68 e0 fa 40 c0       	push   $0xc040fae0
c040c61f:	e8 32 0e 00 00       	call   c040d456 <debug_printf>
c040c624:	83 c4 10             	add    $0x10,%esp
	dprintf("[mp] multiprocessor machine detected\n");
	
	/* start pulling apart system info */
	mp_config = mp_header->configptr;
	dprintf("[mp] system: ");
	for(i = 0; i < 8; i++)
c040c627:	fe 44 24 07          	incb   0x7(%esp)
c040c62b:	80 7c 24 07 07       	cmpb   $0x7,0x7(%esp)
c040c630:	76 d4                	jbe    c040c606 <mp_initialise+0x12b>
		dprintf("%c", mp_config->oemid[i]);
	dprintf(" ");
c040c632:	83 ec 0c             	sub    $0xc,%esp
c040c635:	68 e3 fa 40 c0       	push   $0xc040fae3
c040c63a:	e8 17 0e 00 00       	call   c040d456 <debug_printf>
c040c63f:	83 c4 10             	add    $0x10,%esp
				  
	dprintf(" ");
c040c642:	83 ec 0c             	sub    $0xc,%esp
c040c645:	68 e3 fa 40 c0       	push   $0xc040fae3
c040c64a:	e8 07 0e 00 00       	call   c040d456 <debug_printf>
c040c64f:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 12; i++)
c040c652:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040c657:	eb 25                	jmp    c040c67e <mp_initialise+0x1a3>
		dprintf("%c", mp_config->productid[i]);
c040c659:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c040c65e:	8b 54 24 14          	mov    0x14(%esp),%edx
c040c662:	8a 44 02 10          	mov    0x10(%edx,%eax,1),%al
c040c666:	0f b6 c0             	movzbl %al,%eax
c040c669:	83 ec 08             	sub    $0x8,%esp
c040c66c:	50                   	push   %eax
c040c66d:	68 e0 fa 40 c0       	push   $0xc040fae0
c040c672:	e8 df 0d 00 00       	call   c040d456 <debug_printf>
c040c677:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 8; i++)
		dprintf("%c", mp_config->oemid[i]);
	dprintf(" ");
				  
	dprintf(" ");
	for(i = 0; i < 12; i++)
c040c67a:	fe 44 24 07          	incb   0x7(%esp)
c040c67e:	80 7c 24 07 0b       	cmpb   $0xb,0x7(%esp)
c040c683:	76 d4                	jbe    c040c659 <mp_initialise+0x17e>
		dprintf("%c", mp_config->productid[i]);
	dprintf("\n");
c040c685:	83 ec 0c             	sub    $0xc,%esp
c040c688:	68 e5 fa 40 c0       	push   $0xc040fae5
c040c68d:	e8 c4 0d 00 00       	call   c040d456 <debug_printf>
c040c692:	83 c4 10             	add    $0x10,%esp

	info_block = (mp_entry_block *)((unsigned int)mp_config + sizeof(mp_config_block));
c040c695:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c699:	83 c0 2c             	add    $0x2c,%eax
c040c69c:	89 44 24 18          	mov    %eax,0x18(%esp)
	for(i = 0; i < mp_config->entry_count; i++)
c040c6a0:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040c6a5:	e9 e6 00 00 00       	jmp    c040c790 <mp_initialise+0x2b5>
	{
		unsigned char block_size;
		
		switch(info_block->type)
c040c6aa:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c6ae:	8a 00                	mov    (%eax),%al
c040c6b0:	0f b6 c0             	movzbl %al,%eax
c040c6b3:	85 c0                	test   %eax,%eax
c040c6b5:	74 0e                	je     c040c6c5 <mp_initialise+0x1ea>
c040c6b7:	83 f8 02             	cmp    $0x2,%eax
c040c6ba:	0f 84 8c 00 00 00    	je     c040c74c <mp_initialise+0x271>
c040c6c0:	e9 b2 00 00 00       	jmp    c040c777 <mp_initialise+0x29c>
		{
			case 0: /* cpu */
				dprintf("[mp] found cpu %i (flags %x) ",
						  info_block->id, info_block->flags);
c040c6c5:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c6c9:	8a 40 03             	mov    0x3(%eax),%al
		unsigned char block_size;
		
		switch(info_block->type)
		{
			case 0: /* cpu */
				dprintf("[mp] found cpu %i (flags %x) ",
c040c6cc:	0f b6 d0             	movzbl %al,%edx
						  info_block->id, info_block->flags);
c040c6cf:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c6d3:	8a 40 01             	mov    0x1(%eax),%al
		unsigned char block_size;
		
		switch(info_block->type)
		{
			case 0: /* cpu */
				dprintf("[mp] found cpu %i (flags %x) ",
c040c6d6:	0f b6 c0             	movzbl %al,%eax
c040c6d9:	83 ec 04             	sub    $0x4,%esp
c040c6dc:	52                   	push   %edx
c040c6dd:	50                   	push   %eax
c040c6de:	68 e7 fa 40 c0       	push   $0xc040fae7
c040c6e3:	e8 6e 0d 00 00       	call   c040d456 <debug_printf>
c040c6e8:	83 c4 10             	add    $0x10,%esp
						  info_block->id, info_block->flags);
				if(info_block->flags & MP_IS_BSP)
c040c6eb:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c6ef:	8a 40 03             	mov    0x3(%eax),%al
c040c6f2:	0f b6 c0             	movzbl %al,%eax
c040c6f5:	83 e0 02             	and    $0x2,%eax
c040c6f8:	85 c0                	test   %eax,%eax
c040c6fa:	74 1e                	je     c040c71a <mp_initialise+0x23f>
				{
					mp_boot_cpu = info_block->id;
c040c6fc:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c700:	8a 40 01             	mov    0x1(%eax),%al
c040c703:	a2 f1 38 41 c0       	mov    %al,0xc04138f1
					dprintf("[boot processor]");
c040c708:	83 ec 0c             	sub    $0xc,%esp
c040c70b:	68 05 fb 40 c0       	push   $0xc040fb05
c040c710:	e8 41 0d 00 00       	call   c040d456 <debug_printf>
c040c715:	83 c4 10             	add    $0x10,%esp
c040c718:	eb 10                	jmp    c040c72a <mp_initialise+0x24f>
				}
				else
				{
					dprintf("[application processor]");
c040c71a:	83 ec 0c             	sub    $0xc,%esp
c040c71d:	68 16 fb 40 c0       	push   $0xc040fb16
c040c722:	e8 2f 0d 00 00       	call   c040d456 <debug_printf>
c040c727:	83 c4 10             	add    $0x10,%esp
				}
				dprintf("\n");
c040c72a:	83 ec 0c             	sub    $0xc,%esp
c040c72d:	68 e5 fa 40 c0       	push   $0xc040fae5
c040c732:	e8 1f 0d 00 00       	call   c040d456 <debug_printf>
c040c737:	83 c4 10             	add    $0x10,%esp
				mp_cpus++;
c040c73a:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c73f:	40                   	inc    %eax
c040c740:	a2 f0 38 41 c0       	mov    %al,0xc04138f0
				block_size = 20;
c040c745:	c6 44 24 1f 14       	movb   $0x14,0x1f(%esp)
				break;
c040c74a:	eb 30                	jmp    c040c77c <mp_initialise+0x2a1>
				
			case 2: /* ioapic */
				dprintf("[mp] found an ioapic (id %i flags %x addr %p)\n", 
c040c74c:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c750:	8b 48 04             	mov    0x4(%eax),%ecx
						  info_block->id, info_block->flags, info_block->physaddr);
c040c753:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c757:	8a 40 03             	mov    0x3(%eax),%al
				mp_cpus++;
				block_size = 20;
				break;
				
			case 2: /* ioapic */
				dprintf("[mp] found an ioapic (id %i flags %x addr %p)\n", 
c040c75a:	0f b6 d0             	movzbl %al,%edx
						  info_block->id, info_block->flags, info_block->physaddr);
c040c75d:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c761:	8a 40 01             	mov    0x1(%eax),%al
				mp_cpus++;
				block_size = 20;
				break;
				
			case 2: /* ioapic */
				dprintf("[mp] found an ioapic (id %i flags %x addr %p)\n", 
c040c764:	0f b6 c0             	movzbl %al,%eax
c040c767:	51                   	push   %ecx
c040c768:	52                   	push   %edx
c040c769:	50                   	push   %eax
c040c76a:	68 30 fb 40 c0       	push   $0xc040fb30
c040c76f:	e8 e2 0c 00 00       	call   c040d456 <debug_printf>
c040c774:	83 c4 10             	add    $0x10,%esp
						  info_block->id, info_block->flags, info_block->physaddr);

			default:
				block_size = 8;
c040c777:	c6 44 24 1f 08       	movb   $0x8,0x1f(%esp)
				break;
		}
		
		info_block = (mp_entry_block *)((unsigned int)info_block + block_size);
c040c77c:	0f b6 54 24 1f       	movzbl 0x1f(%esp),%edx
c040c781:	8b 44 24 18          	mov    0x18(%esp),%eax
c040c785:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040c788:	89 44 24 18          	mov    %eax,0x18(%esp)
	for(i = 0; i < 12; i++)
		dprintf("%c", mp_config->productid[i]);
	dprintf("\n");

	info_block = (mp_entry_block *)((unsigned int)mp_config + sizeof(mp_config_block));
	for(i = 0; i < mp_config->entry_count; i++)
c040c78c:	fe 44 24 07          	incb   0x7(%esp)
c040c790:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c040c795:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c799:	66 8b 40 22          	mov    0x22(%eax),%ax
c040c79d:	66 39 c2             	cmp    %ax,%dx
c040c7a0:	0f 82 04 ff ff ff    	jb     c040c6aa <mp_initialise+0x1cf>
	dprintf("[mp] checking apic reg access... bsp apic id %i version %x\n",
			  *(LAPIC_ID_REG), *(LAPIC_VER_REG));
#endif
	
	/* let the bootstrap processor continue the initialisation */
	int_initialise_mproc(INT_IAMBSP);
c040c7a6:	83 ec 0c             	sub    $0xc,%esp
c040c7a9:	6a 01                	push   $0x1
c040c7ab:	e8 32 62 ff ff       	call   c04029e2 <int_initialise_mproc>
c040c7b0:	83 c4 10             	add    $0x10,%esp
	
	return success;
c040c7b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040c7b8:	83 c4 2c             	add    $0x2c,%esp
c040c7bb:	c3                   	ret    

c040c7bc <_main>:
      essential.
   => mbd = ptr to multiboot data about the system we're running in
      magic = special word passed by the bootloader to prove it is multiboot capable
*/
void _main(multiboot_info_t *mbd, unsigned int magic)
{
c040c7bc:	83 ec 0c             	sub    $0xc,%esp
   if(DEBUG) debug_initialise();
c040c7bf:	e8 50 10 00 00       	call   c040d814 <debug_initialise>
   dprintf("[core] diosix-hyatt " __TIME__ " " __DATE__ " (built with GCC " __VERSION__ ")\n");
c040c7c4:	83 ec 0c             	sub    $0xc,%esp
c040c7c7:	68 60 fb 40 c0       	push   $0xc040fb60
c040c7cc:	e8 85 0c 00 00       	call   c040d456 <debug_printf>
c040c7d1:	83 c4 10             	add    $0x10,%esp
	
	if(magic != MULTIBOOT_MAGIC) /* as defined in the multiboot spec */
c040c7d4:	81 7c 24 14 02 b0 ad 	cmpl   $0x2badb002,0x14(%esp)
c040c7db:	2b 
c040c7dc:	74 19                	je     c040c7f7 <_main+0x3b>
		dprintf("*** warning: bootloader magic was %x (expecting %x).\n", magic, MULTIBOOT_MAGIC);
c040c7de:	83 ec 04             	sub    $0x4,%esp
c040c7e1:	68 02 b0 ad 2b       	push   $0x2badb002
c040c7e6:	ff 74 24 1c          	pushl  0x1c(%esp)
c040c7ea:	68 a4 fb 40 c0       	push   $0xc040fba4
c040c7ef:	e8 62 0c 00 00       	call   c040d456 <debug_printf>
c040c7f4:	83 c4 10             	add    $0x10,%esp
	
	/* ---- multiboot + SMP data must be preserved during these calls ------- */
	/* initialise interrupt handling and discover processor(s) */
   if(mp_initialise()) goto goforhalt;
c040c7f7:	e8 df fc ff ff       	call   c040c4db <mp_initialise>
c040c7fc:	85 c0                	test   %eax,%eax
c040c7fe:	75 40                	jne    c040c840 <_main+0x84>
	
	/* parse modules payloaded by the boot loader, best halt if there are none? */
   if(payload_preinit(mbd)) goto goforhalt;
c040c800:	83 ec 0c             	sub    $0xc,%esp
c040c803:	ff 74 24 1c          	pushl  0x1c(%esp)
c040c807:	e8 e0 03 00 00       	call   c040cbec <payload_preinit>
c040c80c:	83 c4 10             	add    $0x10,%esp
c040c80f:	85 c0                	test   %eax,%eax
c040c811:	75 30                	jne    c040c843 <_main+0x87>

   /* initialise the memory manager or halt if it fails */
   if(vmm_initialise(mbd)) goto goforhalt;
c040c813:	83 ec 0c             	sub    $0xc,%esp
c040c816:	ff 74 24 1c          	pushl  0x1c(%esp)
c040c81a:	e8 d8 9f ff ff       	call   c04067f7 <vmm_initialise>
c040c81f:	83 c4 10             	add    $0x10,%esp
c040c822:	85 c0                	test   %eax,%eax
c040c824:	75 20                	jne    c040c846 <_main+0x8a>

   /* initialise process and thread management, prepare first processes */
	sched_pre_initalise();
c040c826:	e8 10 96 ff ff       	call   c0405e3b <sched_pre_initalise>
	
	/* bring up the processor(s) */
	mp_post_initialise();
c040c82b:	e8 c0 fa ff ff       	call   c040c2f0 <mp_post_initialise>
	
   if(proc_initialise()) goto goforhalt;
c040c830:	e8 19 f3 ff ff       	call   c040bb4e <proc_initialise>
c040c835:	85 c0                	test   %eax,%eax
c040c837:	75 10                	jne    c040c849 <_main+0x8d>
   /* ---- multiboot + SMP data is no longer required by this point ------- */

	/* hocus pocus, mumbo jumbo, black magic */
	sched_initialise(); /* enable interrupts and start the execution of
c040c839:	e8 18 96 ff ff       	call   c0405e56 <sched_initialise>
c040c83e:	eb 0a                	jmp    c040c84a <_main+0x8e>
	if(magic != MULTIBOOT_MAGIC) /* as defined in the multiboot spec */
		dprintf("*** warning: bootloader magic was %x (expecting %x).\n", magic, MULTIBOOT_MAGIC);
	
	/* ---- multiboot + SMP data must be preserved during these calls ------- */
	/* initialise interrupt handling and discover processor(s) */
   if(mp_initialise()) goto goforhalt;
c040c840:	90                   	nop
c040c841:	eb 07                	jmp    c040c84a <_main+0x8e>
	
	/* parse modules payloaded by the boot loader, best halt if there are none? */
   if(payload_preinit(mbd)) goto goforhalt;
c040c843:	90                   	nop
c040c844:	eb 04                	jmp    c040c84a <_main+0x8e>

   /* initialise the memory manager or halt if it fails */
   if(vmm_initialise(mbd)) goto goforhalt;
c040c846:	90                   	nop
c040c847:	eb 01                	jmp    c040c84a <_main+0x8e>
	sched_pre_initalise();
	
	/* bring up the processor(s) */
	mp_post_initialise();
	
   if(proc_initialise()) goto goforhalt;
c040c849:	90                   	nop
								  userspace processes */
	/* shouldn't fall through... but halt if so */
	
goforhalt:
   /* halt here - there is nothing to return to */
   dprintf("\n*** unexpected end-of-boot. halting.\n");
c040c84a:	83 ec 0c             	sub    $0xc,%esp
c040c84d:	68 dc fb 40 c0       	push   $0xc040fbdc
c040c852:	e8 ff 0b 00 00       	call   c040d456 <debug_printf>
c040c857:	83 c4 10             	add    $0x10,%esp
   while(1);
c040c85a:	eb fe                	jmp    c040c85a <_main+0x9e>

c040c85c <payload_exist_here>:
   rather inefficient if there are lots of modules...
   => ptr = address to check
   <= 0 if no payload object at addr, or result code
*/
kresult payload_exist_here(unsigned int ptr)
{
c040c85c:	83 ec 1c             	sub    $0x1c,%esp
   mb_module_t *module = NULL;
c040c85f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040c866:	00 
	unsigned int loop;

   for(loop = 0; loop < payload_modulemax; loop++)
c040c867:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040c86e:	00 
c040c86f:	eb 37                	jmp    c040c8a8 <payload_exist_here+0x4c>
   {
		module = payload_readmodule(loop);
c040c871:	83 ec 0c             	sub    $0xc,%esp
c040c874:	ff 74 24 18          	pushl  0x18(%esp)
c040c878:	e8 3f 00 00 00       	call   c040c8bc <payload_readmodule>
c040c87d:	83 c4 10             	add    $0x10,%esp
c040c880:	89 44 24 08          	mov    %eax,0x8(%esp)
		
      if(ptr >= module->mod_start && ptr < module->mod_end)
c040c884:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c888:	8b 00                	mov    (%eax),%eax
c040c88a:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040c88e:	77 14                	ja     c040c8a4 <payload_exist_here+0x48>
c040c890:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c894:	8b 40 04             	mov    0x4(%eax),%eax
c040c897:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040c89b:	76 07                	jbe    c040c8a4 <payload_exist_here+0x48>
         return e_payload_obj_here;
c040c89d:	b8 0e 00 00 00       	mov    $0xe,%eax
c040c8a2:	eb 14                	jmp    c040c8b8 <payload_exist_here+0x5c>
kresult payload_exist_here(unsigned int ptr)
{
   mb_module_t *module = NULL;
	unsigned int loop;

   for(loop = 0; loop < payload_modulemax; loop++)
c040c8a4:	ff 44 24 0c          	incl   0xc(%esp)
c040c8a8:	a1 f4 38 41 c0       	mov    0xc04138f4,%eax
c040c8ad:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c040c8b1:	72 be                	jb     c040c871 <payload_exist_here+0x15>
		
      if(ptr >= module->mod_start && ptr < module->mod_end)
         return e_payload_obj_here;
   }

   return success; /* fall through */
c040c8b3:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040c8b8:	83 c4 1c             	add    $0x1c,%esp
c040c8bb:	c3                   	ret    

c040c8bc <payload_readmodule>:
   Look up a module loaded with the kernel and return details about it.
   => modulenum = module number, 0 for first module
   <= pointer to multiboot module data or NULL for no more
*/
mb_module_t *payload_readmodule(unsigned int modulenum)
{
c040c8bc:	83 ec 1c             	sub    $0x1c,%esp
	mb_module_t *module = (mb_module_t *)mbd_ptr->mods_addr;
c040c8bf:	a1 f8 38 41 c0       	mov    0xc04138f8,%eax
c040c8c4:	8b 40 18             	mov    0x18(%eax),%eax
c040c8c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(!module)
c040c8cb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040c8d0:	75 12                	jne    c040c8e4 <payload_readmodule+0x28>
	{
		dprintf("*** trying to probe payloads before preinit - halting.\n");
c040c8d2:	83 ec 0c             	sub    $0xc,%esp
c040c8d5:	68 04 fc 40 c0       	push   $0xc040fc04
c040c8da:	e8 77 0b 00 00       	call   c040d456 <debug_printf>
c040c8df:	83 c4 10             	add    $0x10,%esp
		while(1);
c040c8e2:	eb fe                	jmp    c040c8e2 <payload_readmodule+0x26>
	}
	
	module = (mb_module_t *)((unsigned int)module + 
									 (sizeof(mb_module_t) * modulenum));
c040c8e4:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c8e8:	89 c2                	mov    %eax,%edx
c040c8ea:	c1 e2 04             	shl    $0x4,%edx
	{
		dprintf("*** trying to probe payloads before preinit - halting.\n");
		while(1);
	}
	
	module = (mb_module_t *)((unsigned int)module + 
c040c8ed:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c8f1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040c8f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
									 (sizeof(mb_module_t) * modulenum));
	
   return (mb_module_t *)KERNEL_PHYS2LOG(module);
c040c8f8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c8fc:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c040c901:	83 c4 1c             	add    $0x1c,%esp
c040c904:	c3                   	ret    

c040c905 <payload_parsemodule>:
   => module = pointer to structure describing the payload module to parse
      payload = pointer to payload info structure to fill in
   <= payload type or 0 for failure
*/
payload_type payload_parsemodule(mb_module_t *module, payload_descr *payload)
{
c040c905:	53                   	push   %ebx
c040c906:	83 ec 18             	sub    $0x18,%esp
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
c040c909:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c90d:	8b 00                	mov    (%eax),%eax
c040c90f:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c914:	89 04 24             	mov    %eax,(%esp)
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040c917:	8b 04 24             	mov    (%esp),%eax
c040c91a:	8a 00                	mov    (%eax),%al
c040c91c:	3c 4b                	cmp    $0x4b,%al
c040c91e:	0f 85 99 00 00 00    	jne    c040c9bd <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
c040c924:	8b 04 24             	mov    (%esp),%eax
c040c927:	40                   	inc    %eax
c040c928:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040c92a:	3c 53                	cmp    $0x53,%al
c040c92c:	0f 85 8b 00 00 00    	jne    c040c9bd <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
c040c932:	8b 04 24             	mov    (%esp),%eax
c040c935:	83 c0 02             	add    $0x2,%eax
c040c938:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040c93a:	3c 59                	cmp    $0x59,%al
c040c93c:	75 7f                	jne    c040c9bd <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
c040c93e:	8b 04 24             	mov    (%esp),%eax
c040c941:	83 c0 03             	add    $0x3,%eax
c040c944:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040c946:	3c 4d                	cmp    $0x4d,%al
c040c948:	75 73                	jne    c040c9bd <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      dprintf("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040c94a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c94e:	8b 48 04             	mov    0x4(%eax),%ecx
c040c951:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c955:	8b 10                	mov    (%eax),%edx
				  CPU_ID, module->mod_start, module->mod_end);
c040c957:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	if(magic[0] == 'K' &&
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      dprintf("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040c95c:	3c 01                	cmp    $0x1,%al
c040c95e:	76 0c                	jbe    c040c96c <payload_parsemodule+0x67>
				  CPU_ID, module->mod_start, module->mod_end);
c040c960:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c965:	8b 00                	mov    (%eax),%eax
	if(magic[0] == 'K' &&
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      dprintf("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040c967:	c1 e8 18             	shr    $0x18,%eax
c040c96a:	eb 08                	jmp    c040c974 <payload_parsemodule+0x6f>
c040c96c:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c971:	0f b6 c0             	movzbl %al,%eax
c040c974:	51                   	push   %ecx
c040c975:	52                   	push   %edx
c040c976:	50                   	push   %eax
c040c977:	68 3c fc 40 c0       	push   $0xc040fc3c
c040c97c:	e8 d5 0a 00 00       	call   c040d456 <debug_printf>
c040c981:	83 c4 10             	add    $0x10,%esp
				  CPU_ID, module->mod_start, module->mod_end);
      if(debug_init_sym_table((char *)((unsigned int)magic + (sizeof(char) * 5)),
										(char *)KERNEL_PHYS2LOG(module->mod_end)) == success)
c040c984:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c988:	8b 40 04             	mov    0x4(%eax),%eax
c040c98b:	2d 00 00 00 40       	sub    $0x40000000,%eax
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      dprintf("[payload:%i] found a kernel symbol table (%x - %x)\n",
				  CPU_ID, module->mod_start, module->mod_end);
      if(debug_init_sym_table((char *)((unsigned int)magic + (sizeof(char) * 5)),
c040c990:	89 c2                	mov    %eax,%edx
c040c992:	8b 04 24             	mov    (%esp),%eax
c040c995:	83 c0 05             	add    $0x5,%eax
c040c998:	83 ec 08             	sub    $0x8,%esp
c040c99b:	52                   	push   %edx
c040c99c:	50                   	push   %eax
c040c99d:	e8 fe 0a 00 00       	call   c040d4a0 <debug_init_sym_table>
c040c9a2:	83 c4 10             	add    $0x10,%esp
c040c9a5:	85 c0                	test   %eax,%eax
c040c9a7:	75 0a                	jne    c040c9b3 <payload_parsemodule+0xae>
										(char *)KERNEL_PHYS2LOG(module->mod_end)) == success)
			return payload_sym;
c040c9a9:	b8 02 00 00 00       	mov    $0x2,%eax
c040c9ae:	e9 34 02 00 00       	jmp    c040cbe7 <payload_parsemodule+0x2e2>
		else
			return payload_bad;
c040c9b3:	b8 00 00 00 00       	mov    $0x0,%eax
c040c9b8:	e9 2a 02 00 00       	jmp    c040cbe7 <payload_parsemodule+0x2e2>
   }
	
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
c040c9bd:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c9c1:	8b 00                	mov    (%eax),%eax
c040c9c3:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c9c8:	89 44 24 04          	mov    %eax,0x4(%esp)
   dprintf("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
c040c9cc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c9d0:	8b 40 08             	mov    0x8(%eax),%eax
c040c9d3:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040c9d8:	89 c2                	mov    %eax,%edx
c040c9da:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040c9df:	3c 01                	cmp    $0x1,%al
c040c9e1:	76 0c                	jbe    c040c9ef <payload_parsemodule+0xea>
c040c9e3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040c9e8:	8b 00                	mov    (%eax),%eax
c040c9ea:	c1 e8 18             	shr    $0x18,%eax
c040c9ed:	eb 08                	jmp    c040c9f7 <payload_parsemodule+0xf2>
c040c9ef:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040c9f4:	0f b6 c0             	movzbl %al,%eax
c040c9f7:	ff 74 24 04          	pushl  0x4(%esp)
c040c9fb:	52                   	push   %edx
c040c9fc:	50                   	push   %eax
c040c9fd:	68 70 fc 40 c0       	push   $0xc040fc70
c040ca02:	e8 4f 0a 00 00       	call   c040d456 <debug_printf>
c040ca07:	83 c4 10             	add    $0x10,%esp
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040ca0a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca0e:	8a 00                	mov    (%eax),%al
c040ca10:	3c 7f                	cmp    $0x7f,%al
c040ca12:	75 21                	jne    c040ca35 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
c040ca14:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca18:	8a 40 01             	mov    0x1(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   dprintf("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040ca1b:	3c 45                	cmp    $0x45,%al
c040ca1d:	75 16                	jne    c040ca35 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
c040ca1f:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca23:	8a 40 02             	mov    0x2(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   dprintf("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040ca26:	3c 4c                	cmp    $0x4c,%al
c040ca28:	75 0b                	jne    c040ca35 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
      fheader->e_ident[3] != 'F')
c040ca2a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca2e:	8a 40 03             	mov    0x3(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   dprintf("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040ca31:	3c 46                	cmp    $0x46,%al
c040ca33:	74 1a                	je     c040ca4f <payload_parsemodule+0x14a>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
      fheader->e_ident[3] != 'F')
   {
      dprintf(" ... is not a valid ELF\n");
c040ca35:	83 ec 0c             	sub    $0xc,%esp
c040ca38:	68 95 fc 40 c0       	push   $0xc040fc95
c040ca3d:	e8 14 0a 00 00       	call   c040d456 <debug_printf>
c040ca42:	83 c4 10             	add    $0x10,%esp
      return payload_bad;
c040ca45:	b8 00 00 00 00       	mov    $0x0,%eax
c040ca4a:	e9 98 01 00 00       	jmp    c040cbe7 <payload_parsemodule+0x2e2>
   }

   if(fheader->e_machine != EM_PORT)
c040ca4f:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca53:	66 8b 40 12          	mov    0x12(%eax),%ax
c040ca57:	66 83 f8 03          	cmp    $0x3,%ax
c040ca5b:	74 26                	je     c040ca83 <payload_parsemodule+0x17e>
   {
      dprintf(" ... is incompatible with this machine (%x)\n",
              fheader->e_machine);
c040ca5d:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca61:	66 8b 40 12          	mov    0x12(%eax),%ax
      return payload_bad;
   }

   if(fheader->e_machine != EM_PORT)
   {
      dprintf(" ... is incompatible with this machine (%x)\n",
c040ca65:	0f b7 c0             	movzwl %ax,%eax
c040ca68:	83 ec 08             	sub    $0x8,%esp
c040ca6b:	50                   	push   %eax
c040ca6c:	68 b0 fc 40 c0       	push   $0xc040fcb0
c040ca71:	e8 e0 09 00 00       	call   c040d456 <debug_printf>
c040ca76:	83 c4 10             	add    $0x10,%esp
              fheader->e_machine);
      return payload_bad;
c040ca79:	b8 00 00 00 00       	mov    $0x0,%eax
c040ca7e:	e9 64 01 00 00       	jmp    c040cbe7 <payload_parsemodule+0x2e2>
   }

   /* fill in some basic info about this module */
   payload->name = (char *)KERNEL_PHYS2LOG(module->string);
c040ca83:	8b 44 24 20          	mov    0x20(%esp),%eax
c040ca87:	8b 40 08             	mov    0x8(%eax),%eax
c040ca8a:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040ca8f:	89 c2                	mov    %eax,%edx
c040ca91:	8b 44 24 24          	mov    0x24(%esp),%eax
c040ca95:	89 50 2c             	mov    %edx,0x2c(%eax)
   payload->entry = (void *)fheader->e_entry;
c040ca98:	8b 44 24 04          	mov    0x4(%esp),%eax
c040ca9c:	8b 40 18             	mov    0x18(%eax),%eax
c040ca9f:	89 c2                	mov    %eax,%edx
c040caa1:	8b 44 24 24          	mov    0x24(%esp),%eax
c040caa5:	89 50 28             	mov    %edx,0x28(%eax)

   /* now inspect the various headers to pull out the code and data */
   if(fheader->e_phoff)
c040caa8:	8b 44 24 04          	mov    0x4(%esp),%eax
c040caac:	8b 40 1c             	mov    0x1c(%eax),%eax
c040caaf:	85 c0                	test   %eax,%eax
c040cab1:	0f 84 1b 01 00 00    	je     c040cbd2 <payload_parsemodule+0x2cd>
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
c040cab7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040cabe:	00 
c040cabf:	e9 fa 00 00 00       	jmp    c040cbbe <payload_parsemodule+0x2b9>
      {
         pheader = (Elf32_Phdr *)((unsigned int)fheader + fheader->e_phoff +
c040cac4:	8b 44 24 04          	mov    0x4(%esp),%eax
c040cac8:	8b 50 1c             	mov    0x1c(%eax),%edx
c040cacb:	8b 44 24 04          	mov    0x4(%esp),%eax
c040cacf:	01 c2                	add    %eax,%edx
                                  (p_loop * sizeof(Elf32_Phdr)));
c040cad1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040cad5:	c1 e0 05             	shl    $0x5,%eax
   if(fheader->e_phoff)
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
      {
         pheader = (Elf32_Phdr *)((unsigned int)fheader + fheader->e_phoff +
c040cad8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040cadb:	89 44 24 08          	mov    %eax,0x8(%esp)
                                  (p_loop * sizeof(Elf32_Phdr)));

         if(pheader->p_type == PT_LOAD)
c040cadf:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cae3:	8b 00                	mov    (%eax),%eax
c040cae5:	83 f8 01             	cmp    $0x1,%eax
c040cae8:	0f 85 cc 00 00 00    	jne    c040cbba <payload_parsemodule+0x2b5>
         {
            /* we expect two areas: code and then data, and nothing else */
            if(p_loop > PAYLOAD_DATA)
c040caee:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c040caf3:	7e 1a                	jle    c040cb0f <payload_parsemodule+0x20a>
            {
               dprintf(" ... has unexpected areas!\n");
c040caf5:	83 ec 0c             	sub    $0xc,%esp
c040caf8:	68 dd fc 40 c0       	push   $0xc040fcdd
c040cafd:	e8 54 09 00 00       	call   c040d456 <debug_printf>
c040cb02:	83 c4 10             	add    $0x10,%esp
               return payload_bad;
c040cb05:	b8 00 00 00 00       	mov    $0x0,%eax
c040cb0a:	e9 d8 00 00 00       	jmp    c040cbe7 <payload_parsemodule+0x2e2>
            }

            payload->areas[p_loop].virtual = (void *)pheader->p_vaddr;
c040cb0f:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c040cb13:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cb17:	8b 40 08             	mov    0x8(%eax),%eax
c040cb1a:	89 c1                	mov    %eax,%ecx
c040cb1c:	8b 54 24 24          	mov    0x24(%esp),%edx
c040cb20:	89 d8                	mov    %ebx,%eax
c040cb22:	c1 e0 02             	shl    $0x2,%eax
c040cb25:	01 d8                	add    %ebx,%eax
c040cb27:	c1 e0 02             	shl    $0x2,%eax
c040cb2a:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
            payload->areas[p_loop].physical = (void *)(pheader->p_offset +
c040cb2d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040cb31:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cb35:	8b 50 04             	mov    0x4(%eax),%edx
c040cb38:	8b 44 24 04          	mov    0x4(%esp),%eax
c040cb3c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040cb3f:	89 c2                	mov    %eax,%edx
c040cb41:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040cb45:	89 c8                	mov    %ecx,%eax
c040cb47:	c1 e0 02             	shl    $0x2,%eax
c040cb4a:	01 c8                	add    %ecx,%eax
c040cb4c:	c1 e0 02             	shl    $0x2,%eax
c040cb4f:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040cb52:	83 c0 04             	add    $0x4,%eax
c040cb55:	89 10                	mov    %edx,(%eax)
                                              (unsigned int)fheader);
            payload->areas[p_loop].size = pheader->p_filesz;
c040cb57:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040cb5b:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cb5f:	8b 50 10             	mov    0x10(%eax),%edx
c040cb62:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040cb66:	89 c8                	mov    %ecx,%eax
c040cb68:	c1 e0 02             	shl    $0x2,%eax
c040cb6b:	01 c8                	add    %ecx,%eax
c040cb6d:	c1 e0 02             	shl    $0x2,%eax
c040cb70:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040cb73:	83 c0 08             	add    $0x8,%eax
c040cb76:	89 10                	mov    %edx,(%eax)
            payload->areas[p_loop].memsize = pheader->p_memsz;
c040cb78:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040cb7c:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cb80:	8b 50 14             	mov    0x14(%eax),%edx
c040cb83:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040cb87:	89 c8                	mov    %ecx,%eax
c040cb89:	c1 e0 02             	shl    $0x2,%eax
c040cb8c:	01 c8                	add    %ecx,%eax
c040cb8e:	c1 e0 02             	shl    $0x2,%eax
c040cb91:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040cb94:	83 c0 0c             	add    $0xc,%eax
c040cb97:	89 10                	mov    %edx,(%eax)
            payload->areas[p_loop].flags = pheader->p_flags;
c040cb99:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040cb9d:	8b 44 24 08          	mov    0x8(%esp),%eax
c040cba1:	8b 50 18             	mov    0x18(%eax),%edx
c040cba4:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040cba8:	89 c8                	mov    %ecx,%eax
c040cbaa:	c1 e0 02             	shl    $0x2,%eax
c040cbad:	01 c8                	add    %ecx,%eax
c040cbaf:	c1 e0 02             	shl    $0x2,%eax
c040cbb2:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040cbb5:	83 c0 10             	add    $0x10,%eax
c040cbb8:	89 10                	mov    %edx,(%eax)

   /* now inspect the various headers to pull out the code and data */
   if(fheader->e_phoff)
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
c040cbba:	ff 44 24 0c          	incl   0xc(%esp)
c040cbbe:	8b 44 24 04          	mov    0x4(%esp),%eax
c040cbc2:	8b 40 2c             	mov    0x2c(%eax),%eax
c040cbc5:	0f b7 c0             	movzwl %ax,%eax
c040cbc8:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040cbcc:	0f 8f f2 fe ff ff    	jg     c040cac4 <payload_parsemodule+0x1bf>
            payload->areas[p_loop].flags = pheader->p_flags;
         }
      }
   }

   dprintf(" ... done\n");
c040cbd2:	83 ec 0c             	sub    $0xc,%esp
c040cbd5:	68 f9 fc 40 c0       	push   $0xc040fcf9
c040cbda:	e8 77 08 00 00       	call   c040d456 <debug_printf>
c040cbdf:	83 c4 10             	add    $0x10,%esp
   return payload_exe;
c040cbe2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040cbe7:	83 c4 18             	add    $0x18,%esp
c040cbea:	5b                   	pop    %ebx
c040cbeb:	c3                   	ret    

c040cbec <payload_preinit>:
   to be rather dull with just the microkernel present.
   => mbd = pointer to multiboot info in physical memory
   <= 0 for success, or result code
*/
kresult payload_preinit(multiboot_info_t *mbd)
{	
c040cbec:	83 ec 0c             	sub    $0xc,%esp
	mbd = (multiboot_info_t *)KERNEL_PHYS2LOG(mbd);
c040cbef:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cbf3:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040cbf8:	89 44 24 10          	mov    %eax,0x10(%esp)

   /* keep a copy of the multiboot info pointer */
   mbd_ptr = mbd;
c040cbfc:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cc00:	a3 f8 38 41 c0       	mov    %eax,0xc04138f8

   /* bit 3 indicates modules loaded, although we must also check mods_count */
   if(!((mbd->flags & (1<<3)) && mbd->mods_count))
c040cc05:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cc09:	8b 00                	mov    (%eax),%eax
c040cc0b:	83 e0 08             	and    $0x8,%eax
c040cc0e:	85 c0                	test   %eax,%eax
c040cc10:	74 0b                	je     c040cc1d <payload_preinit+0x31>
c040cc12:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cc16:	8b 40 14             	mov    0x14(%eax),%eax
c040cc19:	85 c0                	test   %eax,%eax
c040cc1b:	75 35                	jne    c040cc52 <payload_preinit+0x66>
   {
      dprintf("[payload:%i] No modules loaded with kernel.\n", CPU_ID);
c040cc1d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040cc22:	3c 01                	cmp    $0x1,%al
c040cc24:	76 0c                	jbe    c040cc32 <payload_preinit+0x46>
c040cc26:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040cc2b:	8b 00                	mov    (%eax),%eax
c040cc2d:	c1 e8 18             	shr    $0x18,%eax
c040cc30:	eb 08                	jmp    c040cc3a <payload_preinit+0x4e>
c040cc32:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040cc37:	0f b6 c0             	movzbl %al,%eax
c040cc3a:	83 ec 08             	sub    $0x8,%esp
c040cc3d:	50                   	push   %eax
c040cc3e:	68 04 fd 40 c0       	push   $0xc040fd04
c040cc43:	e8 0e 08 00 00       	call   c040d456 <debug_printf>
c040cc48:	83 c4 10             	add    $0x10,%esp
      return e_payload_missing;
c040cc4b:	b8 0f 00 00 00       	mov    $0xf,%eax
c040cc50:	eb 47                	jmp    c040cc99 <payload_preinit+0xad>
   }

   dprintf("[payload:%i] %i module(s) in payload\n",
c040cc52:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cc56:	8b 50 14             	mov    0x14(%eax),%edx
           CPU_ID, mbd->mods_count);
c040cc59:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
   {
      dprintf("[payload:%i] No modules loaded with kernel.\n", CPU_ID);
      return e_payload_missing;
   }

   dprintf("[payload:%i] %i module(s) in payload\n",
c040cc5e:	3c 01                	cmp    $0x1,%al
c040cc60:	76 0c                	jbe    c040cc6e <payload_preinit+0x82>
           CPU_ID, mbd->mods_count);
c040cc62:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040cc67:	8b 00                	mov    (%eax),%eax
   {
      dprintf("[payload:%i] No modules loaded with kernel.\n", CPU_ID);
      return e_payload_missing;
   }

   dprintf("[payload:%i] %i module(s) in payload\n",
c040cc69:	c1 e8 18             	shr    $0x18,%eax
c040cc6c:	eb 08                	jmp    c040cc76 <payload_preinit+0x8a>
c040cc6e:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040cc73:	0f b6 c0             	movzbl %al,%eax
c040cc76:	83 ec 04             	sub    $0x4,%esp
c040cc79:	52                   	push   %edx
c040cc7a:	50                   	push   %eax
c040cc7b:	68 34 fd 40 c0       	push   $0xc040fd34
c040cc80:	e8 d1 07 00 00       	call   c040d456 <debug_printf>
c040cc85:	83 c4 10             	add    $0x10,%esp
           CPU_ID, mbd->mods_count);

	payload_modulemax = mbd->mods_count;
c040cc88:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cc8c:	8b 40 14             	mov    0x14(%eax),%eax
c040cc8f:	a3 f4 38 41 c0       	mov    %eax,0xc04138f4
	
   return success;
c040cc94:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040cc99:	83 c4 0c             	add    $0xc,%esp
c040cc9c:	c3                   	ret    
c040cc9d:	00 00                	add    %al,(%eax)
	...

c040cca0 <serial_writebyte>:
/* serial_writebyte
   Write a byte out out to the serial port
   => c = character to output
*/
void serial_writebyte(unsigned char c)
{
c040cca0:	83 ec 1c             	sub    $0x1c,%esp
c040cca3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040cca7:	88 44 24 0c          	mov    %al,0xc(%esp)
   /* loop waiting for bit 5 of the line status register to set, indicating
      data can be written */
   while((x86_inportb(SERIAL_HW + 5) & 0x20) == 0) __asm__ __volatile("pause");
c040ccab:	eb 02                	jmp    c040ccaf <serial_writebyte+0xf>
c040ccad:	f3 90                	pause  
c040ccaf:	83 ec 0c             	sub    $0xc,%esp
c040ccb2:	68 fd 03 00 00       	push   $0x3fd
c040ccb7:	e8 ad 3a ff ff       	call   c0400769 <x86_inportb>
c040ccbc:	83 c4 10             	add    $0x10,%esp
c040ccbf:	83 e0 20             	and    $0x20,%eax
c040ccc2:	85 c0                	test   %eax,%eax
c040ccc4:	74 e7                	je     c040ccad <serial_writebyte+0xd>
   x86_outportb(SERIAL_HW + 0, c);
c040ccc6:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040cccb:	83 ec 08             	sub    $0x8,%esp
c040ccce:	50                   	push   %eax
c040cccf:	68 f8 03 00 00       	push   $0x3f8
c040ccd4:	e8 ae 3a ff ff       	call   c0400787 <x86_outportb>
c040ccd9:	83 c4 10             	add    $0x10,%esp
}
c040ccdc:	83 c4 1c             	add    $0x1c,%esp
c040ccdf:	c3                   	ret    

c040cce0 <serial_initialise>:

/* serial_initialise
   Start up the serial debugging output */
void serial_initialise(void)
{
c040cce0:	83 ec 0c             	sub    $0xc,%esp
   /* set baud, etc */
   x86_outportb(SERIAL_HW + 3, 0x80);
c040cce3:	83 ec 08             	sub    $0x8,%esp
c040cce6:	68 80 00 00 00       	push   $0x80
c040cceb:	68 fb 03 00 00       	push   $0x3fb
c040ccf0:	e8 92 3a ff ff       	call   c0400787 <x86_outportb>
c040ccf5:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 0, 0x30);
c040ccf8:	83 ec 08             	sub    $0x8,%esp
c040ccfb:	6a 30                	push   $0x30
c040ccfd:	68 f8 03 00 00       	push   $0x3f8
c040cd02:	e8 80 3a ff ff       	call   c0400787 <x86_outportb>
c040cd07:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 1, 0x00);
c040cd0a:	83 ec 08             	sub    $0x8,%esp
c040cd0d:	6a 00                	push   $0x0
c040cd0f:	68 f9 03 00 00       	push   $0x3f9
c040cd14:	e8 6e 3a ff ff       	call   c0400787 <x86_outportb>
c040cd19:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 3, 0x03);
c040cd1c:	83 ec 08             	sub    $0x8,%esp
c040cd1f:	6a 03                	push   $0x3
c040cd21:	68 fb 03 00 00       	push   $0x3fb
c040cd26:	e8 5c 3a ff ff       	call   c0400787 <x86_outportb>
c040cd2b:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 4, 0x00);
c040cd2e:	83 ec 08             	sub    $0x8,%esp
c040cd31:	6a 00                	push   $0x0
c040cd33:	68 fc 03 00 00       	push   $0x3fc
c040cd38:	e8 4a 3a ff ff       	call   c0400787 <x86_outportb>
c040cd3d:	83 c4 10             	add    $0x10,%esp
   x86_inportb(SERIAL_HW);
c040cd40:	83 ec 0c             	sub    $0xc,%esp
c040cd43:	68 f8 03 00 00       	push   $0x3f8
c040cd48:	e8 1c 3a ff ff       	call   c0400769 <x86_inportb>
c040cd4d:	83 c4 10             	add    $0x10,%esp
}
c040cd50:	83 c4 0c             	add    $0xc,%esp
c040cd53:	c3                   	ret    

c040cd54 <debug_writebyte>:
   Write a byte out to the debugging output stream, usually a serial port
   => c = character to write
      ptr = unused
*/
static int debug_writebyte(unsigned c, void **ptr)
{
c040cd54:	83 ec 0c             	sub    $0xc,%esp
   serial_writebyte(c); /* port-specific */
c040cd57:	8b 44 24 10          	mov    0x10(%esp),%eax
c040cd5b:	0f b6 c0             	movzbl %al,%eax
c040cd5e:	83 ec 0c             	sub    $0xc,%esp
c040cd61:	50                   	push   %eax
c040cd62:	e8 39 ff ff ff       	call   c040cca0 <serial_writebyte>
c040cd67:	83 c4 10             	add    $0x10,%esp
   return 0;
c040cd6a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040cd6f:	83 c4 0c             	add    $0xc,%esp
c040cd72:	c3                   	ret    

c040cd73 <debug_stacktrace>:

/* debug_stacktrace
   Dump a copy of the current kernel stack in a not-so-pretty way */
void debug_stacktrace(void)
{
c040cd73:	53                   	push   %ebx
c040cd74:	83 ec 48             	sub    $0x48,%esp
	unsigned int *ptr, *base, sym_base;
	unsigned int tid, pid;
	char buffer[32];
	
	/* first, work out where the stack starts */
	if(cpu_table[CPU_ID].current)
c040cd77:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040cd7d:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040cd82:	3c 01                	cmp    $0x1,%al
c040cd84:	76 0f                	jbe    c040cd95 <debug_stacktrace+0x22>
c040cd86:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040cd8b:	8b 00                	mov    (%eax),%eax
c040cd8d:	c1 e8 18             	shr    $0x18,%eax
c040cd90:	c1 e0 06             	shl    $0x6,%eax
c040cd93:	eb 0b                	jmp    c040cda0 <debug_stacktrace+0x2d>
c040cd95:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040cd9a:	0f b6 c0             	movzbl %al,%eax
c040cd9d:	c1 e0 06             	shl    $0x6,%eax
c040cda0:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040cda3:	8b 40 04             	mov    0x4(%eax),%eax
c040cda6:	85 c0                	test   %eax,%eax
c040cda8:	0f 84 a5 00 00 00    	je     c040ce53 <debug_stacktrace+0xe0>
	{
		/* we're running threads, so find the current thread's kernel
		   stack base */
		base = (unsigned int *)cpu_table[CPU_ID].current->tss.esp0;
c040cdae:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040cdb4:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040cdb9:	3c 01                	cmp    $0x1,%al
c040cdbb:	76 0f                	jbe    c040cdcc <debug_stacktrace+0x59>
c040cdbd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040cdc2:	8b 00                	mov    (%eax),%eax
c040cdc4:	c1 e8 18             	shr    $0x18,%eax
c040cdc7:	c1 e0 06             	shl    $0x6,%eax
c040cdca:	eb 0b                	jmp    c040cdd7 <debug_stacktrace+0x64>
c040cdcc:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040cdd1:	0f b6 c0             	movzbl %al,%eax
c040cdd4:	c1 e0 06             	shl    $0x6,%eax
c040cdd7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040cdda:	8b 40 04             	mov    0x4(%eax),%eax
c040cddd:	8b 40 3c             	mov    0x3c(%eax),%eax
c040cde0:	89 44 24 34          	mov    %eax,0x34(%esp)
		tid = cpu_table[CPU_ID].current->tid;
c040cde4:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040cdea:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040cdef:	3c 01                	cmp    $0x1,%al
c040cdf1:	76 0f                	jbe    c040ce02 <debug_stacktrace+0x8f>
c040cdf3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040cdf8:	8b 00                	mov    (%eax),%eax
c040cdfa:	c1 e8 18             	shr    $0x18,%eax
c040cdfd:	c1 e0 06             	shl    $0x6,%eax
c040ce00:	eb 0b                	jmp    c040ce0d <debug_stacktrace+0x9a>
c040ce02:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040ce07:	0f b6 c0             	movzbl %al,%eax
c040ce0a:	c1 e0 06             	shl    $0x6,%eax
c040ce0d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040ce10:	8b 40 04             	mov    0x4(%eax),%eax
c040ce13:	8b 40 04             	mov    0x4(%eax),%eax
c040ce16:	89 44 24 38          	mov    %eax,0x38(%esp)
		pid = cpu_table[CPU_ID].current->proc->pid;
c040ce1a:	8b 15 e4 38 41 c0    	mov    0xc04138e4,%edx
c040ce20:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
c040ce25:	3c 01                	cmp    $0x1,%al
c040ce27:	76 0f                	jbe    c040ce38 <debug_stacktrace+0xc5>
c040ce29:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040ce2e:	8b 00                	mov    (%eax),%eax
c040ce30:	c1 e8 18             	shr    $0x18,%eax
c040ce33:	c1 e0 06             	shl    $0x6,%eax
c040ce36:	eb 0b                	jmp    c040ce43 <debug_stacktrace+0xd0>
c040ce38:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040ce3d:	0f b6 c0             	movzbl %al,%eax
c040ce40:	c1 e0 06             	shl    $0x6,%eax
c040ce43:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040ce46:	8b 40 04             	mov    0x4(%eax),%eax
c040ce49:	8b 00                	mov    (%eax),%eax
c040ce4b:	8b 00                	mov    (%eax),%eax
c040ce4d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c040ce51:	eb 18                	jmp    c040ce6b <debug_stacktrace+0xf8>
	}
	else
	{
		/* kernel is still booting and using the initial stack */
		base = (unsigned int *)&(KernelBootStackBase);
c040ce53:	c7 44 24 34 bc 38 41 	movl   $0xc04138bc,0x34(%esp)
c040ce5a:	c0 
		tid = pid = 0;
c040ce5b:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
c040ce62:	00 
c040ce63:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040ce67:	89 44 24 38          	mov    %eax,0x38(%esp)
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
c040ce6b:	89 e0                	mov    %esp,%eax
c040ce6d:	89 44 24 30          	mov    %eax,0x30(%esp)
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040ce71:	8b 54 24 34          	mov    0x34(%esp),%edx
c040ce75:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ce79:	29 c2                	sub    %eax,%edx
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);
c040ce7b:	a0 f0 38 41 c0       	mov    0xc04138f0,%al
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040ce80:	3c 01                	cmp    $0x1,%al
c040ce82:	76 0c                	jbe    c040ce90 <debug_stacktrace+0x11d>
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);
c040ce84:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040ce89:	8b 00                	mov    (%eax),%eax
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040ce8b:	c1 e8 18             	shr    $0x18,%eax
c040ce8e:	eb 08                	jmp    c040ce98 <debug_stacktrace+0x125>
c040ce90:	a0 f1 38 41 c0       	mov    0xc04138f1,%al
c040ce95:	0f b6 c0             	movzbl %al,%eax
c040ce98:	83 ec 04             	sub    $0x4,%esp
c040ce9b:	ff 74 24 40          	pushl  0x40(%esp)
c040ce9f:	ff 74 24 40          	pushl  0x40(%esp)
c040cea3:	52                   	push   %edx
c040cea4:	ff 74 24 40          	pushl  0x40(%esp)
c040cea8:	ff 74 24 48          	pushl  0x48(%esp)
c040ceac:	50                   	push   %eax
c040cead:	68 5c fd 40 c0       	push   $0xc040fd5c
c040ceb2:	e8 9f 05 00 00       	call   c040d456 <debug_printf>
c040ceb7:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);

	while(base >= ptr)
c040ceba:	e9 81 00 00 00       	jmp    c040cf40 <debug_stacktrace+0x1cd>
	{
		/* look up a kernel symbol if relevant */
		if((*(base) >= KERNEL_VIRTUAL_BASE) && (*(base) < KERNEL_VIRTUAL_END))
c040cebf:	8b 44 24 34          	mov    0x34(%esp),%eax
c040cec3:	8b 00                	mov    (%eax),%eax
c040cec5:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c040ceca:	76 6f                	jbe    c040cf3b <debug_stacktrace+0x1c8>
c040cecc:	8b 44 24 34          	mov    0x34(%esp),%eax
c040ced0:	8b 00                	mov    (%eax),%eax
c040ced2:	b9 08 39 41 c0       	mov    $0xc0413908,%ecx
c040ced7:	ba 00 00 40 c0       	mov    $0xc0400000,%edx
c040cedc:	89 cb                	mov    %ecx,%ebx
c040cede:	29 d3                	sub    %edx,%ebx
c040cee0:	89 da                	mov    %ebx,%edx
c040cee2:	c1 fa 02             	sar    $0x2,%edx
c040cee5:	81 ea 00 00 c0 3f    	sub    $0x3fc00000,%edx
c040ceeb:	39 d0                	cmp    %edx,%eax
c040ceed:	73 4c                	jae    c040cf3b <debug_stacktrace+0x1c8>
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
c040ceef:	8b 44 24 34          	mov    0x34(%esp),%eax
c040cef3:	8b 00                	mov    (%eax),%eax
c040cef5:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c040cef9:	52                   	push   %edx
c040cefa:	6a 20                	push   $0x20
c040cefc:	8d 54 24 14          	lea    0x14(%esp),%edx
c040cf00:	52                   	push   %edx
c040cf01:	50                   	push   %eax
c040cf02:	e8 03 08 00 00       	call   c040d70a <debug_lookup_symbol>
c040cf07:	83 c4 10             	add    $0x10,%esp
c040cf0a:	85 c0                	test   %eax,%eax
c040cf0c:	75 2d                	jne    c040cf3b <debug_stacktrace+0x1c8>
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
						  base, *(base), buffer, (*base) - sym_base);
c040cf0e:	8b 44 24 34          	mov    0x34(%esp),%eax
c040cf12:	8b 10                	mov    (%eax),%edx
	while(base >= ptr)
	{
		/* look up a kernel symbol if relevant */
		if((*(base) >= KERNEL_VIRTUAL_BASE) && (*(base) < KERNEL_VIRTUAL_END))
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
c040cf14:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040cf18:	29 c2                	sub    %eax,%edx
c040cf1a:	8b 44 24 34          	mov    0x34(%esp),%eax
c040cf1e:	8b 00                	mov    (%eax),%eax
c040cf20:	83 ec 0c             	sub    $0xc,%esp
c040cf23:	52                   	push   %edx
c040cf24:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c040cf28:	52                   	push   %edx
c040cf29:	50                   	push   %eax
c040cf2a:	ff 74 24 4c          	pushl  0x4c(%esp)
c040cf2e:	68 b8 fd 40 c0       	push   $0xc040fdb8
c040cf33:	e8 1e 05 00 00       	call   c040d456 <debug_printf>
c040cf38:	83 c4 20             	add    $0x20,%esp
						  base, *(base), buffer, (*base) - sym_base);
		base--;
c040cf3b:	83 6c 24 34 04       	subl   $0x4,0x34(%esp)
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);

	while(base >= ptr)
c040cf40:	8b 44 24 34          	mov    0x34(%esp),%eax
c040cf44:	3b 44 24 30          	cmp    0x30(%esp),%eax
c040cf48:	0f 83 71 ff ff ff    	jae    c040cebf <debug_stacktrace+0x14c>
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
						  base, *(base), buffer, (*base) - sym_base);
		base--;
	}
	dprintf("\n");
c040cf4e:	83 ec 0c             	sub    $0xc,%esp
c040cf51:	68 df fd 40 c0       	push   $0xc040fddf
c040cf56:	e8 fb 04 00 00       	call   c040d456 <debug_printf>
c040cf5b:	83 c4 10             	add    $0x10,%esp
#endif
}
c040cf5e:	83 c4 48             	add    $0x48,%esp
c040cf61:	5b                   	pop    %ebx
c040cf62:	c3                   	ret    

c040cf63 <debug_assert>:

/* debug_assert
 Report an assert() failure and halt. Code taken from: 
 http://www.acm.uiuc.edu/sigops/roll_your_own/2.a.html */
void debug_assert(char *exp, char *file, char *basefile, unsigned int line)
{
c040cf63:	83 ec 0c             	sub    $0xc,%esp
	debug_printf("[debug] assert(%s) failed in file %s (included from %s), line %d\n"
c040cf66:	83 ec 0c             	sub    $0xc,%esp
c040cf69:	ff 74 24 28          	pushl  0x28(%esp)
c040cf6d:	ff 74 24 28          	pushl  0x28(%esp)
c040cf71:	ff 74 24 28          	pushl  0x28(%esp)
c040cf75:	ff 74 24 28          	pushl  0x28(%esp)
c040cf79:	68 e4 fd 40 c0       	push   $0xc040fde4
c040cf7e:	e8 d3 04 00 00       	call   c040d456 <debug_printf>
c040cf83:	83 c4 20             	add    $0x20,%esp
					 "*** halting.\n", exp, file, basefile, line);
	while(1);
c040cf86:	eb fe                	jmp    c040cf86 <debug_assert+0x23>

c040cf88 <strlen>:
   ANSI strlen() implementation
   => str = nul-terminated string to calculate length of
   <= number of characters
*/
unsigned int strlen(const unsigned char *str)
{
c040cf88:	83 ec 10             	sub    $0x10,%esp
   unsigned int ret_val;

   for(ret_val = 0; *str != '\0'; str++)
c040cf8b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040cf92:	00 
c040cf93:	eb 08                	jmp    c040cf9d <strlen+0x15>
      ret_val++;
c040cf95:	ff 44 24 0c          	incl   0xc(%esp)
*/
unsigned int strlen(const unsigned char *str)
{
   unsigned int ret_val;

   for(ret_val = 0; *str != '\0'; str++)
c040cf99:	ff 44 24 14          	incl   0x14(%esp)
c040cf9d:	8b 44 24 14          	mov    0x14(%esp),%eax
c040cfa1:	8a 00                	mov    (%eax),%al
c040cfa3:	84 c0                	test   %al,%al
c040cfa5:	75 ee                	jne    c040cf95 <strlen+0xd>
      ret_val++;
   return ret_val;
c040cfa7:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040cfab:	83 c4 10             	add    $0x10,%esp
c040cfae:	c3                   	ret    

c040cfaf <debug_do_printf>:
      fn = function to call with arg 'ptr' for each character to be output
           ie: fn(character, ptr);
   <= total number of characters output
*/
static int debug_do_printf(const char *fmt, va_list args, fnptr_t fn, void *ptr)
{
c040cfaf:	83 ec 4c             	sub    $0x4c,%esp
   unsigned state, flags, radix, actual_wd, count, given_wd;
   unsigned char *where, buf[PR_BUFLEN];
   long num;

   state = flags = count = given_wd = 0;
c040cfb2:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040cfb9:	00 
c040cfba:	8b 44 24 30          	mov    0x30(%esp),%eax
c040cfbe:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c040cfc2:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040cfc6:	89 44 24 20          	mov    %eax,0x20(%esp)
c040cfca:	8b 44 24 20          	mov    0x20(%esp),%eax
c040cfce:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   /* begin scanning format specifier list */
   for(; *fmt; fmt++)
c040cfd2:	e9 69 04 00 00       	jmp    c040d440 <debug_do_printf+0x491>
   {
      switch(state)
c040cfd7:	83 7c 24 1c 04       	cmpl   $0x4,0x1c(%esp)
c040cfdc:	0f 87 3f 04 00 00    	ja     c040d421 <debug_do_printf+0x472>
c040cfe2:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040cfe6:	c1 e0 02             	shl    $0x2,%eax
c040cfe9:	8b 80 34 fe 40 c0    	mov    -0x3fbf01cc(%eax),%eax
c040cfef:	ff e0                	jmp    *%eax
      {
         /* STATE 0: AWAITING % */
         case 0:
            if(*fmt != '%')     /* not %... */
c040cff1:	8b 44 24 50          	mov    0x50(%esp),%eax
c040cff5:	8a 00                	mov    (%eax),%al
c040cff7:	3c 25                	cmp    $0x25,%al
c040cff9:	74 24                	je     c040d01f <debug_do_printf+0x70>
            {
               fn(*fmt, &ptr);  /* ...just echo it */
c040cffb:	8b 44 24 50          	mov    0x50(%esp),%eax
c040cfff:	8a 00                	mov    (%eax),%al
c040d001:	0f be c0             	movsbl %al,%eax
c040d004:	83 ec 08             	sub    $0x8,%esp
c040d007:	8d 54 24 64          	lea    0x64(%esp),%edx
c040d00b:	52                   	push   %edx
c040d00c:	50                   	push   %eax
c040d00d:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d011:	ff d0                	call   *%eax
c040d013:	83 c4 10             	add    $0x10,%esp
               count++;
c040d016:	ff 44 24 2c          	incl   0x2c(%esp)
               break;
c040d01a:	e9 1d 04 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }
            /* found %, get next char and advance state to check if
               next char is a flag */
            state++;
c040d01f:	ff 44 24 1c          	incl   0x1c(%esp)
            fmt++;
c040d023:	ff 44 24 50          	incl   0x50(%esp)
            /* FALL THROUGH */

         /* STATE 1: AWAITING FLAGS (%-0) */
         case 1:
            if(*fmt == '%')     /* %% */
c040d027:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d02b:	8a 00                	mov    (%eax),%al
c040d02d:	3c 25                	cmp    $0x25,%al
c040d02f:	75 3c                	jne    c040d06d <debug_do_printf+0xbe>
            {
               fn(*fmt, &ptr);
c040d031:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d035:	8a 00                	mov    (%eax),%al
c040d037:	0f be c0             	movsbl %al,%eax
c040d03a:	83 ec 08             	sub    $0x8,%esp
c040d03d:	8d 54 24 64          	lea    0x64(%esp),%edx
c040d041:	52                   	push   %edx
c040d042:	50                   	push   %eax
c040d043:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d047:	ff d0                	call   *%eax
c040d049:	83 c4 10             	add    $0x10,%esp
               count++;
c040d04c:	ff 44 24 2c          	incl   0x2c(%esp)
               state = flags = given_wd = 0;
c040d050:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040d057:	00 
c040d058:	8b 44 24 30          	mov    0x30(%esp),%eax
c040d05c:	89 44 24 20          	mov    %eax,0x20(%esp)
c040d060:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d064:	89 44 24 1c          	mov    %eax,0x1c(%esp)
               break;
c040d068:	e9 cf 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }
            if(*fmt == '-')
c040d06d:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d071:	8a 00                	mov    (%eax),%al
c040d073:	3c 2d                	cmp    $0x2d,%al
c040d075:	75 32                	jne    c040d0a9 <debug_do_printf+0xfa>
            {
               if(flags & PR_LJ)/* %-- is illegal */
c040d077:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d07b:	83 e0 01             	and    $0x1,%eax
c040d07e:	84 c0                	test   %al,%al
c040d080:	74 1d                	je     c040d09f <debug_do_printf+0xf0>
                  state = flags = given_wd = 0;
c040d082:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040d089:	00 
c040d08a:	8b 44 24 30          	mov    0x30(%esp),%eax
c040d08e:	89 44 24 20          	mov    %eax,0x20(%esp)
c040d092:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d096:	89 44 24 1c          	mov    %eax,0x1c(%esp)
               else
                  flags |= PR_LJ;
               break;
c040d09a:	e9 9d 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            if(*fmt == '-')
            {
               if(flags & PR_LJ)/* %-- is illegal */
                  state = flags = given_wd = 0;
               else
                  flags |= PR_LJ;
c040d09f:	83 4c 24 20 01       	orl    $0x1,0x20(%esp)
               break;
c040d0a4:	e9 93 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }

            /* not a flag char: advance state to check if it's field width */
            state++;
c040d0a9:	ff 44 24 1c          	incl   0x1c(%esp)

            /* check now for '%0...' */
            if(*fmt == '0')
c040d0ad:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d0b1:	8a 00                	mov    (%eax),%al
c040d0b3:	3c 30                	cmp    $0x30,%al
c040d0b5:	75 09                	jne    c040d0c0 <debug_do_printf+0x111>
            {
               flags |= PR_LZ;
c040d0b7:	83 4c 24 20 40       	orl    $0x40,0x20(%esp)
               fmt++;
c040d0bc:	ff 44 24 50          	incl   0x50(%esp)
            }
            /* FALL THROUGH */

         /* STATE 2: AWAITING (NUMERIC) FIELD WIDTH */
         case 2:
            if(*fmt >= '0' && *fmt <= '9')
c040d0c0:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d0c4:	8a 00                	mov    (%eax),%al
c040d0c6:	3c 2f                	cmp    $0x2f,%al
c040d0c8:	7e 31                	jle    c040d0fb <debug_do_printf+0x14c>
c040d0ca:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d0ce:	8a 00                	mov    (%eax),%al
c040d0d0:	3c 39                	cmp    $0x39,%al
c040d0d2:	7f 27                	jg     c040d0fb <debug_do_printf+0x14c>
            {
               given_wd = 10 * given_wd + (*fmt - '0');
c040d0d4:	8b 54 24 30          	mov    0x30(%esp),%edx
c040d0d8:	89 d0                	mov    %edx,%eax
c040d0da:	c1 e0 02             	shl    $0x2,%eax
c040d0dd:	01 d0                	add    %edx,%eax
c040d0df:	d1 e0                	shl    %eax
c040d0e1:	89 c2                	mov    %eax,%edx
c040d0e3:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d0e7:	8a 00                	mov    (%eax),%al
c040d0e9:	0f be c0             	movsbl %al,%eax
c040d0ec:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040d0ef:	83 e8 30             	sub    $0x30,%eax
c040d0f2:	89 44 24 30          	mov    %eax,0x30(%esp)
               break;
c040d0f6:	e9 41 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }

            /* not field width: advance state to check if it's a modifier */
            state++;
c040d0fb:	ff 44 24 1c          	incl   0x1c(%esp)

            /* FALL THROUGH */
         /* STATE 3: AWAITING MODIFIER CHARS (FNlh) */
         case 3:
            if(*fmt == 'F')
c040d0ff:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d103:	8a 00                	mov    (%eax),%al
c040d105:	3c 46                	cmp    $0x46,%al
c040d107:	75 0d                	jne    c040d116 <debug_do_printf+0x167>
            {
               flags |= PR_FP;
c040d109:	81 4c 24 20 80 00 00 	orl    $0x80,0x20(%esp)
c040d110:	00 
               break;
c040d111:	e9 26 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }
            if(*fmt == 'N') break;
c040d116:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d11a:	8a 00                	mov    (%eax),%al
c040d11c:	3c 4e                	cmp    $0x4e,%al
c040d11e:	0f 84 17 03 00 00    	je     c040d43b <debug_do_printf+0x48c>
            if(*fmt == 'l')
c040d124:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d128:	8a 00                	mov    (%eax),%al
c040d12a:	3c 6c                	cmp    $0x6c,%al
c040d12c:	75 0a                	jne    c040d138 <debug_do_printf+0x189>
            {
               flags |= PR_32;
c040d12e:	83 4c 24 20 08       	orl    $0x8,0x20(%esp)
               break;
c040d133:	e9 04 03 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }
            if(*fmt == 'h')
c040d138:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d13c:	8a 00                	mov    (%eax),%al
c040d13e:	3c 68                	cmp    $0x68,%al
c040d140:	75 0a                	jne    c040d14c <debug_do_printf+0x19d>
            {
               flags |= PR_16;
c040d142:	83 4c 24 20 10       	orl    $0x10,0x20(%esp)
               break;
c040d147:	e9 f0 02 00 00       	jmp    c040d43c <debug_do_printf+0x48d>
            }

            /* not modifier: advance state to check if it's a conversion char */
            state++;
c040d14c:	ff 44 24 1c          	incl   0x1c(%esp)
            /* FALL THROUGH */

         /* STATE 4: AWAITING CONVERSION CHARS (Xxpndiuocs) */
         case 4:
            where = buf + PR_BUFLEN - 1;
c040d150:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040d154:	83 c0 0f             	add    $0xf,%eax
c040d157:	89 44 24 34          	mov    %eax,0x34(%esp)
            *where = '\0';
c040d15b:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d15f:	c6 00 00             	movb   $0x0,(%eax)
            switch(*fmt)
c040d162:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d166:	8a 00                	mov    (%eax),%al
c040d168:	0f be c0             	movsbl %al,%eax
c040d16b:	83 e8 58             	sub    $0x58,%eax
c040d16e:	83 f8 20             	cmp    $0x20,%eax
c040d171:	0f 87 aa 02 00 00    	ja     c040d421 <debug_do_printf+0x472>
c040d177:	8b 04 85 48 fe 40 c0 	mov    -0x3fbf01b8(,%eax,4),%eax
c040d17e:	ff e0                	jmp    *%eax
            {
               case 'X':
                  flags |= PR_CA;
c040d180:	83 4c 24 20 02       	orl    $0x2,0x20(%esp)
                  /* FALL THROUGH */
               /* xxx - far pointers (%Fp, %Fn) not yet supported */
               case 'x':
               case 'p':
               case 'n':
                  radix = 16;
c040d185:	c7 44 24 24 10 00 00 	movl   $0x10,0x24(%esp)
c040d18c:	00 
                  goto DO_NUM;
c040d18d:	eb 17                	jmp    c040d1a6 <debug_do_printf+0x1f7>
               case 'd':
               case 'i':
                  flags |= PR_SG;
c040d18f:	83 4c 24 20 04       	orl    $0x4,0x20(%esp)
                  /* FALL THROUGH */
               case 'u':
                  radix = 10;
c040d194:	c7 44 24 24 0a 00 00 	movl   $0xa,0x24(%esp)
c040d19b:	00 
                  goto DO_NUM;
c040d19c:	eb 08                	jmp    c040d1a6 <debug_do_printf+0x1f7>
               case 'o':
                  radix = 8;
c040d19e:	c7 44 24 24 08 00 00 	movl   $0x8,0x24(%esp)
c040d1a5:	00 

/* load the value to be printed. l=long=32 bits: */
DO_NUM:          if(flags & PR_32)
c040d1a6:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d1aa:	83 e0 08             	and    $0x8,%eax
c040d1ad:	85 c0                	test   %eax,%eax
c040d1af:	74 14                	je     c040d1c5 <debug_do_printf+0x216>
                     num = va_arg(args, unsigned long);
c040d1b1:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d1b6:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d1ba:	83 e8 04             	sub    $0x4,%eax
c040d1bd:	8b 00                	mov    (%eax),%eax
c040d1bf:	89 44 24 38          	mov    %eax,0x38(%esp)
c040d1c3:	eb 75                	jmp    c040d23a <debug_do_printf+0x28b>
                  /* h=short=16 bits (signed or unsigned) */
                  else
                     if(flags & PR_16)
c040d1c5:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d1c9:	83 e0 10             	and    $0x10,%eax
c040d1cc:	85 c0                	test   %eax,%eax
c040d1ce:	74 39                	je     c040d209 <debug_do_printf+0x25a>
                     {
                        if(flags & PR_SG)
c040d1d0:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d1d4:	83 e0 04             	and    $0x4,%eax
c040d1d7:	85 c0                	test   %eax,%eax
c040d1d9:	74 16                	je     c040d1f1 <debug_do_printf+0x242>
                           num = va_arg(args, short);
c040d1db:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d1e0:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d1e4:	83 e8 04             	sub    $0x4,%eax
c040d1e7:	66 8b 00             	mov    (%eax),%ax
c040d1ea:	98                   	cwtl   
c040d1eb:	89 44 24 38          	mov    %eax,0x38(%esp)
                        else
                           num = va_arg(args, unsigned short);
c040d1ef:	eb 49                	jmp    c040d23a <debug_do_printf+0x28b>
c040d1f1:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d1f6:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d1fa:	83 e8 04             	sub    $0x4,%eax
c040d1fd:	66 8b 00             	mov    (%eax),%ax
c040d200:	0f b7 c0             	movzwl %ax,%eax
c040d203:	89 44 24 38          	mov    %eax,0x38(%esp)
c040d207:	eb 31                	jmp    c040d23a <debug_do_printf+0x28b>
                     }
                     /* no h nor l: sizeof(int) bits (signed or unsigned) */
                     else
                     {
                        if(flags & PR_SG)
c040d209:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d20d:	83 e0 04             	and    $0x4,%eax
c040d210:	85 c0                	test   %eax,%eax
c040d212:	74 14                	je     c040d228 <debug_do_printf+0x279>
                           num = va_arg(args, int);
c040d214:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d219:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d21d:	83 e8 04             	sub    $0x4,%eax
c040d220:	8b 00                	mov    (%eax),%eax
c040d222:	89 44 24 38          	mov    %eax,0x38(%esp)
c040d226:	eb 12                	jmp    c040d23a <debug_do_printf+0x28b>
                        else
                           num = va_arg(args, unsigned int);
c040d228:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d22d:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d231:	83 e8 04             	sub    $0x4,%eax
c040d234:	8b 00                	mov    (%eax),%eax
c040d236:	89 44 24 38          	mov    %eax,0x38(%esp)
                     }
                     /* take care of sign */
                     if(flags & PR_SG)
c040d23a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d23e:	83 e0 04             	and    $0x4,%eax
c040d241:	85 c0                	test   %eax,%eax
c040d243:	74 10                	je     c040d255 <debug_do_printf+0x2a6>
                     {
                        if(num < 0)
c040d245:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c040d24a:	79 09                	jns    c040d255 <debug_do_printf+0x2a6>
                        {
                           flags |= PR_WS;
c040d24c:	83 4c 24 20 20       	orl    $0x20,0x20(%esp)
                           num = -num;
c040d251:	f7 5c 24 38          	negl   0x38(%esp)
   OK, I found my mistake. The math here is _always_ unsigned */
                     do
                     {
                        unsigned long temp;
          
                        temp = (unsigned long)num % radix;
c040d255:	8b 44 24 38          	mov    0x38(%esp),%eax
c040d259:	ba 00 00 00 00       	mov    $0x0,%edx
c040d25e:	f7 74 24 24          	divl   0x24(%esp)
c040d262:	89 54 24 3c          	mov    %edx,0x3c(%esp)
                        where--;
c040d266:	ff 4c 24 34          	decl   0x34(%esp)
                        if(temp < 10)
c040d26a:	83 7c 24 3c 09       	cmpl   $0x9,0x3c(%esp)
c040d26f:	77 0f                	ja     c040d280 <debug_do_printf+0x2d1>
                           *where = temp + '0';
c040d271:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040d275:	8d 50 30             	lea    0x30(%eax),%edx
c040d278:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d27c:	88 10                	mov    %dl,(%eax)
c040d27e:	eb 27                	jmp    c040d2a7 <debug_do_printf+0x2f8>
                        else
                           if(flags & PR_CA)
c040d280:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d284:	83 e0 02             	and    $0x2,%eax
c040d287:	85 c0                	test   %eax,%eax
c040d289:	74 0f                	je     c040d29a <debug_do_printf+0x2eb>
                              *where = temp - 10 + 'A';
c040d28b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040d28f:	8d 50 37             	lea    0x37(%eax),%edx
c040d292:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d296:	88 10                	mov    %dl,(%eax)
c040d298:	eb 0d                	jmp    c040d2a7 <debug_do_printf+0x2f8>
                           else
                              *where = temp - 10 + 'a';
c040d29a:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040d29e:	8d 50 57             	lea    0x57(%eax),%edx
c040d2a1:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d2a5:	88 10                	mov    %dl,(%eax)
                        num = (unsigned long)num / radix;
c040d2a7:	8b 44 24 38          	mov    0x38(%esp),%eax
c040d2ab:	ba 00 00 00 00       	mov    $0x0,%edx
c040d2b0:	f7 74 24 24          	divl   0x24(%esp)
c040d2b4:	89 44 24 38          	mov    %eax,0x38(%esp)
                     }
                     while(num != 0);
c040d2b8:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c040d2bd:	75 96                	jne    c040d255 <debug_do_printf+0x2a6>
                     goto EMIT;
c040d2bf:	eb 3e                	jmp    c040d2ff <debug_do_printf+0x350>

               case 'c':
/* disallow pad-left-with-zeroes for %c */
                  flags &= ~PR_LZ;
c040d2c1:	83 64 24 20 bf       	andl   $0xffffffbf,0x20(%esp)
                  where--;
c040d2c6:	ff 4c 24 34          	decl   0x34(%esp)
                  *where = (unsigned char)va_arg(args, unsigned char);
c040d2ca:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d2cf:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d2d3:	83 e8 04             	sub    $0x4,%eax
c040d2d6:	8a 10                	mov    (%eax),%dl
c040d2d8:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d2dc:	88 10                	mov    %dl,(%eax)
                  actual_wd = 1;
c040d2de:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
c040d2e5:	00 
                  goto EMIT2;
c040d2e6:	eb 5c                	jmp    c040d344 <debug_do_printf+0x395>

               case 's':
/* disallow pad-left-with-zeroes for %s */
                  flags &= ~PR_LZ;
c040d2e8:	83 64 24 20 bf       	andl   $0xffffffbf,0x20(%esp)
                  where = va_arg(args, unsigned char *);
c040d2ed:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040d2f2:	8b 44 24 54          	mov    0x54(%esp),%eax
c040d2f6:	83 e8 04             	sub    $0x4,%eax
c040d2f9:	8b 00                	mov    (%eax),%eax
c040d2fb:	89 44 24 34          	mov    %eax,0x34(%esp)

EMIT:
                  actual_wd = strlen(where);
c040d2ff:	83 ec 0c             	sub    $0xc,%esp
c040d302:	ff 74 24 40          	pushl  0x40(%esp)
c040d306:	e8 7d fc ff ff       	call   c040cf88 <strlen>
c040d30b:	83 c4 10             	add    $0x10,%esp
c040d30e:	89 44 24 28          	mov    %eax,0x28(%esp)
                  if(flags & PR_WS)
c040d312:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d316:	83 e0 20             	and    $0x20,%eax
c040d319:	85 c0                	test   %eax,%eax
c040d31b:	74 04                	je     c040d321 <debug_do_printf+0x372>
                     actual_wd++;
c040d31d:	ff 44 24 28          	incl   0x28(%esp)
/* if we pad left with ZEROES, do the sign now */
                  if((flags & (PR_WS | PR_LZ)) == (PR_WS | PR_LZ))
c040d321:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d325:	83 e0 60             	and    $0x60,%eax
c040d328:	83 f8 60             	cmp    $0x60,%eax
c040d32b:	75 17                	jne    c040d344 <debug_do_printf+0x395>
                  {
                     fn('-', &ptr);
c040d32d:	83 ec 08             	sub    $0x8,%esp
c040d330:	8d 44 24 64          	lea    0x64(%esp),%eax
c040d334:	50                   	push   %eax
c040d335:	6a 2d                	push   $0x2d
c040d337:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d33b:	ff d0                	call   *%eax
c040d33d:	83 c4 10             	add    $0x10,%esp
                     count++;
c040d340:	ff 44 24 2c          	incl   0x2c(%esp)
                  }
/* pad on left with spaces or zeroes (for right justify) */
EMIT2:            if((flags & PR_LJ) == 0)
c040d344:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d348:	83 e0 01             	and    $0x1,%eax
c040d34b:	85 c0                	test   %eax,%eax
c040d34d:	75 3d                	jne    c040d38c <debug_do_printf+0x3dd>
                  {
                     while(given_wd > actual_wd)
c040d34f:	eb 31                	jmp    c040d382 <debug_do_printf+0x3d3>
                     {
                        fn(flags & PR_LZ ? '0' : ' ', &ptr);
c040d351:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d355:	83 e0 40             	and    $0x40,%eax
c040d358:	85 c0                	test   %eax,%eax
c040d35a:	74 07                	je     c040d363 <debug_do_printf+0x3b4>
c040d35c:	b8 30 00 00 00       	mov    $0x30,%eax
c040d361:	eb 05                	jmp    c040d368 <debug_do_printf+0x3b9>
c040d363:	b8 20 00 00 00       	mov    $0x20,%eax
c040d368:	83 ec 08             	sub    $0x8,%esp
c040d36b:	8d 54 24 64          	lea    0x64(%esp),%edx
c040d36f:	52                   	push   %edx
c040d370:	50                   	push   %eax
c040d371:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d375:	ff d0                	call   *%eax
c040d377:	83 c4 10             	add    $0x10,%esp
                        count++;
c040d37a:	ff 44 24 2c          	incl   0x2c(%esp)
                        given_wd--;
c040d37e:	ff 4c 24 30          	decl   0x30(%esp)
                     count++;
                  }
/* pad on left with spaces or zeroes (for right justify) */
EMIT2:            if((flags & PR_LJ) == 0)
                  {
                     while(given_wd > actual_wd)
c040d382:	8b 44 24 30          	mov    0x30(%esp),%eax
c040d386:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040d38a:	77 c5                	ja     c040d351 <debug_do_printf+0x3a2>
                        count++;
                        given_wd--;
                     }
                  }
/* if we pad left with SPACES, do the sign now */
                  if((flags & (PR_WS | PR_LZ)) == PR_WS)
c040d38c:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d390:	83 e0 60             	and    $0x60,%eax
c040d393:	83 f8 20             	cmp    $0x20,%eax
c040d396:	75 3e                	jne    c040d3d6 <debug_do_printf+0x427>
                  {
                     fn('-', &ptr);
c040d398:	83 ec 08             	sub    $0x8,%esp
c040d39b:	8d 44 24 64          	lea    0x64(%esp),%eax
c040d39f:	50                   	push   %eax
c040d3a0:	6a 2d                	push   $0x2d
c040d3a2:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d3a6:	ff d0                	call   *%eax
c040d3a8:	83 c4 10             	add    $0x10,%esp
                     count++;
c040d3ab:	ff 44 24 2c          	incl   0x2c(%esp)
                  }
/* emit string/char/converted number */
                  while(*where != '\0')
c040d3af:	eb 26                	jmp    c040d3d7 <debug_do_printf+0x428>
                  {
                     fn(*where++, &ptr);
c040d3b1:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d3b5:	8a 00                	mov    (%eax),%al
c040d3b7:	0f b6 c0             	movzbl %al,%eax
c040d3ba:	ff 44 24 34          	incl   0x34(%esp)
c040d3be:	83 ec 08             	sub    $0x8,%esp
c040d3c1:	8d 54 24 64          	lea    0x64(%esp),%edx
c040d3c5:	52                   	push   %edx
c040d3c6:	50                   	push   %eax
c040d3c7:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d3cb:	ff d0                	call   *%eax
c040d3cd:	83 c4 10             	add    $0x10,%esp
                     count++;
c040d3d0:	ff 44 24 2c          	incl   0x2c(%esp)
c040d3d4:	eb 01                	jmp    c040d3d7 <debug_do_printf+0x428>
                  {
                     fn('-', &ptr);
                     count++;
                  }
/* emit string/char/converted number */
                  while(*where != '\0')
c040d3d6:	90                   	nop
c040d3d7:	8b 44 24 34          	mov    0x34(%esp),%eax
c040d3db:	8a 00                	mov    (%eax),%al
c040d3dd:	84 c0                	test   %al,%al
c040d3df:	75 d0                	jne    c040d3b1 <debug_do_printf+0x402>
                  {
                     fn(*where++, &ptr);
                     count++;
                  }
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
c040d3e1:	8b 44 24 30          	mov    0x30(%esp),%eax
c040d3e5:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040d3e9:	73 0a                	jae    c040d3f5 <debug_do_printf+0x446>
                     given_wd = 0;
c040d3eb:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040d3f2:	00 
                  else
                     given_wd -= actual_wd;
                  for(; given_wd; given_wd--)
c040d3f3:	eb 25                	jmp    c040d41a <debug_do_printf+0x46b>
                  }
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
                     given_wd = 0;
                  else
                     given_wd -= actual_wd;
c040d3f5:	8b 44 24 28          	mov    0x28(%esp),%eax
c040d3f9:	29 44 24 30          	sub    %eax,0x30(%esp)
                  for(; given_wd; given_wd--)
c040d3fd:	eb 1b                	jmp    c040d41a <debug_do_printf+0x46b>
                  {
                     fn(' ', &ptr);
c040d3ff:	83 ec 08             	sub    $0x8,%esp
c040d402:	8d 44 24 64          	lea    0x64(%esp),%eax
c040d406:	50                   	push   %eax
c040d407:	6a 20                	push   $0x20
c040d409:	8b 44 24 68          	mov    0x68(%esp),%eax
c040d40d:	ff d0                	call   *%eax
c040d40f:	83 c4 10             	add    $0x10,%esp
                     count++;
c040d412:	ff 44 24 2c          	incl   0x2c(%esp)
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
                     given_wd = 0;
                  else
                     given_wd -= actual_wd;
                  for(; given_wd; given_wd--)
c040d416:	ff 4c 24 30          	decl   0x30(%esp)
c040d41a:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040d41f:	75 de                	jne    c040d3ff <debug_do_printf+0x450>
               default:
                  break;
            }

            default:
               state = flags = given_wd = 0;
c040d421:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040d428:	00 
c040d429:	8b 44 24 30          	mov    0x30(%esp),%eax
c040d42d:	89 44 24 20          	mov    %eax,0x20(%esp)
c040d431:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d435:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c040d439:	eb 01                	jmp    c040d43c <debug_do_printf+0x48d>
            if(*fmt == 'F')
            {
               flags |= PR_FP;
               break;
            }
            if(*fmt == 'N') break;
c040d43b:	90                   	nop
   unsigned char *where, buf[PR_BUFLEN];
   long num;

   state = flags = count = given_wd = 0;
   /* begin scanning format specifier list */
   for(; *fmt; fmt++)
c040d43c:	ff 44 24 50          	incl   0x50(%esp)
c040d440:	8b 44 24 50          	mov    0x50(%esp),%eax
c040d444:	8a 00                	mov    (%eax),%al
c040d446:	84 c0                	test   %al,%al
c040d448:	0f 85 89 fb ff ff    	jne    c040cfd7 <debug_do_printf+0x28>
               state = flags = given_wd = 0;
               break;
         }
      }

   return count;
c040d44e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
}
c040d452:	83 c4 4c             	add    $0x4c,%esp
c040d455:	c3                   	ret    

c040d456 <debug_printf>:
   Output a formatted string to the user via the kernel's serial channel
   => as per ANSI C's printf()
   <= none
*/
void debug_printf(const char *fmt, ...)
{
c040d456:	83 ec 1c             	sub    $0x1c,%esp
   va_list args;

	/* gain exclusive access to the debug output stream */
	lock_spin(&debug_spinlock);
c040d459:	83 ec 0c             	sub    $0xc,%esp
c040d45c:	68 fc 38 41 c0       	push   $0xc04138fc
c040d461:	e8 fa 2f ff ff       	call   c0400460 <lock_spin>
c040d466:	83 c4 10             	add    $0x10,%esp
	
   va_start(args, fmt);
c040d469:	8d 44 24 20          	lea    0x20(%esp),%eax
c040d46d:	83 c0 04             	add    $0x4,%eax
c040d470:	89 44 24 0c          	mov    %eax,0xc(%esp)
   (void)debug_do_printf(fmt, args, debug_writebyte, NULL);
c040d474:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d478:	6a 00                	push   $0x0
c040d47a:	68 54 cd 40 c0       	push   $0xc040cd54
c040d47f:	ff 74 24 14          	pushl  0x14(%esp)
c040d483:	50                   	push   %eax
c040d484:	e8 26 fb ff ff       	call   c040cfaf <debug_do_printf>
c040d489:	83 c4 10             	add    $0x10,%esp
   va_end(args);
	
	/* release the debug output stream */
	unlock_spin(&debug_spinlock);
c040d48c:	83 ec 0c             	sub    $0xc,%esp
c040d48f:	68 fc 38 41 c0       	push   $0xc04138fc
c040d494:	e8 e7 2f ff ff       	call   c0400480 <unlock_spin>
c040d499:	83 c4 10             	add    $0x10,%esp
}
c040d49c:	83 c4 1c             	add    $0x1c,%esp
c040d49f:	c3                   	ret    

c040d4a0 <debug_init_sym_table>:
      end = pointer to the end of the symbol table in memory
   <= success or an error code
*/
kresult debug_init_sym_table(char *table, char *end)
{	
	debug_sym_tbl_start = table;
c040d4a0:	8b 44 24 04          	mov    0x4(%esp),%eax
c040d4a4:	a3 00 39 41 c0       	mov    %eax,0xc0413900
	debug_sym_tbl_end = end;
c040d4a9:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d4ad:	a3 04 39 41 c0       	mov    %eax,0xc0413904

	return success;
c040d4b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040d4b7:	c3                   	ret    

c040d4b8 <debug_ascii2uint>:
            this pointer is updated to point to the end of the string
		base = 10 for unsigned decimal text or 16 for unsigned hex text
   <= converted unsigned int
*/
unsigned int debug_ascii2uint(char **str, unsigned char base)
{
c040d4b8:	83 ec 14             	sub    $0x14,%esp
c040d4bb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040d4bf:	88 04 24             	mov    %al,(%esp)
	unsigned int value = 0, power = 1;
c040d4c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c040d4c9:	00 
c040d4ca:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c040d4d1:	00 
	char *ptr = *str;
c040d4d2:	8b 44 24 18          	mov    0x18(%esp),%eax
c040d4d6:	8b 00                	mov    (%eax),%eax
c040d4d8:	89 44 24 0c          	mov    %eax,0xc(%esp)
	char *start = *str;
c040d4dc:	8b 44 24 18          	mov    0x18(%esp),%eax
c040d4e0:	8b 00                	mov    (%eax),%eax
c040d4e2:	89 44 24 10          	mov    %eax,0x10(%esp)
	
	/* skip to the end of the string */
	while(*ptr != ' ')
c040d4e6:	eb 04                	jmp    c040d4ec <debug_ascii2uint+0x34>
		ptr++;
c040d4e8:	ff 44 24 0c          	incl   0xc(%esp)
	unsigned int value = 0, power = 1;
	char *ptr = *str;
	char *start = *str;
	
	/* skip to the end of the string */
	while(*ptr != ' ')
c040d4ec:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040d4f0:	8a 00                	mov    (%eax),%al
c040d4f2:	3c 20                	cmp    $0x20,%al
c040d4f4:	75 f2                	jne    c040d4e8 <debug_ascii2uint+0x30>
		ptr++;

	/* update the pointer to the end of the string */
	*str = ptr;
c040d4f6:	8b 44 24 18          	mov    0x18(%esp),%eax
c040d4fa:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040d4fe:	89 10                	mov    %edx,(%eax)

	ptr--; /* reverse over the space terminator */
c040d500:	ff 4c 24 0c          	decl   0xc(%esp)
	
	/* now work our way back through the string... */
	while((unsigned int)ptr >= (unsigned int)start)
c040d504:	e9 e9 01 00 00       	jmp    c040d6f2 <debug_ascii2uint+0x23a>
	{
		/* ...converting the digits */
		switch(*ptr)
c040d509:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040d50d:	8a 00                	mov    (%eax),%al
c040d50f:	0f be c0             	movsbl %al,%eax
c040d512:	83 e8 30             	sub    $0x30,%eax
c040d515:	83 f8 36             	cmp    $0x36,%eax
c040d518:	0f 87 c1 01 00 00    	ja     c040d6df <debug_ascii2uint+0x227>
c040d51e:	8b 04 85 cc fe 40 c0 	mov    -0x3fbf0134(,%eax,4),%eax
c040d525:	ff e0                	jmp    *%eax
		{
			case '0': value = value + (0 * power); break;
			case '1': value = value + (1 * power); break;
c040d527:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d52b:	01 44 24 04          	add    %eax,0x4(%esp)
c040d52f:	e9 ab 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '2': value = value + (2 * power); break;
c040d534:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d538:	d1 e0                	shl    %eax
c040d53a:	01 44 24 04          	add    %eax,0x4(%esp)
c040d53e:	e9 9c 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '3': value = value + (3 * power); break;
c040d543:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d547:	89 d0                	mov    %edx,%eax
c040d549:	d1 e0                	shl    %eax
c040d54b:	01 d0                	add    %edx,%eax
c040d54d:	01 44 24 04          	add    %eax,0x4(%esp)
c040d551:	e9 89 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '4': value = value + (4 * power); break;
c040d556:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d55a:	c1 e0 02             	shl    $0x2,%eax
c040d55d:	01 44 24 04          	add    %eax,0x4(%esp)
c040d561:	e9 79 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '5': value = value + (5 * power); break;
c040d566:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d56a:	89 d0                	mov    %edx,%eax
c040d56c:	c1 e0 02             	shl    $0x2,%eax
c040d56f:	01 d0                	add    %edx,%eax
c040d571:	01 44 24 04          	add    %eax,0x4(%esp)
c040d575:	e9 65 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '6': value = value + (6 * power); break;
c040d57a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d57e:	89 d0                	mov    %edx,%eax
c040d580:	d1 e0                	shl    %eax
c040d582:	01 d0                	add    %edx,%eax
c040d584:	d1 e0                	shl    %eax
c040d586:	01 44 24 04          	add    %eax,0x4(%esp)
c040d58a:	e9 50 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '7': value = value + (7 * power); break;
c040d58f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d593:	89 c2                	mov    %eax,%edx
c040d595:	c1 e2 03             	shl    $0x3,%edx
c040d598:	89 d1                	mov    %edx,%ecx
c040d59a:	29 c1                	sub    %eax,%ecx
c040d59c:	89 c8                	mov    %ecx,%eax
c040d59e:	01 44 24 04          	add    %eax,0x4(%esp)
c040d5a2:	e9 38 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '8': value = value + (8 * power); break;
c040d5a7:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d5ab:	c1 e0 03             	shl    $0x3,%eax
c040d5ae:	01 44 24 04          	add    %eax,0x4(%esp)
c040d5b2:	e9 28 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case '9': value = value + (9 * power); break;
c040d5b7:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d5bb:	89 d0                	mov    %edx,%eax
c040d5bd:	c1 e0 03             	shl    $0x3,%eax
c040d5c0:	01 d0                	add    %edx,%eax
c040d5c2:	01 44 24 04          	add    %eax,0x4(%esp)
c040d5c6:	e9 14 01 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			/* uppercase hex codes */
			case 'A': value = value + (10 * power); break;
c040d5cb:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d5cf:	89 d0                	mov    %edx,%eax
c040d5d1:	c1 e0 02             	shl    $0x2,%eax
c040d5d4:	01 d0                	add    %edx,%eax
c040d5d6:	d1 e0                	shl    %eax
c040d5d8:	01 44 24 04          	add    %eax,0x4(%esp)
c040d5dc:	e9 fe 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'B': value = value + (11 * power); break;
c040d5e1:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d5e5:	89 d0                	mov    %edx,%eax
c040d5e7:	c1 e0 02             	shl    $0x2,%eax
c040d5ea:	01 d0                	add    %edx,%eax
c040d5ec:	d1 e0                	shl    %eax
c040d5ee:	01 d0                	add    %edx,%eax
c040d5f0:	01 44 24 04          	add    %eax,0x4(%esp)
c040d5f4:	e9 e6 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'C': value = value + (12 * power); break;
c040d5f9:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d5fd:	89 d0                	mov    %edx,%eax
c040d5ff:	d1 e0                	shl    %eax
c040d601:	01 d0                	add    %edx,%eax
c040d603:	c1 e0 02             	shl    $0x2,%eax
c040d606:	01 44 24 04          	add    %eax,0x4(%esp)
c040d60a:	e9 d0 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'D': value = value + (13 * power); break;
c040d60f:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d613:	89 d0                	mov    %edx,%eax
c040d615:	d1 e0                	shl    %eax
c040d617:	01 d0                	add    %edx,%eax
c040d619:	c1 e0 02             	shl    $0x2,%eax
c040d61c:	01 d0                	add    %edx,%eax
c040d61e:	01 44 24 04          	add    %eax,0x4(%esp)
c040d622:	e9 b8 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'E': value = value + (14 * power); break;
c040d627:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d62b:	d1 e0                	shl    %eax
c040d62d:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c040d634:	89 d1                	mov    %edx,%ecx
c040d636:	29 c1                	sub    %eax,%ecx
c040d638:	89 c8                	mov    %ecx,%eax
c040d63a:	01 44 24 04          	add    %eax,0x4(%esp)
c040d63e:	e9 9c 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'F': value = value + (15 * power); break;
c040d643:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d647:	89 d0                	mov    %edx,%eax
c040d649:	d1 e0                	shl    %eax
c040d64b:	01 d0                	add    %edx,%eax
c040d64d:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040d654:	01 d0                	add    %edx,%eax
c040d656:	01 44 24 04          	add    %eax,0x4(%esp)
c040d65a:	e9 80 00 00 00       	jmp    c040d6df <debug_ascii2uint+0x227>
			/* lowercase hex codes */
			case 'a': value = value + (10 * power); break;
c040d65f:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d663:	89 d0                	mov    %edx,%eax
c040d665:	c1 e0 02             	shl    $0x2,%eax
c040d668:	01 d0                	add    %edx,%eax
c040d66a:	d1 e0                	shl    %eax
c040d66c:	01 44 24 04          	add    %eax,0x4(%esp)
c040d670:	eb 6d                	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'b': value = value + (11 * power); break;
c040d672:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d676:	89 d0                	mov    %edx,%eax
c040d678:	c1 e0 02             	shl    $0x2,%eax
c040d67b:	01 d0                	add    %edx,%eax
c040d67d:	d1 e0                	shl    %eax
c040d67f:	01 d0                	add    %edx,%eax
c040d681:	01 44 24 04          	add    %eax,0x4(%esp)
c040d685:	eb 58                	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'c': value = value + (12 * power); break;
c040d687:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d68b:	89 d0                	mov    %edx,%eax
c040d68d:	d1 e0                	shl    %eax
c040d68f:	01 d0                	add    %edx,%eax
c040d691:	c1 e0 02             	shl    $0x2,%eax
c040d694:	01 44 24 04          	add    %eax,0x4(%esp)
c040d698:	eb 45                	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'd': value = value + (13 * power); break;
c040d69a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d69e:	89 d0                	mov    %edx,%eax
c040d6a0:	d1 e0                	shl    %eax
c040d6a2:	01 d0                	add    %edx,%eax
c040d6a4:	c1 e0 02             	shl    $0x2,%eax
c040d6a7:	01 d0                	add    %edx,%eax
c040d6a9:	01 44 24 04          	add    %eax,0x4(%esp)
c040d6ad:	eb 30                	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'e': value = value + (14 * power); break;
c040d6af:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d6b3:	d1 e0                	shl    %eax
c040d6b5:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c040d6bc:	89 d1                	mov    %edx,%ecx
c040d6be:	29 c1                	sub    %eax,%ecx
c040d6c0:	89 c8                	mov    %ecx,%eax
c040d6c2:	01 44 24 04          	add    %eax,0x4(%esp)
c040d6c6:	eb 17                	jmp    c040d6df <debug_ascii2uint+0x227>
			case 'f': value = value + (15 * power); break;
c040d6c8:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d6cc:	89 d0                	mov    %edx,%eax
c040d6ce:	d1 e0                	shl    %eax
c040d6d0:	01 d0                	add    %edx,%eax
c040d6d2:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040d6d9:	01 d0                	add    %edx,%eax
c040d6db:	01 44 24 04          	add    %eax,0x4(%esp)
		}

		ptr--;
c040d6df:	ff 4c 24 0c          	decl   0xc(%esp)
		power = power * base;
c040d6e3:	0f b6 04 24          	movzbl (%esp),%eax
c040d6e7:	8b 54 24 08          	mov    0x8(%esp),%edx
c040d6eb:	0f af c2             	imul   %edx,%eax
c040d6ee:	89 44 24 08          	mov    %eax,0x8(%esp)
	*str = ptr;

	ptr--; /* reverse over the space terminator */
	
	/* now work our way back through the string... */
	while((unsigned int)ptr >= (unsigned int)start)
c040d6f2:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040d6f6:	8b 44 24 10          	mov    0x10(%esp),%eax
c040d6fa:	39 c2                	cmp    %eax,%edx
c040d6fc:	0f 83 07 fe ff ff    	jae    c040d509 <debug_ascii2uint+0x51>

		ptr--;
		power = power * base;
	}
	
	return value;
c040d702:	8b 44 24 04          	mov    0x4(%esp),%eax
}
c040d706:	83 c4 14             	add    $0x14,%esp
c040d709:	c3                   	ret    

c040d70a <debug_lookup_symbol>:
      size = buffer size in bytes
      symbol = pointer to word to write in base address of found symbol
   <= success or a failure code
*/
kresult debug_lookup_symbol(unsigned int addr, char *buffer, unsigned int size, unsigned int *symbol)
{
c040d70a:	83 ec 10             	sub    $0x10,%esp
	/* give up now if we don't have a symbol table */
	if(!debug_sym_tbl_start || !debug_sym_tbl_end) return e_not_found;
c040d70d:	a1 00 39 41 c0       	mov    0xc0413900,%eax
c040d712:	85 c0                	test   %eax,%eax
c040d714:	74 09                	je     c040d71f <debug_lookup_symbol+0x15>
c040d716:	a1 04 39 41 c0       	mov    0xc0413904,%eax
c040d71b:	85 c0                	test   %eax,%eax
c040d71d:	75 0a                	jne    c040d729 <debug_lookup_symbol+0x1f>
c040d71f:	b8 02 00 00 00       	mov    $0x2,%eax
c040d724:	e9 e7 00 00 00       	jmp    c040d810 <debug_lookup_symbol+0x106>
	
	char *ptr = debug_sym_tbl_start;
c040d729:	a1 00 39 41 c0       	mov    0xc0413900,%eax
c040d72e:	89 04 24             	mov    %eax,(%esp)
#ifdef KSYM_DEBUG
	dprintf("[debug:%i] looking up symbol for %x\n", CPU_ID, addr);
#endif
	
	/* attempt to parse a line in the symbol file - rather brute force */
	while(ptr < debug_sym_tbl_end)
c040d731:	e9 c5 00 00 00       	jmp    c040d7fb <debug_lookup_symbol+0xf1>
	{
		/* convert values, remembering to jump over space seperator */
		sym_addr = debug_ascii2uint(&ptr, 16); ptr++;
c040d736:	6a 10                	push   $0x10
c040d738:	8d 44 24 04          	lea    0x4(%esp),%eax
c040d73c:	50                   	push   %eax
c040d73d:	e8 76 fd ff ff       	call   c040d4b8 <debug_ascii2uint>
c040d742:	83 c4 08             	add    $0x8,%esp
c040d745:	89 44 24 04          	mov    %eax,0x4(%esp)
c040d749:	8b 04 24             	mov    (%esp),%eax
c040d74c:	40                   	inc    %eax
c040d74d:	89 04 24             	mov    %eax,(%esp)
		sym_size = debug_ascii2uint(&ptr, 10); ptr++;
c040d750:	6a 0a                	push   $0xa
c040d752:	8d 44 24 04          	lea    0x4(%esp),%eax
c040d756:	50                   	push   %eax
c040d757:	e8 5c fd ff ff       	call   c040d4b8 <debug_ascii2uint>
c040d75c:	83 c4 08             	add    $0x8,%esp
c040d75f:	89 44 24 08          	mov    %eax,0x8(%esp)
c040d763:	8b 04 24             	mov    (%esp),%eax
c040d766:	40                   	inc    %eax
c040d767:	89 04 24             	mov    %eax,(%esp)
#ifdef KSYM_DEBUG
		dprintf("[debug:%i] found a symbol for %x size %i\n", CPU_ID, sym_addr, sym_size);
#endif
		
		/* look for an address match */
		if(addr >= sym_addr && addr < (sym_addr + sym_size))
c040d76a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040d76e:	3b 44 24 04          	cmp    0x4(%esp),%eax
c040d772:	72 73                	jb     c040d7e7 <debug_lookup_symbol+0xdd>
c040d774:	8b 44 24 08          	mov    0x8(%esp),%eax
c040d778:	8b 54 24 04          	mov    0x4(%esp),%edx
c040d77c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040d77f:	3b 44 24 14          	cmp    0x14(%esp),%eax
c040d783:	76 65                	jbe    c040d7ea <debug_lookup_symbol+0xe0>
		{
			/* copy the symbol string into the buffer */
			unsigned int loop = 0;
c040d785:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040d78c:	00 
			
			while(*ptr != '\n' && loop < (size - sizeof(char)))
c040d78d:	eb 1c                	jmp    c040d7ab <debug_lookup_symbol+0xa1>
			{
				buffer[loop] = *ptr;
c040d78f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040d793:	8b 54 24 18          	mov    0x18(%esp),%edx
c040d797:	01 c2                	add    %eax,%edx
c040d799:	8b 04 24             	mov    (%esp),%eax
c040d79c:	8a 00                	mov    (%eax),%al
c040d79e:	88 02                	mov    %al,(%edx)
				loop++;
c040d7a0:	ff 44 24 0c          	incl   0xc(%esp)
				ptr++;
c040d7a4:	8b 04 24             	mov    (%esp),%eax
c040d7a7:	40                   	inc    %eax
c040d7a8:	89 04 24             	mov    %eax,(%esp)
		if(addr >= sym_addr && addr < (sym_addr + sym_size))
		{
			/* copy the symbol string into the buffer */
			unsigned int loop = 0;
			
			while(*ptr != '\n' && loop < (size - sizeof(char)))
c040d7ab:	8b 04 24             	mov    (%esp),%eax
c040d7ae:	8a 00                	mov    (%eax),%al
c040d7b0:	3c 0a                	cmp    $0xa,%al
c040d7b2:	74 0b                	je     c040d7bf <debug_lookup_symbol+0xb5>
c040d7b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040d7b8:	48                   	dec    %eax
c040d7b9:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040d7bd:	77 d0                	ja     c040d78f <debug_lookup_symbol+0x85>
				loop++;
				ptr++;
			}
			
			/* write in the sym base address, terminate the string and get out of here */
			*symbol = sym_addr;
c040d7bf:	8b 44 24 20          	mov    0x20(%esp),%eax
c040d7c3:	8b 54 24 04          	mov    0x4(%esp),%edx
c040d7c7:	89 10                	mov    %edx,(%eax)
			buffer[loop] = NULL;
c040d7c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040d7cd:	8b 54 24 18          	mov    0x18(%esp),%edx
c040d7d1:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040d7d4:	c6 00 00             	movb   $0x0,(%eax)
			return success;
c040d7d7:	b8 00 00 00 00       	mov    $0x0,%eax
c040d7dc:	eb 32                	jmp    c040d810 <debug_lookup_symbol+0x106>
		}
		
		/* skip to the end of the line */
		while(*ptr != '\n') ptr++;
c040d7de:	8b 04 24             	mov    (%esp),%eax
c040d7e1:	40                   	inc    %eax
c040d7e2:	89 04 24             	mov    %eax,(%esp)
c040d7e5:	eb 04                	jmp    c040d7eb <debug_lookup_symbol+0xe1>
c040d7e7:	90                   	nop
c040d7e8:	eb 01                	jmp    c040d7eb <debug_lookup_symbol+0xe1>
c040d7ea:	90                   	nop
c040d7eb:	8b 04 24             	mov    (%esp),%eax
c040d7ee:	8a 00                	mov    (%eax),%al
c040d7f0:	3c 0a                	cmp    $0xa,%al
c040d7f2:	75 ea                	jne    c040d7de <debug_lookup_symbol+0xd4>
		ptr++; /* skip over the newline terminator */
c040d7f4:	8b 04 24             	mov    (%esp),%eax
c040d7f7:	40                   	inc    %eax
c040d7f8:	89 04 24             	mov    %eax,(%esp)
#ifdef KSYM_DEBUG
	dprintf("[debug:%i] looking up symbol for %x\n", CPU_ID, addr);
#endif
	
	/* attempt to parse a line in the symbol file - rather brute force */
	while(ptr < debug_sym_tbl_end)
c040d7fb:	8b 14 24             	mov    (%esp),%edx
c040d7fe:	a1 04 39 41 c0       	mov    0xc0413904,%eax
c040d803:	39 c2                	cmp    %eax,%edx
c040d805:	0f 82 2b ff ff ff    	jb     c040d736 <debug_lookup_symbol+0x2c>
		while(*ptr != '\n') ptr++;
		ptr++; /* skip over the newline terminator */
	}
	
	/* fail if we're still here */
	return e_failure;
c040d80b:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040d810:	83 c4 10             	add    $0x10,%esp
c040d813:	c3                   	ret    

c040d814 <debug_initialise>:

/* debug_initialise
   The kernel wants to do some low level debugging. By default, the i386 port
   uses the first IBM PC serial port. */
void debug_initialise(void)
{
c040d814:	83 ec 0c             	sub    $0xc,%esp
#ifdef DEBUG
   serial_initialise(); /* port-specific */
c040d817:	e8 c4 f4 ff ff       	call   c040cce0 <serial_initialise>
	
   /* can I get a witness? */
   dprintf("[core] Now debugging to serial port.\n");
c040d81c:	83 ec 0c             	sub    $0xc,%esp
c040d81f:	68 a8 ff 40 c0       	push   $0xc040ffa8
c040d824:	e8 2d fc ff ff       	call   c040d456 <debug_printf>
c040d829:	83 c4 10             	add    $0x10,%esp
#endif
}
c040d82c:	83 c4 0c             	add    $0xc,%esp
c040d82f:	c3                   	ret    
c040d830:	5b                   	pop    %ebx
c040d831:	6c                   	insb   (%dx),%es:(%edi)
c040d832:	6f                   	outsl  %ds:(%esi),(%dx)
c040d833:	63 6b 3a             	arpl   %bp,0x3a(%ebx)
c040d836:	25 69 5d 20 4f       	and    $0x4f205d69,%eax
c040d83b:	4d                   	dec    %ebp
c040d83c:	47                   	inc    %edi
c040d83d:	57                   	push   %edi
c040d83e:	54                   	push   %esp
c040d83f:	46                   	inc    %esi
c040d840:	20 77 61             	and    %dh,0x61(%edi)
c040d843:	69 74 65 64 20 74 6f 	imul   $0x6f6f7420,0x64(%ebp,%eiz,2),%esi
c040d84a:	6f 
c040d84b:	20 6c 6f 6e          	and    %ch,0x6e(%edi,%ebp,2)
c040d84f:	67 20 66 6f          	addr16 and %ah,0x6f(%bp)
c040d853:	72 20                	jb     c040d875 <debug_initialise+0x61>
c040d855:	67 61                	addr16 popa 
c040d857:	74 65                	je     c040d8be <debug_initialise+0xaa>
c040d859:	20 25 70 20 74 6f    	and    %ah,0x6f742070
c040d85f:	20 62 65             	and    %ah,0x65(%edx)
c040d862:	63 6f 6d             	arpl   %bp,0x6d(%edi)
c040d865:	65 20 61 76          	and    %ah,%gs:0x76(%ecx)
c040d869:	61                   	popa   
c040d86a:	69 6c 61 62 6c 65 20 	imul   $0x2820656c,0x62(%ecx,%eiz,2),%ebp
c040d871:	28 
c040d872:	66                   	data16
c040d873:	6c                   	insb   (%dx),%es:(%edi)
c040d874:	61                   	popa   
c040d875:	67 73 20             	addr16 jae c040d898 <debug_initialise+0x84>
c040d878:	25 78 29 0a 20       	and    $0x200a2978,%eax
c040d87d:	20 20                	and    %ah,(%eax)
c040d87f:	20 20                	and    %ah,(%eax)
c040d881:	20 20                	and    %ah,(%eax)
c040d883:	20 20                	and    %ah,(%eax)
c040d885:	6c                   	insb   (%dx),%es:(%edi)
c040d886:	6f                   	outsl  %ds:(%esi),(%dx)
c040d887:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040d88a:	69 73 20 6f 77 6e 65 	imul   $0x656e776f,0x20(%ebx),%esi
c040d891:	64 20 62 79          	and    %ah,%fs:0x79(%edx)
c040d895:	20 25 70 00 20 28    	and    %ah,0x28200070
c040d89b:	74 68                	je     c040d905 <debug_initialise+0xf1>
c040d89d:	72 65                	jb     c040d904 <debug_initialise+0xf0>
c040d89f:	61                   	popa   
c040d8a0:	64 20 25 69 20 70 72 	and    %ah,%fs:0x72702069
c040d8a7:	6f                   	outsl  %ds:(%esi),(%dx)
c040d8a8:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d8ab:	73 20                	jae    c040d8cd <debug_initialise+0xb9>
c040d8ad:	25 69 29 00 0a       	and    $0xa002969,%eax
c040d8b2:	00 00                	add    %al,(%eax)
c040d8b4:	0a 20                	or     (%eax),%ah
c040d8b6:	5f                   	pop    %edi
c040d8b7:	7c 5f                	jl     c040d918 <debug_initialise+0x104>
c040d8b9:	7c 5f                	jl     c040d91a <debug_initialise+0x106>
c040d8bb:	7c 20                	jl     c040d8dd <debug_initialise+0xc9>
c040d8bd:	20 20                	and    %ah,(%eax)
c040d8bf:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d8c2:	20 20                	and    %ah,(%eax)
c040d8c4:	20 20                	and    %ah,(%eax)
c040d8c6:	5f                   	pop    %edi
c040d8c7:	7c 5f                	jl     c040d928 <debug_initialise+0x114>
c040d8c9:	7c 20                	jl     c040d8eb <debug_initialise+0xd7>
c040d8cb:	20 20                	and    %ah,(%eax)
c040d8cd:	20 20                	and    %ah,(%eax)
c040d8cf:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d8d2:	5f                   	pop    %edi
c040d8d3:	7c 5f                	jl     c040d934 <debug_initialise+0x120>
c040d8d5:	7c 20                	jl     c040d8f7 <debug_initialise+0xe3>
c040d8d7:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d8da:	20 20                	and    %ah,(%eax)
c040d8dc:	20 20                	and    %ah,(%eax)
c040d8de:	20 20                	and    %ah,(%eax)
c040d8e0:	20 20                	and    %ah,(%eax)
c040d8e2:	20 20                	and    %ah,(%eax)
c040d8e4:	20 20                	and    %ah,(%eax)
c040d8e6:	0a 20                	or     (%eax),%ah
c040d8e8:	5f                   	pop    %edi
c040d8e9:	7c 20                	jl     c040d90b <debug_initialise+0xf7>
c040d8eb:	20 20                	and    %ah,(%eax)
c040d8ed:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d8f0:	20 20                	and    %ah,(%eax)
c040d8f2:	20 20                	and    %ah,(%eax)
c040d8f4:	20 20                	and    %ah,(%eax)
c040d8f6:	5f                   	pop    %edi
c040d8f7:	7c 20                	jl     c040d919 <debug_initialise+0x105>
c040d8f9:	20 20                	and    %ah,(%eax)
c040d8fb:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d8fe:	20 20                	and    %ah,(%eax)
c040d900:	5f                   	pop    %edi
c040d901:	7c 20                	jl     c040d923 <debug_initialise+0x10f>
c040d903:	20 20                	and    %ah,(%eax)
c040d905:	20 20                	and    %ah,(%eax)
c040d907:	20 20                	and    %ah,(%eax)
c040d909:	20 20                	and    %ah,(%eax)
c040d90b:	20 20                	and    %ah,(%eax)
c040d90d:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d910:	20 20                	and    %ah,(%eax)
c040d912:	20 20                	and    %ah,(%eax)
c040d914:	5f                   	pop    %edi
c040d915:	7c 20                	jl     c040d937 <debug_initialise+0x123>
c040d917:	20 0a                	and    %cl,(%edx)
c040d919:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d91c:	20 20                	and    %ah,(%eax)
c040d91e:	20 20                	and    %ah,(%eax)
c040d920:	5f                   	pop    %edi
c040d921:	7c 20                	jl     c040d943 <debug_initialise+0x12f>
c040d923:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d926:	20 20                	and    %ah,(%eax)
c040d928:	5f                   	pop    %edi
c040d929:	7c 20                	jl     c040d94b <debug_initialise+0x137>
c040d92b:	20 20                	and    %ah,(%eax)
c040d92d:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d930:	20 20                	and    %ah,(%eax)
c040d932:	20 20                	and    %ah,(%eax)
c040d934:	5f                   	pop    %edi
c040d935:	7c 5f                	jl     c040d996 <debug_initialise+0x182>
c040d937:	7c 20                	jl     c040d959 <debug_initialise+0x145>
c040d939:	20 20                	and    %ah,(%eax)
c040d93b:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d93e:	20 20                	and    %ah,(%eax)
c040d940:	20 20                	and    %ah,(%eax)
c040d942:	5f                   	pop    %edi
c040d943:	7c 5f                	jl     c040d9a4 <debug_initialise+0x190>
c040d945:	7c 20                	jl     c040d967 <debug_initialise+0x153>
c040d947:	20 20                	and    %ah,(%eax)
c040d949:	20 0a                	and    %cl,(%edx)
c040d94b:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d94e:	20 20                	and    %ah,(%eax)
c040d950:	20 20                	and    %ah,(%eax)
c040d952:	5f                   	pop    %edi
c040d953:	7c 20                	jl     c040d975 <debug_initialise+0x161>
c040d955:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d958:	20 20                	and    %ah,(%eax)
c040d95a:	5f                   	pop    %edi
c040d95b:	7c 20                	jl     c040d97d <debug_initialise+0x169>
c040d95d:	20 20                	and    %ah,(%eax)
c040d95f:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d962:	20 20                	and    %ah,(%eax)
c040d964:	20 20                	and    %ah,(%eax)
c040d966:	20 20                	and    %ah,(%eax)
c040d968:	20 20                	and    %ah,(%eax)
c040d96a:	5f                   	pop    %edi
c040d96b:	7c 20                	jl     c040d98d <debug_initialise+0x179>
c040d96d:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d970:	20 20                	and    %ah,(%eax)
c040d972:	5f                   	pop    %edi
c040d973:	7c 20                	jl     c040d995 <debug_initialise+0x181>
c040d975:	20 20                	and    %ah,(%eax)
c040d977:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d97a:	20 20                	and    %ah,(%eax)
c040d97c:	0a 20                	or     (%eax),%ah
c040d97e:	5f                   	pop    %edi
c040d97f:	7c 5f                	jl     c040d9e0 <debug_initialise+0x1cc>
c040d981:	7c 5f                	jl     c040d9e2 <debug_initialise+0x1ce>
c040d983:	7c 20                	jl     c040d9a5 <debug_initialise+0x191>
c040d985:	20 20                	and    %ah,(%eax)
c040d987:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d98a:	20 20                	and    %ah,(%eax)
c040d98c:	20 20                	and    %ah,(%eax)
c040d98e:	5f                   	pop    %edi
c040d98f:	7c 5f                	jl     c040d9f0 <debug_initialise+0x1dc>
c040d991:	7c 20                	jl     c040d9b3 <debug_initialise+0x19f>
c040d993:	20 20                	and    %ah,(%eax)
c040d995:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d998:	5f                   	pop    %edi
c040d999:	7c 5f                	jl     c040d9fa <debug_initialise+0x1e6>
c040d99b:	7c 20                	jl     c040d9bd <debug_initialise+0x1a9>
c040d99d:	20 20                	and    %ah,(%eax)
c040d99f:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d9a2:	20 20                	and    %ah,(%eax)
c040d9a4:	5f                   	pop    %edi
c040d9a5:	7c 20                	jl     c040d9c7 <debug_initialise+0x1b3>
c040d9a7:	20 20                	and    %ah,(%eax)
c040d9a9:	20 5f 7c             	and    %bl,0x7c(%edi)
c040d9ac:	20 20                	and    %ah,(%eax)
c040d9ae:	0a 0a                	or     (%edx),%cl
c040d9b0:	20 43 6f             	and    %al,0x6f(%ebx)
c040d9b3:	70 79                	jo     c040da2e <debug_initialise+0x21a>
c040d9b5:	72 69                	jb     c040da20 <debug_initialise+0x20c>
c040d9b7:	67 68 74 20 28 63    	addr16 push $0x63282074
c040d9bd:	29 20                	sub    %esp,(%eax)
c040d9bf:	43                   	inc    %ebx
c040d9c0:	68 72 69 73 20       	push   $0x20736972
c040d9c5:	57                   	push   %edi
c040d9c6:	69 6c 6c 69 61 6d 73 	imul   $0x20736d61,0x69(%esp,%ebp,2),%ebp
c040d9cd:	20 
c040d9ce:	61                   	popa   
c040d9cf:	6e                   	outsb  %ds:(%esi),(%dx)
c040d9d0:	64 20 63 6f          	and    %ah,%fs:0x6f(%ebx)
c040d9d4:	6e                   	outsb  %ds:(%esi),(%dx)
c040d9d5:	74 72                	je     c040da49 <debug_initialise+0x235>
c040d9d7:	69 62 75 74 6f 72 73 	imul   $0x73726f74,0x75(%edx),%esp
c040d9de:	2c 20                	sub    $0x20,%al
c040d9e0:	32 30                	xor    (%eax),%dh
c040d9e2:	30 39                	xor    %bh,(%ecx)
c040d9e4:	2e 0a 20             	or     %cs:(%eax),%ah
c040d9e7:	53                   	push   %ebx
c040d9e8:	65 65 20 68 74       	and    %ch,%gs:0x74(%eax)
c040d9ed:	74 70                	je     c040da5f <debug_initialise+0x24b>
c040d9ef:	3a 2f                	cmp    (%edi),%ch
c040d9f1:	2f                   	das    
c040d9f2:	64 69 6f 64 65 73 69 	imul   $0x67697365,%fs:0x64(%edi),%ebp
c040d9f9:	67 
c040d9fa:	6e                   	outsb  %ds:(%esi),(%dx)
c040d9fb:	2e 63 6f 2e          	arpl   %bp,%cs:0x2e(%edi)
c040d9ff:	75 6b                	jne    c040da6c <debug_initialise+0x258>
c040da01:	2f                   	das    
c040da02:	20 66 6f             	and    %ah,0x6f(%esi)
c040da05:	72 20                	jb     c040da27 <debug_initialise+0x213>
c040da07:	75 73                	jne    c040da7c <debug_initialise+0x268>
c040da09:	61                   	popa   
c040da0a:	67 65 20 61 6e       	addr16 and %ah,%gs:0x6e(%bx,%di)
c040da0f:	64 20 6c 69 63       	and    %ch,%fs:0x63(%ecx,%ebp,2)
c040da14:	65 6e                	outsb  %gs:(%esi),(%dx)
c040da16:	63 65 2e             	arpl   %sp,0x2e(%ebp)
c040da19:	0a 0a                	or     (%edx),%cl
c040da1b:	5b                   	pop    %ebx
c040da1c:	78 38                	js     c040da56 <debug_initialise+0x242>
c040da1e:	36                   	ss
c040da1f:	5d                   	pop    %ebp
c040da20:	20 69 33             	and    %ch,0x33(%ecx)
c040da23:	38 36                	cmp    %dh,(%esi)
c040da25:	20 70 6f             	and    %dh,0x6f(%eax)
c040da28:	72 74                	jb     c040da9e <debug_initialise+0x28a>
c040da2a:	20 69 6e             	and    %ch,0x6e(%ecx)
c040da2d:	69 74 69 61 6c 69 73 	imul   $0x6573696c,0x61(%ecx,%ebp,2),%esi
c040da34:	65 
c040da35:	64 0a 00             	or     %fs:(%eax),%al
c040da38:	5b                   	pop    %ebx
c040da39:	78 38                	js     c040da73 <debug_initialise+0x25f>
c040da3b:	36 3a 25 69 5d 20 73 	cmp    %ss:0x73205d69,%ah
c040da42:	77 69                	ja     c040daad <debug_initialise+0x299>
c040da44:	74 63                	je     c040daa9 <debug_initialise+0x295>
c040da46:	68 69 6e 67 20       	push   $0x20676e69
c040da4b:	74 68                	je     c040dab5 <debug_initialise+0x2a1>
c040da4d:	72 65                	jb     c040dab4 <debug_initialise+0x2a0>
c040da4f:	61                   	popa   
c040da50:	64 20 25 70 20 66 6f 	and    %ah,%fs:0x6f662070
c040da57:	72 20                	jb     c040da79 <debug_initialise+0x265>
c040da59:	25 70 20 28 72       	and    $0x72282070,%eax
c040da5e:	65                   	gs
c040da5f:	67 73 20             	addr16 jae c040da82 <debug_initialise+0x26e>
c040da62:	25 70 29 20 28       	and    $0x28202970,%eax
c040da67:	64                   	fs
c040da68:	73 2f                	jae    c040da99 <debug_initialise+0x285>
c040da6a:	73 73                	jae    c040dadf <debug_initialise+0x2cb>
c040da6c:	20 25 78 20 63 73    	and    %ah,0x73632078
c040da72:	20 25 78 20 73 73    	and    %ah,0x73732078
c040da78:	30 20                	xor    %ah,(%eax)
c040da7a:	25 78 20 65 73       	and    $0x73652078,%eax
c040da7f:	70 30                	jo     c040dab1 <debug_initialise+0x29d>
c040da81:	20 25 78 29 0a 00    	and    %ah,0xa2978
c040da87:	00 5b 78             	add    %bl,0x78(%ebx)
c040da8a:	38 36                	cmp    %dh,(%esi)
c040da8c:	3a 25 69 5d 20 50    	cmp    0x50205d69,%ah
c040da92:	52                   	push   %edx
c040da93:	45                   	inc    %ebp
c040da94:	2d 53 57 41 50       	sub    $0x50415753,%eax
c040da99:	3a 20                	cmp    (%eax),%ah
c040da9b:	64                   	fs
c040da9c:	73 20                	jae    c040dabe <debug_initialise+0x2aa>
c040da9e:	25 78 20 65 64       	and    $0x64652078,%eax
c040daa3:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040daa9:	73 69                	jae    c040db14 <debug_initialise+0x300>
c040daab:	20 25 78 20 65 62    	and    %ah,0x62652078
c040dab1:	70 20                	jo     c040dad3 <debug_initialise+0x2bf>
c040dab3:	25 78 20 65 73       	and    $0x73652078,%eax
c040dab8:	70 20                	jo     c040dada <debug_initialise+0x2c6>
c040daba:	25 78 20 65 62       	and    $0x62652078,%eax
c040dabf:	78 20                	js     c040dae1 <debug_initialise+0x2cd>
c040dac1:	25 78 20 65 64       	and    $0x64652078,%eax
c040dac6:	78 20                	js     c040dae8 <debug_initialise+0x2d4>
c040dac8:	25 78 20 65 63       	and    $0x63652078,%eax
c040dacd:	78 20                	js     c040daef <debug_initialise+0x2db>
c040dacf:	25 78 20 65 61       	and    $0x61652078,%eax
c040dad4:	78 20                	js     c040daf6 <debug_initialise+0x2e2>
c040dad6:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040dadb:	20 20                	and    %ah,(%eax)
c040dadd:	20 20                	and    %ah,(%eax)
c040dadf:	69 6e 74 6e 75 6d 20 	imul   $0x206d756e,0x74(%esi),%ebp
c040dae6:	25 78 20 65 72       	and    $0x72652078,%eax
c040daeb:	72 63                	jb     c040db50 <debug_initialise+0x33c>
c040daed:	6f                   	outsl  %ds:(%esi),(%dx)
c040daee:	64 65 20 25 78 20 65 	and    %ah,%fs:%gs:0x69652078
c040daf5:	69 
c040daf6:	70 20                	jo     c040db18 <debug_initialise+0x304>
c040daf8:	25 78 20 63 73       	and    $0x73632078,%eax
c040dafd:	20 25 78 20 65 66    	and    %ah,0x66652078
c040db03:	6c                   	insb   (%dx),%es:(%edi)
c040db04:	61                   	popa   
c040db05:	67 73 20             	addr16 jae c040db28 <debug_initialise+0x314>
c040db08:	25 78 20 75 73       	and    $0x73752078,%eax
c040db0d:	65                   	gs
c040db0e:	72 65                	jb     c040db75 <debug_initialise+0x361>
c040db10:	73 70                	jae    c040db82 <debug_initialise+0x36e>
c040db12:	20 25 78 20 73 73    	and    %ah,0x73732078
c040db18:	20 25 78 0a 00 00    	and    %ah,0xa78
c040db1e:	00 00                	add    %al,(%eax)
c040db20:	5b                   	pop    %ebx
c040db21:	78 38                	js     c040db5b <debug_initialise+0x347>
c040db23:	36 3a 25 69 5d 20 50 	cmp    %ss:0x50205d69,%ah
c040db2a:	4f                   	dec    %edi
c040db2b:	53                   	push   %ebx
c040db2c:	54                   	push   %esp
c040db2d:	2d 53 57 41 50       	sub    $0x50415753,%eax
c040db32:	3a 20                	cmp    (%eax),%ah
c040db34:	64                   	fs
c040db35:	73 20                	jae    c040db57 <debug_initialise+0x343>
c040db37:	25 78 20 65 64       	and    $0x64652078,%eax
c040db3c:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040db42:	73 69                	jae    c040dbad <debug_initialise+0x399>
c040db44:	20 25 78 20 65 62    	and    %ah,0x62652078
c040db4a:	70 20                	jo     c040db6c <debug_initialise+0x358>
c040db4c:	25 78 20 65 73       	and    $0x73652078,%eax
c040db51:	70 20                	jo     c040db73 <debug_initialise+0x35f>
c040db53:	25 78 20 65 62       	and    $0x62652078,%eax
c040db58:	78 20                	js     c040db7a <debug_initialise+0x366>
c040db5a:	25 78 20 65 64       	and    $0x64652078,%eax
c040db5f:	78 20                	js     c040db81 <debug_initialise+0x36d>
c040db61:	25 78 20 65 63       	and    $0x63652078,%eax
c040db66:	78 20                	js     c040db88 <debug_initialise+0x374>
c040db68:	25 78 20 65 61       	and    $0x61652078,%eax
c040db6d:	78 20                	js     c040db8f <debug_initialise+0x37b>
c040db6f:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040db74:	20 20                	and    %ah,(%eax)
c040db76:	20 20                	and    %ah,(%eax)
c040db78:	69 6e 74 6e 75 6d 20 	imul   $0x206d756e,0x74(%esi),%ebp
c040db7f:	25 78 20 65 72       	and    $0x72652078,%eax
c040db84:	72 63                	jb     c040dbe9 <debug_initialise+0x3d5>
c040db86:	6f                   	outsl  %ds:(%esi),(%dx)
c040db87:	64 65 20 25 78 20 65 	and    %ah,%fs:%gs:0x69652078
c040db8e:	69 
c040db8f:	70 20                	jo     c040dbb1 <debug_initialise+0x39d>
c040db91:	25 78 20 63 73       	and    $0x73632078,%eax
c040db96:	20 25 78 20 65 66    	and    %ah,0x66652078
c040db9c:	6c                   	insb   (%dx),%es:(%edi)
c040db9d:	61                   	popa   
c040db9e:	67 73 20             	addr16 jae c040dbc1 <debug_initialise+0x3ad>
c040dba1:	25 78 20 75 73       	and    $0x73752078,%eax
c040dba6:	65                   	gs
c040dba7:	72 65                	jb     c040dc0e <debug_initialise+0x3fa>
c040dba9:	73 70                	jae    c040dc1b <debug_initialise+0x407>
c040dbab:	20 25 78 20 73 73    	and    %ah,0x73732078
c040dbb1:	20 25 78 0a 00 00    	and    %ah,0xa78
c040dbb7:	00 5b 78             	add    %bl,0x78(%ebx)
c040dbba:	38 36                	cmp    %dh,(%esi)
c040dbbc:	3a 25 69 5d 20 72    	cmp    0x72205d69,%ah
c040dbc2:	65                   	gs
c040dbc3:	73 75                	jae    c040dc3a <debug_initialise+0x426>
c040dbc5:	6d                   	insl   (%dx),%es:(%edi)
c040dbc6:	69 6e 67 20 77 61 72 	imul   $0x72617720,0x67(%esi),%ebp
c040dbcd:	6d                   	insl   (%dx),%es:(%edi)
c040dbce:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040dbd2:	65                   	gs
c040dbd3:	61                   	popa   
c040dbd4:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040dbdb:	70 29                	jo     c040dc06 <debug_initialise+0x3f2>
c040dbdd:	20 6f 66             	and    %ch,0x66(%edi)
c040dbe0:	20 70 72             	and    %dh,0x72(%eax)
c040dbe3:	6f                   	outsl  %ds:(%esi),(%dx)
c040dbe4:	63 65 73             	arpl   %sp,0x73(%ebp)
c040dbe7:	73 20                	jae    c040dc09 <debug_initialise+0x3f5>
c040dbe9:	25 69 20 28 25       	and    $0x25282069,%eax
c040dbee:	70 29                	jo     c040dc19 <debug_initialise+0x405>
c040dbf0:	20 28                	and    %ch,(%eax)
c040dbf2:	72 65                	jb     c040dc59 <debug_initialise+0x445>
c040dbf4:	67 73 20             	addr16 jae c040dc17 <debug_initialise+0x403>
c040dbf7:	25 70 29 20 28       	and    $0x28202970,%eax
c040dbfc:	64                   	fs
c040dbfd:	73 2f                	jae    c040dc2e <debug_initialise+0x41a>
c040dbff:	73 73                	jae    c040dc74 <debug_initialise+0x460>
c040dc01:	20 25 78 20 63 73    	and    %ah,0x73632078
c040dc07:	20 25 78 20 73 73    	and    %ah,0x73732078
c040dc0d:	30 20                	xor    %ah,(%eax)
c040dc0f:	25 78 20 65 73       	and    $0x73652078,%eax
c040dc14:	70 30                	jo     c040dc46 <debug_initialise+0x432>
c040dc16:	20 25 78 29 0a 00    	and    %ah,0xa2978
c040dc1c:	5b                   	pop    %ebx
c040dc1d:	78 38                	js     c040dc57 <debug_initialise+0x443>
c040dc1f:	36 3a 25 69 5d 20 77 	cmp    %ss:0x77205d69,%ah
c040dc26:	61                   	popa   
c040dc27:	72 6d                	jb     c040dc96 <debug_initialise+0x482>
c040dc29:	20 63 6f             	and    %ah,0x6f(%ebx)
c040dc2c:	6e                   	outsb  %ds:(%esi),(%dx)
c040dc2d:	74 65                	je     c040dc94 <debug_initialise+0x480>
c040dc2f:	78 74                	js     c040dca5 <debug_initialise+0x491>
c040dc31:	3a 20                	cmp    (%eax),%ah
c040dc33:	64                   	fs
c040dc34:	73 20                	jae    c040dc56 <debug_initialise+0x442>
c040dc36:	25 78 20 65 64       	and    $0x64652078,%eax
c040dc3b:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040dc41:	73 69                	jae    c040dcac <debug_initialise+0x498>
c040dc43:	20 25 78 20 65 62    	and    %ah,0x62652078
c040dc49:	70 20                	jo     c040dc6b <debug_initialise+0x457>
c040dc4b:	25 78 20 65 73       	and    $0x73652078,%eax
c040dc50:	70 20                	jo     c040dc72 <debug_initialise+0x45e>
c040dc52:	25 78 20 65 62       	and    $0x62652078,%eax
c040dc57:	78 20                	js     c040dc79 <debug_initialise+0x465>
c040dc59:	25 78 20 65 64       	and    $0x64652078,%eax
c040dc5e:	78 20                	js     c040dc80 <debug_initialise+0x46c>
c040dc60:	25 78 20 65 63       	and    $0x63652078,%eax
c040dc65:	78 20                	js     c040dc87 <debug_initialise+0x473>
c040dc67:	25 78 20 65 61       	and    $0x61652078,%eax
c040dc6c:	78 20                	js     c040dc8e <debug_initialise+0x47a>
c040dc6e:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040dc73:	20 20                	and    %ah,(%eax)
c040dc75:	20 20                	and    %ah,(%eax)
c040dc77:	69 6e 74 6e 75 6d 20 	imul   $0x206d756e,0x74(%esi),%ebp
c040dc7e:	25 78 20 65 72       	and    $0x72652078,%eax
c040dc83:	72 63                	jb     c040dce8 <debug_initialise+0x4d4>
c040dc85:	6f                   	outsl  %ds:(%esi),(%dx)
c040dc86:	64 65 20 25 78 20 65 	and    %ah,%fs:%gs:0x69652078
c040dc8d:	69 
c040dc8e:	70 20                	jo     c040dcb0 <debug_initialise+0x49c>
c040dc90:	25 78 20 63 73       	and    $0x73632078,%eax
c040dc95:	20 25 78 20 65 66    	and    %ah,0x66652078
c040dc9b:	6c                   	insb   (%dx),%es:(%edi)
c040dc9c:	61                   	popa   
c040dc9d:	67 73 20             	addr16 jae c040dcc0 <debug_initialise+0x4ac>
c040dca0:	25 78 20 75 73       	and    $0x73752078,%eax
c040dca5:	65                   	gs
c040dca6:	72 65                	jb     c040dd0d <debug_initialise+0x4f9>
c040dca8:	73 70                	jae    c040dd1a <debug_initialise+0x506>
c040dcaa:	20 25 78 20 73 73    	and    %ah,0x73732078
c040dcb0:	20 25 78 0a 00 00    	and    %ah,0xa78
c040dcb6:	00 00                	add    %al,(%eax)
c040dcb8:	5b                   	pop    %ebx
c040dcb9:	78 38                	js     c040dcf3 <debug_initialise+0x4df>
c040dcbb:	36 3a 25 69 5d 20 4f 	cmp    %ss:0x4f205d69,%ah
c040dcc2:	4d                   	dec    %ebp
c040dcc3:	47                   	inc    %edi
c040dcc4:	57                   	push   %edi
c040dcc5:	54                   	push   %esp
c040dcc6:	46                   	inc    %esi
c040dcc7:	3a 20                	cmp    (%eax),%ah
c040dcc9:	63 61 6e             	arpl   %sp,0x6e(%ecx)
c040dccc:	6e                   	outsb  %ds:(%esi),(%dx)
c040dccd:	6f                   	outsl  %ds:(%esi),(%dx)
c040dcce:	74 20                	je     c040dcf0 <debug_initialise+0x4dc>
c040dcd0:	66 69 6e 64 20 61    	imul   $0x6120,0x64(%esi),%bp
c040dcd6:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040dcda:	65                   	gs
c040dcdb:	61                   	popa   
c040dcdc:	64 20 74 6f 20       	and    %dh,%fs:0x20(%edi,%ebp,2)
c040dce1:	6b 69 63 6b          	imul   $0x6b,0x63(%ecx),%ebp
c040dce5:	73 74                	jae    c040dd5b <debug_initialise+0x547>
c040dce7:	61                   	popa   
c040dce8:	72 74                	jb     c040dd5e <debug_initialise+0x54a>
c040dcea:	2e 0a 00             	or     %cs:(%eax),%al
c040dced:	00 00                	add    %al,(%eax)
c040dcef:	00 5b 78             	add    %bl,0x78(%ebx)
c040dcf2:	38 36                	cmp    %dh,(%esi)
c040dcf4:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040dcfa:	69 63 6b 73 74 61 72 	imul   $0x72617473,0x6b(%ebx),%esp
c040dd01:	74 69                	je     c040dd6c <debug_initialise+0x558>
c040dd03:	6e                   	outsb  %ds:(%esi),(%dx)
c040dd04:	67 20 63 6f          	addr16 and %ah,0x6f(%bp,%di)
c040dd08:	6c                   	insb   (%dx),%es:(%edi)
c040dd09:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040dd0e:	65                   	gs
c040dd0f:	61                   	popa   
c040dd10:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040dd17:	70 29                	jo     c040dd42 <debug_initialise+0x52e>
c040dd19:	20 6f 66             	and    %ch,0x66(%edi)
c040dd1c:	20 70 72             	and    %dh,0x72(%eax)
c040dd1f:	6f                   	outsl  %ds:(%esi),(%dx)
c040dd20:	63 65 73             	arpl   %sp,0x73(%ebp)
c040dd23:	73 20                	jae    c040dd45 <debug_initialise+0x531>
c040dd25:	25 69 20 28 25       	and    $0x25282069,%eax
c040dd2a:	70 29                	jo     c040dd55 <debug_initialise+0x541>
c040dd2c:	20 73 74             	and    %dh,0x74(%ebx)
c040dd2f:	61                   	popa   
c040dd30:	63 6b 62             	arpl   %bp,0x62(%ebx)
c040dd33:	61                   	popa   
c040dd34:	73 65                	jae    c040dd9b <debug_initialise+0x587>
c040dd36:	20 25 78 20 6b 73    	and    %ah,0x736b2078
c040dd3c:	74 61                	je     c040dd9f <debug_initialise+0x58b>
c040dd3e:	63 6b 62             	arpl   %bp,0x62(%ebx)
c040dd41:	61                   	popa   
c040dd42:	73 65                	jae    c040dda9 <debug_initialise+0x595>
c040dd44:	20 25 78 20 74 73    	and    %ah,0x73742078
c040dd4a:	73 20                	jae    c040dd6c <debug_initialise+0x558>
c040dd4c:	25 78 20 61 74       	and    $0x74612078,%eax
c040dd51:	20 45 49             	and    %al,0x49(%ebp)
c040dd54:	50                   	push   %eax
c040dd55:	20 25 78 0a 00 00    	and    %ah,0xa78
c040dd5b:	00 5b 78             	add    %bl,0x78(%ebx)
c040dd5e:	38 36                	cmp    %dh,(%esi)
c040dd60:	3a 25 69 5d 20 63    	cmp    0x63205d69,%ah
c040dd66:	68 61 6e 67 69       	push   $0x69676e61
c040dd6b:	6e                   	outsb  %ds:(%esi),(%dx)
c040dd6c:	67 20 54 53          	addr16 and %dl,0x53(%si)
c040dd70:	53                   	push   %ebx
c040dd71:	3a 20                	cmp    (%eax),%ah
c040dd73:	67                   	addr16
c040dd74:	64                   	fs
c040dd75:	74 70                	je     c040dde7 <debug_initialise+0x5d3>
c040dd77:	74 72                	je     c040ddeb <debug_initialise+0x5d7>
c040dd79:	20 25 70 20 28 67    	and    %ah,0x67282070
c040dd7f:	64                   	fs
c040dd80:	74 20                	je     c040dda2 <debug_initialise+0x58e>
c040dd82:	62 61 73             	bound  %esp,0x73(%ecx)
c040dd85:	65 20 25 78 20 73 69 	and    %ah,%gs:0x69732078
c040dd8c:	7a 65                	jp     c040ddf3 <debug_initialise+0x5df>
c040dd8e:	20 25 69 20 62 79    	and    %ah,0x79622069
c040dd94:	74 65                	je     c040ddfb <debug_initialise+0x5e7>
c040dd96:	73 29                	jae    c040ddc1 <debug_initialise+0x5ad>
c040dd98:	20 65 6e             	and    %ah,0x6e(%ebp)
c040dd9b:	74 72                	je     c040de0f <debug_initialise+0x5fb>
c040dd9d:	79 20                	jns    c040ddbf <debug_initialise+0x5ab>
c040dd9f:	25 70 20 74 73       	and    $0x73742070,%eax
c040dda4:	73 20                	jae    c040ddc6 <debug_initialise+0x5b2>
c040dda6:	25 70 0a 00 00       	and    $0xa70,%eax
c040ddab:	00 5b 78             	add    %bl,0x78(%ebx)
c040ddae:	38 36                	cmp    %dh,(%esi)
c040ddb0:	3a 25 69 5d 20 73    	cmp    0x73205d69,%ah
c040ddb6:	77 69                	ja     c040de21 <debug_initialise+0x60d>
c040ddb8:	74 63                	je     c040de1d <debug_initialise+0x609>
c040ddba:	68 69 6e 67 20       	push   $0x20676e69
c040ddbf:	66                   	data16
c040ddc0:	72 6f                	jb     c040de31 <debug_initialise+0x61d>
c040ddc2:	6d                   	insl   (%dx),%es:(%edi)
c040ddc3:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040ddc7:	65                   	gs
c040ddc8:	61                   	popa   
c040ddc9:	64 20 25 70 20 28 74 	and    %ah,%fs:0x74282070
c040ddd0:	69 64 20 25 69 20 70 	imul   $0x69702069,0x25(%eax,%eiz,1),%esp
c040ddd7:	69 
c040ddd8:	64 20 25 69 29 20 77 	and    %ah,%fs:0x77202969
c040dddf:	69 74 68 20 6c 6f 63 	imul   $0x6b636f6c,0x20(%eax,%ebp,2),%esi
c040dde6:	6b 
c040dde7:	20 25 70 20 73 74    	and    %ah,0x74732070
c040dded:	69 6c 6c 20 65 6e 67 	imul   $0x61676e65,0x20(%esp,%ebp,2),%ebp
c040ddf4:	61 
c040ddf5:	67 65 64 21 0a       	addr16 and %ecx,%fs:%gs:(%bp,%si)
c040ddfa:	00 00                	add    %al,(%eax)
c040ddfc:	20 20                	and    %ah,(%eax)
c040ddfe:	20 20                	and    %ah,(%eax)
c040de00:	20 20                	and    %ah,(%eax)
c040de02:	20 20                	and    %ah,(%eax)
c040de04:	6c                   	insb   (%dx),%es:(%edi)
c040de05:	6f                   	outsl  %ds:(%esi),(%dx)
c040de06:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040de09:	6f                   	outsl  %ds:(%esi),(%dx)
c040de0a:	77 6e                	ja     c040de7a <debug_initialise+0x666>
c040de0c:	65                   	gs
c040de0d:	72 20                	jb     c040de2f <debug_initialise+0x61b>
c040de0f:	69 73 20 25 70 20 28 	imul   $0x28207025,0x20(%ebx),%esi
c040de16:	74 69                	je     c040de81 <debug_initialise+0x66d>
c040de18:	64 20 25 69 20 70 69 	and    %ah,%fs:0x69702069
c040de1f:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040de26:	20 2a                	and    %ch,(%edx)
c040de28:	2a 2a                	sub    (%edx),%ch
c040de2a:	20 68 61             	and    %ch,0x61(%eax)
c040de2d:	6c                   	insb   (%dx),%es:(%edi)
c040de2e:	74 69                	je     c040de99 <debug_initialise+0x685>
c040de30:	6e                   	outsb  %ds:(%esi),(%dx)
c040de31:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040de35:	00 00                	add    %al,(%eax)
c040de37:	00 5b 78             	add    %bl,0x78(%ebx)
c040de3a:	38 36                	cmp    %dh,(%esi)
c040de3c:	3a 25 69 5d 20 73    	cmp    0x73205d69,%ah
c040de42:	77 69                	ja     c040dead <debug_initialise+0x699>
c040de44:	74 63                	je     c040dea9 <debug_initialise+0x695>
c040de46:	68 69 6e 67 20       	push   $0x20676e69
c040de4b:	66                   	data16
c040de4c:	72 6f                	jb     c040debd <debug_initialise+0x6a9>
c040de4e:	6d                   	insl   (%dx),%es:(%edi)
c040de4f:	20 70 72             	and    %dh,0x72(%eax)
c040de52:	6f                   	outsl  %ds:(%esi),(%dx)
c040de53:	63 65 73             	arpl   %sp,0x73(%ebp)
c040de56:	73 20                	jae    c040de78 <debug_initialise+0x664>
c040de58:	25 70 20 28 70       	and    $0x70282070,%eax
c040de5d:	69 64 20 25 69 29 20 	imul   $0x77202969,0x25(%eax,%eiz,1),%esp
c040de64:	77 
c040de65:	69 74 68 20 6c 6f 63 	imul   $0x6b636f6c,0x20(%eax,%ebp,2),%esi
c040de6c:	6b 
c040de6d:	20 25 70 20 73 74    	and    %ah,0x74732070
c040de73:	69 6c 6c 20 65 6e 67 	imul   $0x61676e65,0x20(%esp,%ebp,2),%ebp
c040de7a:	61 
c040de7b:	67 65 64 21 0a       	addr16 and %ecx,%fs:%gs:(%bp,%si)
c040de80:	00 00                	add    %al,(%eax)
c040de82:	00 00                	add    %al,(%eax)
c040de84:	5b                   	pop    %ebx
c040de85:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040de8c:	20 41 50             	and    %al,0x50(%ecx)
c040de8f:	49                   	dec    %ecx
c040de90:	43                   	inc    %ebx
c040de91:	20 73 70             	and    %dh,0x70(%ebx)
c040de94:	75 72                	jne    c040df08 <debug_initialise+0x6f4>
c040de96:	69 6f 75 73 20 69 6e 	imul   $0x6e692073,0x75(%edi),%ebp
c040de9d:	74 65                	je     c040df04 <debug_initialise+0x6f0>
c040de9f:	72 72                	jb     c040df13 <debug_initialise+0x6ff>
c040dea1:	75 70                	jne    c040df13 <debug_initialise+0x6ff>
c040dea3:	74 0a                	je     c040deaf <debug_initialise+0x69b>
c040dea5:	00 00                	add    %al,(%eax)
c040dea7:	00 5b 69             	add    %bl,0x69(%ebx)
c040deaa:	6e                   	outsb  %ds:(%esi),(%dx)
c040deab:	74 3a                	je     c040dee7 <debug_initialise+0x6d3>
c040dead:	25 69 5d 20 41       	and    $0x41205d69,%eax
c040deb2:	50                   	push   %eax
c040deb3:	49                   	dec    %ecx
c040deb4:	43                   	inc    %ebx
c040deb5:	20 74 69 6d          	and    %dh,0x6d(%ecx,%ebp,2)
c040deb9:	65                   	gs
c040deba:	72 20                	jb     c040dedc <debug_initialise+0x6c8>
c040debc:	69 6e 74 65 72 72 75 	imul   $0x75727265,0x74(%esi),%ebp
c040dec3:	70 74                	jo     c040df39 <debug_initialise+0x725>
c040dec5:	0a 00                	or     (%eax),%al
c040dec7:	5b                   	pop    %ebx
c040dec8:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040decf:	20 41 50             	and    %al,0x50(%ecx)
c040ded2:	49                   	dec    %ecx
c040ded3:	43                   	inc    %ebx
c040ded4:	20 69 6e             	and    %ch,0x6e(%ecx)
c040ded7:	74 65                	je     c040df3e <debug_initialise+0x72a>
c040ded9:	72 72                	jb     c040df4d <debug_initialise+0x739>
c040dedb:	75 70                	jne    c040df4d <debug_initialise+0x739>
c040dedd:	74 3a                	je     c040df19 <debug_initialise+0x705>
c040dedf:	20 25 78 0a 00 5b    	and    %ah,0x5b000a78
c040dee5:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040deec:	20 75 6e             	and    %dh,0x6e(%ebp)
c040deef:	68 61 6e 64 6c       	push   $0x6c646e61
c040def4:	65 64 20 69 6e       	and    %ch,%fs:%gs:0x6e(%ecx)
c040def9:	74 65                	je     c040df60 <debug_initialise+0x74c>
c040defb:	72 72                	jb     c040df6f <debug_initialise+0x75b>
c040defd:	75 70                	jne    c040df6f <debug_initialise+0x75b>
c040deff:	74 20                	je     c040df21 <debug_initialise+0x70d>
c040df01:	25 78 20 72 65       	and    $0x65722078,%eax
c040df06:	63 65 69             	arpl   %sp,0x69(%ebp)
c040df09:	76 65                	jbe    c040df70 <debug_initialise+0x75c>
c040df0b:	64 21 0a             	and    %ecx,%fs:(%edx)
c040df0e:	00 00                	add    %al,(%eax)
c040df10:	5b                   	pop    %ebx
c040df11:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040df18:	20 61 63             	and    %ah,0x63(%ecx)
c040df1b:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
c040df1f:	6c                   	insb   (%dx),%es:(%edi)
c040df20:	65 64 67 69 6e 67 20 	addr16 imul $0x49504120,%fs:%gs:0x67(%bp),%ebp
c040df27:	41 50 49 
c040df2a:	43                   	inc    %ebx
c040df2b:	20 69 6e             	and    %ch,0x6e(%ecx)
c040df2e:	74 65                	je     c040df95 <debug_initialise+0x781>
c040df30:	72 72                	jb     c040dfa4 <debug_initialise+0x790>
c040df32:	75 70                	jne    c040dfa4 <debug_initialise+0x790>
c040df34:	74 20                	je     c040df56 <debug_initialise+0x742>
c040df36:	28 25 78 29 0a 00    	sub    %ah,0xa2978
c040df3c:	5b                   	pop    %ebx
c040df3d:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040df44:	20 61 63             	and    %ah,0x63(%ecx)
c040df47:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
c040df4b:	6c                   	insb   (%dx),%es:(%edi)
c040df4c:	65 64 67 69 6e 67 20 	addr16 imul $0x646c6f20,%fs:%gs:0x67(%bp),%ebp
c040df53:	6f 6c 64 
c040df56:	2d 77 6f 72 6c       	sub    $0x6c726f77,%eax
c040df5b:	64 20 69 6e          	and    %ch,%fs:0x6e(%ecx)
c040df5f:	74 65                	je     c040dfc6 <debug_initialise+0x7b2>
c040df61:	72 72                	jb     c040dfd5 <debug_initialise+0x7c1>
c040df63:	75 70                	jne    c040dfd5 <debug_initialise+0x7c1>
c040df65:	74 20                	je     c040df87 <debug_initialise+0x773>
c040df67:	28 25 78 29 0a 00    	sub    %ah,0xa2978
c040df6d:	00 00                	add    %al,(%eax)
c040df6f:	00 d7                	add    %dl,%bh
c040df71:	15 40 c0 e9 16       	adc    $0x16e9c040,%eax
c040df76:	40                   	inc    %eax
c040df77:	c0 e9 16             	shr    $0x16,%cl
c040df7a:	40                   	inc    %eax
c040df7b:	c0 e9 16             	shr    $0x16,%cl
c040df7e:	40                   	inc    %eax
c040df7f:	c0 e9 16             	shr    $0x16,%cl
c040df82:	40                   	inc    %eax
c040df83:	c0 e9 16             	shr    $0x16,%cl
c040df86:	40                   	inc    %eax
c040df87:	c0 e9 16             	shr    $0x16,%cl
c040df8a:	40                   	inc    %eax
c040df8b:	c0 e9 16             	shr    $0x16,%cl
c040df8e:	40                   	inc    %eax
c040df8f:	c0 e9 16             	shr    $0x16,%cl
c040df92:	40                   	inc    %eax
c040df93:	c0 e9 16             	shr    $0x16,%cl
c040df96:	40                   	inc    %eax
c040df97:	c0 e9 16             	shr    $0x16,%cl
c040df9a:	40                   	inc    %eax
c040df9b:	c0 e9 16             	shr    $0x16,%cl
c040df9e:	40                   	inc    %eax
c040df9f:	c0 e9 16             	shr    $0x16,%cl
c040dfa2:	40                   	inc    %eax
c040dfa3:	c0 e9 16             	shr    $0x16,%cl
c040dfa6:	40                   	inc    %eax
c040dfa7:	c0 e9 16             	shr    $0x16,%cl
c040dfaa:	40                   	inc    %eax
c040dfab:	c0 e9 16             	shr    $0x16,%cl
c040dfae:	40                   	inc    %eax
c040dfaf:	c0                   	(bad)  
c040dfb0:	71 16                	jno    c040dfc8 <debug_initialise+0x7b4>
c040dfb2:	40                   	inc    %eax
c040dfb3:	c0                   	(bad)  
c040dfb4:	b4 16                	mov    $0x16,%ah
c040dfb6:	40                   	inc    %eax
c040dfb7:	c0                   	(bad)  
c040dfb8:	b4 16                	mov    $0x16,%ah
c040dfba:	40                   	inc    %eax
c040dfbb:	c0                   	(bad)  
c040dfbc:	b4 16                	mov    $0x16,%ah
c040dfbe:	40                   	inc    %eax
c040dfbf:	c0 e9 16             	shr    $0x16,%cl
c040dfc2:	40                   	inc    %eax
c040dfc3:	c0                   	(bad)  
c040dfc4:	b4 16                	mov    $0x16,%ah
c040dfc6:	40                   	inc    %eax
c040dfc7:	c0                   	(bad)  
c040dfc8:	b4 16                	mov    $0x16,%ah
c040dfca:	40                   	inc    %eax
c040dfcb:	c0 e9 16             	shr    $0x16,%cl
c040dfce:	40                   	inc    %eax
c040dfcf:	c0 e9 16             	shr    $0x16,%cl
c040dfd2:	40                   	inc    %eax
c040dfd3:	c0 e9 16             	shr    $0x16,%cl
c040dfd6:	40                   	inc    %eax
c040dfd7:	c0 e9 16             	shr    $0x16,%cl
c040dfda:	40                   	inc    %eax
c040dfdb:	c0 e9 16             	shr    $0x16,%cl
c040dfde:	40                   	inc    %eax
c040dfdf:	c0 e9 16             	shr    $0x16,%cl
c040dfe2:	40                   	inc    %eax
c040dfe3:	c0 e9 16             	shr    $0x16,%cl
c040dfe6:	40                   	inc    %eax
c040dfe7:	c0 e9 16             	shr    $0x16,%cl
c040dfea:	40                   	inc    %eax
c040dfeb:	c0 39 16             	sarb   $0x16,(%ecx)
c040dfee:	40                   	inc    %eax
c040dfef:	c0 c5 15             	rol    $0x15,%ch
c040dff2:	40                   	inc    %eax
c040dff3:	c0 5b 69 6e          	rcrb   $0x6e,0x69(%ebx)
c040dff7:	74 3a                	je     c040e033 <debug_initialise+0x81f>
c040dff9:	25 69 5d 20 49       	and    $0x49205d69,%eax
c040dffe:	4e                   	dec    %esi
c040dfff:	3a 20                	cmp    (%eax),%ah
c040e001:	64                   	fs
c040e002:	73 20                	jae    c040e024 <debug_initialise+0x810>
c040e004:	25 78 20 65 64       	and    $0x64652078,%eax
c040e009:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040e00f:	73 69                	jae    c040e07a <debug_initialise+0x866>
c040e011:	20 25 78 20 65 62    	and    %ah,0x62652078
c040e017:	70 20                	jo     c040e039 <debug_initialise+0x825>
c040e019:	25 78 20 65 73       	and    $0x73652078,%eax
c040e01e:	70 20                	jo     c040e040 <debug_initialise+0x82c>
c040e020:	25 78 20 65 62       	and    $0x62652078,%eax
c040e025:	78 20                	js     c040e047 <debug_initialise+0x833>
c040e027:	25 78 20 65 64       	and    $0x64652078,%eax
c040e02c:	78 20                	js     c040e04e <debug_initialise+0x83a>
c040e02e:	25 78 20 65 63       	and    $0x63652078,%eax
c040e033:	78 20                	js     c040e055 <debug_initialise+0x841>
c040e035:	25 78 20 65 61       	and    $0x61652078,%eax
c040e03a:	78 20                	js     c040e05c <debug_initialise+0x848>
c040e03c:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040e041:	20 20                	and    %ah,(%eax)
c040e043:	20 20                	and    %ah,(%eax)
c040e045:	69 6e 74 6e 75 6d 20 	imul   $0x206d756e,0x74(%esi),%ebp
c040e04c:	25 78 20 65 72       	and    $0x72652078,%eax
c040e051:	72 63                	jb     c040e0b6 <debug_initialise+0x8a2>
c040e053:	6f                   	outsl  %ds:(%esi),(%dx)
c040e054:	64 65 20 25 78 20 65 	and    %ah,%fs:%gs:0x69652078
c040e05b:	69 
c040e05c:	70 20                	jo     c040e07e <debug_initialise+0x86a>
c040e05e:	25 78 20 63 73       	and    $0x73632078,%eax
c040e063:	20 25 78 20 65 66    	and    %ah,0x66652078
c040e069:	6c                   	insb   (%dx),%es:(%edi)
c040e06a:	61                   	popa   
c040e06b:	67 73 20             	addr16 jae c040e08e <debug_initialise+0x87a>
c040e06e:	25 78 20 75 73       	and    $0x73752078,%eax
c040e073:	65                   	gs
c040e074:	72 65                	jb     c040e0db <debug_initialise+0x8c7>
c040e076:	73 70                	jae    c040e0e8 <debug_initialise+0x8d4>
c040e078:	20 25 78 20 73 73    	and    %ah,0x73732078
c040e07e:	20 25 78 0a 00 00    	and    %ah,0xa78
c040e084:	5b                   	pop    %ebx
c040e085:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e08c:	20 44 4f 55          	and    %al,0x55(%edi,%ecx,2)
c040e090:	42                   	inc    %edx
c040e091:	4c                   	dec    %esp
c040e092:	45                   	inc    %ebp
c040e093:	20 46 41             	and    %al,0x41(%esi)
c040e096:	55                   	push   %ebp
c040e097:	4c                   	dec    %esp
c040e098:	54                   	push   %esp
c040e099:	3a 20                	cmp    (%eax),%ah
c040e09b:	63 6f 64             	arpl   %bp,0x64(%edi)
c040e09e:	65 20 25 69 20 28 25 	and    %ah,%gs:0x25282069
c040e0a5:	78 29                	js     c040e0d0 <debug_initialise+0x8bc>
c040e0a7:	0a 00                	or     (%eax),%al
c040e0a9:	00 00                	add    %al,(%eax)
c040e0ab:	00 5b 69             	add    %bl,0x69(%ebx)
c040e0ae:	6e                   	outsb  %ds:(%esi),(%dx)
c040e0af:	74 3a                	je     c040e0eb <debug_initialise+0x8d7>
c040e0b1:	25 69 5d 20 47       	and    $0x47205d69,%eax
c040e0b6:	50                   	push   %eax
c040e0b7:	46                   	inc    %esi
c040e0b8:	3a 20                	cmp    (%eax),%ah
c040e0ba:	63 6f 64             	arpl   %bp,0x64(%edi)
c040e0bd:	65 20 25 69 20 28 30 	and    %ah,%gs:0x30282069
c040e0c4:	78 25                	js     c040e0eb <debug_initialise+0x8d7>
c040e0c6:	78 29                	js     c040e0f1 <debug_initialise+0x8dd>
c040e0c8:	20 65 69             	and    %ah,0x69(%ebp)
c040e0cb:	70 20                	jo     c040e0ed <debug_initialise+0x8d9>
c040e0cd:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040e0d2:	20 20                	and    %ah,(%eax)
c040e0d4:	20 20                	and    %ah,(%eax)
c040e0d6:	64                   	fs
c040e0d7:	73 20                	jae    c040e0f9 <debug_initialise+0x8e5>
c040e0d9:	25 78 20 65 64       	and    $0x64652078,%eax
c040e0de:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040e0e4:	62 70 20             	bound  %esi,0x20(%eax)
c040e0e7:	25 78 20 65 73       	and    $0x73652078,%eax
c040e0ec:	70 20                	jo     c040e10e <debug_initialise+0x8fa>
c040e0ee:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040e0f3:	20 20                	and    %ah,(%eax)
c040e0f5:	20 20                	and    %ah,(%eax)
c040e0f7:	65                   	gs
c040e0f8:	61                   	popa   
c040e0f9:	78 20                	js     c040e11b <debug_initialise+0x907>
c040e0fb:	25 78 20 63 73       	and    $0x73632078,%eax
c040e100:	20 25 78 20 65 66    	and    %ah,0x66652078
c040e106:	6c                   	insb   (%dx),%es:(%edi)
c040e107:	61                   	popa   
c040e108:	67 73 20             	addr16 jae c040e12b <debug_initialise+0x917>
c040e10b:	25 78 20 75 73       	and    $0x73752078,%eax
c040e110:	65                   	gs
c040e111:	72 65                	jb     c040e178 <debug_initialise+0x964>
c040e113:	73 70                	jae    c040e185 <debug_initialise+0x971>
c040e115:	20 25 78 20 73 73    	and    %ah,0x73732078
c040e11b:	20 25 78 0a 00 2a    	and    %ah,0x2a000a78
c040e121:	2a 2a                	sub    (%edx),%ch
c040e123:	20 70 61             	and    %dh,0x61(%eax)
c040e126:	6e                   	outsb  %ds:(%esi),(%dx)
c040e127:	69 63 3a 20 75 6e 68 	imul   $0x686e7520,0x3a(%ebx),%esp
c040e12e:	61                   	popa   
c040e12f:	6e                   	outsb  %ds:(%esi),(%dx)
c040e130:	64                   	fs
c040e131:	6c                   	insb   (%dx),%es:(%edi)
c040e132:	65 64 20 73 65       	and    %dh,%fs:%gs:0x65(%ebx)
c040e137:	72 69                	jb     c040e1a2 <debug_initialise+0x98e>
c040e139:	6f                   	outsl  %ds:(%esi),(%dx)
c040e13a:	75 73                	jne    c040e1af <debug_initialise+0x99b>
c040e13c:	20 66 61             	and    %ah,0x61(%esi)
c040e13f:	75 6c                	jne    c040e1ad <debug_initialise+0x999>
c040e141:	74 20                	je     c040e163 <debug_initialise+0x94f>
c040e143:	69 6e 20 74 68 65 20 	imul   $0x20656874,0x20(%esi),%ebp
c040e14a:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040e14e:	65                   	gs
c040e14f:	6c                   	insb   (%dx),%es:(%edi)
c040e150:	2e 20 68 61          	and    %ch,%cs:0x61(%eax)
c040e154:	6c                   	insb   (%dx),%es:(%edi)
c040e155:	74 69                	je     c040e1c0 <debug_initialise+0x9ac>
c040e157:	6e                   	outsb  %ds:(%esi),(%dx)
c040e158:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040e15c:	5b                   	pop    %ebx
c040e15d:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e164:	20 75 6e             	and    %dh,0x6e(%ebp)
c040e167:	6b 6e 6f 77          	imul   $0x77,0x6f(%esi),%ebp
c040e16b:	6e                   	outsb  %ds:(%esi),(%dx)
c040e16c:	20 73 79             	and    %dh,0x79(%ebx)
c040e16f:	73 63                	jae    c040e1d4 <debug_initialise+0x9c0>
c040e171:	61                   	popa   
c040e172:	6c                   	insb   (%dx),%es:(%edi)
c040e173:	6c                   	insb   (%dx),%es:(%edi)
c040e174:	20 25 78 20 62 79    	and    %ah,0x79622078
c040e17a:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040e17e:	65                   	gs
c040e17f:	61                   	popa   
c040e180:	64 20 25 69 20 69 6e 	and    %ah,%fs:0x6e692069
c040e187:	20 70 72             	and    %dh,0x72(%eax)
c040e18a:	6f                   	outsl  %ds:(%esi),(%dx)
c040e18b:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e18e:	73 20                	jae    c040e1b0 <debug_initialise+0x99c>
c040e190:	25 69 0a 00 5b       	and    $0x5b000a69,%eax
c040e195:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e19c:	20 75 6e             	and    %dh,0x6e(%ebp)
c040e19f:	68 61 6e 64 6c       	push   $0x6c646e61
c040e1a4:	65 64 20 65 78       	and    %ah,%fs:%gs:0x78(%ebp)
c040e1a9:	63 65 70             	arpl   %sp,0x70(%ebp)
c040e1ac:	74 69                	je     c040e217 <debug_initialise+0xa03>
c040e1ae:	6f                   	outsl  %ds:(%esi),(%dx)
c040e1af:	6e                   	outsb  %ds:(%esi),(%dx)
c040e1b0:	20 25 78 2f 25 78    	and    %ah,0x78252f78
c040e1b6:	20 72 65             	and    %dh,0x65(%edx)
c040e1b9:	63 65 69             	arpl   %sp,0x69(%ebp)
c040e1bc:	76 65                	jbe    c040e223 <debug_initialise+0xa0f>
c040e1be:	64 21 0a             	and    %ecx,%fs:(%edx)
c040e1c1:	00 00                	add    %al,(%eax)
c040e1c3:	00 5b 69             	add    %bl,0x69(%ebx)
c040e1c6:	6e                   	outsb  %ds:(%esi),(%dx)
c040e1c7:	74 3a                	je     c040e203 <debug_initialise+0x9ef>
c040e1c9:	25 69 5d 20 4f       	and    $0x4f205d69,%eax
c040e1ce:	55                   	push   %ebp
c040e1cf:	54                   	push   %esp
c040e1d0:	3a 20                	cmp    (%eax),%ah
c040e1d2:	64                   	fs
c040e1d3:	73 20                	jae    c040e1f5 <debug_initialise+0x9e1>
c040e1d5:	25 78 20 65 64       	and    $0x64652078,%eax
c040e1da:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040e1e0:	73 69                	jae    c040e24b <debug_initialise+0xa37>
c040e1e2:	20 25 78 20 65 62    	and    %ah,0x62652078
c040e1e8:	70 20                	jo     c040e20a <debug_initialise+0x9f6>
c040e1ea:	25 78 20 65 73       	and    $0x73652078,%eax
c040e1ef:	70 20                	jo     c040e211 <debug_initialise+0x9fd>
c040e1f1:	25 78 20 65 62       	and    $0x62652078,%eax
c040e1f6:	78 20                	js     c040e218 <debug_initialise+0xa04>
c040e1f8:	25 78 20 65 64       	and    $0x64652078,%eax
c040e1fd:	78 20                	js     c040e21f <debug_initialise+0xa0b>
c040e1ff:	25 78 20 65 63       	and    $0x63652078,%eax
c040e204:	78 20                	js     c040e226 <debug_initialise+0xa12>
c040e206:	25 78 20 65 61       	and    $0x61652078,%eax
c040e20b:	78 20                	js     c040e22d <debug_initialise+0xa19>
c040e20d:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040e212:	20 20                	and    %ah,(%eax)
c040e214:	20 20                	and    %ah,(%eax)
c040e216:	69 6e 74 6e 75 6d 20 	imul   $0x206d756e,0x74(%esi),%ebp
c040e21d:	25 78 20 65 72       	and    $0x72652078,%eax
c040e222:	72 63                	jb     c040e287 <debug_initialise+0xa73>
c040e224:	6f                   	outsl  %ds:(%esi),(%dx)
c040e225:	64 65 20 25 78 20 65 	and    %ah,%fs:%gs:0x69652078
c040e22c:	69 
c040e22d:	70 20                	jo     c040e24f <debug_initialise+0xa3b>
c040e22f:	25 78 20 63 73       	and    $0x73632078,%eax
c040e234:	20 25 78 20 65 66    	and    %ah,0x66652078
c040e23a:	6c                   	insb   (%dx),%es:(%edi)
c040e23b:	61                   	popa   
c040e23c:	67 73 20             	addr16 jae c040e25f <debug_initialise+0xa4b>
c040e23f:	25 78 20 75 73       	and    $0x73752078,%eax
c040e244:	65                   	gs
c040e245:	72 65                	jb     c040e2ac <debug_initialise+0xa98>
c040e247:	73 70                	jae    c040e2b9 <debug_initialise+0xaa5>
c040e249:	20 25 78 20 73 73    	and    %ah,0x73732078
c040e24f:	20 25 78 0a 00 a3    	and    %ah,0xa3000a78
c040e255:	1d 40 c0 bb 1d       	sbb    $0x1dbbc040,%eax
c040e25a:	40                   	inc    %eax
c040e25b:	c0 d3 1d             	rcl    $0x1d,%bl
c040e25e:	40                   	inc    %eax
c040e25f:	c0 eb 1d             	shr    $0x1d,%bl
c040e262:	40                   	inc    %eax
c040e263:	c0 03 1e             	rolb   $0x1e,(%ebx)
c040e266:	40                   	inc    %eax
c040e267:	c0 1b 1e             	rcrb   $0x1e,(%ebx)
c040e26a:	40                   	inc    %eax
c040e26b:	c0                   	(bad)  
c040e26c:	33 1e                	xor    (%esi),%ebx
c040e26e:	40                   	inc    %eax
c040e26f:	c0 4b 1e 40          	rorb   $0x40,0x1e(%ebx)
c040e273:	c0 63 1e 40          	shlb   $0x40,0x1e(%ebx)
c040e277:	c0 5b 69 6e          	rcrb   $0x6e,0x69(%ebx)
c040e27b:	74 3a                	je     c040e2b7 <debug_initialise+0xaa3>
c040e27d:	25 69 5d 20 6c       	and    $0x6c205d69,%eax
c040e282:	6f                   	outsl  %ds:(%esi),(%dx)
c040e283:	61                   	popa   
c040e284:	64 69 6e 67 20 69 64 	imul   $0x74646920,%fs:0x67(%esi),%ebp
c040e28b:	74 
c040e28c:	72 20                	jb     c040e2ae <debug_initialise+0xa9a>
c040e28e:	77 69                	ja     c040e2f9 <debug_initialise+0xae5>
c040e290:	74 68                	je     c040e2fa <debug_initialise+0xae6>
c040e292:	20 25 70 20 28 25    	and    %ah,0x25282070
c040e298:	78 20                	js     c040e2ba <debug_initialise+0xaa6>
c040e29a:	25 78 29 0a 00       	and    $0xa2978,%eax
c040e29f:	00 5b 69             	add    %bl,0x69(%ebx)
c040e2a2:	6e                   	outsb  %ds:(%esi),(%dx)
c040e2a3:	74 3a                	je     c040e2df <debug_initialise+0xacb>
c040e2a5:	25 69 5d 20 73       	and    $0x73205d69,%eax
c040e2aa:	65                   	gs
c040e2ab:	74 74                	je     c040e321 <debug_initialise+0xb0d>
c040e2ad:	69 6e 67 20 67 61 74 	imul   $0x74616720,0x67(%esi),%ebp
c040e2b4:	65 3a 20             	cmp    %gs:(%eax),%ah
c040e2b7:	23 25 69 20 3d 20    	and    0x203d2069,%esp
c040e2bd:	25 78 3a 25 78       	and    $0x78253a78,%eax
c040e2c2:	0a 00                	or     (%eax),%al
c040e2c4:	5b                   	pop    %ebx
c040e2c5:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e2cc:	20 69 6e             	and    %ch,0x6e(%ecx)
c040e2cf:	69 74 69 61 6c 69 73 	imul   $0x6973696c,0x61(%ecx,%ebp,2),%esi
c040e2d6:	69 
c040e2d7:	6e                   	outsb  %ds:(%esi),(%dx)
c040e2d8:	67 20 63 6f          	addr16 and %ah,0x6f(%bp,%di)
c040e2dc:	6d                   	insl   (%dx),%es:(%edi)
c040e2dd:	6d                   	insl   (%dx),%es:(%edi)
c040e2de:	6f                   	outsl  %ds:(%esi),(%dx)
c040e2df:	6e                   	outsb  %ds:(%esi),(%dx)
c040e2e0:	20 65 78             	and    %ah,0x78(%ebp)
c040e2e3:	63 65 70             	arpl   %sp,0x70(%ebp)
c040e2e6:	74 69                	je     c040e351 <debug_initialise+0xb3d>
c040e2e8:	6f                   	outsl  %ds:(%esi),(%dx)
c040e2e9:	6e                   	outsb  %ds:(%esi),(%dx)
c040e2ea:	20 61 6e             	and    %ah,0x6e(%ecx)
c040e2ed:	64 20 73 79          	and    %dh,%fs:0x79(%ebx)
c040e2f1:	73 63                	jae    c040e356 <debug_initialise+0xb42>
c040e2f3:	61                   	popa   
c040e2f4:	6c                   	insb   (%dx),%es:(%edi)
c040e2f5:	6c                   	insb   (%dx),%es:(%edi)
c040e2f6:	20 68 61             	and    %ch,0x61(%eax)
c040e2f9:	6e                   	outsb  %ds:(%esi),(%dx)
c040e2fa:	64                   	fs
c040e2fb:	6c                   	insb   (%dx),%es:(%edi)
c040e2fc:	65                   	gs
c040e2fd:	72 73                	jb     c040e372 <debug_initialise+0xb5e>
c040e2ff:	2e 2e 2e 20 0a       	and    %cl,%cs:(%edx)
c040e304:	00 00                	add    %al,(%eax)
c040e306:	00 00                	add    %al,(%eax)
c040e308:	5b                   	pop    %ebx
c040e309:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e310:	20 73 65             	and    %dh,0x65(%ebx)
c040e313:	6e                   	outsb  %ds:(%esi),(%dx)
c040e314:	64 69 6e 67 20 49 4e 	imul   $0x494e4920,%fs:0x67(%esi),%ebp
c040e31b:	49 
c040e31c:	54                   	push   %esp
c040e31d:	20 49 50             	and    %cl,0x50(%ecx)
c040e320:	49                   	dec    %ecx
c040e321:	20 28                	and    %ch,(%eax)
c040e323:	25 78 29 20 74       	and    $0x74202978,%eax
c040e328:	6f                   	outsl  %ds:(%esi),(%dx)
c040e329:	20 41 50             	and    %al,0x50(%ecx)
c040e32c:	20 25 69 2e 2e 0a    	and    %ah,0xa2e2e69
c040e332:	00 00                	add    %al,(%eax)
c040e334:	5b                   	pop    %ebx
c040e335:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e33c:	20 73 65             	and    %dh,0x65(%ebx)
c040e33f:	6e                   	outsb  %ds:(%esi),(%dx)
c040e340:	64 69 6e 67 20 73 74 	imul   $0x61747320,%fs:0x67(%esi),%ebp
c040e347:	61 
c040e348:	72 74                	jb     c040e3be <debug_initialise+0xbaa>
c040e34a:	75 70                	jne    c040e3bc <debug_initialise+0xba8>
c040e34c:	20 49 50             	and    %cl,0x50(%ecx)
c040e34f:	49                   	dec    %ecx
c040e350:	20 28                	and    %ch,(%eax)
c040e352:	25 78 29 20 74       	and    $0x74202978,%eax
c040e357:	6f                   	outsl  %ds:(%esi),(%dx)
c040e358:	20 41 50             	and    %al,0x50(%ecx)
c040e35b:	20 25 69 2e 2e 0a    	and    %ah,0xa2e2e69
c040e361:	00 00                	add    %al,(%eax)
c040e363:	00 5b 69             	add    %bl,0x69(%ebx)
c040e366:	6e                   	outsb  %ds:(%esi),(%dx)
c040e367:	74 3a                	je     c040e3a3 <debug_initialise+0xb8f>
c040e369:	25 69 5d 20 72       	and    $0x72205d69,%eax
c040e36e:	6f                   	outsl  %ds:(%esi),(%dx)
c040e36f:	75 74                	jne    c040e3e5 <debug_initialise+0xbd1>
c040e371:	69 6e 67 20 49 4f 41 	imul   $0x414f4920,0x67(%esi),%ebp
c040e378:	50                   	push   %eax
c040e379:	49                   	dec    %ecx
c040e37a:	43                   	inc    %ebx
c040e37b:	20 25 69 20 49 52    	and    %ah,0x52492069
c040e381:	51                   	push   %ecx
c040e382:	20 25 69 20 74 6f    	and    %ah,0x6f742069
c040e388:	20 43 50             	and    %al,0x50(%ebx)
c040e38b:	55                   	push   %ebp
c040e38c:	20 25 69 20 28 66    	and    %ah,0x66282069
c040e392:	6c                   	insb   (%dx),%es:(%edi)
c040e393:	61                   	popa   
c040e394:	67 73 20             	addr16 jae c040e3b7 <debug_initialise+0xba3>
c040e397:	25 78 29 0a 00       	and    $0xa2978,%eax
c040e39c:	5b                   	pop    %ebx
c040e39d:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e3a4:	20 70 72             	and    %dh,0x72(%eax)
c040e3a7:	6f                   	outsl  %ds:(%esi),(%dx)
c040e3a8:	67 72 61             	addr16 jb c040e40c <debug_initialise+0xbf8>
c040e3ab:	6d                   	insl   (%dx),%es:(%edi)
c040e3ac:	6d                   	insl   (%dx),%es:(%edi)
c040e3ad:	69 6e 67 20 41 50 49 	imul   $0x49504120,0x67(%esi),%ebp
c040e3b4:	43                   	inc    %ebx
c040e3b5:	20 6f 6e             	and    %ch,0x6e(%edi)
c040e3b8:	20 63 70             	and    %ah,0x70(%ebx)
c040e3bb:	75 20                	jne    c040e3dd <debug_initialise+0xbc9>
c040e3bd:	25 69 0a 00 00       	and    $0xa69,%eax
c040e3c2:	00 00                	add    %al,(%eax)
c040e3c4:	5b                   	pop    %ebx
c040e3c5:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e3cc:	20 70 65             	and    %dh,0x65(%eax)
c040e3cf:	72 66                	jb     c040e437 <debug_initialise+0xc23>
c040e3d1:	6f                   	outsl  %ds:(%esi),(%dx)
c040e3d2:	72 6d                	jb     c040e441 <debug_initialise+0xc2d>
c040e3d4:	69 6e 67 20 41 50 49 	imul   $0x49504120,0x67(%esi),%ebp
c040e3db:	43                   	inc    %ebx
c040e3dc:	20 70 72             	and    %dh,0x72(%eax)
c040e3df:	65                   	gs
c040e3e0:	2d 66 6c 69 67       	sub    $0x67696c66,%eax
c040e3e5:	68 74 20 63 68       	push   $0x68632074
c040e3ea:	65 63 6b 73          	arpl   %bp,%gs:0x73(%ebx)
c040e3ee:	2e 2e 2e 0a 00       	or     %cs:(%eax),%al
c040e3f3:	00 5b 69             	add    %bl,0x69(%ebx)
c040e3f6:	6e                   	outsb  %ds:(%esi),(%dx)
c040e3f7:	74 3a                	je     c040e433 <debug_initialise+0xc1f>
c040e3f9:	25 69 5d 20 70       	and    $0x70205d69,%eax
c040e3fe:	72 6f                	jb     c040e46f <debug_initialise+0xc5b>
c040e400:	67 72 61             	addr16 jb c040e464 <debug_initialise+0xc50>
c040e403:	6d                   	insl   (%dx),%es:(%edi)
c040e404:	6d                   	insl   (%dx),%es:(%edi)
c040e405:	69 6e 67 20 41 50 49 	imul   $0x49504120,0x67(%esi),%ebp
c040e40c:	43                   	inc    %ebx
c040e40d:	20 74 69 6d          	and    %dh,0x6d(%ecx,%ebp,2)
c040e411:	65                   	gs
c040e412:	72 20                	jb     c040e434 <debug_initialise+0xc20>
c040e414:	77 69                	ja     c040e47f <debug_initialise+0xc6b>
c040e416:	74 68                	je     c040e480 <debug_initialise+0xc6c>
c040e418:	20 72 65             	and    %dh,0x65(%edx)
c040e41b:	6c                   	insb   (%dx),%es:(%edi)
c040e41c:	6f                   	outsl  %ds:(%esi),(%dx)
c040e41d:	61                   	popa   
c040e41e:	64 20 76 61          	and    %dh,%fs:0x61(%esi)
c040e422:	6c                   	insb   (%dx),%es:(%edi)
c040e423:	75 65                	jne    c040e48a <debug_initialise+0xc76>
c040e425:	20 6f 66             	and    %ch,0x66(%edi)
c040e428:	20 25 78 0a 00 00    	and    %ah,0xa78
c040e42e:	00 00                	add    %al,(%eax)
c040e430:	5b                   	pop    %ebx
c040e431:	69 6e 74 3a 25 69 5d 	imul   $0x5d69253a,0x74(%esi),%ebp
c040e438:	20 75 6e             	and    %dh,0x6e(%ebp)
c040e43b:	69 70 72 6f 63 3a 20 	imul   $0x203a636f,0x72(%eax),%esi
c040e442:	74 69                	je     c040e4ad <debug_initialise+0xc99>
c040e444:	6d                   	insl   (%dx),%es:(%edi)
c040e445:	65                   	gs
c040e446:	72 3a                	jb     c040e482 <debug_initialise+0xc6e>
c040e448:	20 25 69 48 7a 0a    	and    %ah,0xa7a4869
c040e44e:	00 00                	add    %al,(%eax)
c040e450:	5b                   	pop    %ebx
c040e451:	73 79                	jae    c040e4cc <debug_initialise+0xcb8>
c040e453:	73 3a                	jae    c040e48f <debug_initialise+0xc7b>
c040e455:	25 69 5d 20 53       	and    $0x53205d69,%eax
c040e45a:	59                   	pop    %ecx
c040e45b:	53                   	push   %ebx
c040e45c:	43                   	inc    %ebx
c040e45d:	41                   	inc    %ecx
c040e45e:	4c                   	dec    %esp
c040e45f:	4c                   	dec    %esp
c040e460:	5f                   	pop    %edi
c040e461:	45                   	inc    %ebp
c040e462:	58                   	pop    %eax
c040e463:	49                   	dec    %ecx
c040e464:	54                   	push   %esp
c040e465:	20 63 61             	and    %ah,0x61(%ebx)
c040e468:	6c                   	insb   (%dx),%es:(%edi)
c040e469:	6c                   	insb   (%dx),%es:(%edi)
c040e46a:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e46f:	20 70 72             	and    %dh,0x72(%eax)
c040e472:	6f                   	outsl  %ds:(%esi),(%dx)
c040e473:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e476:	73 20                	jae    c040e498 <debug_initialise+0xc84>
c040e478:	25 69 20 28 25       	and    $0x25282069,%eax
c040e47d:	70 29                	jo     c040e4a8 <debug_initialise+0xc94>
c040e47f:	20 28                	and    %ch,(%eax)
c040e481:	74 68                	je     c040e4eb <debug_initialise+0xcd7>
c040e483:	72 65                	jb     c040e4ea <debug_initialise+0xcd6>
c040e485:	61                   	popa   
c040e486:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e48d:	00 00                	add    %al,(%eax)
c040e48f:	00 5b 73             	add    %bl,0x73(%ebx)
c040e492:	79 73                	jns    c040e507 <debug_initialise+0xcf3>
c040e494:	3a 25 69 5d 20 53    	cmp    0x53205d69,%ah
c040e49a:	59                   	pop    %ecx
c040e49b:	53                   	push   %ebx
c040e49c:	43                   	inc    %ebx
c040e49d:	41                   	inc    %ecx
c040e49e:	4c                   	dec    %esp
c040e49f:	4c                   	dec    %esp
c040e4a0:	5f                   	pop    %edi
c040e4a1:	46                   	inc    %esi
c040e4a2:	4f                   	dec    %edi
c040e4a3:	52                   	push   %edx
c040e4a4:	4b                   	dec    %ebx
c040e4a5:	20 63 61             	and    %ah,0x61(%ebx)
c040e4a8:	6c                   	insb   (%dx),%es:(%edi)
c040e4a9:	6c                   	insb   (%dx),%es:(%edi)
c040e4aa:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e4af:	20 70 72             	and    %dh,0x72(%eax)
c040e4b2:	6f                   	outsl  %ds:(%esi),(%dx)
c040e4b3:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e4b6:	73 20                	jae    c040e4d8 <debug_initialise+0xcc4>
c040e4b8:	25 69 20 28 25       	and    $0x25282069,%eax
c040e4bd:	70 29                	jo     c040e4e8 <debug_initialise+0xcd4>
c040e4bf:	20 28                	and    %ch,(%eax)
c040e4c1:	74 68                	je     c040e52b <debug_initialise+0xd17>
c040e4c3:	72 65                	jb     c040e52a <debug_initialise+0xd16>
c040e4c5:	61                   	popa   
c040e4c6:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e4cd:	00 00                	add    %al,(%eax)
c040e4cf:	00 5b 73             	add    %bl,0x73(%ebx)
c040e4d2:	79 73                	jns    c040e547 <debug_initialise+0xd33>
c040e4d4:	3a 25 69 5d 20 53    	cmp    0x53205d69,%ah
c040e4da:	59                   	pop    %ecx
c040e4db:	53                   	push   %ebx
c040e4dc:	43                   	inc    %ebx
c040e4dd:	41                   	inc    %ecx
c040e4de:	4c                   	dec    %esp
c040e4df:	4c                   	dec    %esp
c040e4e0:	5f                   	pop    %edi
c040e4e1:	4b                   	dec    %ebx
c040e4e2:	49                   	dec    %ecx
c040e4e3:	4c                   	dec    %esp
c040e4e4:	4c                   	dec    %esp
c040e4e5:	28 25 69 29 20 63    	sub    %ah,0x63202969
c040e4eb:	61                   	popa   
c040e4ec:	6c                   	insb   (%dx),%es:(%edi)
c040e4ed:	6c                   	insb   (%dx),%es:(%edi)
c040e4ee:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e4f3:	20 70 72             	and    %dh,0x72(%eax)
c040e4f6:	6f                   	outsl  %ds:(%esi),(%dx)
c040e4f7:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e4fa:	73 20                	jae    c040e51c <debug_initialise+0xd08>
c040e4fc:	25 69 20 28 25       	and    $0x25282069,%eax
c040e501:	70 29                	jo     c040e52c <debug_initialise+0xd18>
c040e503:	20 28                	and    %ch,(%eax)
c040e505:	74 68                	je     c040e56f <debug_initialise+0xd5b>
c040e507:	72 65                	jb     c040e56e <debug_initialise+0xd5a>
c040e509:	61                   	popa   
c040e50a:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e511:	00 00                	add    %al,(%eax)
c040e513:	00 5b 73             	add    %bl,0x73(%ebx)
c040e516:	79 73                	jns    c040e58b <debug_initialise+0xd77>
c040e518:	3a 25 69 5d 20 53    	cmp    0x53205d69,%ah
c040e51e:	59                   	pop    %ecx
c040e51f:	53                   	push   %ebx
c040e520:	43                   	inc    %ebx
c040e521:	41                   	inc    %ecx
c040e522:	4c                   	dec    %esp
c040e523:	4c                   	dec    %esp
c040e524:	5f                   	pop    %edi
c040e525:	59                   	pop    %ecx
c040e526:	49                   	dec    %ecx
c040e527:	45                   	inc    %ebp
c040e528:	4c                   	dec    %esp
c040e529:	44                   	inc    %esp
c040e52a:	20 63 61             	and    %ah,0x61(%ebx)
c040e52d:	6c                   	insb   (%dx),%es:(%edi)
c040e52e:	6c                   	insb   (%dx),%es:(%edi)
c040e52f:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e534:	20 70 72             	and    %dh,0x72(%eax)
c040e537:	6f                   	outsl  %ds:(%esi),(%dx)
c040e538:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e53b:	73 20                	jae    c040e55d <debug_initialise+0xd49>
c040e53d:	25 69 20 28 25       	and    $0x25282069,%eax
c040e542:	70 29                	jo     c040e56d <debug_initialise+0xd59>
c040e544:	20 28                	and    %ch,(%eax)
c040e546:	74 68                	je     c040e5b0 <debug_initialise+0xd9c>
c040e548:	72 65                	jb     c040e5af <debug_initialise+0xd9b>
c040e54a:	61                   	popa   
c040e54b:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e552:	00 00                	add    %al,(%eax)
c040e554:	5b                   	pop    %ebx
c040e555:	73 79                	jae    c040e5d0 <debug_initialise+0xdbc>
c040e557:	73 3a                	jae    c040e593 <debug_initialise+0xd7f>
c040e559:	25 69 5d 20 53       	and    $0x53205d69,%eax
c040e55e:	59                   	pop    %ecx
c040e55f:	53                   	push   %ebx
c040e560:	43                   	inc    %ebx
c040e561:	41                   	inc    %ecx
c040e562:	4c                   	dec    %esp
c040e563:	4c                   	dec    %esp
c040e564:	5f                   	pop    %edi
c040e565:	54                   	push   %esp
c040e566:	48                   	dec    %eax
c040e567:	52                   	push   %edx
c040e568:	45                   	inc    %ebp
c040e569:	41                   	inc    %ecx
c040e56a:	44                   	inc    %esp
c040e56b:	5f                   	pop    %edi
c040e56c:	45                   	inc    %ebp
c040e56d:	58                   	pop    %eax
c040e56e:	49                   	dec    %ecx
c040e56f:	54                   	push   %esp
c040e570:	20 63 61             	and    %ah,0x61(%ebx)
c040e573:	6c                   	insb   (%dx),%es:(%edi)
c040e574:	6c                   	insb   (%dx),%es:(%edi)
c040e575:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e57a:	20 70 72             	and    %dh,0x72(%eax)
c040e57d:	6f                   	outsl  %ds:(%esi),(%dx)
c040e57e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e581:	73 20                	jae    c040e5a3 <debug_initialise+0xd8f>
c040e583:	25 69 20 28 25       	and    $0x25282069,%eax
c040e588:	70 29                	jo     c040e5b3 <debug_initialise+0xd9f>
c040e58a:	20 28                	and    %ch,(%eax)
c040e58c:	74 68                	je     c040e5f6 <debug_initialise+0xde2>
c040e58e:	72 65                	jb     c040e5f5 <debug_initialise+0xde1>
c040e590:	61                   	popa   
c040e591:	64 20 25 69 20 74 68 	and    %ah,%fs:0x68742069
c040e598:	72 65                	jb     c040e5ff <debug_initialise+0xdeb>
c040e59a:	61                   	popa   
c040e59b:	64                   	fs
c040e59c:	73 20                	jae    c040e5be <debug_initialise+0xdaa>
c040e59e:	25 69 29 0a 00       	and    $0xa2969,%eax
c040e5a3:	00 5b 73             	add    %bl,0x73(%ebx)
c040e5a6:	79 73                	jns    c040e61b <debug_initialise+0xe07>
c040e5a8:	3a 25 69 5d 20 53    	cmp    0x53205d69,%ah
c040e5ae:	59                   	pop    %ecx
c040e5af:	53                   	push   %ebx
c040e5b0:	43                   	inc    %ebx
c040e5b1:	41                   	inc    %ecx
c040e5b2:	4c                   	dec    %esp
c040e5b3:	4c                   	dec    %esp
c040e5b4:	5f                   	pop    %edi
c040e5b5:	54                   	push   %esp
c040e5b6:	48                   	dec    %eax
c040e5b7:	52                   	push   %edx
c040e5b8:	45                   	inc    %ebp
c040e5b9:	41                   	inc    %ecx
c040e5ba:	44                   	inc    %esp
c040e5bb:	5f                   	pop    %edi
c040e5bc:	46                   	inc    %esi
c040e5bd:	4f                   	dec    %edi
c040e5be:	52                   	push   %edx
c040e5bf:	4b                   	dec    %ebx
c040e5c0:	20 63 61             	and    %ah,0x61(%ebx)
c040e5c3:	6c                   	insb   (%dx),%es:(%edi)
c040e5c4:	6c                   	insb   (%dx),%es:(%edi)
c040e5c5:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e5ca:	20 70 72             	and    %dh,0x72(%eax)
c040e5cd:	6f                   	outsl  %ds:(%esi),(%dx)
c040e5ce:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e5d1:	73 20                	jae    c040e5f3 <debug_initialise+0xddf>
c040e5d3:	25 69 20 28 25       	and    $0x25282069,%eax
c040e5d8:	70 29                	jo     c040e603 <debug_initialise+0xdef>
c040e5da:	20 28                	and    %ch,(%eax)
c040e5dc:	74 68                	je     c040e646 <debug_initialise+0xe32>
c040e5de:	72 65                	jb     c040e645 <debug_initialise+0xe31>
c040e5e0:	61                   	popa   
c040e5e1:	64 20 25 69 20 75 73 	and    %ah,%fs:0x73752069
c040e5e8:	72 65                	jb     c040e64f <debug_initialise+0xe3b>
c040e5ea:	73 70                	jae    c040e65c <debug_initialise+0xe48>
c040e5ec:	20 25 78 29 0a 00    	and    %ah,0xa2978
c040e5f2:	00 00                	add    %al,(%eax)
c040e5f4:	5b                   	pop    %ebx
c040e5f5:	73 79                	jae    c040e670 <debug_initialise+0xe5c>
c040e5f7:	73 3a                	jae    c040e633 <debug_initialise+0xe1f>
c040e5f9:	25 69 5d 20 63       	and    $0x63205d69,%eax
c040e5fe:	6c                   	insb   (%dx),%es:(%edi)
c040e5ff:	6f                   	outsl  %ds:(%esi),(%dx)
c040e600:	6e                   	outsb  %ds:(%esi),(%dx)
c040e601:	69 6e 67 20 73 74 61 	imul   $0x61747320,0x67(%esi),%ebp
c040e608:	63 6b 3a             	arpl   %bp,0x3a(%ebx)
c040e60b:	20 74 61 72          	and    %dh,0x72(%ecx,%eiz,2)
c040e60f:	67                   	addr16
c040e610:	65                   	gs
c040e611:	74 20                	je     c040e633 <debug_initialise+0xe1f>
c040e613:	65                   	gs
c040e614:	73 70                	jae    c040e686 <debug_initialise+0xe72>
c040e616:	20 25 78 20 73 6f    	and    %ah,0x6f732078
c040e61c:	75 72                	jne    c040e690 <debug_initialise+0xe7c>
c040e61e:	63 65 20             	arpl   %sp,0x20(%ebp)
c040e621:	65                   	gs
c040e622:	73 70                	jae    c040e694 <debug_initialise+0xe80>
c040e624:	20 25 78 20 28 25    	and    %ah,0x25282078
c040e62a:	69 20 62 79 74 65    	imul   $0x65747962,(%eax),%esp
c040e630:	73 29                	jae    c040e65b <debug_initialise+0xe47>
c040e632:	20 28                	and    %ch,(%eax)
c040e634:	74 61                	je     c040e697 <debug_initialise+0xe83>
c040e636:	72 67                	jb     c040e69f <debug_initialise+0xe8b>
c040e638:	65                   	gs
c040e639:	74 20                	je     c040e65b <debug_initialise+0xe47>
c040e63b:	73 74                	jae    c040e6b1 <debug_initialise+0xe9d>
c040e63d:	61                   	popa   
c040e63e:	63 6b 62             	arpl   %bp,0x62(%ebx)
c040e641:	61                   	popa   
c040e642:	73 65                	jae    c040e6a9 <debug_initialise+0xe95>
c040e644:	20 25 78 20 73 6f    	and    %ah,0x6f732078
c040e64a:	75 72                	jne    c040e6be <debug_initialise+0xeaa>
c040e64c:	63 65 20             	arpl   %sp,0x20(%ebp)
c040e64f:	73 74                	jae    c040e6c5 <debug_initialise+0xeb1>
c040e651:	61                   	popa   
c040e652:	63 6b 62             	arpl   %bp,0x62(%ebx)
c040e655:	61                   	popa   
c040e656:	73 65                	jae    c040e6bd <debug_initialise+0xea9>
c040e658:	20 25 78 29 0a 00    	and    %ah,0xa2978
c040e65e:	00 00                	add    %al,(%eax)
c040e660:	5b                   	pop    %ebx
c040e661:	73 79                	jae    c040e6dc <debug_initialise+0xec8>
c040e663:	73 3a                	jae    c040e69f <debug_initialise+0xe8b>
c040e665:	25 69 5d 20 53       	and    $0x53205d69,%eax
c040e66a:	59                   	pop    %ecx
c040e66b:	53                   	push   %ebx
c040e66c:	43                   	inc    %ebx
c040e66d:	41                   	inc    %ecx
c040e66e:	4c                   	dec    %esp
c040e66f:	4c                   	dec    %esp
c040e670:	5f                   	pop    %edi
c040e671:	54                   	push   %esp
c040e672:	48                   	dec    %eax
c040e673:	52                   	push   %edx
c040e674:	45                   	inc    %ebp
c040e675:	41                   	inc    %ecx
c040e676:	44                   	inc    %esp
c040e677:	5f                   	pop    %edi
c040e678:	4b                   	dec    %ebx
c040e679:	49                   	dec    %ecx
c040e67a:	4c                   	dec    %esp
c040e67b:	4c                   	dec    %esp
c040e67c:	28 25 69 29 20 63    	sub    %ah,0x63202969
c040e682:	61                   	popa   
c040e683:	6c                   	insb   (%dx),%es:(%edi)
c040e684:	6c                   	insb   (%dx),%es:(%edi)
c040e685:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e68a:	20 70 72             	and    %dh,0x72(%eax)
c040e68d:	6f                   	outsl  %ds:(%esi),(%dx)
c040e68e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e691:	73 20                	jae    c040e6b3 <debug_initialise+0xe9f>
c040e693:	25 69 20 28 25       	and    $0x25282069,%eax
c040e698:	70 29                	jo     c040e6c3 <debug_initialise+0xeaf>
c040e69a:	20 28                	and    %ch,(%eax)
c040e69c:	74 68                	je     c040e706 <debug_initialise+0xef2>
c040e69e:	72 65                	jb     c040e705 <debug_initialise+0xef1>
c040e6a0:	61                   	popa   
c040e6a1:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e6a8:	5b                   	pop    %ebx
c040e6a9:	73 79                	jae    c040e724 <debug_initialise+0xf10>
c040e6ab:	73 3a                	jae    c040e6e7 <debug_initialise+0xed3>
c040e6ad:	25 69 5d 20 53       	and    $0x53205d69,%eax
c040e6b2:	59                   	pop    %ecx
c040e6b3:	53                   	push   %ebx
c040e6b4:	43                   	inc    %ebx
c040e6b5:	41                   	inc    %ecx
c040e6b6:	4c                   	dec    %esp
c040e6b7:	4c                   	dec    %esp
c040e6b8:	5f                   	pop    %edi
c040e6b9:	4d                   	dec    %ebp
c040e6ba:	53                   	push   %ebx
c040e6bb:	47                   	inc    %edi
c040e6bc:	5f                   	pop    %edi
c040e6bd:	53                   	push   %ebx
c040e6be:	45                   	inc    %ebp
c040e6bf:	4e                   	dec    %esi
c040e6c0:	44                   	inc    %esp
c040e6c1:	28 25 78 29 20 63    	sub    %ah,0x63202978
c040e6c7:	61                   	popa   
c040e6c8:	6c                   	insb   (%dx),%es:(%edi)
c040e6c9:	6c                   	insb   (%dx),%es:(%edi)
c040e6ca:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e6cf:	20 70 72             	and    %dh,0x72(%eax)
c040e6d2:	6f                   	outsl  %ds:(%esi),(%dx)
c040e6d3:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e6d6:	73 20                	jae    c040e6f8 <debug_initialise+0xee4>
c040e6d8:	25 69 20 28 25       	and    $0x25282069,%eax
c040e6dd:	70 29                	jo     c040e708 <debug_initialise+0xef4>
c040e6df:	20 28                	and    %ch,(%eax)
c040e6e1:	74 68                	je     c040e74b <debug_initialise+0xf37>
c040e6e3:	72 65                	jb     c040e74a <debug_initialise+0xf36>
c040e6e5:	61                   	popa   
c040e6e6:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e6ed:	00 00                	add    %al,(%eax)
c040e6ef:	00 5b 73             	add    %bl,0x73(%ebx)
c040e6f2:	79 73                	jns    c040e767 <debug_initialise+0xf53>
c040e6f4:	3a 25 69 5d 20 53    	cmp    0x53205d69,%ah
c040e6fa:	59                   	pop    %ecx
c040e6fb:	53                   	push   %ebx
c040e6fc:	43                   	inc    %ebx
c040e6fd:	41                   	inc    %ecx
c040e6fe:	4c                   	dec    %esp
c040e6ff:	4c                   	dec    %esp
c040e700:	5f                   	pop    %edi
c040e701:	4d                   	dec    %ebp
c040e702:	53                   	push   %ebx
c040e703:	47                   	inc    %edi
c040e704:	5f                   	pop    %edi
c040e705:	52                   	push   %edx
c040e706:	45                   	inc    %ebp
c040e707:	43                   	inc    %ebx
c040e708:	56                   	push   %esi
c040e709:	28 25 78 29 20 63    	sub    %ah,0x63202978
c040e70f:	61                   	popa   
c040e710:	6c                   	insb   (%dx),%es:(%edi)
c040e711:	6c                   	insb   (%dx),%es:(%edi)
c040e712:	65 64 20 62 79       	and    %ah,%fs:%gs:0x79(%edx)
c040e717:	20 70 72             	and    %dh,0x72(%eax)
c040e71a:	6f                   	outsl  %ds:(%esi),(%dx)
c040e71b:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e71e:	73 20                	jae    c040e740 <debug_initialise+0xf2c>
c040e720:	25 69 20 28 25       	and    $0x25282069,%eax
c040e725:	70 29                	jo     c040e750 <debug_initialise+0xf3c>
c040e727:	20 28                	and    %ch,(%eax)
c040e729:	74 68                	je     c040e793 <debug_initialise+0xf7f>
c040e72b:	72 65                	jb     c040e792 <debug_initialise+0xf7e>
c040e72d:	61                   	popa   
c040e72e:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040e735:	00 00                	add    %al,(%eax)
c040e737:	00 5b 6d             	add    %bl,0x6d(%ebx)
c040e73a:	73 67                	jae    c040e7a3 <debug_initialise+0xf8f>
c040e73c:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040e742:	4d                   	dec    %ebp
c040e743:	47                   	inc    %edi
c040e744:	57                   	push   %edi
c040e745:	54                   	push   %esp
c040e746:	46                   	inc    %esi
c040e747:	20 6d 73             	and    %ch,0x73(%ebp)
c040e74a:	67 5f                	addr16 pop %edi
c040e74c:	74 65                	je     c040e7b3 <debug_initialise+0xf9f>
c040e74e:	73 74                	jae    c040e7c4 <debug_initialise+0xfb0>
c040e750:	5f                   	pop    %edi
c040e751:	72 65                	jb     c040e7b8 <debug_initialise+0xfa4>
c040e753:	63 65 69             	arpl   %sp,0x69(%ebp)
c040e756:	76 65                	jbe    c040e7bd <debug_initialise+0xfa9>
c040e758:	72 28                	jb     c040e782 <debug_initialise+0xf6e>
c040e75a:	29 20                	sub    %esp,(%eax)
c040e75c:	63 61 6c             	arpl   %sp,0x6c(%ecx)
c040e75f:	6c                   	insb   (%dx),%es:(%edi)
c040e760:	65 64 20 77 69       	and    %dh,%fs:%gs:0x69(%edi)
c040e765:	74 68                	je     c040e7cf <debug_initialise+0xfbb>
c040e767:	20 73 65             	and    %dh,0x65(%ebx)
c040e76a:	6e                   	outsb  %ds:(%esi),(%dx)
c040e76b:	64                   	fs
c040e76c:	65                   	gs
c040e76d:	72 20                	jb     c040e78f <debug_initialise+0xf7b>
c040e76f:	25 70 20 74 61       	and    $0x61742070,%eax
c040e774:	72 67                	jb     c040e7dd <debug_initialise+0xfc9>
c040e776:	65                   	gs
c040e777:	74 20                	je     c040e799 <debug_initialise+0xf85>
c040e779:	25 70 20 6d 73       	and    $0x736d2070,%eax
c040e77e:	67 20 25             	addr16 and %ah,(%di)
c040e781:	70 0a                	jo     c040e78d <debug_initialise+0xf79>
c040e783:	00 5b 73             	add    %bl,0x73(%ebx)
c040e786:	63 68 65             	arpl   %bp,0x65(%eax)
c040e789:	64 3a 25 69 5d 20 74 	cmp    %fs:0x74205d69,%ah
c040e790:	6f                   	outsl  %ds:(%esi),(%dx)
c040e791:	74 61                	je     c040e7f4 <debug_initialise+0xfe0>
c040e793:	6c                   	insb   (%dx),%es:(%edi)
c040e794:	20 71 75             	and    %dh,0x75(%ecx)
c040e797:	65                   	gs
c040e798:	75 65                	jne    c040e7ff <debug_initialise+0xfeb>
c040e79a:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040e79f:	65                   	gs
c040e7a0:	61                   	popa   
c040e7a1:	64                   	fs
c040e7a2:	73 20                	jae    c040e7c4 <debug_initialise+0xfb0>
c040e7a4:	6e                   	outsb  %ds:(%esi),(%dx)
c040e7a5:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7a6:	77 3a                	ja     c040e7e2 <debug_initialise+0xfce>
c040e7a8:	20 25 69 20 28 75    	and    %ah,0x75282069
c040e7ae:	70 20                	jo     c040e7d0 <debug_initialise+0xfbc>
c040e7b0:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7b1:	6e                   	outsb  %ds:(%esi),(%dx)
c040e7b2:	65 29 0a             	sub    %ecx,%gs:(%edx)
c040e7b5:	00 00                	add    %al,(%eax)
c040e7b7:	00 5b 73             	add    %bl,0x73(%ebx)
c040e7ba:	63 68 65             	arpl   %bp,0x65(%eax)
c040e7bd:	64 3a 25 69 5d 20 74 	cmp    %fs:0x74205d69,%ah
c040e7c4:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7c5:	74 61                	je     c040e828 <debug_initialise+0x1014>
c040e7c7:	6c                   	insb   (%dx),%es:(%edi)
c040e7c8:	20 71 75             	and    %dh,0x75(%ecx)
c040e7cb:	65                   	gs
c040e7cc:	75 65                	jne    c040e833 <debug_initialise+0x101f>
c040e7ce:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040e7d3:	65                   	gs
c040e7d4:	61                   	popa   
c040e7d5:	64                   	fs
c040e7d6:	73 20                	jae    c040e7f8 <debug_initialise+0xfe4>
c040e7d8:	6e                   	outsb  %ds:(%esi),(%dx)
c040e7d9:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7da:	77 3a                	ja     c040e816 <debug_initialise+0x1002>
c040e7dc:	20 25 69 20 28 64    	and    %ah,0x64282069
c040e7e2:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7e3:	77 6e                	ja     c040e853 <debug_initialise+0x103f>
c040e7e5:	20 6f 6e             	and    %ch,0x6e(%edi)
c040e7e8:	65 29 0a             	sub    %ecx,%gs:(%edx)
c040e7eb:	00 5b 73             	add    %bl,0x73(%ebx)
c040e7ee:	63 68 65             	arpl   %bp,0x65(%eax)
c040e7f1:	64 3a 25 69 5d 20 6c 	cmp    %fs:0x6c205d69,%ah
c040e7f8:	6f                   	outsl  %ds:(%esi),(%dx)
c040e7f9:	63 6b 69             	arpl   %bp,0x69(%ebx)
c040e7fc:	6e                   	outsb  %ds:(%esi),(%dx)
c040e7fd:	67 20 70 72          	addr16 and %dh,0x72(%bx,%si)
c040e801:	6f                   	outsl  %ds:(%esi),(%dx)
c040e802:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e805:	73 20                	jae    c040e827 <debug_initialise+0x1013>
c040e807:	25 69 20 28 25       	and    $0x25282069,%eax
c040e80c:	70 29                	jo     c040e837 <debug_initialise+0x1023>
c040e80e:	0a 00                	or     (%eax),%al
c040e810:	5b                   	pop    %ebx
c040e811:	73 63                	jae    c040e876 <debug_initialise+0x1062>
c040e813:	68 65 64 3a 25       	push   $0x253a6465
c040e818:	69 5d 20 75 6e 6c 6f 	imul   $0x6f6c6e75,0x20(%ebp),%ebx
c040e81f:	63 6b 69             	arpl   %bp,0x69(%ebx)
c040e822:	6e                   	outsb  %ds:(%esi),(%dx)
c040e823:	67 20 70 72          	addr16 and %dh,0x72(%bx,%si)
c040e827:	6f                   	outsl  %ds:(%esi),(%dx)
c040e828:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e82b:	73 20                	jae    c040e84d <debug_initialise+0x1039>
c040e82d:	25 69 20 28 25       	and    $0x25282069,%eax
c040e832:	70 29                	jo     c040e85d <debug_initialise+0x1049>
c040e834:	0a 00                	or     (%eax),%al
c040e836:	5b                   	pop    %ebx
c040e837:	73 63                	jae    c040e89c <debug_initialise+0x1088>
c040e839:	68 65 64 3a 25       	push   $0x253a6465
c040e83e:	69 5d 20 63 61 72 65 	imul   $0x65726163,0x20(%ebp),%ebx
c040e845:	74 61                	je     c040e8a8 <debug_initialise+0x1094>
c040e847:	6b 65 72 20          	imul   $0x20,0x72(%ebp),%esp
c040e84b:	74 69                	je     c040e8b6 <debug_initialise+0x10a2>
c040e84d:	63 6b 0a             	arpl   %bp,0xa(%ebx)
c040e850:	00 00                	add    %al,(%eax)
c040e852:	00 00                	add    %al,(%eax)
c040e854:	5b                   	pop    %ebx
c040e855:	73 63                	jae    c040e8ba <debug_initialise+0x10a6>
c040e857:	68 65 64 3a 25       	push   $0x253a6465
c040e85c:	69 5d 20 74 69 6d 65 	imul   $0x656d6974,0x20(%ebp),%ebx
c040e863:	73 6c                	jae    c040e8d1 <debug_initialise+0x10bd>
c040e865:	69 63 65 20 66 6f 72 	imul   $0x726f6620,0x65(%ebx),%esp
c040e86c:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040e870:	65                   	gs
c040e871:	61                   	popa   
c040e872:	64 20 25 69 20 6f 66 	and    %ah,%fs:0x666f2069
c040e879:	20 70 72             	and    %dh,0x72(%eax)
c040e87c:	6f                   	outsl  %ds:(%esi),(%dx)
c040e87d:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e880:	73 20                	jae    c040e8a2 <debug_initialise+0x108e>
c040e882:	25 69 20 65 78       	and    $0x78652069,%eax
c040e887:	70 69                	jo     c040e8f2 <debug_initialise+0x10de>
c040e889:	72 65                	jb     c040e8f0 <debug_initialise+0x10dc>
c040e88b:	64 0a 00             	or     %fs:(%eax),%al
c040e88e:	5b                   	pop    %ebx
c040e88f:	73 63                	jae    c040e8f4 <debug_initialise+0x10e0>
c040e891:	68 65 64 3a 25       	push   $0x253a6465
c040e896:	69 5d 20 71 75 65 75 	imul   $0x75657571,0x20(%ebp),%ebx
c040e89d:	65 20 65 6d          	and    %ah,%gs:0x6d(%ebp)
c040e8a1:	70 74                	jo     c040e917 <debug_initialise+0x1103>
c040e8a3:	79 21                	jns    c040e8c6 <debug_initialise+0x10b2>
c040e8a5:	0a 00                	or     (%eax),%al
c040e8a7:	00 5b 73             	add    %bl,0x73(%ebx)
c040e8aa:	63 68 65             	arpl   %bp,0x65(%eax)
c040e8ad:	64 3a 25 69 5d 20 70 	cmp    %fs:0x70205d69,%ah
c040e8b4:	69 63 6b 69 6e 67 20 	imul   $0x20676e69,0x6b(%ebx),%esp
c040e8bb:	66                   	data16
c040e8bc:	72 6f                	jb     c040e92d <debug_initialise+0x1119>
c040e8be:	6d                   	insl   (%dx),%es:(%edi)
c040e8bf:	20 63 70             	and    %ah,0x70(%ebx)
c040e8c2:	75 20                	jne    c040e8e4 <debug_initialise+0x10d0>
c040e8c4:	25 69 20 71 75       	and    $0x75712069,%eax
c040e8c9:	65                   	gs
c040e8ca:	75 65                	jne    c040e931 <debug_initialise+0x111d>
c040e8cc:	3a 20                	cmp    (%eax),%ah
c040e8ce:	73 74                	jae    c040e944 <debug_initialise+0x1130>
c040e8d0:	61                   	popa   
c040e8d1:	72 74                	jb     c040e947 <debug_initialise+0x1133>
c040e8d3:	5b                   	pop    %ebx
c040e8d4:	74 25                	je     c040e8fb <debug_initialise+0x10e7>
c040e8d6:	69 20 70 25 69 5d    	imul   $0x5d692570,(%eax),%esp
c040e8dc:	20 00                	and    %al,(%eax)
c040e8de:	28 74 25 69          	sub    %dh,0x69(%ebp,%eiz,1)
c040e8e2:	20 70 25             	and    %dh,0x25(%eax)
c040e8e5:	69 29 20 00 65 6e    	imul   $0x6e650020,(%ecx),%ebp
c040e8eb:	64                   	fs
c040e8ec:	5b                   	pop    %ebx
c040e8ed:	74 25                	je     c040e914 <debug_initialise+0x1100>
c040e8ef:	69 20 70 25 69 5d    	imul   $0x5d692570,(%eax),%esp
c040e8f5:	0a 00                	or     (%eax),%al
c040e8f7:	65 6e                	outsb  %gs:(%esi),(%dx)
c040e8f9:	64                   	fs
c040e8fa:	5b                   	pop    %ebx
c040e8fb:	4e                   	dec    %esi
c040e8fc:	55                   	push   %ebp
c040e8fd:	4c                   	dec    %esp
c040e8fe:	4c                   	dec    %esp
c040e8ff:	5d                   	pop    %ebp
c040e900:	0a 00                	or     (%eax),%al
c040e902:	00 00                	add    %al,(%eax)
c040e904:	5b                   	pop    %ebx
c040e905:	73 63                	jae    c040e96a <debug_initialise+0x1156>
c040e907:	68 65 64 3a 25       	push   $0x253a6465
c040e90c:	69 5d 20 73 77 69 74 	imul   $0x74697773,0x20(%ebp),%ebx
c040e913:	63 68 65             	arpl   %bp,0x65(%eax)
c040e916:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040e91b:	65                   	gs
c040e91c:	61                   	popa   
c040e91d:	64 20 25 69 20 6f 66 	and    %ah,%fs:0x666f2069
c040e924:	20 70 72             	and    %dh,0x72(%eax)
c040e927:	6f                   	outsl  %ds:(%esi),(%dx)
c040e928:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e92b:	73 20                	jae    c040e94d <debug_initialise+0x1139>
c040e92d:	25 69 20 28 25       	and    $0x25282069,%eax
c040e932:	70 29                	jo     c040e95d <debug_initialise+0x1149>
c040e934:	20 66 6f             	and    %ah,0x6f(%esi)
c040e937:	72 20                	jb     c040e959 <debug_initialise+0x1145>
c040e939:	74 68                	je     c040e9a3 <debug_initialise+0x118f>
c040e93b:	72 65                	jb     c040e9a2 <debug_initialise+0x118e>
c040e93d:	61                   	popa   
c040e93e:	64 20 25 69 20 6f 66 	and    %ah,%fs:0x666f2069
c040e945:	20 70 72             	and    %dh,0x72(%eax)
c040e948:	6f                   	outsl  %ds:(%esi),(%dx)
c040e949:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e94c:	73 20                	jae    c040e96e <debug_initialise+0x115a>
c040e94e:	25 69 20 28 25       	and    $0x25282069,%eax
c040e953:	70 29                	jo     c040e97e <debug_initialise+0x116a>
c040e955:	0a 00                	or     (%eax),%al
c040e957:	00 5b 73             	add    %bl,0x73(%ebx)
c040e95a:	63 68 65             	arpl   %bp,0x65(%eax)
c040e95d:	64 3a 25 69 5d 20 6d 	cmp    %fs:0x6d205d69,%ah
c040e964:	6f                   	outsl  %ds:(%esi),(%dx)
c040e965:	76 65                	jbe    c040e9cc <debug_initialise+0x11b8>
c040e967:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040e96c:	65                   	gs
c040e96d:	61                   	popa   
c040e96e:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040e975:	70 29                	jo     c040e9a0 <debug_initialise+0x118c>
c040e977:	20 6f 66             	and    %ch,0x66(%edi)
c040e97a:	20 70 72             	and    %dh,0x72(%eax)
c040e97d:	6f                   	outsl  %ds:(%esi),(%dx)
c040e97e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e981:	73 20                	jae    c040e9a3 <debug_initialise+0x118f>
c040e983:	25 69 20 74 6f       	and    $0x6f742069,%eax
c040e988:	20 65 6e             	and    %ah,0x6e(%ebp)
c040e98b:	64 20 6f 66          	and    %ch,%fs:0x66(%edi)
c040e98f:	20 63 70             	and    %ah,0x70(%ebx)
c040e992:	75 20                	jne    c040e9b4 <debug_initialise+0x11a0>
c040e994:	25 69 20 71 75       	and    $0x75712069,%eax
c040e999:	65                   	gs
c040e99a:	75 65                	jne    c040ea01 <debug_initialise+0x11ed>
c040e99c:	2c 20                	sub    $0x20,%al
c040e99e:	70 72                	jo     c040ea12 <debug_initialise+0x11fe>
c040e9a0:	69 6f 72 69 74 79 20 	imul   $0x20797469,0x72(%edi),%ebp
c040e9a7:	25 69 0a 00 00       	and    $0xa69,%eax
c040e9ac:	5b                   	pop    %ebx
c040e9ad:	73 63                	jae    c040ea12 <debug_initialise+0x11fe>
c040e9af:	68 65 64 3a 25       	push   $0x253a6465
c040e9b4:	69 5d 20 61 64 64 65 	imul   $0x65646461,0x20(%ebp),%ebx
c040e9bb:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040e9c0:	65                   	gs
c040e9c1:	61                   	popa   
c040e9c2:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040e9c9:	70 29                	jo     c040e9f4 <debug_initialise+0x11e0>
c040e9cb:	20 6f 66             	and    %ch,0x66(%edi)
c040e9ce:	20 70 72             	and    %dh,0x72(%eax)
c040e9d1:	6f                   	outsl  %ds:(%esi),(%dx)
c040e9d2:	63 65 73             	arpl   %sp,0x73(%ebp)
c040e9d5:	73 20                	jae    c040e9f7 <debug_initialise+0x11e3>
c040e9d7:	25 69 20 74 6f       	and    $0x6f742069,%eax
c040e9dc:	20 63 70             	and    %ah,0x70(%ebx)
c040e9df:	75 20                	jne    c040ea01 <debug_initialise+0x11ed>
c040e9e1:	25 69 20 71 75       	and    $0x75712069,%eax
c040e9e6:	65                   	gs
c040e9e7:	75 65                	jne    c040ea4e <debug_initialise+0x123a>
c040e9e9:	2c 20                	sub    $0x20,%al
c040e9eb:	70 72                	jo     c040ea5f <debug_initialise+0x124b>
c040e9ed:	69 6f 72 69 74 79 20 	imul   $0x20797469,0x72(%edi),%ebp
c040e9f4:	25 69 0a 00 5b       	and    $0x5b000a69,%eax
c040e9f9:	73 63                	jae    c040ea5e <debug_initialise+0x124a>
c040e9fb:	68 65 64 3a 25       	push   $0x253a6465
c040ea00:	69 5d 20 72 65 6d 6f 	imul   $0x6f6d6572,0x20(%ebp),%ebx
c040ea07:	76 65                	jbe    c040ea6e <debug_initialise+0x125a>
c040ea09:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040ea0e:	65                   	gs
c040ea0f:	61                   	popa   
c040ea10:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040ea17:	70 29                	jo     c040ea42 <debug_initialise+0x122e>
c040ea19:	20 6f 66             	and    %ch,0x66(%edi)
c040ea1c:	20 70 72             	and    %dh,0x72(%eax)
c040ea1f:	6f                   	outsl  %ds:(%esi),(%dx)
c040ea20:	63 65 73             	arpl   %sp,0x73(%ebp)
c040ea23:	73 20                	jae    c040ea45 <debug_initialise+0x1231>
c040ea25:	25 69 20 66 72       	and    $0x72662069,%eax
c040ea2a:	6f                   	outsl  %ds:(%esi),(%dx)
c040ea2b:	6d                   	insl   (%dx),%es:(%edi)
c040ea2c:	20 63 70             	and    %ah,0x70(%ebx)
c040ea2f:	75 20                	jne    c040ea51 <debug_initialise+0x123d>
c040ea31:	25 69 20 71 75       	and    $0x75712069,%eax
c040ea36:	65                   	gs
c040ea37:	75 65                	jne    c040ea9e <debug_initialise+0x128a>
c040ea39:	2c 20                	sub    $0x20,%al
c040ea3b:	70 72                	jo     c040eaaf <debug_initialise+0x129b>
c040ea3d:	69 6f 72 69 74 79 20 	imul   $0x20797469,0x72(%edi),%ebp
c040ea44:	25 69 0a 00 5b       	and    $0x5b000a69,%eax
c040ea49:	73 63                	jae    c040eaae <debug_initialise+0x129a>
c040ea4b:	68 65 64 3a 25       	push   $0x253a6465
c040ea50:	69 5d 20 6c 6f 61 64 	imul   $0x64616f6c,0x20(%ebp),%ebx
c040ea57:	20 62 61             	and    %ah,0x61(%edx)
c040ea5a:	6c                   	insb   (%dx),%es:(%edi)
c040ea5b:	61                   	popa   
c040ea5c:	6e                   	outsb  %ds:(%esi),(%dx)
c040ea5d:	63 69 6e             	arpl   %bp,0x6e(%ecx)
c040ea60:	67 3a 20             	addr16 cmp (%bx,%si),%ah
c040ea63:	6d                   	insl   (%dx),%es:(%edi)
c040ea64:	61                   	popa   
c040ea65:	78 20                	js     c040ea87 <debug_initialise+0x1273>
c040ea67:	74 68                	je     c040ead1 <debug_initialise+0x12bd>
c040ea69:	72 65                	jb     c040ead0 <debug_initialise+0x12bc>
c040ea6b:	61                   	popa   
c040ea6c:	64                   	fs
c040ea6d:	73 20                	jae    c040ea8f <debug_initialise+0x127b>
c040ea6f:	70 65                	jo     c040ead6 <debug_initialise+0x12c2>
c040ea71:	72 20                	jb     c040ea93 <debug_initialise+0x127f>
c040ea73:	63 70 75             	arpl   %si,0x75(%eax)
c040ea76:	3a 20                	cmp    (%eax),%ah
c040ea78:	25 69 20 6e 65       	and    $0x656e2069,%eax
c040ea7d:	78 74                	js     c040eaf3 <debug_initialise+0x12df>
c040ea7f:	20 71 75             	and    %dh,0x75(%ecx)
c040ea82:	65                   	gs
c040ea83:	75 65                	jne    c040eaea <debug_initialise+0x12d6>
c040ea85:	3a 20                	cmp    (%eax),%ah
c040ea87:	25 69 20 28 25       	and    $0x25282069,%eax
c040ea8c:	69 29 20 68 69 6e    	imul   $0x6e696820,(%ecx),%ebp
c040ea92:	74 3a                	je     c040eace <debug_initialise+0x12ba>
c040ea94:	20 25 69 20 28 25    	and    %ah,0x25282069
c040ea9a:	69 29 20 74 6f 74    	imul   $0x746f7420,(%ecx),%ebp
c040eaa0:	61                   	popa   
c040eaa1:	6c                   	insb   (%dx),%es:(%edi)
c040eaa2:	20 71 75             	and    %dh,0x75(%ecx)
c040eaa5:	65                   	gs
c040eaa6:	75 65                	jne    c040eb0d <debug_initialise+0x12f9>
c040eaa8:	64 3a 20             	cmp    %fs:(%eax),%ah
c040eaab:	25 69 0a 00 00       	and    $0xa69,%eax
c040eab0:	5b                   	pop    %ebx
c040eab1:	73 63                	jae    c040eb16 <debug_initialise+0x1302>
c040eab3:	68 65 64 3a 25       	push   $0x253a6465
c040eab8:	69 5d 20 6c 6f 61 64 	imul   $0x64616f6c,0x20(%ebp),%ebx
c040eabf:	20 62 61             	and    %ah,0x61(%edx)
c040eac2:	6c                   	insb   (%dx),%es:(%edi)
c040eac3:	61                   	popa   
c040eac4:	6e                   	outsb  %ds:(%esi),(%dx)
c040eac5:	63 69 6e             	arpl   %bp,0x6e(%ecx)
c040eac8:	67 3a 20             	addr16 cmp (%bx,%si),%ah
c040eacb:	73 65                	jae    c040eb32 <debug_initialise+0x131e>
c040eacd:	6c                   	insb   (%dx),%es:(%edi)
c040eace:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040ead3:	20 71 75             	and    %dh,0x75(%ecx)
c040ead6:	65                   	gs
c040ead7:	75 65                	jne    c040eb3e <debug_initialise+0x132a>
c040ead9:	3a 20                	cmp    (%eax),%ah
c040eadb:	25 69 0a 00 00       	and    $0xa69,%eax
c040eae0:	5b                   	pop    %ebx
c040eae1:	73 63                	jae    c040eb46 <debug_initialise+0x1332>
c040eae3:	68 65 64 3a 25       	push   $0x253a6465
c040eae8:	69 5d 20 73 74 61 72 	imul   $0x72617473,0x20(%ebp),%ebx
c040eaef:	74 69                	je     c040eb5a <debug_initialise+0x1346>
c040eaf1:	6e                   	outsb  %ds:(%esi),(%dx)
c040eaf2:	67 20 6f 70          	addr16 and %ch,0x70(%bx)
c040eaf6:	65                   	gs
c040eaf7:	72 61                	jb     c040eb5a <debug_initialise+0x1346>
c040eaf9:	74 69                	je     c040eb64 <debug_initialise+0x1350>
c040eafb:	6e                   	outsb  %ds:(%esi),(%dx)
c040eafc:	67 20 73 79          	addr16 and %dh,0x79(%bp,%di)
c040eb00:	73 74                	jae    c040eb76 <debug_initialise+0x1362>
c040eb02:	65                   	gs
c040eb03:	6d                   	insl   (%dx),%es:(%edi)
c040eb04:	2e 2e 2e 0a 00       	or     %cs:(%eax),%al
c040eb09:	00 00                	add    %al,(%eax)
c040eb0b:	00 5b 76             	add    %bl,0x76(%ebx)
c040eb0e:	6d                   	insl   (%dx),%es:(%edi)
c040eb0f:	6d                   	insl   (%dx),%es:(%edi)
c040eb10:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040eb16:	4d                   	dec    %ebp
c040eb17:	47                   	inc    %edi
c040eb18:	57                   	push   %edi
c040eb19:	54                   	push   %esp
c040eb1a:	46                   	inc    %esi
c040eb1b:	3a 20                	cmp    (%eax),%ah
c040eb1d:	66 61                	popaw  
c040eb1f:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040eb26:	20 
c040eb27:	67 72 61             	addr16 jb c040eb8b <debug_initialise+0x1377>
c040eb2a:	62 20                	bound  %esp,(%eax)
c040eb2c:	70 68                	jo     c040eb96 <debug_initialise+0x1382>
c040eb2e:	79 73                	jns    c040eba3 <debug_initialise+0x138f>
c040eb30:	69 63 61 6c 20 70 61 	imul   $0x6170206c,0x61(%ebx),%esp
c040eb37:	67                   	addr16
c040eb38:	65                   	gs
c040eb39:	73 20                	jae    c040eb5b <debug_initialise+0x1347>
c040eb3b:	66 6f                	outsw  %ds:(%esi),(%dx)
c040eb3d:	72 20                	jb     c040eb5f <debug_initialise+0x134b>
c040eb3f:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040eb43:	65                   	gs
c040eb44:	6c                   	insb   (%dx),%es:(%edi)
c040eb45:	20 68 65             	and    %ch,0x65(%eax)
c040eb48:	61                   	popa   
c040eb49:	70 20                	jo     c040eb6b <debug_initialise+0x1357>
c040eb4b:	28 72 65             	sub    %dh,0x65(%edx)
c040eb4e:	71 20                	jno    c040eb70 <debug_initialise+0x135c>
c040eb50:	73 69                	jae    c040ebbb <debug_initialise+0x13a7>
c040eb52:	7a 65                	jp     c040ebb9 <debug_initialise+0x13a5>
c040eb54:	20 25 69 20 62 79    	and    %ah,0x79622069
c040eb5a:	74 65                	je     c040ebc1 <debug_initialise+0x13ad>
c040eb5c:	73 29                	jae    c040eb87 <debug_initialise+0x1373>
c040eb5e:	0a 00                	or     (%eax),%al
c040eb60:	5b                   	pop    %ebx
c040eb61:	76 6d                	jbe    c040ebd0 <debug_initialise+0x13bc>
c040eb63:	6d                   	insl   (%dx),%es:(%edi)
c040eb64:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040eb6a:	4d                   	dec    %ebp
c040eb6b:	47                   	inc    %edi
c040eb6c:	57                   	push   %edi
c040eb6d:	54                   	push   %esp
c040eb6e:	46                   	inc    %esi
c040eb6f:	3a 20                	cmp    (%eax),%ah
c040eb71:	66 61                	popaw  
c040eb73:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040eb7a:	20 
c040eb7b:	67 72 61             	addr16 jb c040ebdf <debug_initialise+0x13cb>
c040eb7e:	62 20                	bound  %esp,(%eax)
c040eb80:	70 68                	jo     c040ebea <debug_initialise+0x13d6>
c040eb82:	79 73                	jns    c040ebf7 <debug_initialise+0x13e3>
c040eb84:	69 63 61 6c 20 70 61 	imul   $0x6170206c,0x61(%ebx),%esp
c040eb8b:	67 65 20 66 6f       	addr16 and %ah,%gs:0x6f(%bp)
c040eb90:	72 20                	jb     c040ebb2 <debug_initialise+0x139e>
c040eb92:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040eb96:	65                   	gs
c040eb97:	6c                   	insb   (%dx),%es:(%edi)
c040eb98:	20 68 65             	and    %ch,0x65(%eax)
c040eb9b:	61                   	popa   
c040eb9c:	70 0a                	jo     c040eba8 <debug_initialise+0x1394>
c040eb9e:	00 00                	add    %al,(%eax)
c040eba0:	5b                   	pop    %ebx
c040eba1:	76 6d                	jbe    c040ec10 <debug_initialise+0x13fc>
c040eba3:	6d                   	insl   (%dx),%es:(%edi)
c040eba4:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ebaa:	4d                   	dec    %ebp
c040ebab:	47                   	inc    %edi
c040ebac:	57                   	push   %edi
c040ebad:	54                   	push   %esp
c040ebae:	46                   	inc    %esi
c040ebaf:	21 20                	and    %esp,(%eax)
c040ebb1:	76 6d                	jbe    c040ec20 <debug_initialise+0x140c>
c040ebb3:	6d                   	insl   (%dx),%es:(%edi)
c040ebb4:	5f                   	pop    %edi
c040ebb5:	66                   	data16
c040ebb6:	72 65                	jb     c040ec1d <debug_initialise+0x1409>
c040ebb8:	65 3a 20             	cmp    %gs:(%eax),%ah
c040ebbb:	67 69 76 65 6e 20 6e 	addr16 imul $0x6f6e206e,0x65(%bp),%esi
c040ebc2:	6f 
c040ebc3:	6e                   	outsb  %ds:(%esi),(%dx)
c040ebc4:	73 65                	jae    c040ec2b <debug_initialise+0x1417>
c040ebc6:	6e                   	outsb  %ds:(%esi),(%dx)
c040ebc7:	73 65                	jae    c040ec2e <debug_initialise+0x141a>
c040ebc9:	20 61 64             	and    %ah,0x64(%ecx)
c040ebcc:	64                   	fs
c040ebcd:	72 65                	jb     c040ec34 <debug_initialise+0x1420>
c040ebcf:	73 73                	jae    c040ec44 <debug_initialise+0x1430>
c040ebd1:	20 25 78 0a 00 00    	and    %ah,0xa78
c040ebd7:	00 5b 76             	add    %bl,0x76(%ebx)
c040ebda:	6d                   	insl   (%dx),%es:(%edi)
c040ebdb:	6d                   	insl   (%dx),%es:(%edi)
c040ebdc:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ebe2:	4d                   	dec    %ebp
c040ebe3:	47                   	inc    %edi
c040ebe4:	57                   	push   %edi
c040ebe5:	54                   	push   %esp
c040ebe6:	46                   	inc    %esi
c040ebe7:	21 20                	and    %esp,(%eax)
c040ebe9:	76 6d                	jbe    c040ec58 <debug_initialise+0x1444>
c040ebeb:	6d                   	insl   (%dx),%es:(%edi)
c040ebec:	5f                   	pop    %edi
c040ebed:	66                   	data16
c040ebee:	72 65                	jb     c040ec55 <debug_initialise+0x1441>
c040ebf0:	65 3a 20             	cmp    %gs:(%eax),%ah
c040ebf3:	62 6c 6f 63          	bound  %ebp,0x63(%edi,%ebp,2)
c040ebf7:	6b 20 25             	imul   $0x25,(%eax),%esp
c040ebfa:	78 20                	js     c040ec1c <debug_initialise+0x1408>
c040ebfc:	68 61 73 20 77       	push   $0x77207361
c040ec01:	72 6f                	jb     c040ec72 <debug_initialise+0x145e>
c040ec03:	6e                   	outsb  %ds:(%esi),(%dx)
c040ec04:	67 20 6d 61          	addr16 and %ch,0x61(%di)
c040ec08:	67 69 63 20 25 78 0a 	addr16 imul $0xa7825,0x20(%bp,%di),%esp
c040ec0f:	00 
c040ec10:	5b                   	pop    %ebx
c040ec11:	76 6d                	jbe    c040ec80 <debug_initialise+0x146c>
c040ec13:	6d                   	insl   (%dx),%es:(%edi)
c040ec14:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ec1a:	4d                   	dec    %ebp
c040ec1b:	47                   	inc    %edi
c040ec1c:	57                   	push   %edi
c040ec1d:	54                   	push   %esp
c040ec1e:	46                   	inc    %esi
c040ec1f:	21 20                	and    %esp,(%eax)
c040ec21:	76 6d                	jbe    c040ec90 <debug_initialise+0x147c>
c040ec23:	6d                   	insl   (%dx),%es:(%edi)
c040ec24:	5f                   	pop    %edi
c040ec25:	72 65                	jb     c040ec8c <debug_initialise+0x1478>
c040ec27:	74 75                	je     c040ec9e <debug_initialise+0x148a>
c040ec29:	72 6e                	jb     c040ec99 <debug_initialise+0x1485>
c040ec2b:	5f                   	pop    %edi
c040ec2c:	70 68                	jo     c040ec96 <debug_initialise+0x1482>
c040ec2e:	79 73                	jns    c040eca3 <debug_initialise+0x148f>
c040ec30:	5f                   	pop    %edi
c040ec31:	70 67                	jo     c040ec9a <debug_initialise+0x1486>
c040ec33:	3a 20                	cmp    (%eax),%ah
c040ec35:	70 68                	jo     c040ec9f <debug_initialise+0x148b>
c040ec37:	79 73                	jns    c040ecac <debug_initialise+0x1498>
c040ec39:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040ec40:	61                   	popa   
c040ec41:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040ec44:	66                   	data16
c040ec45:	72 61                	jb     c040eca8 <debug_initialise+0x1494>
c040ec47:	6d                   	insl   (%dx),%es:(%edi)
c040ec48:	65 20 25 78 20 6e 6f 	and    %ah,%gs:0x6f6e2078
c040ec4f:	74 20                	je     c040ec71 <debug_initialise+0x145d>
c040ec51:	70 61                	jo     c040ecb4 <debug_initialise+0x14a0>
c040ec53:	67 65 20 61 6c       	addr16 and %ah,%gs:0x6c(%bx,%di)
c040ec58:	69 67 6e 65 64 21 0a 	imul   $0xa216465,0x6e(%edi),%esp
c040ec5f:	00 5b 76             	add    %bl,0x76(%ebx)
c040ec62:	6d                   	insl   (%dx),%es:(%edi)
c040ec63:	6d                   	insl   (%dx),%es:(%edi)
c040ec64:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ec6a:	4d                   	dec    %ebp
c040ec6b:	47                   	inc    %edi
c040ec6c:	57                   	push   %edi
c040ec6d:	54                   	push   %esp
c040ec6e:	46                   	inc    %esi
c040ec6f:	21 20                	and    %esp,(%eax)
c040ec71:	76 6d                	jbe    c040ece0 <debug_initialise+0x14cc>
c040ec73:	6d                   	insl   (%dx),%es:(%edi)
c040ec74:	5f                   	pop    %edi
c040ec75:	72 65                	jb     c040ecdc <debug_initialise+0x14c8>
c040ec77:	74 75                	je     c040ecee <debug_initialise+0x14da>
c040ec79:	72 6e                	jb     c040ece9 <debug_initialise+0x14d5>
c040ec7b:	5f                   	pop    %edi
c040ec7c:	70 68                	jo     c040ece6 <debug_initialise+0x14d2>
c040ec7e:	79 73                	jns    c040ecf3 <debug_initialise+0x14df>
c040ec80:	5f                   	pop    %edi
c040ec81:	70 67                	jo     c040ecea <debug_initialise+0x14d6>
c040ec83:	3a 20                	cmp    (%eax),%ah
c040ec85:	6c                   	insb   (%dx),%es:(%edi)
c040ec86:	6f                   	outsl  %ds:(%esi),(%dx)
c040ec87:	77 20                	ja     c040eca9 <debug_initialise+0x1495>
c040ec89:	70 68                	jo     c040ecf3 <debug_initialise+0x14df>
c040ec8b:	79 73                	jns    c040ed00 <debug_initialise+0x14ec>
c040ec8d:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040ec94:	61                   	popa   
c040ec95:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040ec98:	66                   	data16
c040ec99:	72 61                	jb     c040ecfc <debug_initialise+0x14e8>
c040ec9b:	6d                   	insl   (%dx),%es:(%edi)
c040ec9c:	65 20 68 61          	and    %ch,%gs:0x61(%eax)
c040eca0:	73 20                	jae    c040ecc2 <debug_initialise+0x14ae>
c040eca2:	6f                   	outsl  %ds:(%esi),(%dx)
c040eca3:	76 65                	jbe    c040ed0a <debug_initialise+0x14f6>
c040eca5:	72 66                	jb     c040ed0d <debug_initialise+0x14f9>
c040eca7:	6c                   	insb   (%dx),%es:(%edi)
c040eca8:	6f                   	outsl  %ds:(%esi),(%dx)
c040eca9:	77 65                	ja     c040ed10 <debug_initialise+0x14fc>
c040ecab:	64 21 0a             	and    %ecx,%fs:(%edx)
c040ecae:	00 00                	add    %al,(%eax)
c040ecb0:	5b                   	pop    %ebx
c040ecb1:	76 6d                	jbe    c040ed20 <debug_initialise+0x150c>
c040ecb3:	6d                   	insl   (%dx),%es:(%edi)
c040ecb4:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ecba:	4d                   	dec    %ebp
c040ecbb:	47                   	inc    %edi
c040ecbc:	57                   	push   %edi
c040ecbd:	54                   	push   %esp
c040ecbe:	46                   	inc    %esi
c040ecbf:	21 20                	and    %esp,(%eax)
c040ecc1:	76 6d                	jbe    c040ed30 <debug_initialise+0x151c>
c040ecc3:	6d                   	insl   (%dx),%es:(%edi)
c040ecc4:	5f                   	pop    %edi
c040ecc5:	72 65                	jb     c040ed2c <debug_initialise+0x1518>
c040ecc7:	74 75                	je     c040ed3e <debug_initialise+0x152a>
c040ecc9:	72 6e                	jb     c040ed39 <debug_initialise+0x1525>
c040eccb:	5f                   	pop    %edi
c040eccc:	70 68                	jo     c040ed36 <debug_initialise+0x1522>
c040ecce:	79 73                	jns    c040ed43 <debug_initialise+0x152f>
c040ecd0:	5f                   	pop    %edi
c040ecd1:	70 67                	jo     c040ed3a <debug_initialise+0x1526>
c040ecd3:	3a 20                	cmp    (%eax),%ah
c040ecd5:	68 69 67 68 20       	push   $0x20686769
c040ecda:	70 68                	jo     c040ed44 <debug_initialise+0x1530>
c040ecdc:	79 73                	jns    c040ed51 <debug_initialise+0x153d>
c040ecde:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040ece5:	61                   	popa   
c040ece6:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040ece9:	68 61 73 20 6f       	push   $0x6f207361
c040ecee:	76 65                	jbe    c040ed55 <debug_initialise+0x1541>
c040ecf0:	72 66                	jb     c040ed58 <debug_initialise+0x1544>
c040ecf2:	6c                   	insb   (%dx),%es:(%edi)
c040ecf3:	6f                   	outsl  %ds:(%esi),(%dx)
c040ecf4:	77 65                	ja     c040ed5b <debug_initialise+0x1547>
c040ecf6:	64 21 0a             	and    %ecx,%fs:(%edx)
c040ecf9:	00 00                	add    %al,(%eax)
c040ecfb:	00 5b 76             	add    %bl,0x76(%ebx)
c040ecfe:	6d                   	insl   (%dx),%es:(%edi)
c040ecff:	6d                   	insl   (%dx),%es:(%edi)
c040ed00:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040ed06:	65                   	gs
c040ed07:	72 6e                	jb     c040ed77 <debug_initialise+0x1563>
c040ed09:	65                   	gs
c040ed0a:	6c                   	insb   (%dx),%es:(%edi)
c040ed0b:	3a 20                	cmp    (%eax),%ah
c040ed0d:	6c                   	insb   (%dx),%es:(%edi)
c040ed0e:	6f                   	outsl  %ds:(%esi),(%dx)
c040ed0f:	67 69 63 61 6c 20 73 	addr16 imul $0x7473206c,0x61(%bp,%di),%esp
c040ed16:	74 
c040ed17:	61                   	popa   
c040ed18:	72 74                	jb     c040ed8e <debug_initialise+0x157a>
c040ed1a:	20 25 78 20 65 6e    	and    %ah,0x6e652078
c040ed20:	64 20 25 78 20 73 69 	and    %ah,%fs:0x69732078
c040ed27:	7a 65                	jp     c040ed8e <debug_initialise+0x157a>
c040ed29:	20 25 69 20 62 79    	and    %ah,0x79622069
c040ed2f:	74 65                	je     c040ed96 <debug_initialise+0x1582>
c040ed31:	73 0a                	jae    c040ed3d <debug_initialise+0x1529>
c040ed33:	00 5b 76             	add    %bl,0x76(%ebx)
c040ed36:	6d                   	insl   (%dx),%es:(%edi)
c040ed37:	6d                   	insl   (%dx),%es:(%edi)
c040ed38:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040ed3e:	65                   	gs
c040ed3f:	72 6e                	jb     c040edaf <debug_initialise+0x159b>
c040ed41:	65                   	gs
c040ed42:	6c                   	insb   (%dx),%es:(%edi)
c040ed43:	3a 20                	cmp    (%eax),%ah
c040ed45:	70 68                	jo     c040edaf <debug_initialise+0x159b>
c040ed47:	79 73                	jns    c040edbc <debug_initialise+0x15a8>
c040ed49:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040ed50:	61                   	popa   
c040ed51:	72 74                	jb     c040edc7 <debug_initialise+0x15b3>
c040ed53:	20 25 78 20 65 6e    	and    %ah,0x6e652078
c040ed59:	64 20 25 78 20 61 6c 	and    %ah,%fs:0x6c612078
c040ed60:	69 67 6e 65 64 20 65 	imul   $0x65206465,0x6e(%edi),%esp
c040ed67:	6e                   	outsb  %ds:(%esi),(%dx)
c040ed68:	64 20 25 78 0a 00 00 	and    %ah,%fs:0xa78
c040ed6f:	00 2a                	add    %ch,(%edx)
c040ed71:	2a 2a                	sub    (%edx),%ch
c040ed73:	20 6d 69             	and    %ch,0x69(%ebp)
c040ed76:	73 73                	jae    c040edeb <debug_initialise+0x15d7>
c040ed78:	69 6e 67 20 6d 65 6d 	imul   $0x6d656d20,0x67(%esi),%ebp
c040ed7f:	20 6d 61             	and    %ch,0x61(%ebp)
c040ed82:	70 20                	jo     c040eda4 <debug_initialise+0x1590>
c040ed84:	64                   	fs
c040ed85:	61                   	popa   
c040ed86:	74 61                	je     c040ede9 <debug_initialise+0x15d5>
c040ed88:	20 66 72             	and    %ah,0x72(%esi)
c040ed8b:	6f                   	outsl  %ds:(%esi),(%dx)
c040ed8c:	6d                   	insl   (%dx),%es:(%edi)
c040ed8d:	20 6d 75             	and    %ch,0x75(%ebp)
c040ed90:	6c                   	insb   (%dx),%es:(%edi)
c040ed91:	74 69                	je     c040edfc <debug_initialise+0x15e8>
c040ed93:	62 6f 6f             	bound  %ebp,0x6f(%edi)
c040ed96:	74 2e                	je     c040edc6 <debug_initialise+0x15b2>
c040ed98:	20 28                	and    %ch,(%eax)
c040ed9a:	25 78 29 0a 00       	and    $0xa2978,%eax
c040ed9f:	00 5b 76             	add    %bl,0x76(%ebx)
c040eda2:	6d                   	insl   (%dx),%es:(%edi)
c040eda3:	6d                   	insl   (%dx),%es:(%edi)
c040eda4:	3a 25 69 5d 20 66    	cmp    0x66205d69,%ah
c040edaa:	6f                   	outsl  %ds:(%esi),(%dx)
c040edab:	75 6e                	jne    c040ee1b <debug_initialise+0x1607>
c040edad:	64 20 25 69 20 70 61 	and    %ah,%fs:0x61702069
c040edb4:	67                   	addr16
c040edb5:	65                   	gs
c040edb6:	73 2c                	jae    c040ede4 <debug_initialise+0x15d0>
c040edb8:	20 25 69 4d 42 20    	and    %ah,0x20424d69
c040edbe:	74 6f                	je     c040ee2f <debug_initialise+0x161b>
c040edc0:	74 61                	je     c040ee23 <debug_initialise+0x160f>
c040edc2:	6c                   	insb   (%dx),%es:(%edi)
c040edc3:	2c 20                	sub    $0x20,%al
c040edc5:	70 68                	jo     c040ee2f <debug_initialise+0x161b>
c040edc7:	79 73                	jns    c040ee3c <debug_initialise+0x1628>
c040edc9:	20 73 74             	and    %dh,0x74(%ebx)
c040edcc:	61                   	popa   
c040edcd:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040edd0:	73 69                	jae    c040ee3b <debug_initialise+0x1627>
c040edd2:	7a 65                	jp     c040ee39 <debug_initialise+0x1625>
c040edd4:	20 25 69 20 62 79    	and    %ah,0x79622069
c040edda:	74 65                	je     c040ee41 <debug_initialise+0x162d>
c040eddc:	73 0a                	jae    c040ede8 <debug_initialise+0x15d4>
c040edde:	00 00                	add    %al,(%eax)
c040ede0:	2a 2a                	sub    (%edx),%ch
c040ede2:	2a 20                	sub    (%eax),%ah
c040ede4:	4e                   	dec    %esi
c040ede5:	6f                   	outsl  %ds:(%esi),(%dx)
c040ede6:	74 20                	je     c040ee08 <debug_initialise+0x15f4>
c040ede8:	65 6e                	outsb  %gs:(%esi),(%dx)
c040edea:	6f                   	outsl  %ds:(%esi),(%dx)
c040edeb:	75 67                	jne    c040ee54 <debug_initialise+0x1640>
c040eded:	68 20 6d 65 6d       	push   $0x6d656d20
c040edf2:	6f                   	outsl  %ds:(%esi),(%dx)
c040edf3:	72 79                	jb     c040ee6e <debug_initialise+0x165a>
c040edf5:	20 70 72             	and    %dh,0x72(%eax)
c040edf8:	65                   	gs
c040edf9:	73 65                	jae    c040ee60 <debug_initialise+0x164c>
c040edfb:	6e                   	outsb  %ds:(%esi),(%dx)
c040edfc:	74 2c                	je     c040ee2a <debug_initialise+0x1616>
c040edfe:	20 6d 75             	and    %ch,0x75(%ebp)
c040ee01:	73 74                	jae    c040ee77 <debug_initialise+0x1663>
c040ee03:	20 68 61             	and    %ch,0x61(%eax)
c040ee06:	76 65                	jbe    c040ee6d <debug_initialise+0x1659>
c040ee08:	20 61 74             	and    %ah,0x74(%ecx)
c040ee0b:	20 6c 65 61          	and    %ch,0x61(%ebp,%eiz,2)
c040ee0f:	73 74                	jae    c040ee85 <debug_initialise+0x1671>
c040ee11:	20 25 69 20 62 79    	and    %ah,0x79622069
c040ee17:	74 65                	je     c040ee7e <debug_initialise+0x166a>
c040ee19:	73 20                	jae    c040ee3b <debug_initialise+0x1627>
c040ee1b:	61                   	popa   
c040ee1c:	76 61                	jbe    c040ee7f <debug_initialise+0x166b>
c040ee1e:	69 6c 61 62 6c 65 2e 	imul   $0xa2e656c,0x62(%ecx,%eiz,2),%ebp
c040ee25:	0a 
c040ee26:	00 00                	add    %al,(%eax)
c040ee28:	5b                   	pop    %ebx
c040ee29:	76 6d                	jbe    c040ee98 <debug_initialise+0x1684>
c040ee2b:	6d                   	insl   (%dx),%es:(%edi)
c040ee2c:	3a 25 69 5d 20 70    	cmp    0x70205d69,%ah
c040ee32:	61                   	popa   
c040ee33:	67 65 20 73 74       	addr16 and %dh,%gs:0x74(%bp,%di)
c040ee38:	61                   	popa   
c040ee39:	63 6b 3a             	arpl   %bp,0x3a(%ebx)
c040ee3c:	20 6c 6f 20          	and    %ch,0x20(%edi,%ebp,2)
c040ee40:	62 61 73             	bound  %esp,0x73(%ecx)
c040ee43:	65 20 25 70 20 68 69 	and    %ah,%gs:0x69682070
c040ee4a:	20 62 61             	and    %ah,0x61(%edx)
c040ee4d:	73 65                	jae    c040eeb4 <debug_initialise+0x16a0>
c040ee4f:	3a 20                	cmp    (%eax),%ah
c040ee51:	25 70 20 74 6f       	and    $0x6f742070,%eax
c040ee56:	70 3a                	jo     c040ee92 <debug_initialise+0x167e>
c040ee58:	20 25 70 20 61 6c    	and    %ah,0x6c612070
c040ee5e:	69 67 6e 65 64 20 74 	imul   $0x74206465,0x6e(%edi),%esp
c040ee65:	6f                   	outsl  %ds:(%esi),(%dx)
c040ee66:	70 3a                	jo     c040eea2 <debug_initialise+0x168e>
c040ee68:	20 25 70 0a 00 00    	and    %ah,0xa70
c040ee6e:	00 00                	add    %al,(%eax)
c040ee70:	5b                   	pop    %ebx
c040ee71:	76 6d                	jbe    c040eee0 <debug_initialise+0x16cc>
c040ee73:	6d                   	insl   (%dx),%es:(%edi)
c040ee74:	3a 25 69 5d 20 6d    	cmp    0x6d205d69,%ah
c040ee7a:	65                   	gs
c040ee7b:	6d                   	insl   (%dx),%es:(%edi)
c040ee7c:	20 72 65             	and    %dh,0x65(%edx)
c040ee7f:	67 69 6f 6e 3a 20 73 	addr16 imul $0x7473203a,0x6e(%bx),%ebp
c040ee86:	74 
c040ee87:	61                   	popa   
c040ee88:	72 74                	jb     c040eefe <debug_initialise+0x16ea>
c040ee8a:	20 25 78 20 6c 65    	and    %ah,0x656c2078
c040ee90:	6e                   	outsb  %ds:(%esi),(%dx)
c040ee91:	67 74 68             	addr16 je c040eefc <debug_initialise+0x16e8>
c040ee94:	20 25 69 20 74 79    	and    %ah,0x79742069
c040ee9a:	70 65                	jo     c040ef01 <debug_initialise+0x16ed>
c040ee9c:	20 25 78 0a 00 00    	and    %ah,0xa78
c040eea2:	00 00                	add    %al,(%eax)
c040eea4:	2a 2a                	sub    (%edx),%ch
c040eea6:	2a 20                	sub    (%eax),%ah
c040eea8:	6c                   	insb   (%dx),%es:(%edi)
c040eea9:	6f                   	outsl  %ds:(%esi),(%dx)
c040eeaa:	6d                   	insl   (%dx),%es:(%edi)
c040eeab:	65                   	gs
c040eeac:	6d                   	insl   (%dx),%es:(%edi)
c040eead:	20 70 61             	and    %dh,0x61(%eax)
c040eeb0:	67 65 20 73 74       	addr16 and %dh,%gs:0x74(%bp,%di)
c040eeb5:	61                   	popa   
c040eeb6:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040eeb9:	63 72 61             	arpl   %si,0x61(%edx)
c040eebc:	73 68                	jae    c040ef26 <debug_initialise+0x1712>
c040eebe:	65 64 20 69 6e       	and    %ch,%fs:%gs:0x6e(%ecx)
c040eec3:	74 6f                	je     c040ef34 <debug_initialise+0x1720>
c040eec5:	20 68 69             	and    %ch,0x69(%eax)
c040eec8:	6d                   	insl   (%dx),%es:(%edi)
c040eec9:	65                   	gs
c040eeca:	6d                   	insl   (%dx),%es:(%edi)
c040eecb:	20 73 74             	and    %dh,0x74(%ebx)
c040eece:	61                   	popa   
c040eecf:	63 6b 21             	arpl   %bp,0x21(%ebx)
c040eed2:	0a 20                	or     (%eax),%ah
c040eed4:	20 20                	and    %ah,(%eax)
c040eed6:	20 70 74             	and    %dh,0x74(%eax)
c040eed9:	72 20                	jb     c040eefb <debug_initialise+0x16e7>
c040eedb:	25 70 20 61 66       	and    $0x66612070,%eax
c040eee0:	74 65                	je     c040ef47 <debug_initialise+0x1733>
c040eee2:	72 20                	jb     c040ef04 <debug_initialise+0x16f0>
c040eee4:	25 69 20 70 61       	and    $0x61702069,%eax
c040eee9:	67                   	addr16
c040eeea:	65                   	gs
c040eeeb:	73 20                	jae    c040ef0d <debug_initialise+0x16f9>
c040eeed:	28 25 78 29 20 2d    	sub    %ah,0x2d202978
c040eef3:	20 68 61             	and    %ch,0x61(%eax)
c040eef6:	6c                   	insb   (%dx),%es:(%edi)
c040eef7:	74 69                	je     c040ef62 <debug_initialise+0x174e>
c040eef9:	6e                   	outsb  %ds:(%esi),(%dx)
c040eefa:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040eefe:	00 00                	add    %al,(%eax)
c040ef00:	5b                   	pop    %ebx
c040ef01:	76 6d                	jbe    c040ef70 <debug_initialise+0x175c>
c040ef03:	6d                   	insl   (%dx),%es:(%edi)
c040ef04:	3a 25 69 5d 20 61    	cmp    0x61205d69,%ah
c040ef0a:	64 64 65 64 20 70 68 	and    %dh,%fs:%gs:0x68(%eax)
c040ef11:	79 73                	jns    c040ef86 <debug_initialise+0x1772>
c040ef13:	20 70 61             	and    %dh,0x61(%eax)
c040ef16:	67                   	addr16
c040ef17:	65                   	gs
c040ef18:	73 3a                	jae    c040ef54 <debug_initialise+0x1740>
c040ef1a:	20 25 69 20 6c 6f    	and    %ah,0x6f6c2069
c040ef20:	77 2c                	ja     c040ef4e <debug_initialise+0x173a>
c040ef22:	20 25 69 20 68 69    	and    %ah,0x69682069
c040ef28:	67 68 20 28 25 69    	addr16 push $0x69252820
c040ef2e:	20 72 65             	and    %dh,0x65(%edx)
c040ef31:	73 65                	jae    c040ef98 <debug_initialise+0x1784>
c040ef33:	72 76                	jb     c040efab <debug_initialise+0x1797>
c040ef35:	65 64 29 0a          	sub    %ecx,%fs:%gs:(%edx)
c040ef39:	00 00                	add    %al,(%eax)
c040ef3b:	00 5b 76             	add    %bl,0x76(%ebx)
c040ef3e:	6d                   	insl   (%dx),%es:(%edi)
c040ef3f:	6d                   	insl   (%dx),%es:(%edi)
c040ef40:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040ef46:	4d                   	dec    %ebp
c040ef47:	47                   	inc    %edi
c040ef48:	57                   	push   %edi
c040ef49:	54                   	push   %esp
c040ef4a:	46                   	inc    %esi
c040ef4b:	3a 20                	cmp    (%eax),%ah
c040ef4d:	76 6d                	jbe    c040efbc <debug_initialise+0x17a8>
c040ef4f:	6d                   	insl   (%dx),%es:(%edi)
c040ef50:	5f                   	pop    %edi
c040ef51:	6d                   	insl   (%dx),%es:(%edi)
c040ef52:	65                   	gs
c040ef53:	6d                   	insl   (%dx),%es:(%edi)
c040ef54:	63 70 79             	arpl   %si,0x79(%eax)
c040ef57:	75 73                	jne    c040efcc <debug_initialise+0x17b8>
c040ef59:	65                   	gs
c040ef5a:	72 20                	jb     c040ef7c <debug_initialise+0x1768>
c040ef5c:	68 61 73 20 62       	push   $0x62207361
c040ef61:	61                   	popa   
c040ef62:	64 20 70 61          	and    %dh,%fs:0x61(%eax)
c040ef66:	72 61                	jb     c040efc9 <debug_initialise+0x17b5>
c040ef68:	6d                   	insl   (%dx),%es:(%edi)
c040ef69:	73 21                	jae    c040ef8c <debug_initialise+0x1778>
c040ef6b:	0a 20                	or     (%eax),%ah
c040ef6d:	20 20                	and    %ah,(%eax)
c040ef6f:	20 20                	and    %ah,(%eax)
c040ef71:	20 20                	and    %ah,(%eax)
c040ef73:	20 20                	and    %ah,(%eax)
c040ef75:	20 20                	and    %ah,(%eax)
c040ef77:	20 20                	and    %ah,(%eax)
c040ef79:	20 74 61 72          	and    %dh,0x72(%ecx,%eiz,2)
c040ef7d:	67                   	addr16
c040ef7e:	65                   	gs
c040ef7f:	74 20                	je     c040efa1 <debug_initialise+0x178d>
c040ef81:	3d 20 25 70 20       	cmp    $0x20702520,%eax
c040ef86:	28 70 72             	sub    %dh,0x72(%eax)
c040ef89:	6f                   	outsl  %ds:(%esi),(%dx)
c040ef8a:	63 20                	arpl   %sp,(%eax)
c040ef8c:	25 70 29 0a 20       	and    $0x200a2970,%eax
c040ef91:	20 20                	and    %ah,(%eax)
c040ef93:	20 20                	and    %ah,(%eax)
c040ef95:	20 20                	and    %ah,(%eax)
c040ef97:	20 20                	and    %ah,(%eax)
c040ef99:	20 20                	and    %ah,(%eax)
c040ef9b:	20 20                	and    %ah,(%eax)
c040ef9d:	20 73 6f             	and    %dh,0x6f(%ebx)
c040efa0:	75 72                	jne    c040f014 <debug_initialise+0x1800>
c040efa2:	63 65 20             	arpl   %sp,0x20(%ebp)
c040efa5:	3d 20 25 70 20       	cmp    $0x20702520,%eax
c040efaa:	28 70 72             	sub    %dh,0x72(%eax)
c040efad:	6f                   	outsl  %ds:(%esi),(%dx)
c040efae:	63 20                	arpl   %sp,(%eax)
c040efb0:	25 70 29 0a 20       	and    $0x200a2970,%eax
c040efb5:	20 20                	and    %ah,(%eax)
c040efb7:	20 20                	and    %ah,(%eax)
c040efb9:	20 20                	and    %ah,(%eax)
c040efbb:	20 20                	and    %ah,(%eax)
c040efbd:	20 20                	and    %ah,(%eax)
c040efbf:	20 20                	and    %ah,(%eax)
c040efc1:	20 63 6f             	and    %ah,0x6f(%ebx)
c040efc4:	70 79                	jo     c040f03f <debug_initialise+0x182b>
c040efc6:	69 6e 67 3a 20 25 69 	imul   $0x6925203a,0x67(%esi),%ebp
c040efcd:	20 62 79             	and    %ah,0x79(%edx)
c040efd0:	74 65                	je     c040f037 <debug_initialise+0x1823>
c040efd2:	73 0a                	jae    c040efde <debug_initialise+0x17ca>
c040efd4:	00 2e                	add    %ch,(%esi)
c040efd6:	2e                   	cs
c040efd7:	2f                   	das    
c040efd8:	2e                   	cs
c040efd9:	2e                   	cs
c040efda:	2f                   	das    
c040efdb:	63 6f 72             	arpl   %bp,0x72(%edi)
c040efde:	65                   	gs
c040efdf:	2f                   	das    
c040efe0:	76 6d                	jbe    c040f04f <debug_initialise+0x183b>
c040efe2:	6d                   	insl   (%dx),%es:(%edi)
c040efe3:	2e 63 00             	arpl   %ax,%cs:(%eax)
c040efe6:	74 21                	je     c040f009 <debug_initialise+0x17f5>
c040efe8:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040efed:	00 00                	add    %al,(%eax)
c040efef:	00 53 47             	add    %dl,0x47(%ebx)
c040eff2:	4c                   	dec    %esp
c040eff3:	49                   	dec    %ecx
c040eff4:	42                   	inc    %edx
c040eff5:	5f                   	pop    %edi
c040eff6:	5f                   	pop    %edi
c040eff7:	5f                   	pop    %edi
c040eff8:	47                   	inc    %edi
c040eff9:	45                   	inc    %ebp
c040effa:	54                   	push   %esp
c040effb:	5f                   	pop    %edi
c040effc:	56                   	push   %esi
c040effd:	41                   	inc    %ecx
c040effe:	4c                   	dec    %esp
c040efff:	55                   	push   %ebp
c040f000:	45                   	inc    %ebp
c040f001:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040f005:	63 6f 6c             	arpl   %bp,0x6c(%edi)
c040f008:	6f                   	outsl  %ds:(%esi),(%dx)
c040f009:	75 72                	jne    c040f07d <debug_initialise+0x1869>
c040f00b:	29 3d 3d 31 00 63    	sub    %edi,0x6300313d
c040f011:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040f017:	20 26                	and    %ah,(%esi)
c040f019:	26 20 53 47          	and    %dl,%es:0x47(%ebx)
c040f01d:	4c                   	dec    %esp
c040f01e:	49                   	dec    %ecx
c040f01f:	42                   	inc    %edx
c040f020:	5f                   	pop    %edi
c040f021:	5f                   	pop    %edi
c040f022:	5f                   	pop    %edi
c040f023:	47                   	inc    %edi
c040f024:	45                   	inc    %ebp
c040f025:	54                   	push   %esp
c040f026:	5f                   	pop    %edi
c040f027:	56                   	push   %esi
c040f028:	41                   	inc    %ecx
c040f029:	4c                   	dec    %esp
c040f02a:	55                   	push   %ebp
c040f02b:	45                   	inc    %ebp
c040f02c:	28 63 2d             	sub    %ah,0x2d(%ebx)
c040f02f:	3e 63 6f 6c          	arpl   %bp,%ds:0x6c(%edi)
c040f033:	6f                   	outsl  %ds:(%esi),(%dx)
c040f034:	75 72                	jne    c040f0a8 <debug_initialise+0x1894>
c040f036:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040f03c:	63 6c 3d 3d          	arpl   %bp,0x3d(%ebp,%edi,1)
c040f040:	4e                   	dec    %esi
c040f041:	55                   	push   %ebp
c040f042:	4c                   	dec    %esp
c040f043:	4c                   	dec    %esp
c040f044:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040f048:	53                   	push   %ebx
c040f049:	47                   	inc    %edi
c040f04a:	4c                   	dec    %esp
c040f04b:	49                   	dec    %ecx
c040f04c:	42                   	inc    %edx
c040f04d:	5f                   	pop    %edi
c040f04e:	5f                   	pop    %edi
c040f04f:	5f                   	pop    %edi
c040f050:	47                   	inc    %edi
c040f051:	45                   	inc    %ebp
c040f052:	54                   	push   %esp
c040f053:	5f                   	pop    %edi
c040f054:	56                   	push   %esi
c040f055:	41                   	inc    %ecx
c040f056:	4c                   	dec    %esp
c040f057:	55                   	push   %ebp
c040f058:	45                   	inc    %ebp
c040f059:	28 63 6c             	sub    %ah,0x6c(%ebx)
c040f05c:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040f061:	6f                   	outsl  %ds:(%esi),(%dx)
c040f062:	75 72                	jne    c040f0d6 <debug_initialise+0x18c2>
c040f064:	29 3d 3d 30 00 30    	sub    %edi,0x3000303d
c040f06a:	00 62 6c             	add    %ah,0x6c(%edx)
c040f06d:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040f073:	00 62 72             	add    %ah,0x72(%edx)
c040f076:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040f07c:	00 00                	add    %al,(%eax)
c040f07e:	00 00                	add    %al,(%eax)
c040f080:	53                   	push   %ebx
c040f081:	47                   	inc    %edi
c040f082:	4c                   	dec    %esp
c040f083:	49                   	dec    %ecx
c040f084:	42                   	inc    %edx
c040f085:	5f                   	pop    %edi
c040f086:	5f                   	pop    %edi
c040f087:	5f                   	pop    %edi
c040f088:	47                   	inc    %edi
c040f089:	45                   	inc    %ebp
c040f08a:	54                   	push   %esp
c040f08b:	5f                   	pop    %edi
c040f08c:	56                   	push   %esi
c040f08d:	41                   	inc    %ecx
c040f08e:	4c                   	dec    %esp
c040f08f:	55                   	push   %ebp
c040f090:	45                   	inc    %ebp
c040f091:	28 62 6c             	sub    %ah,0x6c(%edx)
c040f094:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040f099:	6f                   	outsl  %ds:(%esi),(%dx)
c040f09a:	75 72                	jne    c040f10e <debug_initialise+0x18fa>
c040f09c:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040f0a2:	00 00                	add    %al,(%eax)
c040f0a4:	53                   	push   %ebx
c040f0a5:	47                   	inc    %edi
c040f0a6:	4c                   	dec    %esp
c040f0a7:	49                   	dec    %ecx
c040f0a8:	42                   	inc    %edx
c040f0a9:	5f                   	pop    %edi
c040f0aa:	5f                   	pop    %edi
c040f0ab:	5f                   	pop    %edi
c040f0ac:	47                   	inc    %edi
c040f0ad:	45                   	inc    %ebp
c040f0ae:	54                   	push   %esp
c040f0af:	5f                   	pop    %edi
c040f0b0:	56                   	push   %esi
c040f0b1:	41                   	inc    %ecx
c040f0b2:	4c                   	dec    %esp
c040f0b3:	55                   	push   %ebp
c040f0b4:	45                   	inc    %ebp
c040f0b5:	28 62 72             	sub    %ah,0x72(%edx)
c040f0b8:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040f0bd:	6f                   	outsl  %ds:(%esi),(%dx)
c040f0be:	75 72                	jne    c040f132 <debug_initialise+0x191e>
c040f0c0:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040f0c6:	00 00                	add    %al,(%eax)
c040f0c8:	62 72 21             	bound  %esi,0x21(%edx)
c040f0cb:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040f0d0:	20 26                	and    %ah,(%esi)
c040f0d2:	26 20 53 47          	and    %dl,%es:0x47(%ebx)
c040f0d6:	4c                   	dec    %esp
c040f0d7:	49                   	dec    %ecx
c040f0d8:	42                   	inc    %edx
c040f0d9:	5f                   	pop    %edi
c040f0da:	5f                   	pop    %edi
c040f0db:	5f                   	pop    %edi
c040f0dc:	47                   	inc    %edi
c040f0dd:	45                   	inc    %ebp
c040f0de:	54                   	push   %esp
c040f0df:	5f                   	pop    %edi
c040f0e0:	56                   	push   %esi
c040f0e1:	41                   	inc    %ecx
c040f0e2:	4c                   	dec    %esp
c040f0e3:	55                   	push   %ebp
c040f0e4:	45                   	inc    %ebp
c040f0e5:	28 62 72             	sub    %ah,0x72(%edx)
c040f0e8:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040f0ed:	6f                   	outsl  %ds:(%esi),(%dx)
c040f0ee:	75 72                	jne    c040f162 <debug_initialise+0x194e>
c040f0f0:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040f0f6:	00 00                	add    %al,(%eax)
c040f0f8:	30 20                	xor    %ah,(%eax)
c040f0fa:	26 26 20 22          	and    %ah,%es:(%edx)
c040f0fe:	54                   	push   %esp
c040f0ff:	68 65 20 65 6c       	push   $0x6c652065
c040f104:	65                   	gs
c040f105:	6d                   	insl   (%dx),%es:(%edi)
c040f106:	65 6e                	outsb  %gs:(%esi),(%dx)
c040f108:	74 20                	je     c040f12a <debug_initialise+0x1916>
c040f10a:	74 6f                	je     c040f17b <debug_initialise+0x1967>
c040f10c:	20 64 65 6c          	and    %ah,0x6c(%ebp,%eiz,2)
c040f110:	65                   	gs
c040f111:	74 65                	je     c040f178 <debug_initialise+0x1964>
c040f113:	20 6e 6f             	and    %ch,0x6f(%esi)
c040f116:	74 20                	je     c040f138 <debug_initialise+0x1924>
c040f118:	66 6f                	outsw  %ds:(%esi),(%dx)
c040f11a:	75 6e                	jne    c040f18a <debug_initialise+0x1976>
c040f11c:	64 20 69 6e          	and    %ch,%fs:0x6e(%ecx)
c040f120:	20 74 68 65          	and    %dh,0x65(%eax,%ebp,2)
c040f124:	20 74 72 65          	and    %dh,0x65(%edx,%esi,2)
c040f128:	65                   	gs
c040f129:	2c 20                	sub    $0x20,%al
c040f12b:	20 75 73             	and    %dh,0x73(%ebp)
c040f12e:	65 20 27             	and    %ah,%gs:(%edi)
c040f131:	64                   	fs
c040f132:	65                   	gs
c040f133:	6c                   	insb   (%dx),%es:(%edi)
c040f134:	65                   	gs
c040f135:	74 65                	je     c040f19c <debug_initialise+0x1988>
c040f137:	5f                   	pop    %edi
c040f138:	69 66 5f 6d 65 6d 62 	imul   $0x626d656d,0x5f(%esi),%esp
c040f13f:	65                   	gs
c040f140:	72 27                	jb     c040f169 <debug_initialise+0x1955>
c040f142:	22 21                	and    (%ecx),%ah
c040f144:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040f149:	00 00                	add    %al,(%eax)
c040f14b:	00 65 6c             	add    %ah,0x6c(%ebp)
c040f14e:	65                   	gs
c040f14f:	6d                   	insl   (%dx),%es:(%edi)
c040f150:	3d 3d 74 20 26       	cmp    $0x2620743d,%eax
c040f155:	26 20 22             	and    %ah,%es:(%edx)
c040f158:	44                   	inc    %esp
c040f159:	65                   	gs
c040f15a:	6c                   	insb   (%dx),%es:(%edi)
c040f15b:	65                   	gs
c040f15c:	74 69                	je     c040f1c7 <debug_initialise+0x19b3>
c040f15e:	6e                   	outsb  %ds:(%esi),(%dx)
c040f15f:	67 20 61 6e          	addr16 and %ah,0x6e(%bx,%di)
c040f163:	20 65 6c             	and    %ah,0x6c(%ebp)
c040f166:	65                   	gs
c040f167:	6d                   	insl   (%dx),%es:(%edi)
c040f168:	65 6e                	outsb  %gs:(%esi),(%dx)
c040f16a:	74 20                	je     c040f18c <debug_initialise+0x1978>
c040f16c:	77 68                	ja     c040f1d6 <debug_initialise+0x19c2>
c040f16e:	69 63 68 20 69 73 20 	imul   $0x20736920,0x68(%ebx),%esp
c040f175:	6e                   	outsb  %ds:(%esi),(%dx)
c040f176:	6f                   	outsl  %ds:(%esi),(%dx)
c040f177:	6e                   	outsb  %ds:(%esi),(%dx)
c040f178:	20 6d 65             	and    %ch,0x65(%ebp)
c040f17b:	6d                   	insl   (%dx),%es:(%edi)
c040f17c:	62 65 72             	bound  %esp,0x72(%ebp)
c040f17f:	20 6f 66             	and    %ch,0x66(%edi)
c040f182:	20 74 68 65          	and    %dh,0x65(%eax,%ebp,2)
c040f186:	20 74 72 65          	and    %dh,0x65(%edx,%esi,2)
c040f18a:	65                   	gs
c040f18b:	2c 20                	sub    $0x20,%al
c040f18d:	75 73                	jne    c040f202 <debug_initialise+0x19ee>
c040f18f:	65 20 27             	and    %ah,%gs:(%edi)
c040f192:	64                   	fs
c040f193:	65                   	gs
c040f194:	6c                   	insb   (%dx),%es:(%edi)
c040f195:	65                   	gs
c040f196:	74 65                	je     c040f1fd <debug_initialise+0x19e9>
c040f198:	5f                   	pop    %edi
c040f199:	69 66 5f 6d 65 6d 62 	imul   $0x626d656d,0x5f(%esi),%esp
c040f1a0:	65                   	gs
c040f1a1:	72 27                	jb     c040f1ca <debug_initialise+0x19b6>
c040f1a3:	22 21                	and    (%ecx),%ah
c040f1a5:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040f1aa:	00 74 20 3d          	add    %dh,0x3d(%eax,%eiz,1)
c040f1ae:	3d 20 65 6c 65       	cmp    $0x656c6520,%eax
c040f1b3:	6d                   	insl   (%dx),%es:(%edi)
c040f1b4:	00 00                	add    %al,(%eax)
c040f1b6:	00 00                	add    %al,(%eax)
c040f1b8:	30 20                	xor    %ah,(%eax)
c040f1ba:	26 26 20 22          	and    %ah,%es:(%edx)
c040f1be:	74 68                	je     c040f228 <debug_initialise+0x1a14>
c040f1c0:	65 20 62 69          	and    %ah,%gs:0x69(%edx)
c040f1c4:	6e                   	outsb  %ds:(%esi),(%dx)
c040f1c5:	61                   	popa   
c040f1c6:	72 79                	jb     c040f241 <debug_initialise+0x1a2d>
c040f1c8:	5f                   	pop    %edi
c040f1c9:	74 72                	je     c040f23d <debug_initialise+0x1a29>
c040f1cb:	65 65 20 69 73       	and    %ch,%gs:0x73(%ecx)
c040f1d0:	20 74 6f 6f          	and    %dh,0x6f(%edi,%ebp,2)
c040f1d4:	20 64 65 65          	and    %ah,0x65(%ebp,%eiz,2)
c040f1d8:	70 22                	jo     c040f1fc <debug_initialise+0x19e8>
c040f1da:	00 69 74             	add    %ch,0x74(%ecx)
c040f1dd:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040f1e3:	00 2a                	add    %ch,(%edx)
c040f1e5:	70 61                	jo     c040f248 <debug_initialise+0x1a34>
c040f1e7:	74 68                	je     c040f251 <debug_initialise+0x1a3d>
c040f1e9:	64                   	fs
c040f1ea:	65                   	gs
c040f1eb:	65                   	gs
c040f1ec:	70 20                	jo     c040f20e <debug_initialise+0x19fa>
c040f1ee:	3d 3d 20 63 64       	cmp    $0x6463203d,%eax
c040f1f3:	65                   	gs
c040f1f4:	65                   	gs
c040f1f5:	70 00                	jo     c040f1f7 <debug_initialise+0x19e3>
c040f1f7:	76 6d                	jbe    c040f266 <debug_initialise+0x1a52>
c040f1f9:	6d                   	insl   (%dx),%es:(%edi)
c040f1fa:	5f                   	pop    %edi
c040f1fb:	63 6d 70             	arpl   %bp,0x70(%ebp)
c040f1fe:	5f                   	pop    %edi
c040f1ff:	76 6d                	jbe    c040f26e <debug_initialise+0x1a5a>
c040f201:	61                   	popa   
c040f202:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040f206:	6c                   	insb   (%dx),%es:(%edi)
c040f207:	65                   	gs
c040f208:	66                   	data16
c040f209:	74 2c                	je     c040f237 <debug_initialise+0x1a23>
c040f20b:	20 74 29 20          	and    %dh,0x20(%ecx,%ebp,1)
c040f20f:	3c 3d                	cmp    $0x3d,%al
c040f211:	20 30                	and    %dh,(%eax)
c040f213:	00 76 6d             	add    %dh,0x6d(%esi)
c040f216:	6d                   	insl   (%dx),%es:(%edi)
c040f217:	5f                   	pop    %edi
c040f218:	63 6d 70             	arpl   %bp,0x70(%ebp)
c040f21b:	5f                   	pop    %edi
c040f21c:	76 6d                	jbe    c040f28b <debug_initialise+0x1a77>
c040f21e:	61                   	popa   
c040f21f:	28 74 2c 20          	sub    %dh,0x20(%esp,%ebp,1)
c040f223:	74 2d                	je     c040f252 <debug_initialise+0x1a3e>
c040f225:	3e 72 69             	jb,pt  c040f291 <debug_initialise+0x1a7d>
c040f228:	67 68 74 29 20 3c    	addr16 push $0x3c202974
c040f22e:	3d 20 30 00 00       	cmp    $0x3020,%eax
c040f233:	00 74 2d 3e          	add    %dh,0x3e(%ebp,%ebp,1)
c040f237:	6c                   	insb   (%dx),%es:(%edi)
c040f238:	65                   	gs
c040f239:	66                   	data16
c040f23a:	74 20                	je     c040f25c <debug_initialise+0x1a48>
c040f23c:	3d 3d 20 4e 55       	cmp    $0x554e203d,%eax
c040f241:	4c                   	dec    %esp
c040f242:	4c                   	dec    %esp
c040f243:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040f247:	53                   	push   %ebx
c040f248:	47                   	inc    %edi
c040f249:	4c                   	dec    %esp
c040f24a:	49                   	dec    %ecx
c040f24b:	42                   	inc    %edx
c040f24c:	5f                   	pop    %edi
c040f24d:	5f                   	pop    %edi
c040f24e:	5f                   	pop    %edi
c040f24f:	47                   	inc    %edi
c040f250:	45                   	inc    %ebp
c040f251:	54                   	push   %esp
c040f252:	5f                   	pop    %edi
c040f253:	56                   	push   %esi
c040f254:	41                   	inc    %ecx
c040f255:	4c                   	dec    %esp
c040f256:	55                   	push   %ebp
c040f257:	45                   	inc    %ebp
c040f258:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040f25c:	6c                   	insb   (%dx),%es:(%edi)
c040f25d:	65                   	gs
c040f25e:	66                   	data16
c040f25f:	74 2d                	je     c040f28e <debug_initialise+0x1a7a>
c040f261:	3e 63 6f 6c          	arpl   %bp,%ds:0x6c(%edi)
c040f265:	6f                   	outsl  %ds:(%esi),(%dx)
c040f266:	75 72                	jne    c040f2da <debug_initialise+0x1ac6>
c040f268:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040f26e:	00 00                	add    %al,(%eax)
c040f270:	74 2d                	je     c040f29f <debug_initialise+0x1a8b>
c040f272:	3e 72 69             	jb,pt  c040f2de <debug_initialise+0x1aca>
c040f275:	67 68 74 20 3d 3d    	addr16 push $0x3d3d2074
c040f27b:	20 4e 55             	and    %cl,0x55(%esi)
c040f27e:	4c                   	dec    %esp
c040f27f:	4c                   	dec    %esp
c040f280:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040f284:	53                   	push   %ebx
c040f285:	47                   	inc    %edi
c040f286:	4c                   	dec    %esp
c040f287:	49                   	dec    %ecx
c040f288:	42                   	inc    %edx
c040f289:	5f                   	pop    %edi
c040f28a:	5f                   	pop    %edi
c040f28b:	5f                   	pop    %edi
c040f28c:	47                   	inc    %edi
c040f28d:	45                   	inc    %ebp
c040f28e:	54                   	push   %esp
c040f28f:	5f                   	pop    %edi
c040f290:	56                   	push   %esi
c040f291:	41                   	inc    %ecx
c040f292:	4c                   	dec    %esp
c040f293:	55                   	push   %ebp
c040f294:	45                   	inc    %ebp
c040f295:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040f299:	72 69                	jb     c040f304 <debug_initialise+0x1af0>
c040f29b:	67 68 74 2d 3e 63    	addr16 push $0x633e2d74
c040f2a1:	6f                   	outsl  %ds:(%esi),(%dx)
c040f2a2:	6c                   	insb   (%dx),%es:(%edi)
c040f2a3:	6f                   	outsl  %ds:(%esi),(%dx)
c040f2a4:	75 72                	jne    c040f318 <debug_initialise+0x1b04>
c040f2a6:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040f2ac:	74 3d                	je     c040f2eb <debug_initialise+0x1ad7>
c040f2ae:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040f2b3:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040f2b7:	53                   	push   %ebx
c040f2b8:	47                   	inc    %edi
c040f2b9:	4c                   	dec    %esp
c040f2ba:	49                   	dec    %ecx
c040f2bb:	42                   	inc    %edx
c040f2bc:	5f                   	pop    %edi
c040f2bd:	5f                   	pop    %edi
c040f2be:	5f                   	pop    %edi
c040f2bf:	47                   	inc    %edi
c040f2c0:	45                   	inc    %ebp
c040f2c1:	54                   	push   %esp
c040f2c2:	5f                   	pop    %edi
c040f2c3:	56                   	push   %esi
c040f2c4:	41                   	inc    %ecx
c040f2c5:	4c                   	dec    %esp
c040f2c6:	55                   	push   %ebp
c040f2c7:	45                   	inc    %ebp
c040f2c8:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040f2cc:	63 6f 6c             	arpl   %bp,0x6c(%edi)
c040f2cf:	6f                   	outsl  %ds:(%esi),(%dx)
c040f2d0:	75 72                	jne    c040f344 <debug_initialise+0x1b30>
c040f2d2:	29 20                	sub    %esp,(%eax)
c040f2d4:	3d 3d 20 30 00       	cmp    $0x30203d,%eax
c040f2d9:	00 00                	add    %al,(%eax)
c040f2db:	00 5b 76             	add    %bl,0x76(%ebx)
c040f2de:	6d                   	insl   (%dx),%es:(%edi)
c040f2df:	6d                   	insl   (%dx),%es:(%edi)
c040f2e0:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040f2e6:	4d                   	dec    %ebp
c040f2e7:	47                   	inc    %edi
c040f2e8:	57                   	push   %edi
c040f2e9:	54                   	push   %esp
c040f2ea:	46                   	inc    %esi
c040f2eb:	20 70 61             	and    %dh,0x61(%eax)
c040f2ee:	67 65 20 63 6c       	addr16 and %ah,%gs:0x6c(%bp,%di)
c040f2f3:	61                   	popa   
c040f2f4:	69 6d 65 64 20 74 6f 	imul   $0x6f742064,0x65(%ebp),%ebp
c040f2fb:	20 68 61             	and    %ch,0x61(%eax)
c040f2fe:	76 65                	jbe    c040f365 <debug_initialise+0x1b51>
c040f300:	20 70 68             	and    %dh,0x68(%eax)
c040f303:	79 73                	jns    c040f378 <debug_initialise+0x1b64>
c040f305:	69 63 61 6c 20 6d 65 	imul   $0x656d206c,0x61(%ebx),%esp
c040f30c:	6d                   	insl   (%dx),%es:(%edi)
c040f30d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f30e:	72 79                	jb     c040f389 <debug_initialise+0x1b75>
c040f310:	20 2d 20 62 75 74    	and    %ch,0x74756220
c040f316:	20 64 6f 65          	and    %ah,0x65(%edi,%ebp,2)
c040f31a:	73 6e                	jae    c040f38a <debug_initialise+0x1b76>
c040f31c:	27                   	daa    
c040f31d:	74 0a                	je     c040f329 <debug_initialise+0x1b15>
c040f31f:	00 0a                	add    %cl,(%edx)
c040f321:	2a 2a                	sub    (%edx),%ch
c040f323:	2a 20                	sub    (%eax),%ah
c040f325:	70 61                	jo     c040f388 <debug_initialise+0x1b74>
c040f327:	6e                   	outsb  %ds:(%esi),(%dx)
c040f328:	69 63 3a 20 75 6e 68 	imul   $0x686e7520,0x3a(%ebx),%esp
c040f32f:	61                   	popa   
c040f330:	6e                   	outsb  %ds:(%esi),(%dx)
c040f331:	64                   	fs
c040f332:	6c                   	insb   (%dx),%es:(%edi)
c040f333:	65 64 20 73 65       	and    %dh,%fs:%gs:0x65(%ebx)
c040f338:	72 69                	jb     c040f3a3 <debug_initialise+0x1b8f>
c040f33a:	6f                   	outsl  %ds:(%esi),(%dx)
c040f33b:	75 73                	jne    c040f3b0 <debug_initialise+0x1b9c>
c040f33d:	20 66 61             	and    %ah,0x61(%esi)
c040f340:	75 6c                	jne    c040f3ae <debug_initialise+0x1b9a>
c040f342:	74 20                	je     c040f364 <debug_initialise+0x1b50>
c040f344:	69 6e 20 74 68 65 20 	imul   $0x20656874,0x20(%esi),%ebp
c040f34b:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040f34f:	65                   	gs
c040f350:	6c                   	insb   (%dx),%es:(%edi)
c040f351:	2e 20 68 61          	and    %ch,%cs:0x61(%eax)
c040f355:	6c                   	insb   (%dx),%es:(%edi)
c040f356:	74 69                	je     c040f3c1 <debug_initialise+0x1bad>
c040f358:	6e                   	outsb  %ds:(%esi),(%dx)
c040f359:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040f35d:	00 00                	add    %al,(%eax)
c040f35f:	00 5b 70             	add    %bl,0x70(%ebx)
c040f362:	61                   	popa   
c040f363:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f367:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040f36e:	54                   	push   %esp
c040f36f:	46                   	inc    %esi
c040f370:	20 75 73             	and    %dh,0x73(%ebp)
c040f373:	65                   	gs
c040f374:	72 73                	jb     c040f3e9 <debug_initialise+0x1bd5>
c040f376:	70 61                	jo     c040f3d9 <debug_initialise+0x1bc5>
c040f378:	63 65 20             	arpl   %sp,0x20(%ebp)
c040f37b:	70 61                	jo     c040f3de <debug_initialise+0x1bca>
c040f37d:	67 65 20 6d 61       	addr16 and %ch,%gs:0x61(%di)
c040f382:	6e                   	outsb  %ds:(%esi),(%dx)
c040f383:	61                   	popa   
c040f384:	67                   	addr16
c040f385:	65                   	gs
c040f386:	72 20                	jb     c040f3a8 <debug_initialise+0x1b94>
c040f388:	68 61 73 20 67       	push   $0x67207361
c040f38d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f38e:	6e                   	outsb  %ds:(%esi),(%dx)
c040f38f:	65 20 41 57          	and    %al,%gs:0x57(%ecx)
c040f393:	4f                   	dec    %edi
c040f394:	4c                   	dec    %esp
c040f395:	0a 20                	or     (%eax),%ah
c040f397:	20 20                	and    %ah,(%eax)
c040f399:	20 20                	and    %ah,(%eax)
c040f39b:	20 20                	and    %ah,(%eax)
c040f39d:	20 20                	and    %ah,(%eax)
c040f39f:	20 74 72 69          	and    %dh,0x69(%edx,%esi,2)
c040f3a3:	65 64 20 74 61 6c    	and    %dh,%fs:%gs:0x6c(%ecx,%eiz,2)
c040f3a9:	6b 69 6e 67          	imul   $0x67,0x6e(%ecx),%ebp
c040f3ad:	20 74 6f 20          	and    %dh,0x20(%edi,%ebp,2)
c040f3b1:	70 72                	jo     c040f425 <debug_initialise+0x1c11>
c040f3b3:	6f                   	outsl  %ds:(%esi),(%dx)
c040f3b4:	63 20                	arpl   %sp,(%eax)
c040f3b6:	25 69 20 28 25       	and    $0x25282069,%eax
c040f3bb:	70 29                	jo     c040f3e6 <debug_initialise+0x1bd2>
c040f3bd:	20 77 68             	and    %dh,0x68(%edi)
c040f3c0:	69 6c 65 20 63 6c 6f 	imul   $0x6e6f6c63,0x20(%ebp,%eiz,2),%ebp
c040f3c7:	6e 
c040f3c8:	69 6e 67 20 25 69 20 	imul   $0x20692520,0x67(%esi),%ebp
c040f3cf:	28 25 70 29 0a 00    	sub    %ah,0xa2970
c040f3d5:	00 00                	add    %al,(%eax)
c040f3d7:	00 5b 70             	add    %bl,0x70(%ebx)
c040f3da:	61                   	popa   
c040f3db:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f3df:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040f3e6:	54                   	push   %esp
c040f3e7:	46                   	inc    %esi
c040f3e8:	20 75 73             	and    %dh,0x73(%ebp)
c040f3eb:	65                   	gs
c040f3ec:	72 73                	jb     c040f461 <debug_initialise+0x1c4d>
c040f3ee:	70 61                	jo     c040f451 <debug_initialise+0x1c3d>
c040f3f0:	63 65 20             	arpl   %sp,0x20(%ebp)
c040f3f3:	70 61                	jo     c040f456 <debug_initialise+0x1c42>
c040f3f5:	67 65 20 6d 61       	addr16 and %ch,%gs:0x61(%di)
c040f3fa:	6e                   	outsb  %ds:(%esi),(%dx)
c040f3fb:	61                   	popa   
c040f3fc:	67                   	addr16
c040f3fd:	65                   	gs
c040f3fe:	72 20                	jb     c040f420 <debug_initialise+0x1c0c>
c040f400:	68 61 73 20 67       	push   $0x67207361
c040f405:	6f                   	outsl  %ds:(%esi),(%dx)
c040f406:	6e                   	outsb  %ds:(%esi),(%dx)
c040f407:	65 20 41 57          	and    %al,%gs:0x57(%ecx)
c040f40b:	4f                   	dec    %edi
c040f40c:	4c                   	dec    %esp
c040f40d:	0a 20                	or     (%eax),%ah
c040f40f:	20 20                	and    %ah,(%eax)
c040f411:	20 20                	and    %ah,(%eax)
c040f413:	20 20                	and    %ah,(%eax)
c040f415:	74 72                	je     c040f489 <debug_initialise+0x1c75>
c040f417:	69 65 64 20 74 61 6c 	imul   $0x6c617420,0x64(%ebp),%esp
c040f41e:	6b 69 6e 67          	imul   $0x67,0x6e(%ecx),%ebp
c040f422:	20 74 6f 20          	and    %dh,0x20(%edi,%ebp,2)
c040f426:	70 72                	jo     c040f49a <debug_initialise+0x1c86>
c040f428:	6f                   	outsl  %ds:(%esi),(%dx)
c040f429:	63 20                	arpl   %sp,(%eax)
c040f42b:	25 69 20 28 25       	and    $0x25282069,%eax
c040f430:	70 29                	jo     c040f45b <debug_initialise+0x1c47>
c040f432:	20 77 68             	and    %dh,0x68(%edi)
c040f435:	69 6c 65 20 74 65 61 	imul   $0x72616574,0x20(%ebp,%eiz,2),%ebp
c040f43c:	72 
c040f43d:	69 6e 67 20 64 6f 77 	imul   $0x776f6420,0x67(%esi),%ebp
c040f444:	6e                   	outsb  %ds:(%esi),(%dx)
c040f445:	20 25 69 20 28 25    	and    %ah,0x25282069
c040f44b:	70 29                	jo     c040f476 <debug_initialise+0x1c62>
c040f44d:	0a 00                	or     (%eax),%al
c040f44f:	00 5b 70             	add    %bl,0x70(%ebx)
c040f452:	61                   	popa   
c040f453:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f457:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040f45e:	54                   	push   %esp
c040f45f:	46                   	inc    %esi
c040f460:	20 62 61             	and    %ah,0x61(%edx)
c040f463:	64 20 70 61          	and    %dh,%fs:0x61(%eax)
c040f467:	67 65 20 64 69       	addr16 and %ah,%gs:0x69(%si)
c040f46c:	72 65                	jb     c040f4d3 <debug_initialise+0x1cbf>
c040f46e:	63 74 6f 72          	arpl   %si,0x72(%edi,%ebp,2)
c040f472:	79 20                	jns    c040f494 <debug_initialise+0x1c80>
c040f474:	70 6f                	jo     c040f4e5 <debug_initialise+0x1cd1>
c040f476:	69 6e 74 65 72 20 74 	imul   $0x74207265,0x74(%esi),%ebp
c040f47d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f47e:	20 70 67             	and    %dh,0x67(%eax)
c040f481:	5f                   	pop    %edi
c040f482:	61                   	popa   
c040f483:	64                   	fs
c040f484:	64                   	fs
c040f485:	5f                   	pop    %edi
c040f486:	34 4b                	xor    $0x4b,%al
c040f488:	5f                   	pop    %edi
c040f489:	6d                   	insl   (%dx),%es:(%edi)
c040f48a:	61                   	popa   
c040f48b:	70 70                	jo     c040f4fd <debug_initialise+0x1ce9>
c040f48d:	69 6e 67 21 0a 20 20 	imul   $0x20200a21,0x67(%esi),%ebp
c040f494:	20 20                	and    %ah,(%eax)
c040f496:	20 20                	and    %ah,(%eax)
c040f498:	20 20                	and    %ah,(%eax)
c040f49a:	20 20                	and    %ah,(%eax)
c040f49c:	20 20                	and    %ah,(%eax)
c040f49e:	20 20                	and    %ah,(%eax)
c040f4a0:	70 67                	jo     c040f509 <debug_initialise+0x1cf5>
c040f4a2:	64 69 72 20 25 70 20 	imul   $0x76207025,%fs:0x20(%edx),%esi
c040f4a9:	76 
c040f4aa:	69 72 74 75 61 6c 20 	imul   $0x206c6175,0x74(%edx),%esi
c040f4b1:	25 78 20 70 68       	and    $0x68702078,%eax
c040f4b6:	79 73                	jns    c040f52b <debug_initialise+0x1d17>
c040f4b8:	69 63 61 6c 20 25 78 	imul   $0x7825206c,0x61(%ebx),%esp
c040f4bf:	20 66 6c             	and    %ah,0x6c(%esi)
c040f4c2:	61                   	popa   
c040f4c3:	67 73 20             	addr16 jae c040f4e6 <debug_initialise+0x1cd2>
c040f4c6:	25 69 0a 20 20       	and    $0x20200a69,%eax
c040f4cb:	20 20                	and    %ah,(%eax)
c040f4cd:	20 20                	and    %ah,(%eax)
c040f4cf:	20 20                	and    %ah,(%eax)
c040f4d1:	20 20                	and    %ah,(%eax)
c040f4d3:	20 20                	and    %ah,(%eax)
c040f4d5:	20 20                	and    %ah,(%eax)
c040f4d7:	70 67                	jo     c040f540 <debug_initialise+0x1d2c>
c040f4d9:	64 69 72 5f 69 6e 64 	imul   $0x65646e69,%fs:0x5f(%edx),%esi
c040f4e0:	65 
c040f4e1:	78 20                	js     c040f503 <debug_initialise+0x1cef>
c040f4e3:	25 69 20 70 67       	and    $0x67702069,%eax
c040f4e8:	74 61                	je     c040f54b <debug_initialise+0x1d37>
c040f4ea:	62 6c 65 5f          	bound  %ebp,0x5f(%ebp,%eiz,2)
c040f4ee:	69 6e 64 65 78 20 25 	imul   $0x25207865,0x64(%esi),%ebp
c040f4f5:	69 0a 00 2a 2a 2a    	imul   $0x2a2a2a00,(%edx),%ecx
c040f4fb:	20 66 61             	and    %ah,0x61(%esi)
c040f4fe:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040f505:	20 
c040f506:	6d                   	insl   (%dx),%es:(%edi)
c040f507:	61                   	popa   
c040f508:	70 20                	jo     c040f52a <debug_initialise+0x1d16>
c040f50a:	76 69                	jbe    c040f575 <debug_initialise+0x1d61>
c040f50c:	72 74                	jb     c040f582 <debug_initialise+0x1d6e>
c040f50e:	75 61                	jne    c040f571 <debug_initialise+0x1d5d>
c040f510:	6c                   	insb   (%dx),%es:(%edi)
c040f511:	20 25 78 20 74 6f    	and    %ah,0x6f742078
c040f517:	20 70 68             	and    %dh,0x68(%eax)
c040f51a:	79 73                	jns    c040f58f <debug_initialise+0x1d7b>
c040f51c:	69 63 61 6c 20 25 78 	imul   $0x7825206c,0x61(%ebx),%esp
c040f523:	20 69 6e             	and    %ch,0x6e(%ecx)
c040f526:	74 6f                	je     c040f597 <debug_initialise+0x1d83>
c040f528:	20 6b 65             	and    %ch,0x65(%ebx)
c040f52b:	72 6e                	jb     c040f59b <debug_initialise+0x1d87>
c040f52d:	65                   	gs
c040f52e:	6c                   	insb   (%dx),%es:(%edi)
c040f52f:	21 20                	and    %esp,(%eax)
c040f531:	68 61 6c 74 69       	push   $0x69746c61
c040f536:	6e                   	outsb  %ds:(%esi),(%dx)
c040f537:	67 2e 00 00          	addr16 add %al,%cs:(%bx,%si)
c040f53b:	00 5b 70             	add    %bl,0x70(%ebx)
c040f53e:	61                   	popa   
c040f53f:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f543:	69 5d 20 69 6e 69 74 	imul   $0x74696e69,0x20(%ebp),%ebx
c040f54a:	69 61 6c 69 73 69 6e 	imul   $0x6e697369,0x6c(%ecx),%esp
c040f551:	67 2e 2e 20 6b 65    	addr16 and %ch,%cs:0x65(%bp,%di)
c040f557:	72 6e                	jb     c040f5c7 <debug_initialise+0x1db3>
c040f559:	65                   	gs
c040f55a:	6c                   	insb   (%dx),%es:(%edi)
c040f55b:	20 70 61             	and    %dh,0x61(%eax)
c040f55e:	67 65 20 64 69       	addr16 and %ah,%gs:0x69(%si)
c040f563:	72 20                	jb     c040f585 <debug_initialise+0x1d71>
c040f565:	25 78 0a 00 5b       	and    $0x5b000a78,%eax
c040f56a:	70 61                	jo     c040f5cd <debug_initialise+0x1db9>
c040f56c:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f570:	69 5d 20 76 6d 6d 20 	imul   $0x206d6d76,0x20(%ebp),%ebx
c040f577:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%esi),%ebp
c040f57e:	69 73 65 64 0a 00 5b 	imul   $0x5b000a64,0x65(%ebx),%esi
c040f585:	70 61                	jo     c040f5e8 <debug_initialise+0x1dd4>
c040f587:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040f58b:	69 5d 20 66 61 75 6c 	imul   $0x6c756166,0x20(%ebp),%ebx
c040f592:	74 3a                	je     c040f5ce <debug_initialise+0x1dba>
c040f594:	20 63 6f             	and    %ah,0x6f(%ebx)
c040f597:	64 65 20 25 69 20 65 	and    %ah,%fs:%gs:0x69652069
c040f59e:	69 
c040f59f:	70 20                	jo     c040f5c1 <debug_initialise+0x1dad>
c040f5a1:	25 78 20 28 25       	and    $0x25282078,%eax
c040f5a6:	78 3a                	js     c040f5e2 <debug_initialise+0x1dce>
c040f5a8:	25 73 29 20 66       	and    $0x66202973,%eax
c040f5ad:	61                   	popa   
c040f5ae:	75 6c                	jne    c040f61c <debug_initialise+0x1e08>
c040f5b0:	74 20                	je     c040f5d2 <debug_initialise+0x1dbe>
c040f5b2:	61                   	popa   
c040f5b3:	74 20                	je     c040f5d5 <debug_initialise+0x1dc1>
c040f5b5:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040f5ba:	20 20                	and    %ah,(%eax)
c040f5bc:	20 20                	and    %ah,(%eax)
c040f5be:	64                   	fs
c040f5bf:	73 20                	jae    c040f5e1 <debug_initialise+0x1dcd>
c040f5c1:	25 78 20 65 64       	and    $0x64652078,%eax
c040f5c6:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040f5cc:	62 70 20             	bound  %esi,0x20(%eax)
c040f5cf:	25 78 20 65 73       	and    $0x73652078,%eax
c040f5d4:	70 20                	jo     c040f5f6 <debug_initialise+0x1de2>
c040f5d6:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040f5db:	20 20                	and    %ah,(%eax)
c040f5dd:	20 20                	and    %ah,(%eax)
c040f5df:	65                   	gs
c040f5e0:	61                   	popa   
c040f5e1:	78 20                	js     c040f603 <debug_initialise+0x1def>
c040f5e3:	25 78 20 63 73       	and    $0x73632078,%eax
c040f5e8:	20 25 78 20 65 66    	and    %ah,0x66652078
c040f5ee:	6c                   	insb   (%dx),%es:(%edi)
c040f5ef:	61                   	popa   
c040f5f0:	67 73 20             	addr16 jae c040f613 <debug_initialise+0x1dff>
c040f5f3:	25 78 20 75 73       	and    $0x73752078,%eax
c040f5f8:	65                   	gs
c040f5f9:	72 65                	jb     c040f660 <debug_initialise+0x1e4c>
c040f5fb:	73 70                	jae    c040f66d <debug_initialise+0x1e59>
c040f5fd:	20 25 78 20 73 73    	and    %ah,0x73732078
c040f603:	20 25 78 0a 00 20    	and    %ah,0x20000a78
c040f609:	20 20                	and    %ah,(%eax)
c040f60b:	20 20                	and    %ah,(%eax)
c040f60d:	20 52 65             	and    %dl,0x65(%edx)
c040f610:	61                   	popa   
c040f611:	73 6f                	jae    c040f682 <debug_initialise+0x1e6e>
c040f613:	6e                   	outsb  %ds:(%esi),(%dx)
c040f614:	3a 20                	cmp    (%eax),%ah
c040f616:	00 41 63             	add    %al,0x63(%ecx)
c040f619:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f61c:	73 56                	jae    c040f674 <debug_initialise+0x1e60>
c040f61e:	69 6f 6c 61 74 69 6f 	imul   $0x6f697461,0x6c(%edi),%ebp
c040f625:	6e                   	outsb  %ds:(%esi),(%dx)
c040f626:	20 00                	and    %al,(%eax)
c040f628:	4e                   	dec    %esi
c040f629:	6f                   	outsl  %ds:(%esi),(%dx)
c040f62a:	74 50                	je     c040f67c <debug_initialise+0x1e68>
c040f62c:	72 65                	jb     c040f693 <debug_initialise+0x1e7f>
c040f62e:	73 65                	jae    c040f695 <debug_initialise+0x1e81>
c040f630:	6e                   	outsb  %ds:(%esi),(%dx)
c040f631:	74 20                	je     c040f653 <debug_initialise+0x1e3f>
c040f633:	00 57 72             	add    %dl,0x72(%edi)
c040f636:	69 74 65 20 00 52 65 	imul   $0x61655200,0x20(%ebp,%eiz,2),%esi
c040f63d:	61 
c040f63e:	64 20 00             	and    %al,%fs:(%eax)
c040f641:	55                   	push   %ebp
c040f642:	73 65                	jae    c040f6a9 <debug_initialise+0x1e95>
c040f644:	72 20                	jb     c040f666 <debug_initialise+0x1e52>
c040f646:	00 4b 65             	add    %cl,0x65(%ebx)
c040f649:	72 6e                	jb     c040f6b9 <debug_initialise+0x1ea5>
c040f64b:	65                   	gs
c040f64c:	6c                   	insb   (%dx),%es:(%edi)
c040f64d:	20 00                	and    %al,(%eax)
c040f64f:	52                   	push   %edx
c040f650:	65                   	gs
c040f651:	73 65                	jae    c040f6b8 <debug_initialise+0x1ea4>
c040f653:	72 76                	jb     c040f6cb <debug_initialise+0x1eb7>
c040f655:	65 64 20 00          	and    %al,%fs:%gs:(%eax)
c040f659:	4e                   	dec    %esi
c040f65a:	6f                   	outsl  %ds:(%esi),(%dx)
c040f65b:	45                   	inc    %ebp
c040f65c:	78 65                	js     c040f6c3 <debug_initialise+0x1eaf>
c040f65e:	63 75 74             	arpl   %si,0x74(%ebp)
c040f661:	65 20 00             	and    %al,%gs:(%eax)
c040f664:	0a 00                	or     (%eax),%al
c040f666:	00 00                	add    %al,(%eax)
c040f668:	20 20                	and    %ah,(%eax)
c040f66a:	20 20                	and    %ah,(%eax)
c040f66c:	20 20                	and    %ah,(%eax)
c040f66e:	46                   	inc    %esi
c040f66f:	61                   	popa   
c040f670:	75 6c                	jne    c040f6de <debug_initialise+0x1eca>
c040f672:	74 69                	je     c040f6dd <debug_initialise+0x1ec9>
c040f674:	6e                   	outsb  %ds:(%esi),(%dx)
c040f675:	67 20 74 68          	addr16 and %dh,0x68(%si)
c040f679:	72 65                	jb     c040f6e0 <debug_initialise+0x1ecc>
c040f67b:	61                   	popa   
c040f67c:	64 3a 20             	cmp    %fs:(%eax),%ah
c040f67f:	25 69 20 28 25       	and    $0x25282069,%eax
c040f684:	70 29                	jo     c040f6af <debug_initialise+0x1e9b>
c040f686:	20 69 6e             	and    %ch,0x6e(%ecx)
c040f689:	20 70 72             	and    %dh,0x72(%eax)
c040f68c:	6f                   	outsl  %ds:(%esi),(%dx)
c040f68d:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f690:	73 20                	jae    c040f6b2 <debug_initialise+0x1e9e>
c040f692:	25 69 20 28 25       	and    $0x25282069,%eax
c040f697:	70 29                	jo     c040f6c2 <debug_initialise+0x1eae>
c040f699:	20 77 69             	and    %dh,0x69(%edi)
c040f69c:	74 68                	je     c040f706 <debug_initialise+0x1ef2>
c040f69e:	20 70 67             	and    %dh,0x67(%eax)
c040f6a1:	20 64 69 72          	and    %ah,0x72(%ecx,%ebp,2)
c040f6a5:	20 25 70 0a 00 00    	and    %ah,0xa70
c040f6ab:	00 20                	add    %ah,(%eax)
c040f6ad:	20 20                	and    %ah,(%eax)
c040f6af:	20 20                	and    %ah,(%eax)
c040f6b1:	20 50 61             	and    %dl,0x61(%eax)
c040f6b4:	67 65 20 64 69       	addr16 and %ah,%gs:0x69(%si)
c040f6b9:	72 65                	jb     c040f720 <debug_initialise+0x1f0c>
c040f6bb:	63 74 6f 72          	arpl   %si,0x72(%edi,%ebp,2)
c040f6bf:	79 20                	jns    c040f6e1 <debug_initialise+0x1ecd>
c040f6c1:	65 6e                	outsb  %gs:(%esi),(%dx)
c040f6c3:	74 72                	je     c040f737 <debug_initialise+0x1f23>
c040f6c5:	79 20                	jns    c040f6e7 <debug_initialise+0x1ed3>
c040f6c7:	25 78 20 3d 20       	and    $0x203d2078,%eax
c040f6cc:	25 78 0a 00 20       	and    $0x20000a78,%eax
c040f6d1:	20 20                	and    %ah,(%eax)
c040f6d3:	20 20                	and    %ah,(%eax)
c040f6d5:	20 50 61             	and    %dl,0x61(%eax)
c040f6d8:	67 65 20 74 61       	addr16 and %dh,%gs:0x61(%si)
c040f6dd:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040f6e1:	65 6e                	outsb  %gs:(%esi),(%dx)
c040f6e3:	74 72                	je     c040f757 <debug_initialise+0x1f43>
c040f6e5:	79 20                	jns    c040f707 <debug_initialise+0x1ef3>
c040f6e7:	25 78 20 3d 20       	and    $0x203d2078,%eax
c040f6ec:	25 78 0a 00 5b       	and    $0x5b000a78,%eax
c040f6f1:	74 68                	je     c040f75b <debug_initialise+0x1f47>
c040f6f3:	72 65                	jb     c040f75a <debug_initialise+0x1f46>
c040f6f5:	61                   	popa   
c040f6f6:	64 3a 25 69 5d 20 4f 	cmp    %fs:0x4f205d69,%ah
c040f6fd:	4d                   	dec    %ebp
c040f6fe:	47                   	inc    %edi
c040f6ff:	57                   	push   %edi
c040f700:	54                   	push   %esp
c040f701:	46                   	inc    %esi
c040f702:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040f706:	65                   	gs
c040f707:	61                   	popa   
c040f708:	64                   	fs
c040f709:	5f                   	pop    %edi
c040f70a:	66 69 6e 64 5f 74    	imul   $0x745f,0x64(%esi),%bp
c040f710:	68 72 65 61 64       	push   $0x64616572
c040f715:	20 66 61             	and    %ah,0x61(%esi)
c040f718:	69 6c 65 64 20 6f 6e 	imul   $0x206e6f20,0x64(%ebp,%eiz,2),%ebp
c040f71f:	20 
c040f720:	73 61                	jae    c040f783 <debug_initialise+0x1f6f>
c040f722:	6e                   	outsb  %ds:(%esi),(%dx)
c040f723:	69 74 79 20 63 68 65 	imul   $0x63656863,0x20(%ecx,%edi,2),%esi
c040f72a:	63 
c040f72b:	6b 2e 0a             	imul   $0xa,(%esi),%ebp
c040f72e:	20 20                	and    %ah,(%eax)
c040f730:	20 20                	and    %ah,(%eax)
c040f732:	20 20                	and    %ah,(%eax)
c040f734:	20 20                	and    %ah,(%eax)
c040f736:	20 20                	and    %ah,(%eax)
c040f738:	20 20                	and    %ah,(%eax)
c040f73a:	70 72                	jo     c040f7ae <debug_initialise+0x1f9a>
c040f73c:	6f                   	outsl  %ds:(%esi),(%dx)
c040f73d:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f740:	73 20                	jae    c040f762 <debug_initialise+0x1f4e>
c040f742:	25 70 20 74 69       	and    $0x69742070,%eax
c040f747:	64 20 25 69 0a 00 00 	and    %ah,%fs:0xa69
c040f74e:	00 00                	add    %al,(%eax)
c040f750:	5b                   	pop    %ebx
c040f751:	74 68                	je     c040f7bb <debug_initialise+0x1fa7>
c040f753:	72 65                	jb     c040f7ba <debug_initialise+0x1fa6>
c040f755:	61                   	popa   
c040f756:	64 3a 25 69 5d 20 4f 	cmp    %fs:0x4f205d69,%ah
c040f75d:	4d                   	dec    %ebp
c040f75e:	47                   	inc    %edi
c040f75f:	57                   	push   %edi
c040f760:	54                   	push   %esp
c040f761:	46                   	inc    %esi
c040f762:	20 72 65             	and    %dh,0x65(%edx)
c040f765:	74 75                	je     c040f7dc <debug_initialise+0x1fc8>
c040f767:	72 6e                	jb     c040f7d7 <debug_initialise+0x1fc3>
c040f769:	69 6e 67 20 70 68 79 	imul   $0x79687020,0x67(%esi),%ebp
c040f770:	73 69                	jae    c040f7db <debug_initialise+0x1fc7>
c040f772:	63 61 6c             	arpl   %sp,0x6c(%ecx)
c040f775:	20 70 61             	and    %dh,0x61(%eax)
c040f778:	67 65 20 66 72       	addr16 and %ah,%gs:0x72(%bp)
c040f77d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f77e:	6d                   	insl   (%dx),%es:(%edi)
c040f77f:	20 64 79 69          	and    %ah,0x69(%ecx,%edi,2)
c040f783:	6e                   	outsb  %ds:(%esi),(%dx)
c040f784:	67 20 74 68          	addr16 and %dh,0x68(%si)
c040f788:	72 65                	jb     c040f7ef <debug_initialise+0x1fdb>
c040f78a:	61                   	popa   
c040f78b:	64                   	fs
c040f78c:	27                   	daa    
c040f78d:	73 20                	jae    c040f7af <debug_initialise+0x1f9b>
c040f78f:	73 74                	jae    c040f805 <debug_initialise+0x1ff1>
c040f791:	61                   	popa   
c040f792:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040f795:	66 61                	popaw  
c040f797:	69 6c 65 64 0a 20 20 	imul   $0x2020200a,0x64(%ebp,%eiz,2),%ebp
c040f79e:	20 
c040f79f:	20 20                	and    %ah,(%eax)
c040f7a1:	20 20                	and    %ah,(%eax)
c040f7a3:	20 20                	and    %ah,(%eax)
c040f7a5:	20 20                	and    %ah,(%eax)
c040f7a7:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040f7ab:	65                   	gs
c040f7ac:	61                   	popa   
c040f7ad:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040f7b4:	70 29                	jo     c040f7df <debug_initialise+0x1fcb>
c040f7b6:	20 70 72             	and    %dh,0x72(%eax)
c040f7b9:	6f                   	outsl  %ds:(%esi),(%dx)
c040f7ba:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f7bd:	73 20                	jae    c040f7df <debug_initialise+0x1fcb>
c040f7bf:	25 69 20 28 25       	and    $0x25282069,%eax
c040f7c4:	70 29                	jo     c040f7ef <debug_initialise+0x1fdb>
c040f7c6:	20 75 73             	and    %dh,0x73(%ebp)
c040f7c9:	72 20                	jb     c040f7eb <debug_initialise+0x1fd7>
c040f7cb:	25 78 20 70 68       	and    $0x68702078,%eax
c040f7d0:	79 73                	jns    c040f845 <debug_initialise+0x2031>
c040f7d2:	20 25 78 0a 00 00    	and    %ah,0xa78
c040f7d8:	5b                   	pop    %ebx
c040f7d9:	70 72                	jo     c040f84d <debug_initialise+0x2039>
c040f7db:	6f                   	outsl  %ds:(%esi),(%dx)
c040f7dc:	63 3a                	arpl   %di,(%edx)
c040f7de:	25 69 5d 20 69       	and    $0x69205d69,%eax
c040f7e3:	6e                   	outsb  %ds:(%esi),(%dx)
c040f7e4:	69 74 69 61 6c 69 73 	imul   $0x6573696c,0x61(%ecx,%ebp,2),%esi
c040f7eb:	65 
c040f7ec:	64 20 70 72          	and    %dh,%fs:0x72(%eax)
c040f7f0:	6f                   	outsl  %ds:(%esi),(%dx)
c040f7f1:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f7f4:	73 20                	jae    c040f816 <debug_initialise+0x2002>
c040f7f6:	68 61 73 68 20       	push   $0x20687361
c040f7fb:	74 61                	je     c040f85e <debug_initialise+0x204a>
c040f7fd:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040f801:	25 70 2e 2e 2e       	and    $0x2e2e2e70,%eax
c040f806:	20 25 69 20 62 75    	and    %ah,0x75622069
c040f80c:	63 6b 65             	arpl   %bp,0x65(%ebx)
c040f80f:	74 73                	je     c040f884 <debug_initialise+0x2070>
c040f811:	20 25 69 20 6d 61    	and    %ah,0x616d2069
c040f817:	78 20                	js     c040f839 <debug_initialise+0x2025>
c040f819:	70 72                	jo     c040f88d <debug_initialise+0x2079>
c040f81b:	6f                   	outsl  %ds:(%esi),(%dx)
c040f81c:	63 73 0a             	arpl   %si,0xa(%ebx)
c040f81f:	00 5b 70             	add    %bl,0x70(%ebx)
c040f822:	72 6f                	jb     c040f893 <debug_initialise+0x207f>
c040f824:	63 3a                	arpl   %di,(%edx)
c040f826:	25 69 5d 20 66       	and    $0x66205d69,%eax
c040f82b:	61                   	popa   
c040f82c:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040f833:	20 
c040f834:	70 61                	jo     c040f897 <debug_initialise+0x2083>
c040f836:	72 73                	jb     c040f8ab <debug_initialise+0x2097>
c040f838:	65 20 70 61          	and    %dh,%gs:0x61(%eax)
c040f83c:	79 6c                	jns    c040f8aa <debug_initialise+0x2096>
c040f83e:	6f                   	outsl  %ds:(%esi),(%dx)
c040f83f:	61                   	popa   
c040f840:	64 20 6d 6f          	and    %ch,%fs:0x6f(%ebp)
c040f844:	64                   	fs
c040f845:	75 6c                	jne    c040f8b3 <debug_initialise+0x209f>
c040f847:	65 20 61 74          	and    %ah,%gs:0x74(%ecx)
c040f84b:	20 25 78 20 21 0a    	and    %ah,0xa212078
c040f851:	00 00                	add    %al,(%eax)
c040f853:	00 5b 70             	add    %bl,0x70(%ebx)
c040f856:	72 6f                	jb     c040f8c7 <debug_initialise+0x20b3>
c040f858:	63 3a                	arpl   %di,(%edx)
c040f85a:	25 69 5d 20 70       	and    $0x70205d69,%eax
c040f85f:	72 65                	jb     c040f8c6 <debug_initialise+0x20b2>
c040f861:	70 61                	jo     c040f8c4 <debug_initialise+0x20b0>
c040f863:	72 69                	jb     c040f8ce <debug_initialise+0x20ba>
c040f865:	6e                   	outsb  %ds:(%esi),(%dx)
c040f866:	67 20 73 79          	addr16 and %dh,0x79(%bp,%di)
c040f86a:	73 74                	jae    c040f8e0 <debug_initialise+0x20cc>
c040f86c:	65                   	gs
c040f86d:	6d                   	insl   (%dx),%es:(%edi)
c040f86e:	20 70 72             	and    %dh,0x72(%eax)
c040f871:	6f                   	outsl  %ds:(%esi),(%dx)
c040f872:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f875:	73 20                	jae    c040f897 <debug_initialise+0x2083>
c040f877:	27                   	daa    
c040f878:	25 73 27 2e 2e       	and    $0x2e2e2773,%eax
c040f87d:	2e 0a 00             	or     %cs:(%eax),%al
c040f880:	20 20                	and    %ah,(%eax)
c040f882:	20 20                	and    %ah,(%eax)
c040f884:	20 20                	and    %ah,(%eax)
c040f886:	20 63 6f             	and    %ah,0x6f(%ebx)
c040f889:	64 65 3a 20          	cmp    %fs:%gs:(%eax),%ah
c040f88d:	65 6e                	outsb  %gs:(%esi),(%dx)
c040f88f:	74 72                	je     c040f903 <debug_initialise+0x20ef>
c040f891:	79 20                	jns    c040f8b3 <debug_initialise+0x209f>
c040f893:	25 70 20 76 69       	and    $0x69762070,%eax
c040f898:	72 74                	jb     c040f90e <debug_initialise+0x20fa>
c040f89a:	20 25 70 20 70 68    	and    %ah,0x68702070
c040f8a0:	79 73                	jns    c040f915 <debug_initialise+0x2101>
c040f8a2:	20 25 70 20 73 69    	and    %ah,0x69732070
c040f8a8:	7a 65                	jp     c040f90f <debug_initialise+0x20fb>
c040f8aa:	20 25 75 20 6d 65    	and    %ah,0x656d2075
c040f8b0:	6d                   	insl   (%dx),%es:(%edi)
c040f8b1:	73 69                	jae    c040f91c <debug_initialise+0x2108>
c040f8b3:	7a 65                	jp     c040f91a <debug_initialise+0x2106>
c040f8b5:	20 25 75 20 66 6c    	and    %ah,0x6c662075
c040f8bb:	61                   	popa   
c040f8bc:	67 73 20             	addr16 jae c040f8df <debug_initialise+0x20cb>
c040f8bf:	25 75 0a 00 00       	and    $0xa75,%eax
c040f8c4:	20 20                	and    %ah,(%eax)
c040f8c6:	20 20                	and    %ah,(%eax)
c040f8c8:	20 20                	and    %ah,(%eax)
c040f8ca:	20 64 61 74          	and    %ah,0x74(%ecx,%eiz,2)
c040f8ce:	61                   	popa   
c040f8cf:	3a 20                	cmp    (%eax),%ah
c040f8d1:	20 20                	and    %ah,(%eax)
c040f8d3:	20 20                	and    %ah,(%eax)
c040f8d5:	20 20                	and    %ah,(%eax)
c040f8d7:	20 20                	and    %ah,(%eax)
c040f8d9:	20 76 69             	and    %dh,0x69(%esi)
c040f8dc:	72 74                	jb     c040f952 <debug_initialise+0x213e>
c040f8de:	20 25 70 20 70 68    	and    %ah,0x68702070
c040f8e4:	79 73                	jns    c040f959 <debug_initialise+0x2145>
c040f8e6:	20 25 70 20 73 69    	and    %ah,0x69732070
c040f8ec:	7a 65                	jp     c040f953 <debug_initialise+0x213f>
c040f8ee:	20 25 75 20 6d 65    	and    %ah,0x656d2075
c040f8f4:	6d                   	insl   (%dx),%es:(%edi)
c040f8f5:	73 69                	jae    c040f960 <debug_initialise+0x214c>
c040f8f7:	7a 65                	jp     c040f95e <debug_initialise+0x214a>
c040f8f9:	20 25 75 20 66 6c    	and    %ah,0x6c662075
c040f8ff:	61                   	popa   
c040f900:	67 73 20             	addr16 jae c040f923 <debug_initialise+0x210f>
c040f903:	25 75 0a 00 00       	and    $0xa75,%eax
c040f908:	5b                   	pop    %ebx
c040f909:	70 72                	jo     c040f97d <debug_initialise+0x2169>
c040f90b:	6f                   	outsl  %ds:(%esi),(%dx)
c040f90c:	63 3a                	arpl   %di,(%edx)
c040f90e:	25 69 5d 20 4f       	and    $0x4f205d69,%eax
c040f913:	4d                   	dec    %ebp
c040f914:	47                   	inc    %edi
c040f915:	57                   	push   %edi
c040f916:	54                   	push   %esp
c040f917:	46                   	inc    %esi
c040f918:	20 73 79             	and    %dh,0x79(%ebx)
c040f91b:	73 74                	jae    c040f991 <debug_initialise+0x217d>
c040f91d:	65                   	gs
c040f91e:	6d                   	insl   (%dx),%es:(%edi)
c040f91f:	20 70 72             	and    %dh,0x72(%eax)
c040f922:	6f                   	outsl  %ds:(%esi),(%dx)
c040f923:	63 65 73             	arpl   %sp,0x73(%ebp)
c040f926:	73 20                	jae    c040f948 <debug_initialise+0x2134>
c040f928:	25 69 20 28 25       	and    $0x25282069,%eax
c040f92d:	70 29                	jo     c040f958 <debug_initialise+0x2144>
c040f92f:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040f933:	65                   	gs
c040f934:	61                   	popa   
c040f935:	64 20 63 72          	and    %ah,%fs:0x72(%ebx)
c040f939:	65                   	gs
c040f93a:	61                   	popa   
c040f93b:	74 69                	je     c040f9a6 <debug_initialise+0x2192>
c040f93d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f93e:	6e                   	outsb  %ds:(%esi),(%dx)
c040f93f:	20 66 61             	and    %ah,0x61(%esi)
c040f942:	69 6c 65 64 21 0a 00 	imul   $0x2a000a21,0x64(%ebp,%eiz,2),%ebp
c040f949:	2a 
c040f94a:	2a 2a                	sub    (%edx),%ch
c040f94c:	20 68 61             	and    %ch,0x61(%eax)
c040f94f:	6c                   	insb   (%dx),%es:(%edi)
c040f950:	74 69                	je     c040f9bb <debug_initialise+0x21a7>
c040f952:	6e                   	outsb  %ds:(%esi),(%dx)
c040f953:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040f957:	00 5b 6d             	add    %bl,0x6d(%ebx)
c040f95a:	70 3a                	jo     c040f996 <debug_initialise+0x2182>
c040f95c:	25 69 5d 20 75       	and    $0x75205d69,%eax
c040f961:	6e                   	outsb  %ds:(%esi),(%dx)
c040f962:	61                   	popa   
c040f963:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040f967:	74 6f                	je     c040f9d8 <debug_initialise+0x21c4>
c040f969:	20 61 6c             	and    %ah,0x6c(%ecx)
c040f96c:	6c                   	insb   (%dx),%es:(%edi)
c040f96d:	6f                   	outsl  %ds:(%esi),(%dx)
c040f96e:	63 61 74             	arpl   %sp,0x74(%ecx)
c040f971:	65 20 62 6f          	and    %ah,%gs:0x6f(%edx)
c040f975:	6f                   	outsl  %ds:(%esi),(%dx)
c040f976:	74 20                	je     c040f998 <debug_initialise+0x2184>
c040f978:	73 74                	jae    c040f9ee <debug_initialise+0x21da>
c040f97a:	61                   	popa   
c040f97b:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040f97e:	66 6f                	outsw  %ds:(%esi),(%dx)
c040f980:	72 20                	jb     c040f9a2 <debug_initialise+0x218e>
c040f982:	41                   	inc    %ecx
c040f983:	50                   	push   %eax
c040f984:	20 25 69 0a 00 00    	and    %ah,0xa69
c040f98a:	00 00                	add    %al,(%eax)
c040f98c:	5b                   	pop    %ebx
c040f98d:	6d                   	insl   (%dx),%es:(%edi)
c040f98e:	70 3a                	jo     c040f9ca <debug_initialise+0x21b6>
c040f990:	25 69 5d 20 75       	and    $0x75205d69,%eax
c040f995:	6e                   	outsb  %ds:(%esi),(%dx)
c040f996:	61                   	popa   
c040f997:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040f99b:	74 6f                	je     c040fa0c <debug_initialise+0x21f8>
c040f99d:	20 61 6c             	and    %ah,0x6c(%ecx)
c040f9a0:	6c                   	insb   (%dx),%es:(%edi)
c040f9a1:	6f                   	outsl  %ds:(%esi),(%dx)
c040f9a2:	63 61 74             	arpl   %sp,0x74(%ecx)
c040f9a5:	65 20 66 72          	and    %ah,%gs:0x72(%esi)
c040f9a9:	65                   	gs
c040f9aa:	73 68                	jae    c040fa14 <debug_initialise+0x2200>
c040f9ac:	20 47 44             	and    %al,0x44(%edi)
c040f9af:	54                   	push   %esp
c040f9b0:	20 66 6f             	and    %ah,0x6f(%esi)
c040f9b3:	72 20                	jb     c040f9d5 <debug_initialise+0x21c1>
c040f9b5:	41                   	inc    %ecx
c040f9b6:	50                   	push   %eax
c040f9b7:	20 25 69 0a 00 5b    	and    %ah,0x5b000a69
c040f9bd:	6d                   	insl   (%dx),%es:(%edi)
c040f9be:	70 3a                	jo     c040f9fa <debug_initialise+0x21e6>
c040f9c0:	25 69 5d 20 69       	and    $0x69205d69,%eax
c040f9c5:	6e                   	outsb  %ds:(%esi),(%dx)
c040f9c6:	69 74 69 61 6c 69 73 	imul   $0x6173696c,0x61(%ecx,%ebp,2),%esi
c040f9cd:	61 
c040f9ce:	74 69                	je     c040fa39 <debug_initialise+0x2225>
c040f9d0:	6f                   	outsl  %ds:(%esi),(%dx)
c040f9d1:	6e                   	outsb  %ds:(%esi),(%dx)
c040f9d2:	20 6f 66             	and    %ch,0x66(%edi)
c040f9d5:	20 41 50             	and    %al,0x50(%ecx)
c040f9d8:	20 25 69 20 74 69    	and    %ah,0x69742069
c040f9de:	6d                   	insl   (%dx),%es:(%edi)
c040f9df:	65 64 20 6f 75       	and    %ch,%fs:%gs:0x75(%edi)
c040f9e4:	74 0a                	je     c040f9f0 <debug_initialise+0x21dc>
c040f9e6:	00 00                	add    %al,(%eax)
c040f9e8:	5b                   	pop    %ebx
c040f9e9:	6d                   	insl   (%dx),%es:(%edi)
c040f9ea:	70 3a                	jo     c040fa26 <debug_initialise+0x2212>
c040f9ec:	25 69 5d 20 63       	and    $0x63205d69,%eax
c040f9f1:	61                   	popa   
c040f9f2:	6e                   	outsb  %ds:(%esi),(%dx)
c040f9f3:	27                   	daa    
c040f9f4:	74 20                	je     c040fa16 <debug_initialise+0x2202>
c040f9f6:	61                   	popa   
c040f9f7:	6c                   	insb   (%dx),%es:(%edi)
c040f9f8:	6c                   	insb   (%dx),%es:(%edi)
c040f9f9:	6f                   	outsl  %ds:(%esi),(%dx)
c040f9fa:	63 61 74             	arpl   %sp,0x74(%ecx)
c040f9fd:	65 20 63 70          	and    %ah,%gs:0x70(%ebx)
c040fa01:	75 20                	jne    c040fa23 <debug_initialise+0x220f>
c040fa03:	74 61                	je     c040fa66 <debug_initialise+0x2252>
c040fa05:	62 6c 65 21          	bound  %ebp,0x21(%ebp,%eiz,2)
c040fa09:	20 68 61             	and    %ch,0x61(%eax)
c040fa0c:	6c                   	insb   (%dx),%es:(%edi)
c040fa0d:	74 69                	je     c040fa78 <debug_initialise+0x2264>
c040fa0f:	6e                   	outsb  %ds:(%esi),(%dx)
c040fa10:	67 2e 2e 2e 0a 00    	addr16 or %cs:(%bx,%si),%al
c040fa16:	00 00                	add    %al,(%eax)
c040fa18:	5b                   	pop    %ebx
c040fa19:	6d                   	insl   (%dx),%es:(%edi)
c040fa1a:	70 3a                	jo     c040fa56 <debug_initialise+0x2242>
c040fa1c:	25 69 5d 20 69       	and    $0x69205d69,%eax
c040fa21:	6e                   	outsb  %ds:(%esi),(%dx)
c040fa22:	69 74 69 61 6c 69 73 	imul   $0x6573696c,0x61(%ecx,%ebp,2),%esi
c040fa29:	65 
c040fa2a:	64 20 72 75          	and    %dh,%fs:0x75(%edx)
c040fa2e:	6e                   	outsb  %ds:(%esi),(%dx)
c040fa2f:	2d 74 69 6d 65       	sub    $0x656d6974,%eax
c040fa34:	20 63 70             	and    %ah,0x70(%ebx)
c040fa37:	75 20                	jne    c040fa59 <debug_initialise+0x2245>
c040fa39:	74 61                	je     c040fa9c <debug_initialise+0x2288>
c040fa3b:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040fa3f:	25 70 20 28 25       	and    $0x25282070,%eax
c040fa44:	69 20 63 70 75 73    	imul   $0x73757063,(%eax),%esp
c040fa4a:	29 0a                	sub    %ecx,(%edx)
c040fa4c:	00 00                	add    %al,(%eax)
c040fa4e:	00 00                	add    %al,(%eax)
c040fa50:	5b                   	pop    %ebx
c040fa51:	6d                   	insl   (%dx),%es:(%edi)
c040fa52:	70 3a                	jo     c040fa8e <debug_initialise+0x227a>
c040fa54:	25 69 5d 20 77       	and    $0x77205d69,%eax
c040fa59:	6f                   	outsl  %ds:(%esi),(%dx)
c040fa5a:	6b 65 20 75          	imul   $0x75,0x20(%ebp),%esp
c040fa5e:	70 20                	jo     c040fa80 <debug_initialise+0x226c>
c040fa60:	25 69 20 61 70       	and    $0x70612069,%eax
c040fa65:	70 6c                	jo     c040fad3 <debug_initialise+0x22bf>
c040fa67:	69 63 61 74 69 6f 6e 	imul   $0x6e6f6974,0x61(%ebx),%esp
c040fa6e:	20 70 72             	and    %dh,0x72(%eax)
c040fa71:	6f                   	outsl  %ds:(%esi),(%dx)
c040fa72:	63 65 73             	arpl   %sp,0x73(%ebp)
c040fa75:	73 6f                	jae    c040fae6 <debug_initialise+0x22d2>
c040fa77:	72 28                	jb     c040faa1 <debug_initialise+0x228d>
c040fa79:	73 29                	jae    c040faa4 <debug_initialise+0x2290>
c040fa7b:	20 6f 75             	and    %ch,0x75(%edi)
c040fa7e:	74 20                	je     c040faa0 <debug_initialise+0x228c>
c040fa80:	6f                   	outsl  %ds:(%esi),(%dx)
c040fa81:	66                   	data16
c040fa82:	20 25 69 0a 00 00    	and    %ah,0xa69
c040fa88:	5b                   	pop    %ebx
c040fa89:	6d                   	insl   (%dx),%es:(%edi)
c040fa8a:	70 5d                	jo     c040fae9 <debug_initialise+0x22d5>
c040fa8c:	20 61 73             	and    %ah,0x73(%ecx)
c040fa8f:	73 75                	jae    c040fb06 <debug_initialise+0x22f2>
c040fa91:	6d                   	insl   (%dx),%es:(%edi)
c040fa92:	69 6e 67 20 75 6e 69 	imul   $0x696e7520,0x67(%esi),%ebp
c040fa99:	70 72                	jo     c040fb0d <debug_initialise+0x22f9>
c040fa9b:	6f                   	outsl  %ds:(%esi),(%dx)
c040fa9c:	63 65 73             	arpl   %sp,0x73(%ebp)
c040fa9f:	73 6f                	jae    c040fb10 <debug_initialise+0x22fc>
c040faa1:	72 20                	jb     c040fac3 <debug_initialise+0x22af>
c040faa3:	6d                   	insl   (%dx),%es:(%edi)
c040faa4:	61                   	popa   
c040faa5:	63 68 69             	arpl   %bp,0x69(%eax)
c040faa8:	6e                   	outsb  %ds:(%esi),(%dx)
c040faa9:	65 0a 00             	or     %gs:(%eax),%al
c040faac:	5b                   	pop    %ebx
c040faad:	6d                   	insl   (%dx),%es:(%edi)
c040faae:	70 5d                	jo     c040fb0d <debug_initialise+0x22f9>
c040fab0:	20 6d 75             	and    %ch,0x75(%ebp)
c040fab3:	6c                   	insb   (%dx),%es:(%edi)
c040fab4:	74 69                	je     c040fb1f <debug_initialise+0x230b>
c040fab6:	70 72                	jo     c040fb2a <debug_initialise+0x2316>
c040fab8:	6f                   	outsl  %ds:(%esi),(%dx)
c040fab9:	63 65 73             	arpl   %sp,0x73(%ebp)
c040fabc:	73 6f                	jae    c040fb2d <debug_initialise+0x2319>
c040fabe:	72 20                	jb     c040fae0 <debug_initialise+0x22cc>
c040fac0:	6d                   	insl   (%dx),%es:(%edi)
c040fac1:	61                   	popa   
c040fac2:	63 68 69             	arpl   %bp,0x69(%eax)
c040fac5:	6e                   	outsb  %ds:(%esi),(%dx)
c040fac6:	65 20 64 65 74       	and    %ah,%gs:0x74(%ebp,%eiz,2)
c040facb:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040fad0:	0a 00                	or     (%eax),%al
c040fad2:	5b                   	pop    %ebx
c040fad3:	6d                   	insl   (%dx),%es:(%edi)
c040fad4:	70 5d                	jo     c040fb33 <debug_initialise+0x231f>
c040fad6:	20 73 79             	and    %dh,0x79(%ebx)
c040fad9:	73 74                	jae    c040fb4f <debug_initialise+0x233b>
c040fadb:	65                   	gs
c040fadc:	6d                   	insl   (%dx),%es:(%edi)
c040fadd:	3a 20                	cmp    (%eax),%ah
c040fadf:	00 25 63 00 20 00    	add    %ah,0x200063
c040fae5:	0a 00                	or     (%eax),%al
c040fae7:	5b                   	pop    %ebx
c040fae8:	6d                   	insl   (%dx),%es:(%edi)
c040fae9:	70 5d                	jo     c040fb48 <debug_initialise+0x2334>
c040faeb:	20 66 6f             	and    %ah,0x6f(%esi)
c040faee:	75 6e                	jne    c040fb5e <debug_initialise+0x234a>
c040faf0:	64 20 63 70          	and    %ah,%fs:0x70(%ebx)
c040faf4:	75 20                	jne    c040fb16 <debug_initialise+0x2302>
c040faf6:	25 69 20 28 66       	and    $0x66282069,%eax
c040fafb:	6c                   	insb   (%dx),%es:(%edi)
c040fafc:	61                   	popa   
c040fafd:	67 73 20             	addr16 jae c040fb20 <debug_initialise+0x230c>
c040fb00:	25 78 29 20 00       	and    $0x202978,%eax
c040fb05:	5b                   	pop    %ebx
c040fb06:	62 6f 6f             	bound  %ebp,0x6f(%edi)
c040fb09:	74 20                	je     c040fb2b <debug_initialise+0x2317>
c040fb0b:	70 72                	jo     c040fb7f <debug_initialise+0x236b>
c040fb0d:	6f                   	outsl  %ds:(%esi),(%dx)
c040fb0e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040fb11:	73 6f                	jae    c040fb82 <debug_initialise+0x236e>
c040fb13:	72 5d                	jb     c040fb72 <debug_initialise+0x235e>
c040fb15:	00 5b 61             	add    %bl,0x61(%ebx)
c040fb18:	70 70                	jo     c040fb8a <debug_initialise+0x2376>
c040fb1a:	6c                   	insb   (%dx),%es:(%edi)
c040fb1b:	69 63 61 74 69 6f 6e 	imul   $0x6e6f6974,0x61(%ebx),%esp
c040fb22:	20 70 72             	and    %dh,0x72(%eax)
c040fb25:	6f                   	outsl  %ds:(%esi),(%dx)
c040fb26:	63 65 73             	arpl   %sp,0x73(%ebp)
c040fb29:	73 6f                	jae    c040fb9a <debug_initialise+0x2386>
c040fb2b:	72 5d                	jb     c040fb8a <debug_initialise+0x2376>
c040fb2d:	00 00                	add    %al,(%eax)
c040fb2f:	00 5b 6d             	add    %bl,0x6d(%ebx)
c040fb32:	70 5d                	jo     c040fb91 <debug_initialise+0x237d>
c040fb34:	20 66 6f             	and    %ah,0x6f(%esi)
c040fb37:	75 6e                	jne    c040fba7 <debug_initialise+0x2393>
c040fb39:	64 20 61 6e          	and    %ah,%fs:0x6e(%ecx)
c040fb3d:	20 69 6f             	and    %ch,0x6f(%ecx)
c040fb40:	61                   	popa   
c040fb41:	70 69                	jo     c040fbac <debug_initialise+0x2398>
c040fb43:	63 20                	arpl   %sp,(%eax)
c040fb45:	28 69 64             	sub    %ch,0x64(%ecx)
c040fb48:	20 25 69 20 66 6c    	and    %ah,0x6c662069
c040fb4e:	61                   	popa   
c040fb4f:	67 73 20             	addr16 jae c040fb72 <debug_initialise+0x235e>
c040fb52:	25 78 20 61 64       	and    $0x64612078,%eax
c040fb57:	64                   	fs
c040fb58:	72 20                	jb     c040fb7a <debug_initialise+0x2366>
c040fb5a:	25 70 29 0a 00       	and    $0xa2970,%eax
c040fb5f:	00 5b 63             	add    %bl,0x63(%ebx)
c040fb62:	6f                   	outsl  %ds:(%esi),(%dx)
c040fb63:	72 65                	jb     c040fbca <debug_initialise+0x23b6>
c040fb65:	5d                   	pop    %ebp
c040fb66:	20 64 69 6f          	and    %ah,0x6f(%ecx,%ebp,2)
c040fb6a:	73 69                	jae    c040fbd5 <debug_initialise+0x23c1>
c040fb6c:	78 2d                	js     c040fb9b <debug_initialise+0x2387>
c040fb6e:	68 79 61 74 74       	push   $0x74746179
c040fb73:	20 32                	and    %dh,(%edx)
c040fb75:	31 3a                	xor    %edi,(%edx)
c040fb77:	31 30                	xor    %esi,(%eax)
c040fb79:	3a 31                	cmp    (%ecx),%dh
c040fb7b:	39 20                	cmp    %esp,(%eax)
c040fb7d:	4a                   	dec    %edx
c040fb7e:	61                   	popa   
c040fb7f:	6e                   	outsb  %ds:(%esi),(%dx)
c040fb80:	20 31                	and    %dh,(%ecx)
c040fb82:	37                   	aaa    
c040fb83:	20 32                	and    %dh,(%edx)
c040fb85:	30 31                	xor    %dh,(%ecx)
c040fb87:	30 20                	xor    %ah,(%eax)
c040fb89:	28 62 75             	sub    %ah,0x75(%edx)
c040fb8c:	69 6c 74 20 77 69 74 	imul   $0x68746977,0x20(%esp,%esi,2),%ebp
c040fb93:	68 
c040fb94:	20 47 43             	and    %al,0x43(%edi)
c040fb97:	43                   	inc    %ebx
c040fb98:	20 34 2e             	and    %dh,(%esi,%ebp,1)
c040fb9b:	34 2e                	xor    $0x2e,%al
c040fb9d:	31 29                	xor    %ebp,(%ecx)
c040fb9f:	0a 00                	or     (%eax),%al
c040fba1:	00 00                	add    %al,(%eax)
c040fba3:	00 2a                	add    %ch,(%edx)
c040fba5:	2a 2a                	sub    (%edx),%ch
c040fba7:	20 77 61             	and    %dh,0x61(%edi)
c040fbaa:	72 6e                	jb     c040fc1a <debug_initialise+0x2406>
c040fbac:	69 6e 67 3a 20 62 6f 	imul   $0x6f62203a,0x67(%esi),%ebp
c040fbb3:	6f                   	outsl  %ds:(%esi),(%dx)
c040fbb4:	74 6c                	je     c040fc22 <debug_initialise+0x240e>
c040fbb6:	6f                   	outsl  %ds:(%esi),(%dx)
c040fbb7:	61                   	popa   
c040fbb8:	64                   	fs
c040fbb9:	65                   	gs
c040fbba:	72 20                	jb     c040fbdc <debug_initialise+0x23c8>
c040fbbc:	6d                   	insl   (%dx),%es:(%edi)
c040fbbd:	61                   	popa   
c040fbbe:	67 69 63 20 77 61 73 	addr16 imul $0x20736177,0x20(%bp,%di),%esp
c040fbc5:	20 
c040fbc6:	25 78 20 28 65       	and    $0x65282078,%eax
c040fbcb:	78 70                	js     c040fc3d <debug_initialise+0x2429>
c040fbcd:	65 63 74 69 6e       	arpl   %si,%gs:0x6e(%ecx,%ebp,2)
c040fbd2:	67 20 25             	addr16 and %ah,(%di)
c040fbd5:	78 29                	js     c040fc00 <debug_initialise+0x23ec>
c040fbd7:	2e 0a 00             	or     %cs:(%eax),%al
c040fbda:	00 00                	add    %al,(%eax)
c040fbdc:	0a 2a                	or     (%edx),%ch
c040fbde:	2a 2a                	sub    (%edx),%ch
c040fbe0:	20 75 6e             	and    %dh,0x6e(%ebp)
c040fbe3:	65                   	gs
c040fbe4:	78 70                	js     c040fc56 <debug_initialise+0x2442>
c040fbe6:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040fbeb:	20 65 6e             	and    %ah,0x6e(%ebp)
c040fbee:	64                   	fs
c040fbef:	2d 6f 66 2d 62       	sub    $0x622d666f,%eax
c040fbf4:	6f                   	outsl  %ds:(%esi),(%dx)
c040fbf5:	6f                   	outsl  %ds:(%esi),(%dx)
c040fbf6:	74 2e                	je     c040fc26 <debug_initialise+0x2412>
c040fbf8:	20 68 61             	and    %ch,0x61(%eax)
c040fbfb:	6c                   	insb   (%dx),%es:(%edi)
c040fbfc:	74 69                	je     c040fc67 <debug_initialise+0x2453>
c040fbfe:	6e                   	outsb  %ds:(%esi),(%dx)
c040fbff:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040fc03:	00 2a                	add    %ch,(%edx)
c040fc05:	2a 2a                	sub    (%edx),%ch
c040fc07:	20 74 72 79          	and    %dh,0x79(%edx,%esi,2)
c040fc0b:	69 6e 67 20 74 6f 20 	imul   $0x206f7420,0x67(%esi),%ebp
c040fc12:	70 72                	jo     c040fc86 <debug_initialise+0x2472>
c040fc14:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc15:	62 65 20             	bound  %esp,0x20(%ebp)
c040fc18:	70 61                	jo     c040fc7b <debug_initialise+0x2467>
c040fc1a:	79 6c                	jns    c040fc88 <debug_initialise+0x2474>
c040fc1c:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc1d:	61                   	popa   
c040fc1e:	64                   	fs
c040fc1f:	73 20                	jae    c040fc41 <debug_initialise+0x242d>
c040fc21:	62 65 66             	bound  %esp,0x66(%ebp)
c040fc24:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc25:	72 65                	jb     c040fc8c <debug_initialise+0x2478>
c040fc27:	20 70 72             	and    %dh,0x72(%eax)
c040fc2a:	65 69 6e 69 74 20 2d 	imul   $0x202d2074,%gs:0x69(%esi),%ebp
c040fc31:	20 
c040fc32:	68 61 6c 74 69       	push   $0x69746c61
c040fc37:	6e                   	outsb  %ds:(%esi),(%dx)
c040fc38:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040fc3c:	5b                   	pop    %ebx
c040fc3d:	70 61                	jo     c040fca0 <debug_initialise+0x248c>
c040fc3f:	79 6c                	jns    c040fcad <debug_initialise+0x2499>
c040fc41:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc42:	61                   	popa   
c040fc43:	64 3a 25 69 5d 20 66 	cmp    %fs:0x66205d69,%ah
c040fc4a:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc4b:	75 6e                	jne    c040fcbb <debug_initialise+0x24a7>
c040fc4d:	64 20 61 20          	and    %ah,%fs:0x20(%ecx)
c040fc51:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040fc55:	65                   	gs
c040fc56:	6c                   	insb   (%dx),%es:(%edi)
c040fc57:	20 73 79             	and    %dh,0x79(%ebx)
c040fc5a:	6d                   	insl   (%dx),%es:(%edi)
c040fc5b:	62 6f 6c             	bound  %ebp,0x6c(%edi)
c040fc5e:	20 74 61 62          	and    %dh,0x62(%ecx,%eiz,2)
c040fc62:	6c                   	insb   (%dx),%es:(%edi)
c040fc63:	65 20 28             	and    %ch,%gs:(%eax)
c040fc66:	25 78 20 2d 20       	and    $0x202d2078,%eax
c040fc6b:	25 78 29 0a 00       	and    $0xa2978,%eax
c040fc70:	5b                   	pop    %ebx
c040fc71:	70 61                	jo     c040fcd4 <debug_initialise+0x24c0>
c040fc73:	79 6c                	jns    c040fce1 <debug_initialise+0x24cd>
c040fc75:	6f                   	outsl  %ds:(%esi),(%dx)
c040fc76:	61                   	popa   
c040fc77:	64 3a 25 69 5d 20 70 	cmp    %fs:0x70205d69,%ah
c040fc7e:	61                   	popa   
c040fc7f:	72 73                	jb     c040fcf4 <debug_initialise+0x24e0>
c040fc81:	69 6e 67 20 62 69 6e 	imul   $0x6e696220,0x67(%esi),%ebp
c040fc88:	61                   	popa   
c040fc89:	72 79                	jb     c040fd04 <debug_initialise+0x24f0>
c040fc8b:	3a 20                	cmp    (%eax),%ah
c040fc8d:	25 73 20 28 25       	and    $0x25282073,%eax
c040fc92:	78 29                	js     c040fcbd <debug_initialise+0x24a9>
c040fc94:	00 20                	add    %ah,(%eax)
c040fc96:	2e 2e 2e 20 69 73    	and    %ch,%cs:0x73(%ecx)
c040fc9c:	20 6e 6f             	and    %ch,0x6f(%esi)
c040fc9f:	74 20                	je     c040fcc1 <debug_initialise+0x24ad>
c040fca1:	61                   	popa   
c040fca2:	20 76 61             	and    %dh,0x61(%esi)
c040fca5:	6c                   	insb   (%dx),%es:(%edi)
c040fca6:	69 64 20 45 4c 46 0a 	imul   $0xa464c,0x45(%eax,%eiz,1),%esp
c040fcad:	00 
c040fcae:	00 00                	add    %al,(%eax)
c040fcb0:	20 2e                	and    %ch,(%esi)
c040fcb2:	2e 2e 20 69 73       	and    %ch,%cs:0x73(%ecx)
c040fcb7:	20 69 6e             	and    %ch,0x6e(%ecx)
c040fcba:	63 6f 6d             	arpl   %bp,0x6d(%edi)
c040fcbd:	70 61                	jo     c040fd20 <debug_initialise+0x250c>
c040fcbf:	74 69                	je     c040fd2a <debug_initialise+0x2516>
c040fcc1:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040fcc5:	77 69                	ja     c040fd30 <debug_initialise+0x251c>
c040fcc7:	74 68                	je     c040fd31 <debug_initialise+0x251d>
c040fcc9:	20 74 68 69          	and    %dh,0x69(%eax,%ebp,2)
c040fccd:	73 20                	jae    c040fcef <debug_initialise+0x24db>
c040fccf:	6d                   	insl   (%dx),%es:(%edi)
c040fcd0:	61                   	popa   
c040fcd1:	63 68 69             	arpl   %bp,0x69(%eax)
c040fcd4:	6e                   	outsb  %ds:(%esi),(%dx)
c040fcd5:	65 20 28             	and    %ch,%gs:(%eax)
c040fcd8:	25 78 29 0a 00       	and    $0xa2978,%eax
c040fcdd:	20 2e                	and    %ch,(%esi)
c040fcdf:	2e 2e 20 68 61       	and    %ch,%cs:0x61(%eax)
c040fce4:	73 20                	jae    c040fd06 <debug_initialise+0x24f2>
c040fce6:	75 6e                	jne    c040fd56 <debug_initialise+0x2542>
c040fce8:	65                   	gs
c040fce9:	78 70                	js     c040fd5b <debug_initialise+0x2547>
c040fceb:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040fcf0:	20 61 72             	and    %ah,0x72(%ecx)
c040fcf3:	65                   	gs
c040fcf4:	61                   	popa   
c040fcf5:	73 21                	jae    c040fd18 <debug_initialise+0x2504>
c040fcf7:	0a 00                	or     (%eax),%al
c040fcf9:	20 2e                	and    %ch,(%esi)
c040fcfb:	2e 2e 20 64 6f 6e    	and    %ah,%cs:0x6e(%edi,%ebp,2)
c040fd01:	65 0a 00             	or     %gs:(%eax),%al
c040fd04:	5b                   	pop    %ebx
c040fd05:	70 61                	jo     c040fd68 <debug_initialise+0x2554>
c040fd07:	79 6c                	jns    c040fd75 <debug_initialise+0x2561>
c040fd09:	6f                   	outsl  %ds:(%esi),(%dx)
c040fd0a:	61                   	popa   
c040fd0b:	64 3a 25 69 5d 20 4e 	cmp    %fs:0x4e205d69,%ah
c040fd12:	6f                   	outsl  %ds:(%esi),(%dx)
c040fd13:	20 6d 6f             	and    %ch,0x6f(%ebp)
c040fd16:	64                   	fs
c040fd17:	75 6c                	jne    c040fd85 <debug_initialise+0x2571>
c040fd19:	65                   	gs
c040fd1a:	73 20                	jae    c040fd3c <debug_initialise+0x2528>
c040fd1c:	6c                   	insb   (%dx),%es:(%edi)
c040fd1d:	6f                   	outsl  %ds:(%esi),(%dx)
c040fd1e:	61                   	popa   
c040fd1f:	64 65 64 20 77 69    	and    %dh,%fs:%gs:0x69(%edi)
c040fd25:	74 68                	je     c040fd8f <debug_initialise+0x257b>
c040fd27:	20 6b 65             	and    %ch,0x65(%ebx)
c040fd2a:	72 6e                	jb     c040fd9a <debug_initialise+0x2586>
c040fd2c:	65                   	gs
c040fd2d:	6c                   	insb   (%dx),%es:(%edi)
c040fd2e:	2e 0a 00             	or     %cs:(%eax),%al
c040fd31:	00 00                	add    %al,(%eax)
c040fd33:	00 5b 70             	add    %bl,0x70(%ebx)
c040fd36:	61                   	popa   
c040fd37:	79 6c                	jns    c040fda5 <debug_initialise+0x2591>
c040fd39:	6f                   	outsl  %ds:(%esi),(%dx)
c040fd3a:	61                   	popa   
c040fd3b:	64 3a 25 69 5d 20 25 	cmp    %fs:0x25205d69,%ah
c040fd42:	69 20 6d 6f 64 75    	imul   $0x75646f6d,(%eax),%esp
c040fd48:	6c                   	insb   (%dx),%es:(%edi)
c040fd49:	65 28 73 29          	sub    %dh,%gs:0x29(%ebx)
c040fd4d:	20 69 6e             	and    %ch,0x6e(%ecx)
c040fd50:	20 70 61             	and    %dh,0x61(%eax)
c040fd53:	79 6c                	jns    c040fdc1 <debug_initialise+0x25ad>
c040fd55:	6f                   	outsl  %ds:(%esi),(%dx)
c040fd56:	61                   	popa   
c040fd57:	64 0a 00             	or     %fs:(%eax),%al
c040fd5a:	00 00                	add    %al,(%eax)
c040fd5c:	5b                   	pop    %ebx
c040fd5d:	64 65 62 75 67       	bound  %esi,%fs:%gs:0x67(%ebp)
c040fd62:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040fd68:	65                   	gs
c040fd69:	72 6e                	jb     c040fdd9 <debug_initialise+0x25c5>
c040fd6b:	65                   	gs
c040fd6c:	6c                   	insb   (%dx),%es:(%edi)
c040fd6d:	20 73 74             	and    %dh,0x74(%ebx)
c040fd70:	61                   	popa   
c040fd71:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040fd74:	62 61 63             	bound  %esp,0x63(%ecx)
c040fd77:	6b 74 72 61 63       	imul   $0x63,0x61(%edx,%esi,2),%esi
c040fd7c:	65 20 72 65          	and    %dh,%gs:0x65(%edx)
c040fd80:	71 75                	jno    c040fdf7 <debug_initialise+0x25e3>
c040fd82:	65                   	gs
c040fd83:	73 74                	jae    c040fdf9 <debug_initialise+0x25e5>
c040fd85:	65 64 3a 20          	cmp    %fs:%gs:(%eax),%ah
c040fd89:	62 61 73             	bound  %esp,0x73(%ecx)
c040fd8c:	65 20 25 70 20 73 74 	and    %ah,%gs:0x74732070
c040fd93:	61                   	popa   
c040fd94:	63 6b 70             	arpl   %bp,0x70(%ebx)
c040fd97:	74 72                	je     c040fe0b <debug_initialise+0x25f7>
c040fd99:	20 25 70 20 73 69    	and    %ah,0x69732070
c040fd9f:	7a 65                	jp     c040fe06 <debug_initialise+0x25f2>
c040fda1:	20 25 69 20 28 74    	and    %ah,0x74282069
c040fda7:	69 64 20 25 69 20 70 	imul   $0x69702069,0x25(%eax,%eiz,1),%esp
c040fdae:	69 
c040fdaf:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040fdb6:	00 00                	add    %al,(%eax)
c040fdb8:	20 20                	and    %ah,(%eax)
c040fdba:	20 20                	and    %ah,(%eax)
c040fdbc:	20 20                	and    %ah,(%eax)
c040fdbe:	20 20                	and    %ah,(%eax)
c040fdc0:	5b                   	pop    %ebx
c040fdc1:	30 78 25             	xor    %bh,0x25(%eax)
c040fdc4:	70 5d                	jo     c040fe23 <debug_initialise+0x260f>
c040fdc6:	20 20                	and    %ah,(%eax)
c040fdc8:	30 78 25             	xor    %bh,0x25(%eax)
c040fdcb:	78 20                	js     c040fded <debug_initialise+0x25d9>
c040fdcd:	5b                   	pop    %ebx
c040fdce:	66                   	data16
c040fdcf:	75 6e                	jne    c040fe3f <debug_initialise+0x262b>
c040fdd1:	63 20                	arpl   %sp,(%eax)
c040fdd3:	25 73 20 2b 20       	and    $0x202b2073,%eax
c040fdd8:	30 78 25             	xor    %bh,0x25(%eax)
c040fddb:	78 5d                	js     c040fe3a <debug_initialise+0x2626>
c040fddd:	0a 00                	or     (%eax),%al
c040fddf:	0a 00                	or     (%eax),%al
c040fde1:	00 00                	add    %al,(%eax)
c040fde3:	00 5b 64             	add    %bl,0x64(%ebx)
c040fde6:	65 62 75 67          	bound  %esi,%gs:0x67(%ebp)
c040fdea:	5d                   	pop    %ebp
c040fdeb:	20 61 73             	and    %ah,0x73(%ecx)
c040fdee:	73 65                	jae    c040fe55 <debug_initialise+0x2641>
c040fdf0:	72 74                	jb     c040fe66 <debug_initialise+0x2652>
c040fdf2:	28 25 73 29 20 66    	sub    %ah,0x66202973
c040fdf8:	61                   	popa   
c040fdf9:	69 6c 65 64 20 69 6e 	imul   $0x206e6920,0x64(%ebp,%eiz,2),%ebp
c040fe00:	20 
c040fe01:	66 69 6c 65 20 25 73 	imul   $0x7325,0x20(%ebp,%eiz,2),%bp
c040fe08:	20 28                	and    %ch,(%eax)
c040fe0a:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
c040fe11:	64 20 66 72          	and    %ah,%fs:0x72(%esi)
c040fe15:	6f                   	outsl  %ds:(%esi),(%dx)
c040fe16:	6d                   	insl   (%dx),%es:(%edi)
c040fe17:	20 25 73 29 2c 20    	and    %ah,0x202c2973
c040fe1d:	6c                   	insb   (%dx),%es:(%edi)
c040fe1e:	69 6e 65 20 25 64 0a 	imul   $0xa642520,0x65(%esi),%ebp
c040fe25:	2a 2a                	sub    (%edx),%ch
c040fe27:	2a 20                	sub    (%eax),%ah
c040fe29:	68 61 6c 74 69       	push   $0x69746c61
c040fe2e:	6e                   	outsb  %ds:(%esi),(%dx)
c040fe2f:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040fe33:	00 f1                	add    %dh,%cl
c040fe35:	cf                   	iret   
c040fe36:	40                   	inc    %eax
c040fe37:	c0 27 d0             	shlb   $0xd0,(%edi)
c040fe3a:	40                   	inc    %eax
c040fe3b:	c0 c0 d0             	rol    $0xd0,%al
c040fe3e:	40                   	inc    %eax
c040fe3f:	c0 ff d0             	sar    $0xd0,%bh
c040fe42:	40                   	inc    %eax
c040fe43:	c0 50 d1 40          	rclb   $0x40,-0x2f(%eax)
c040fe47:	c0 80 d1 40 c0 21 d4 	rolb   $0xd4,0x21c040d1(%eax)
c040fe4e:	40                   	inc    %eax
c040fe4f:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe52:	40                   	inc    %eax
c040fe53:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe56:	40                   	inc    %eax
c040fe57:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe5a:	40                   	inc    %eax
c040fe5b:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe5e:	40                   	inc    %eax
c040fe5f:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe62:	40                   	inc    %eax
c040fe63:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe66:	40                   	inc    %eax
c040fe67:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe6a:	40                   	inc    %eax
c040fe6b:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe6e:	40                   	inc    %eax
c040fe6f:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe72:	40                   	inc    %eax
c040fe73:	c0 c1 d2             	rol    $0xd2,%cl
c040fe76:	40                   	inc    %eax
c040fe77:	c0 8f d1 40 c0 21 d4 	rorb   $0xd4,0x21c040d1(%edi)
c040fe7e:	40                   	inc    %eax
c040fe7f:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe82:	40                   	inc    %eax
c040fe83:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe86:	40                   	inc    %eax
c040fe87:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe8a:	40                   	inc    %eax
c040fe8b:	c0 8f d1 40 c0 21 d4 	rorb   $0xd4,0x21c040d1(%edi)
c040fe92:	40                   	inc    %eax
c040fe93:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe96:	40                   	inc    %eax
c040fe97:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe9a:	40                   	inc    %eax
c040fe9b:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fe9e:	40                   	inc    %eax
c040fe9f:	c0 85 d1 40 c0 9e d1 	rolb   $0xd1,-0x613fbf2f(%ebp)
c040fea6:	40                   	inc    %eax
c040fea7:	c0 85 d1 40 c0 21 d4 	rolb   $0xd4,0x21c040d1(%ebp)
c040feae:	40                   	inc    %eax
c040feaf:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040feb2:	40                   	inc    %eax
c040feb3:	c0 e8 d2             	shr    $0xd2,%al
c040feb6:	40                   	inc    %eax
c040feb7:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040feba:	40                   	inc    %eax
c040febb:	c0 94 d1 40 c0 21 d4 	rclb   $0x40,-0x2bde3fc0(%ecx,%edx,8)
c040fec2:	40 
c040fec3:	c0 21 d4             	shlb   $0xd4,(%ecx)
c040fec6:	40                   	inc    %eax
c040fec7:	c0 85 d1 40 c0 df d6 	rolb   $0xd6,-0x203fbf2f(%ebp)
c040fece:	40                   	inc    %eax
c040fecf:	c0 27 d5             	shlb   $0xd5,(%edi)
c040fed2:	40                   	inc    %eax
c040fed3:	c0                   	(bad)  
c040fed4:	34 d5                	xor    $0xd5,%al
c040fed6:	40                   	inc    %eax
c040fed7:	c0 43 d5 40          	rolb   $0x40,-0x2b(%ebx)
c040fedb:	c0 56 d5 40          	rclb   $0x40,-0x2b(%esi)
c040fedf:	c0 66 d5 40          	shlb   $0x40,-0x2b(%esi)
c040fee3:	c0 7a d5 40          	sarb   $0x40,-0x2b(%edx)
c040fee7:	c0 8f d5 40 c0 a7 d5 	rorb   $0xd5,-0x583fbf2b(%edi)
c040feee:	40                   	inc    %eax
c040feef:	c0                   	(bad)  
c040fef0:	b7 d5                	mov    $0xd5,%bh
c040fef2:	40                   	inc    %eax
c040fef3:	c0 df d6             	rcr    $0xd6,%bh
c040fef6:	40                   	inc    %eax
c040fef7:	c0 df d6             	rcr    $0xd6,%bh
c040fefa:	40                   	inc    %eax
c040fefb:	c0 df d6             	rcr    $0xd6,%bh
c040fefe:	40                   	inc    %eax
c040feff:	c0 df d6             	rcr    $0xd6,%bh
c040ff02:	40                   	inc    %eax
c040ff03:	c0 df d6             	rcr    $0xd6,%bh
c040ff06:	40                   	inc    %eax
c040ff07:	c0 df d6             	rcr    $0xd6,%bh
c040ff0a:	40                   	inc    %eax
c040ff0b:	c0 df d6             	rcr    $0xd6,%bh
c040ff0e:	40                   	inc    %eax
c040ff0f:	c0 cb d5             	ror    $0xd5,%bl
c040ff12:	40                   	inc    %eax
c040ff13:	c0 e1 d5             	shl    $0xd5,%cl
c040ff16:	40                   	inc    %eax
c040ff17:	c0 f9 d5             	sar    $0xd5,%cl
c040ff1a:	40                   	inc    %eax
c040ff1b:	c0 0f d6             	rorb   $0xd6,(%edi)
c040ff1e:	40                   	inc    %eax
c040ff1f:	c0 27 d6             	shlb   $0xd6,(%edi)
c040ff22:	40                   	inc    %eax
c040ff23:	c0 43 d6 40          	rolb   $0x40,-0x2a(%ebx)
c040ff27:	c0 df d6             	rcr    $0xd6,%bh
c040ff2a:	40                   	inc    %eax
c040ff2b:	c0 df d6             	rcr    $0xd6,%bh
c040ff2e:	40                   	inc    %eax
c040ff2f:	c0 df d6             	rcr    $0xd6,%bh
c040ff32:	40                   	inc    %eax
c040ff33:	c0 df d6             	rcr    $0xd6,%bh
c040ff36:	40                   	inc    %eax
c040ff37:	c0 df d6             	rcr    $0xd6,%bh
c040ff3a:	40                   	inc    %eax
c040ff3b:	c0 df d6             	rcr    $0xd6,%bh
c040ff3e:	40                   	inc    %eax
c040ff3f:	c0 df d6             	rcr    $0xd6,%bh
c040ff42:	40                   	inc    %eax
c040ff43:	c0 df d6             	rcr    $0xd6,%bh
c040ff46:	40                   	inc    %eax
c040ff47:	c0 df d6             	rcr    $0xd6,%bh
c040ff4a:	40                   	inc    %eax
c040ff4b:	c0 df d6             	rcr    $0xd6,%bh
c040ff4e:	40                   	inc    %eax
c040ff4f:	c0 df d6             	rcr    $0xd6,%bh
c040ff52:	40                   	inc    %eax
c040ff53:	c0 df d6             	rcr    $0xd6,%bh
c040ff56:	40                   	inc    %eax
c040ff57:	c0 df d6             	rcr    $0xd6,%bh
c040ff5a:	40                   	inc    %eax
c040ff5b:	c0 df d6             	rcr    $0xd6,%bh
c040ff5e:	40                   	inc    %eax
c040ff5f:	c0 df d6             	rcr    $0xd6,%bh
c040ff62:	40                   	inc    %eax
c040ff63:	c0 df d6             	rcr    $0xd6,%bh
c040ff66:	40                   	inc    %eax
c040ff67:	c0 df d6             	rcr    $0xd6,%bh
c040ff6a:	40                   	inc    %eax
c040ff6b:	c0 df d6             	rcr    $0xd6,%bh
c040ff6e:	40                   	inc    %eax
c040ff6f:	c0 df d6             	rcr    $0xd6,%bh
c040ff72:	40                   	inc    %eax
c040ff73:	c0 df d6             	rcr    $0xd6,%bh
c040ff76:	40                   	inc    %eax
c040ff77:	c0 df d6             	rcr    $0xd6,%bh
c040ff7a:	40                   	inc    %eax
c040ff7b:	c0 df d6             	rcr    $0xd6,%bh
c040ff7e:	40                   	inc    %eax
c040ff7f:	c0 df d6             	rcr    $0xd6,%bh
c040ff82:	40                   	inc    %eax
c040ff83:	c0 df d6             	rcr    $0xd6,%bh
c040ff86:	40                   	inc    %eax
c040ff87:	c0 df d6             	rcr    $0xd6,%bh
c040ff8a:	40                   	inc    %eax
c040ff8b:	c0 df d6             	rcr    $0xd6,%bh
c040ff8e:	40                   	inc    %eax
c040ff8f:	c0 5f d6 40          	rcrb   $0x40,-0x2a(%edi)
c040ff93:	c0                   	(bad)  
c040ff94:	72 d6                	jb     c040ff6c <debug_initialise+0x2758>
c040ff96:	40                   	inc    %eax
c040ff97:	c0 87 d6 40 c0 9a d6 	rolb   $0xd6,-0x653fbf2a(%edi)
c040ff9e:	40                   	inc    %eax
c040ff9f:	c0 af d6 40 c0 c8 d6 	shrb   $0xd6,-0x373fbf2a(%edi)
c040ffa6:	40                   	inc    %eax
c040ffa7:	c0 5b 63 6f          	rcrb   $0x6f,0x63(%ebx)
c040ffab:	72 65                	jb     c0410012 <KernelPageDirectory+0x12>
c040ffad:	5d                   	pop    %ebp
c040ffae:	20 4e 6f             	and    %cl,0x6f(%esi)
c040ffb1:	77 20                	ja     c040ffd3 <debug_initialise+0x27bf>
c040ffb3:	64 65 62 75 67       	bound  %esi,%fs:%gs:0x67(%ebp)
c040ffb8:	67 69 6e 67 20 74 6f 	addr16 imul $0x206f7420,0x67(%bp),%ebp
c040ffbf:	20 
c040ffc0:	73 65                	jae    c0410027 <KernelPageDirectory+0x27>
c040ffc2:	72 69                	jb     c041002d <KernelPageDirectory+0x2d>
c040ffc4:	61                   	popa   
c040ffc5:	6c                   	insb   (%dx),%es:(%edi)
c040ffc6:	20 70 6f             	and    %dh,0x6f(%eax)
c040ffc9:	72 74                	jb     c041003f <KernelPageDirectory+0x3f>
c040ffcb:	2e 0a 00             	or     %cs:(%eax),%al
