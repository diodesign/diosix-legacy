
kernel:     file format elf32-i386


Disassembly of section .text:

c0400000 <MultiBootHeader>:
c0400000:	02 b0 ad 1b 03 00    	add    0x31bad(%eax),%dh
c0400006:	00 00                	add    %al,(%eax)
c0400008:	fb                   	sti    
c0400009:	4f                   	dec    %edi
c040000a:	52                   	push   %edx
c040000b:	e4 b9                	in     $0xb9,%al

c040000c <_loader>:
c040000c:	b9 00 e0 40 00       	mov    $0x40e000,%ecx
c0400011:	0f 22 d9             	mov    %ecx,%cr3
c0400014:	0f 20 e1             	mov    %cr4,%ecx
c0400017:	81 c9 10 00 00 00    	or     $0x10,%ecx
c040001d:	0f 22 e1             	mov    %ecx,%cr4
c0400020:	0f 20 c1             	mov    %cr0,%ecx
c0400023:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c0400029:	0f 22 c1             	mov    %ecx,%cr0
c040002c:	8d 0d 34 00 40 c0    	lea    0xc0400034,%ecx
c0400032:	ff e1                	jmp    *%ecx

c0400034 <StartInHigherHalf>:
c0400034:	0f 01 15 38 f0 40 c0 	lgdtl  0xc040f038
c040003b:	66 b8 10 00          	mov    $0x10,%ax
c040003f:	8e d8                	mov    %eax,%ds
c0400041:	8e c0                	mov    %eax,%es
c0400043:	8e d0                	mov    %eax,%ss
c0400045:	8e e0                	mov    %eax,%fs
c0400047:	8e e8                	mov    %eax,%gs
c0400049:	ea 50 00 40 c0 18 00 	ljmp   $0x18,$0xc0400050

c0400050 <FixupStack>:
c0400050:	bc ec 1c 41 c0       	mov    $0xc0411cec,%esp
c0400055:	50                   	push   %eax
c0400056:	53                   	push   %ebx
c0400057:	e8 5c b1 00 00       	call   c040b1b8 <_main>
c040005c:	eb fe                	jmp    c040005c <FixupStack+0xc>
c040005e:	90                   	nop
c040005f:	90                   	nop

c0400060 <x86_start_ap>:
c0400060:	fa                   	cli    
c0400061:	66 b8 00 10          	mov    $0x1000,%ax
c0400065:	08 00                	or     %al,(%eax)
c0400067:	67 0f 01 10          	addr16 lgdtl (%bx,%si)
c040006b:	0f 20 c0             	mov    %cr0,%eax
c040006e:	66 0d 01 00          	or     $0x1,%ax
c0400072:	00 00                	add    %al,(%eax)
c0400074:	0f 22 c0             	mov    %eax,%cr0
c0400077:	66 ea 1f 00 08 00    	ljmpw  $0x8,$0x1f
c040007d:	18 00                	sbb    %al,(%eax)

c040007f <APEnterPMode>:
c040007f:	b9 00 30 08 00       	mov    $0x83000,%ecx
c0400084:	c7 01 83 00 00 00    	movl   $0x83,(%ecx)
c040008a:	0f 22 d9             	mov    %ecx,%cr3
c040008d:	0f 20 e1             	mov    %cr4,%ecx
c0400090:	81 c9 10 00 00 00    	or     $0x10,%ecx
c0400096:	0f 22 e1             	mov    %ecx,%cr4
c0400099:	0f 20 c1             	mov    %cr0,%ecx
c040009c:	81 c9 00 00 00 80    	or     $0x80000000,%ecx
c04000a2:	0f 22 c1             	mov    %ecx,%cr0
c04000a5:	8d 0d ad 00 40 c0    	lea    0xc04000ad,%ecx
c04000ab:	ff e1                	jmp    *%ecx

c04000ad <APMoveToHigherHalf>:
c04000ad:	b8 38 f0 40 c0       	mov    $0xc040f038,%eax
c04000b2:	0f 01 10             	lgdtl  (%eax)
c04000b5:	66 b8 10 00          	mov    $0x10,%ax
c04000b9:	8e d8                	mov    %eax,%ds
c04000bb:	8e c0                	mov    %eax,%es
c04000bd:	8e d0                	mov    %eax,%ss
c04000bf:	8e e0                	mov    %eax,%fs
c04000c1:	8e e8                	mov    %eax,%gs
c04000c3:	ea ca 00 40 c0 18 00 	ljmp   $0x18,$0xc04000ca

c04000ca <APFixupStack>:
c04000ca:	8b 25 3e f0 40 c0    	mov    0xc040f03e,%esp
c04000d0:	e8 63 a8 00 00       	call   c040a938 <_mp_catch_ap>
c04000d5:	eb fe                	jmp    c04000d5 <APFixupStack+0xb>

c04000d7 <isr0>:
c04000d7:	fa                   	cli    
c04000d8:	6a 00                	push   $0x0
c04000da:	6a 00                	push   $0x0
c04000dc:	e9 0a 03 00 00       	jmp    c04003eb <int_enter_knl>

c04000e1 <isr1>:
c04000e1:	fa                   	cli    
c04000e2:	6a 00                	push   $0x0
c04000e4:	6a 01                	push   $0x1
c04000e6:	e9 00 03 00 00       	jmp    c04003eb <int_enter_knl>

c04000eb <isr2>:
c04000eb:	fa                   	cli    
c04000ec:	6a 00                	push   $0x0
c04000ee:	6a 02                	push   $0x2
c04000f0:	e9 f6 02 00 00       	jmp    c04003eb <int_enter_knl>

c04000f5 <isr3>:
c04000f5:	fa                   	cli    
c04000f6:	6a 00                	push   $0x0
c04000f8:	6a 03                	push   $0x3
c04000fa:	e9 ec 02 00 00       	jmp    c04003eb <int_enter_knl>

c04000ff <isr4>:
c04000ff:	fa                   	cli    
c0400100:	6a 00                	push   $0x0
c0400102:	6a 04                	push   $0x4
c0400104:	e9 e2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400109 <isr5>:
c0400109:	fa                   	cli    
c040010a:	6a 00                	push   $0x0
c040010c:	6a 05                	push   $0x5
c040010e:	e9 d8 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400113 <isr6>:
c0400113:	fa                   	cli    
c0400114:	6a 00                	push   $0x0
c0400116:	6a 06                	push   $0x6
c0400118:	e9 ce 02 00 00       	jmp    c04003eb <int_enter_knl>

c040011d <isr7>:
c040011d:	fa                   	cli    
c040011e:	6a 00                	push   $0x0
c0400120:	6a 07                	push   $0x7
c0400122:	e9 c4 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400127 <isr8>:
c0400127:	fa                   	cli    
c0400128:	6a 08                	push   $0x8
c040012a:	e9 bc 02 00 00       	jmp    c04003eb <int_enter_knl>

c040012f <isr9>:
c040012f:	fa                   	cli    
c0400130:	6a 00                	push   $0x0
c0400132:	6a 09                	push   $0x9
c0400134:	e9 b2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400139 <isr10>:
c0400139:	fa                   	cli    
c040013a:	6a 0a                	push   $0xa
c040013c:	e9 aa 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400141 <isr11>:
c0400141:	fa                   	cli    
c0400142:	6a 0b                	push   $0xb
c0400144:	e9 a2 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400149 <isr12>:
c0400149:	fa                   	cli    
c040014a:	6a 0c                	push   $0xc
c040014c:	e9 9a 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400151 <isr13>:
c0400151:	fa                   	cli    
c0400152:	6a 0d                	push   $0xd
c0400154:	e9 92 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400159 <isr14>:
c0400159:	fa                   	cli    
c040015a:	6a 0e                	push   $0xe
c040015c:	e9 8a 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400161 <isr15>:
c0400161:	fa                   	cli    
c0400162:	6a 00                	push   $0x0
c0400164:	6a 0f                	push   $0xf
c0400166:	e9 80 02 00 00       	jmp    c04003eb <int_enter_knl>

c040016b <isr16>:
c040016b:	fa                   	cli    
c040016c:	6a 00                	push   $0x0
c040016e:	6a 10                	push   $0x10
c0400170:	e9 76 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400175 <isr17>:
c0400175:	fa                   	cli    
c0400176:	6a 00                	push   $0x0
c0400178:	6a 11                	push   $0x11
c040017a:	e9 6c 02 00 00       	jmp    c04003eb <int_enter_knl>

c040017f <isr18>:
c040017f:	fa                   	cli    
c0400180:	6a 00                	push   $0x0
c0400182:	6a 12                	push   $0x12
c0400184:	e9 62 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400189 <isr19>:
c0400189:	fa                   	cli    
c040018a:	6a 00                	push   $0x0
c040018c:	6a 13                	push   $0x13
c040018e:	e9 58 02 00 00       	jmp    c04003eb <int_enter_knl>

c0400193 <isr20>:
c0400193:	fa                   	cli    
c0400194:	6a 00                	push   $0x0
c0400196:	6a 14                	push   $0x14
c0400198:	e9 4e 02 00 00       	jmp    c04003eb <int_enter_knl>

c040019d <isr21>:
c040019d:	fa                   	cli    
c040019e:	6a 00                	push   $0x0
c04001a0:	6a 15                	push   $0x15
c04001a2:	e9 44 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001a7 <isr22>:
c04001a7:	fa                   	cli    
c04001a8:	6a 00                	push   $0x0
c04001aa:	6a 16                	push   $0x16
c04001ac:	e9 3a 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001b1 <isr23>:
c04001b1:	fa                   	cli    
c04001b2:	6a 00                	push   $0x0
c04001b4:	6a 17                	push   $0x17
c04001b6:	e9 30 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001bb <isr24>:
c04001bb:	fa                   	cli    
c04001bc:	6a 00                	push   $0x0
c04001be:	6a 18                	push   $0x18
c04001c0:	e9 26 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001c5 <isr25>:
c04001c5:	fa                   	cli    
c04001c6:	6a 00                	push   $0x0
c04001c8:	6a 19                	push   $0x19
c04001ca:	e9 1c 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001cf <isr26>:
c04001cf:	fa                   	cli    
c04001d0:	6a 00                	push   $0x0
c04001d2:	6a 1a                	push   $0x1a
c04001d4:	e9 12 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001d9 <isr27>:
c04001d9:	fa                   	cli    
c04001da:	6a 00                	push   $0x0
c04001dc:	6a 1b                	push   $0x1b
c04001de:	e9 08 02 00 00       	jmp    c04003eb <int_enter_knl>

c04001e3 <isr28>:
c04001e3:	fa                   	cli    
c04001e4:	6a 00                	push   $0x0
c04001e6:	6a 1c                	push   $0x1c
c04001e8:	e9 fe 01 00 00       	jmp    c04003eb <int_enter_knl>

c04001ed <isr29>:
c04001ed:	fa                   	cli    
c04001ee:	6a 00                	push   $0x0
c04001f0:	6a 1d                	push   $0x1d
c04001f2:	e9 f4 01 00 00       	jmp    c04003eb <int_enter_knl>

c04001f7 <isr30>:
c04001f7:	fa                   	cli    
c04001f8:	6a 00                	push   $0x0
c04001fa:	6a 1e                	push   $0x1e
c04001fc:	e9 ea 01 00 00       	jmp    c04003eb <int_enter_knl>

c0400201 <isr31>:
c0400201:	fa                   	cli    
c0400202:	6a 00                	push   $0x0
c0400204:	6a 1f                	push   $0x1f
c0400206:	e9 e0 01 00 00       	jmp    c04003eb <int_enter_knl>

c040020b <irq0>:
c040020b:	fa                   	cli    
c040020c:	6a 00                	push   $0x0
c040020e:	6a 20                	push   $0x20
c0400210:	e9 fd 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400215 <irq1>:
c0400215:	fa                   	cli    
c0400216:	6a 00                	push   $0x0
c0400218:	6a 21                	push   $0x21
c040021a:	e9 f3 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040021f <irq2>:
c040021f:	fa                   	cli    
c0400220:	6a 00                	push   $0x0
c0400222:	6a 22                	push   $0x22
c0400224:	e9 e9 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400229 <irq3>:
c0400229:	fa                   	cli    
c040022a:	6a 00                	push   $0x0
c040022c:	6a 23                	push   $0x23
c040022e:	e9 df 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400233 <irq4>:
c0400233:	fa                   	cli    
c0400234:	6a 00                	push   $0x0
c0400236:	6a 24                	push   $0x24
c0400238:	e9 d5 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040023d <irq5>:
c040023d:	fa                   	cli    
c040023e:	6a 00                	push   $0x0
c0400240:	6a 25                	push   $0x25
c0400242:	e9 cb 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400247 <irq6>:
c0400247:	fa                   	cli    
c0400248:	6a 00                	push   $0x0
c040024a:	6a 26                	push   $0x26
c040024c:	e9 c1 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400251 <irq7>:
c0400251:	fa                   	cli    
c0400252:	6a 00                	push   $0x0
c0400254:	6a 27                	push   $0x27
c0400256:	e9 b7 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040025b <irq8>:
c040025b:	fa                   	cli    
c040025c:	6a 00                	push   $0x0
c040025e:	6a 28                	push   $0x28
c0400260:	e9 ad 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400265 <irq9>:
c0400265:	fa                   	cli    
c0400266:	6a 00                	push   $0x0
c0400268:	6a 29                	push   $0x29
c040026a:	e9 a3 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040026f <irq10>:
c040026f:	fa                   	cli    
c0400270:	6a 00                	push   $0x0
c0400272:	6a 2a                	push   $0x2a
c0400274:	e9 99 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400279 <irq11>:
c0400279:	fa                   	cli    
c040027a:	6a 00                	push   $0x0
c040027c:	6a 2b                	push   $0x2b
c040027e:	e9 8f 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400283 <irq12>:
c0400283:	fa                   	cli    
c0400284:	6a 00                	push   $0x0
c0400286:	6a 2c                	push   $0x2c
c0400288:	e9 85 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040028d <irq13>:
c040028d:	fa                   	cli    
c040028e:	6a 00                	push   $0x0
c0400290:	6a 2d                	push   $0x2d
c0400292:	e9 7b 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400297 <irq14>:
c0400297:	fa                   	cli    
c0400298:	6a 00                	push   $0x0
c040029a:	6a 2e                	push   $0x2e
c040029c:	e9 71 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002a1 <irq15>:
c04002a1:	fa                   	cli    
c04002a2:	6a 00                	push   $0x0
c04002a4:	6a 2f                	push   $0x2f
c04002a6:	e9 67 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002ab <irq16>:
c04002ab:	fa                   	cli    
c04002ac:	6a 00                	push   $0x0
c04002ae:	6a 30                	push   $0x30
c04002b0:	e9 5d 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002b5 <irq17>:
c04002b5:	fa                   	cli    
c04002b6:	6a 00                	push   $0x0
c04002b8:	6a 31                	push   $0x31
c04002ba:	e9 53 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002bf <irq18>:
c04002bf:	fa                   	cli    
c04002c0:	6a 00                	push   $0x0
c04002c2:	6a 32                	push   $0x32
c04002c4:	e9 49 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002c9 <irq19>:
c04002c9:	fa                   	cli    
c04002ca:	6a 00                	push   $0x0
c04002cc:	6a 33                	push   $0x33
c04002ce:	e9 3f 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002d3 <irq20>:
c04002d3:	fa                   	cli    
c04002d4:	6a 00                	push   $0x0
c04002d6:	6a 3f                	push   $0x3f
c04002d8:	e9 35 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002dd <irq21>:
c04002dd:	fa                   	cli    
c04002de:	6a 00                	push   $0x0
c04002e0:	6a 35                	push   $0x35
c04002e2:	e9 2b 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002e7 <irq22>:
c04002e7:	fa                   	cli    
c04002e8:	6a 00                	push   $0x0
c04002ea:	6a 36                	push   $0x36
c04002ec:	e9 21 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002f1 <irq23>:
c04002f1:	fa                   	cli    
c04002f2:	6a 00                	push   $0x0
c04002f4:	6a 40                	push   $0x40
c04002f6:	e9 17 01 00 00       	jmp    c0400412 <irq_enter_knl>

c04002fb <irq24>:
c04002fb:	fa                   	cli    
c04002fc:	6a 00                	push   $0x0
c04002fe:	6a 41                	push   $0x41
c0400300:	e9 0d 01 00 00       	jmp    c0400412 <irq_enter_knl>

c0400305 <irq25>:
c0400305:	fa                   	cli    
c0400306:	6a 00                	push   $0x0
c0400308:	6a 42                	push   $0x42
c040030a:	e9 03 01 00 00       	jmp    c0400412 <irq_enter_knl>

c040030f <irq26>:
c040030f:	fa                   	cli    
c0400310:	6a 00                	push   $0x0
c0400312:	6a 43                	push   $0x43
c0400314:	e9 f9 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400319 <irq27>:
c0400319:	fa                   	cli    
c040031a:	6a 00                	push   $0x0
c040031c:	6a 44                	push   $0x44
c040031e:	e9 ef 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400323 <irq28>:
c0400323:	fa                   	cli    
c0400324:	6a 00                	push   $0x0
c0400326:	6a 45                	push   $0x45
c0400328:	e9 e5 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040032d <irq29>:
c040032d:	fa                   	cli    
c040032e:	6a 00                	push   $0x0
c0400330:	6a 46                	push   $0x46
c0400332:	e9 db 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400337 <irq30>:
c0400337:	fa                   	cli    
c0400338:	6a 00                	push   $0x0
c040033a:	6a 47                	push   $0x47
c040033c:	e9 d1 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400341 <irq31>:
c0400341:	fa                   	cli    
c0400342:	6a 00                	push   $0x0
c0400344:	6a 48                	push   $0x48
c0400346:	e9 c7 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040034b <irq32>:
c040034b:	fa                   	cli    
c040034c:	6a 00                	push   $0x0
c040034e:	6a 49                	push   $0x49
c0400350:	e9 bd 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400355 <irq33>:
c0400355:	fa                   	cli    
c0400356:	6a 00                	push   $0x0
c0400358:	6a 4a                	push   $0x4a
c040035a:	e9 b3 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040035f <irq34>:
c040035f:	fa                   	cli    
c0400360:	6a 00                	push   $0x0
c0400362:	6a 4b                	push   $0x4b
c0400364:	e9 a9 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400369 <irq35>:
c0400369:	fa                   	cli    
c040036a:	6a 00                	push   $0x0
c040036c:	6a 4c                	push   $0x4c
c040036e:	e9 9f 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400373 <irq36>:
c0400373:	fa                   	cli    
c0400374:	6a 00                	push   $0x0
c0400376:	6a 4d                	push   $0x4d
c0400378:	e9 95 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040037d <irq37>:
c040037d:	fa                   	cli    
c040037e:	6a 00                	push   $0x0
c0400380:	6a 4e                	push   $0x4e
c0400382:	e9 8b 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400387 <irq38>:
c0400387:	fa                   	cli    
c0400388:	6a 00                	push   $0x0
c040038a:	6a 4f                	push   $0x4f
c040038c:	e9 81 00 00 00       	jmp    c0400412 <irq_enter_knl>

c0400391 <irq39>:
c0400391:	fa                   	cli    
c0400392:	6a 00                	push   $0x0
c0400394:	6a 50                	push   $0x50
c0400396:	e9 77 00 00 00       	jmp    c0400412 <irq_enter_knl>

c040039b <irq40>:
c040039b:	fa                   	cli    
c040039c:	6a 00                	push   $0x0
c040039e:	6a 51                	push   $0x51
c04003a0:	e9 6d 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003a5 <irq41>:
c04003a5:	fa                   	cli    
c04003a6:	6a 00                	push   $0x0
c04003a8:	6a 52                	push   $0x52
c04003aa:	e9 63 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003af <irq42>:
c04003af:	fa                   	cli    
c04003b0:	6a 00                	push   $0x0
c04003b2:	6a 53                	push   $0x53
c04003b4:	e9 59 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003b9 <irq43>:
c04003b9:	fa                   	cli    
c04003ba:	6a 00                	push   $0x0
c04003bc:	6a 54                	push   $0x54
c04003be:	e9 4f 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003c3 <irq44>:
c04003c3:	fa                   	cli    
c04003c4:	6a 00                	push   $0x0
c04003c6:	6a 55                	push   $0x55
c04003c8:	e9 45 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003cd <irq45>:
c04003cd:	fa                   	cli    
c04003ce:	6a 00                	push   $0x0
c04003d0:	6a 56                	push   $0x56
c04003d2:	e9 3b 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003d7 <irq46>:
c04003d7:	fa                   	cli    
c04003d8:	6a 00                	push   $0x0
c04003da:	6a 57                	push   $0x57
c04003dc:	e9 31 00 00 00       	jmp    c0400412 <irq_enter_knl>

c04003e1 <isr144>:
c04003e1:	fa                   	cli    
c04003e2:	6a 00                	push   $0x0
c04003e4:	6a 90                	push   $0xffffff90
c04003e6:	e9 00 00 00 00       	jmp    c04003eb <int_enter_knl>

c04003eb <int_enter_knl>:
c04003eb:	60                   	pusha  
c04003ec:	8c d8                	mov    %ds,%eax
c04003ee:	50                   	push   %eax
c04003ef:	66 b8 10 00          	mov    $0x10,%ax
c04003f3:	8e d8                	mov    %eax,%ds
c04003f5:	8e c0                	mov    %eax,%es
c04003f7:	8e e0                	mov    %eax,%fs
c04003f9:	8e e8                	mov    %eax,%gs
c04003fb:	e8 94 0a 00 00       	call   c0400e94 <exception_handler>
c0400400:	58                   	pop    %eax
c0400401:	8e d8                	mov    %eax,%ds
c0400403:	8e c0                	mov    %eax,%es
c0400405:	8e e0                	mov    %eax,%fs
c0400407:	8e e8                	mov    %eax,%gs
c0400409:	61                   	popa   
c040040a:	81 c4 08 00 00 00    	add    $0x8,%esp
c0400410:	fb                   	sti    
c0400411:	cf                   	iret   

c0400412 <irq_enter_knl>:
c0400412:	60                   	pusha  
c0400413:	8c d8                	mov    %ds,%eax
c0400415:	50                   	push   %eax
c0400416:	66 b8 10 00          	mov    $0x10,%ax
c040041a:	8e d8                	mov    %eax,%ds
c040041c:	8e c0                	mov    %eax,%es
c040041e:	8e e0                	mov    %eax,%fs
c0400420:	8e e8                	mov    %eax,%gs
c0400422:	e8 a5 12 00 00       	call   c04016cc <irq_handler>
c0400427:	58                   	pop    %eax
c0400428:	8e d8                	mov    %eax,%ds
c040042a:	8e c0                	mov    %eax,%es
c040042c:	8e e0                	mov    %eax,%fs
c040042e:	8e e8                	mov    %eax,%gs
c0400430:	61                   	popa   
c0400431:	81 c4 08 00 00 00    	add    $0x8,%esp
c0400437:	fb                   	sti    
c0400438:	cf                   	iret   

c0400439 <x86_load_idtr>:
c0400439:	8b 44 24 04          	mov    0x4(%esp),%eax
c040043d:	0f 01 18             	lidtl  (%eax)
c0400440:	c3                   	ret    

c0400441 <x86_load_tss>:
c0400441:	66 b8 33 00          	mov    $0x33,%ax
c0400445:	0f 00 d8             	ltr    %ax
c0400448:	c3                   	ret    

c0400449 <x86_load_gdtr>:
c0400449:	8b 44 24 04          	mov    0x4(%esp),%eax
c040044d:	0f 01 10             	lgdtl  (%eax)
c0400450:	c3                   	ret    

c0400451 <x86_test_and_set>:
c0400451:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400455:	8b 54 24 08          	mov    0x8(%esp),%edx
c0400459:	f0 87 02             	lock xchg %eax,(%edx)
c040045c:	c3                   	ret    
c040045d:	00 00                	add    %al,(%eax)
	...

c0400460 <lock_spin>:
// --------------------- atomic locking support ---------------------------

/* lock_spin
   Block until we've acquired the lock */
void lock_spin(volatile unsigned int *spinlock)
{		
c0400460:	83 ec 0c             	sub    $0xc,%esp
#ifndef UNIPROC
	/* x86_test_and_set(1, ptr) will return 0 if we have the lock, or 1
		if someone else has it */
	while(x86_test_and_set(1, spinlock))
c0400463:	eb 0f                	jmp    c0400474 <lock_spin+0x14>
		   this to avoid spamming the bus with locked read/writes */
		while(*spinlock)
			/* hint to newer processors that this is a spin-wait loop or
			   NOP for older processors - branch predictors go nuts over
			   tight loops like this otherwise */
			__asm__ __volatile__("pause");
c0400465:	f3 90                	pause  
c0400467:	eb 01                	jmp    c040046a <lock_spin+0xa>
	while(x86_test_and_set(1, spinlock))
	{
		/* loop with normal reads to wait for the lock to appear to be ready, then
		   we can try it again - the lock will contain 1 while it's in use - we do
		   this to avoid spamming the bus with locked read/writes */
		while(*spinlock)
c0400469:	90                   	nop
c040046a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040046e:	8b 00                	mov    (%eax),%eax
c0400470:	85 c0                	test   %eax,%eax
c0400472:	75 f1                	jne    c0400465 <lock_spin+0x5>
void lock_spin(volatile unsigned int *spinlock)
{		
#ifndef UNIPROC
	/* x86_test_and_set(1, ptr) will return 0 if we have the lock, or 1
		if someone else has it */
	while(x86_test_and_set(1, spinlock))
c0400474:	83 ec 08             	sub    $0x8,%esp
c0400477:	ff 74 24 18          	pushl  0x18(%esp)
c040047b:	6a 01                	push   $0x1
c040047d:	e8 cf ff ff ff       	call   c0400451 <x86_test_and_set>
c0400482:	83 c4 10             	add    $0x10,%esp
c0400485:	85 c0                	test   %eax,%eax
c0400487:	75 e0                	jne    c0400469 <lock_spin+0x9>
			__asm__ __volatile__("pause");
	}

	/* lock acquired, continue.. */
#endif
}
c0400489:	83 c4 0c             	add    $0xc,%esp
c040048c:	c3                   	ret    

c040048d <unlock_spin>:
   Release a lock */
#ifndef UNIPROC
void unlock_spin(volatile unsigned int *spinlock)
{
	/* just slap a zero in it to unlock */
	*spinlock = 0;
c040048d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400491:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c0400497:	c3                   	ret    

c0400498 <lock_gate>:
				  to mark a gate as defunct, causing other threads to fail if
              they try to access it
	<= success or a failure code
*/
kresult lock_gate(rw_gate *gate, unsigned int flags)
{
c0400498:	83 ec 1c             	sub    $0x1c,%esp
#ifndef UNIPROC
	kresult err = success;
c040049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04004a2:	00 
#endif
	
	LOCK_DEBUG("[lock:%i] -> lock_gate(%p, %x) on cpu %i\n", CPU_ID, gate, flags, CPU_ID);
		
	/* sanity checks */
	if(!gate) return e_failure;
c04004a3:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c04004a8:	75 0a                	jne    c04004b4 <lock_gate+0x1c>
c04004aa:	b8 01 00 00 00       	mov    $0x1,%eax
c04004af:	e9 5f 01 00 00       	jmp    c0400613 <lock_gate+0x17b>
	if(!cpu_table) return success; /* only one processor running */
c04004b4:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04004b9:	85 c0                	test   %eax,%eax
c04004bb:	75 0a                	jne    c04004c7 <lock_gate+0x2f>
c04004bd:	b8 00 00 00 00       	mov    $0x0,%eax
c04004c2:	e9 4c 01 00 00       	jmp    c0400613 <lock_gate+0x17b>
	
	while(1)
	{
		lock_spin(&(gate->spinlock));
c04004c7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04004cb:	83 ec 0c             	sub    $0xc,%esp
c04004ce:	50                   	push   %eax
c04004cf:	e8 8c ff ff ff       	call   c0400460 <lock_spin>
c04004d4:	83 c4 10             	add    $0x10,%esp
		
		/* we're in - is the gate claimed? */
		if(gate->owner)
c04004d7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04004db:	8b 40 04             	mov    0x4(%eax),%eax
c04004de:	85 c0                	test   %eax,%eax
c04004e0:	0f 84 c8 00 00 00    	je     c04005ae <lock_gate+0x116>
		{
			/* it's in use - but is it another thread? */
			if(gate->owner != (unsigned int)cpu_table[CPU_ID].current)
c04004e6:	8b 44 24 20          	mov    0x20(%esp),%eax
c04004ea:	8b 50 04             	mov    0x4(%eax),%edx
c04004ed:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c04004f3:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04004f8:	3c 01                	cmp    $0x1,%al
c04004fa:	76 0f                	jbe    c040050b <lock_gate+0x73>
c04004fc:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400501:	8b 00                	mov    (%eax),%eax
c0400503:	c1 e8 18             	shr    $0x18,%eax
c0400506:	c1 e0 06             	shl    $0x6,%eax
c0400509:	eb 0b                	jmp    c0400516 <lock_gate+0x7e>
c040050b:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400510:	0f b6 c0             	movzbl %al,%eax
c0400513:	c1 e0 06             	shl    $0x6,%eax
c0400516:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0400519:	8b 40 04             	mov    0x4(%eax),%eax
c040051c:	39 c2                	cmp    %eax,%edx
c040051e:	74 7b                	je     c040059b <lock_gate+0x103>
			{
				/* another thread has it :( perform checks */
				
				/* this lock is defunct? */
				if(gate->flags & LOCK_SELFDESTRUCT)
c0400520:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400524:	8b 40 08             	mov    0x8(%eax),%eax
c0400527:	83 e0 02             	and    $0x2,%eax
c040052a:	85 c0                	test   %eax,%eax
c040052c:	74 0d                	je     c040053b <lock_gate+0xa3>
				{
					err = e_failure;
c040052e:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0400535:	00 
					goto exit_lock_gate;
c0400536:	e9 c4 00 00 00       	jmp    c04005ff <lock_gate+0x167>
				}
				
				/* if we're not trying to write and the owner isn't
					writing and a writer isn't waiting, then it's safe to progress */
				if(!(flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITEWAITING))
c040053b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040053f:	83 e0 01             	and    $0x1,%eax
c0400542:	85 c0                	test   %eax,%eax
c0400544:	75 20                	jne    c0400566 <lock_gate+0xce>
c0400546:	8b 44 24 20          	mov    0x20(%esp),%eax
c040054a:	8b 40 08             	mov    0x8(%eax),%eax
c040054d:	83 e0 01             	and    $0x1,%eax
c0400550:	85 c0                	test   %eax,%eax
c0400552:	75 12                	jne    c0400566 <lock_gate+0xce>
c0400554:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400558:	8b 40 08             	mov    0x8(%eax),%eax
c040055b:	83 e0 04             	and    $0x4,%eax
c040055e:	85 c0                	test   %eax,%eax
c0400560:	0f 84 98 00 00 00    	je     c04005fe <lock_gate+0x166>
					goto exit_lock_gate;

				/* if we're trying to write then set a write-wait flag.
				   when this flag is set, stop allowing new reading threads.
				   this should prevent writer starvation */
				if(flags & LOCK_WRITE)
c0400566:	8b 44 24 24          	mov    0x24(%esp),%eax
c040056a:	83 e0 01             	and    $0x1,%eax
c040056d:	84 c0                	test   %al,%al
c040056f:	74 13                	je     c0400584 <lock_gate+0xec>
					gate->flags |= LOCK_WRITEWAITING;
c0400571:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400575:	8b 40 08             	mov    0x8(%eax),%eax
c0400578:	89 c2                	mov    %eax,%edx
c040057a:	83 ca 04             	or     $0x4,%edx
c040057d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400581:	89 50 08             	mov    %edx,0x8(%eax)
			gate->flags = flags;
			gate->refcount = 1; /* first in */
			goto exit_lock_gate;
		}
		
		unlock_spin(&(gate->spinlock));
c0400584:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400588:	83 ec 0c             	sub    $0xc,%esp
c040058b:	50                   	push   %eax
c040058c:	e8 fc fe ff ff       	call   c040048d <unlock_spin>
c0400591:	83 c4 10             	add    $0x10,%esp
		
		/* small window of opportunity for the other thread to
		   release the gate :-/ */
		/* hint to newer processors that this is a spin-wait loop or
		 NOP for older processors */
		__asm__ __volatile__("pause");
c0400594:	f3 90                	pause  
			debug_stacktrace();
			err = e_failure;
			goto exit_lock_gate;
		}
#endif
	}
c0400596:	e9 2c ff ff ff       	jmp    c04004c7 <lock_gate+0x2f>
					gate->flags |= LOCK_WRITEWAITING;
			}
			else
			{
				/* if the gate's owned by this thread, then carry on */
				gate->refcount++; /* keep track of the number of times we're entering */
c040059b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040059f:	8b 40 0c             	mov    0xc(%eax),%eax
c04005a2:	8d 50 01             	lea    0x1(%eax),%edx
c04005a5:	8b 44 24 20          	mov    0x20(%esp),%eax
c04005a9:	89 50 0c             	mov    %edx,0xc(%eax)
				goto exit_lock_gate;
c04005ac:	eb 51                	jmp    c04005ff <lock_gate+0x167>
			}
		}
		else
		{
			/* no one owns this gate, so make our mark */
			gate->owner = (unsigned int)cpu_table[CPU_ID].current;
c04005ae:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04005b4:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04005b9:	3c 01                	cmp    $0x1,%al
c04005bb:	76 0f                	jbe    c04005cc <lock_gate+0x134>
c04005bd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04005c2:	8b 00                	mov    (%eax),%eax
c04005c4:	c1 e8 18             	shr    $0x18,%eax
c04005c7:	c1 e0 06             	shl    $0x6,%eax
c04005ca:	eb 0b                	jmp    c04005d7 <lock_gate+0x13f>
c04005cc:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04005d1:	0f b6 c0             	movzbl %al,%eax
c04005d4:	c1 e0 06             	shl    $0x6,%eax
c04005d7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04005da:	8b 40 04             	mov    0x4(%eax),%eax
c04005dd:	89 c2                	mov    %eax,%edx
c04005df:	8b 44 24 20          	mov    0x20(%esp),%eax
c04005e3:	89 50 04             	mov    %edx,0x4(%eax)
			gate->flags = flags;
c04005e6:	8b 44 24 20          	mov    0x20(%esp),%eax
c04005ea:	8b 54 24 24          	mov    0x24(%esp),%edx
c04005ee:	89 50 08             	mov    %edx,0x8(%eax)
			gate->refcount = 1; /* first in */
c04005f1:	8b 44 24 20          	mov    0x20(%esp),%eax
c04005f5:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
			goto exit_lock_gate;
c04005fc:	eb 01                	jmp    c04005ff <lock_gate+0x167>
				}
				
				/* if we're not trying to write and the owner isn't
					writing and a writer isn't waiting, then it's safe to progress */
				if(!(flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITE) && !(gate->flags & LOCK_WRITEWAITING))
					goto exit_lock_gate;
c04005fe:	90                   	nop
#endif
	}

exit_lock_gate:
	/* release the gate so others can inspect it */
	unlock_spin(&(gate->spinlock));
c04005ff:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400603:	83 ec 0c             	sub    $0xc,%esp
c0400606:	50                   	push   %eax
c0400607:	e8 81 fe ff ff       	call   c040048d <unlock_spin>
c040060c:	83 c4 10             	add    $0x10,%esp
	
	LOCK_DEBUG("[lock:%i] locked %p with %x on cpu %i\n", CPU_ID, gate, flags, 0);
	
	return err;
c040060f:	8b 44 24 0c          	mov    0xc(%esp),%eax
#endif
}
c0400613:	83 c4 1c             	add    $0x1c,%esp
c0400616:	c3                   	ret    

c0400617 <unlock_gate>:
              to mark a gate as defunct, causing other threads to fail if
				  they try to access it
   <= success or a failure code
 */
kresult unlock_gate(rw_gate *gate, unsigned int flags)
{	
c0400617:	83 ec 0c             	sub    $0xc,%esp
#ifndef UNIPROC
	LOCK_DEBUG("[lock:%i] unlock_gate(%p, %x) on cpu %i\n", CPU_ID, gate, flags, 0);
	
	/* sanity checks */
	if(!gate) return e_failure;
c040061a:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040061f:	75 0a                	jne    c040062b <unlock_gate+0x14>
c0400621:	b8 01 00 00 00       	mov    $0x1,%eax
c0400626:	e9 a9 00 00 00       	jmp    c04006d4 <unlock_gate+0xbd>
	if(!cpu_table) return success; /* only one processor running */	
c040062b:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0400630:	85 c0                	test   %eax,%eax
c0400632:	75 0a                	jne    c040063e <unlock_gate+0x27>
c0400634:	b8 00 00 00 00       	mov    $0x0,%eax
c0400639:	e9 96 00 00 00       	jmp    c04006d4 <unlock_gate+0xbd>
	
	lock_spin(&(gate->spinlock));
c040063e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400642:	83 ec 0c             	sub    $0xc,%esp
c0400645:	50                   	push   %eax
c0400646:	e8 15 fe ff ff       	call   c0400460 <lock_spin>
c040064b:	83 c4 10             	add    $0x10,%esp
	
	/* if this is our gate then unset details */
	if(gate->owner == (unsigned int)cpu_table[CPU_ID].current)
c040064e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400652:	8b 50 04             	mov    0x4(%eax),%edx
c0400655:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c040065b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400660:	3c 01                	cmp    $0x1,%al
c0400662:	76 0f                	jbe    c0400673 <unlock_gate+0x5c>
c0400664:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400669:	8b 00                	mov    (%eax),%eax
c040066b:	c1 e8 18             	shr    $0x18,%eax
c040066e:	c1 e0 06             	shl    $0x6,%eax
c0400671:	eb 0b                	jmp    c040067e <unlock_gate+0x67>
c0400673:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400678:	0f b6 c0             	movzbl %al,%eax
c040067b:	c1 e0 06             	shl    $0x6,%eax
c040067e:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0400681:	8b 40 04             	mov    0x4(%eax),%eax
c0400684:	39 c2                	cmp    %eax,%edx
c0400686:	75 37                	jne    c04006bf <unlock_gate+0xa8>
	{
		/* decrement thread entry count and release the gate if the
		   owner has completely left, keeping the self-destruct lock
		   in place if required */
		gate->refcount--;
c0400688:	8b 44 24 10          	mov    0x10(%esp),%eax
c040068c:	8b 40 0c             	mov    0xc(%eax),%eax
c040068f:	8d 50 ff             	lea    -0x1(%eax),%edx
c0400692:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400696:	89 50 0c             	mov    %edx,0xc(%eax)
		if(gate->refcount == 0)
c0400699:	8b 44 24 10          	mov    0x10(%esp),%eax
c040069d:	8b 40 0c             	mov    0xc(%eax),%eax
c04006a0:	85 c0                	test   %eax,%eax
c04006a2:	75 1b                	jne    c04006bf <unlock_gate+0xa8>
		{
			gate->owner = 0;
c04006a4:	8b 44 24 10          	mov    0x10(%esp),%eax
c04006a8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			gate->flags = flags & LOCK_SELFDESTRUCT;
c04006af:	8b 44 24 14          	mov    0x14(%esp),%eax
c04006b3:	89 c2                	mov    %eax,%edx
c04006b5:	83 e2 02             	and    $0x2,%edx
c04006b8:	8b 44 24 10          	mov    0x10(%esp),%eax
c04006bc:	89 50 08             	mov    %edx,0x8(%eax)
		}
	}

	/* release the gate so others can inspect it */
	unlock_spin(&(gate->spinlock));
c04006bf:	8b 44 24 10          	mov    0x10(%esp),%eax
c04006c3:	83 ec 0c             	sub    $0xc,%esp
c04006c6:	50                   	push   %eax
c04006c7:	e8 c1 fd ff ff       	call   c040048d <unlock_spin>
c04006cc:	83 c4 10             	add    $0x10,%esp

	LOCK_DEBUG("[lock:%i] <- unlocked %p with %x on cpu %i\n", CPU_ID, gate, flags, 0);
	
	return success;
c04006cf:	b8 00 00 00 00       	mov    $0x0,%eax
#endif
}
c04006d4:	83 c4 0c             	add    $0xc,%esp
c04006d7:	c3                   	ret    

c04006d8 <x86_inportb>:
   Read from an IO port
   => port = port number to read
   <= data recieved
*/
unsigned x86_inportb(unsigned short port)
{
c04006d8:	83 ec 14             	sub    $0x14,%esp
c04006db:	8b 44 24 18          	mov    0x18(%esp),%eax
c04006df:	66 89 04 24          	mov    %ax,(%esp)
   unsigned char ret_val;

   __asm__ __volatile__("inb %1,%0"
c04006e3:	8b 04 24             	mov    (%esp),%eax
c04006e6:	89 c2                	mov    %eax,%edx
c04006e8:	ec                   	in     (%dx),%al
c04006e9:	88 44 24 13          	mov    %al,0x13(%esp)
                        : "=a"(ret_val)
                        : "d"(port));
   return ret_val;
c04006ed:	0f b6 44 24 13       	movzbl 0x13(%esp),%eax
}
c04006f2:	83 c4 14             	add    $0x14,%esp
c04006f5:	c3                   	ret    

c04006f6 <x86_outportb>:
   => port = port number to access
      val = value to write
*/
void x86_outportb(unsigned port, unsigned val)
{
   __asm__ __volatile__("outb %b0,%w1"
c04006f6:	8b 44 24 08          	mov    0x8(%esp),%eax
c04006fa:	8b 54 24 04          	mov    0x4(%esp),%edx
c04006fe:	ee                   	out    %al,(%dx)
                        :
                        : "a"(val), "d"(port));
}
c04006ff:	c3                   	ret    

c0400700 <x86_read_cyclecount>:
// ------------------- performance monitoring support ----------------------
/* x86_read_cyclecount
   <= returns the CPU's current cycle counter value
*/
unsigned long long x86_read_cyclecount(void)
{
c0400700:	57                   	push   %edi
c0400701:	56                   	push   %esi
c0400702:	53                   	push   %ebx
c0400703:	83 ec 10             	sub    $0x10,%esp
	unsigned int high, low;
	
	__asm__ __volatile__("rdtsc"
c0400706:	0f 31                	rdtsc  
c0400708:	89 44 24 0c          	mov    %eax,0xc(%esp)
c040070c:	89 54 24 08          	mov    %edx,0x8(%esp)
								: "=a"(low), "=d"(high));
	
	return ((unsigned long long)low) | (((unsigned long long)high) << 32);
c0400710:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0400714:	bb 00 00 00 00       	mov    $0x0,%ebx
c0400719:	8b 44 24 08          	mov    0x8(%esp),%eax
c040071d:	ba 00 00 00 00       	mov    $0x0,%edx
c0400722:	89 c2                	mov    %eax,%edx
c0400724:	b8 00 00 00 00       	mov    $0x0,%eax
c0400729:	89 ce                	mov    %ecx,%esi
c040072b:	09 c6                	or     %eax,%esi
c040072d:	89 df                	mov    %ebx,%edi
c040072f:	09 d7                	or     %edx,%edi
c0400731:	89 f0                	mov    %esi,%eax
c0400733:	89 fa                	mov    %edi,%edx
}
c0400735:	83 c4 10             	add    $0x10,%esp
c0400738:	5b                   	pop    %ebx
c0400739:	5e                   	pop    %esi
c040073a:	5f                   	pop    %edi
c040073b:	c3                   	ret    

c040073c <x86_cmos_write>:
	Update a byte in the BIOS NVRAM
   => addr = byte number to change
      vlue = new value to write into the CMOS byte
*/
void x86_cmos_write(unsigned char addr, unsigned char value)
{
c040073c:	83 ec 08             	sub    $0x8,%esp
c040073f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0400743:	8b 44 24 10          	mov    0x10(%esp),%eax
c0400747:	88 54 24 04          	mov    %dl,0x4(%esp)
c040074b:	88 04 24             	mov    %al,(%esp)
	x86_outportb(X86_CMOS_ADDR_PORT, addr);
c040074e:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0400753:	50                   	push   %eax
c0400754:	6a 70                	push   $0x70
c0400756:	e8 9b ff ff ff       	call   c04006f6 <x86_outportb>
c040075b:	83 c4 08             	add    $0x8,%esp
	x86_outportb(X86_CMOS_DATA_PORT, value);	
c040075e:	0f b6 04 24          	movzbl (%esp),%eax
c0400762:	50                   	push   %eax
c0400763:	6a 71                	push   $0x71
c0400765:	e8 8c ff ff ff       	call   c04006f6 <x86_outportb>
c040076a:	83 c4 08             	add    $0x8,%esp
}
c040076d:	83 c4 08             	add    $0x8,%esp
c0400770:	c3                   	ret    

c0400771 <x86_timer_init>:

// ------------------------ multitasking support ---------------------------
/* x86_timer_init
   Program the onboard timer to fire freq-times-a-second, or 0 to disable */
void x86_timer_init(unsigned char freq)
{
c0400771:	83 ec 14             	sub    $0x14,%esp
c0400774:	8b 44 24 18          	mov    0x18(%esp),%eax
c0400778:	88 04 24             	mov    %al,(%esp)
	unsigned char lo, hi;
	unsigned int div;
	
	if(!freq)
c040077b:	80 3c 24 00          	cmpb   $0x0,(%esp)
c040077f:	75 0e                	jne    c040078f <x86_timer_init+0x1e>
	{
		/* disable the timer by parking it in interrupt on 
		   terminal count mode. the chip will wait for a
		   value to be loaded into the data register, 
		   which it won't be */
		x86_outportb(0x43, 1 << 4);
c0400781:	6a 10                	push   $0x10
c0400783:	6a 43                	push   $0x43
c0400785:	e8 6c ff ff ff       	call   c04006f6 <x86_outportb>
c040078a:	83 c4 08             	add    $0x8,%esp
		return;
c040078d:	eb 51                	jmp    c04007e0 <x86_timer_init+0x6f>
	}
	
	/* calculate the divisor - see http://wiki.osdev.org/Programmable_Interval_Timer
		for more details */
	div = 1193180 / freq;
c040078f:	0f b6 14 24          	movzbl (%esp),%edx
c0400793:	b8 dc 34 12 00       	mov    $0x1234dc,%eax
c0400798:	89 d1                	mov    %edx,%ecx
c040079a:	99                   	cltd   
c040079b:	f7 f9                	idiv   %ecx
c040079d:	89 44 24 10          	mov    %eax,0x10(%esp)
	
   /* Send byte to command port - generate a square wave pulse
	   interrupt at a set rate (mode 3) on channel 0 (wired to IRQ0) */
   x86_outportb(0x43, 0x36);
c04007a1:	6a 36                	push   $0x36
c04007a3:	6a 43                	push   $0x43
c04007a5:	e8 4c ff ff ff       	call   c04006f6 <x86_outportb>
c04007aa:	83 c4 08             	add    $0x8,%esp
	
   /* divisor has to be sent byte-wise, lo then hi */
   lo = (unsigned char)(div & 0xff);
c04007ad:	8b 44 24 10          	mov    0x10(%esp),%eax
c04007b1:	88 44 24 0e          	mov    %al,0xe(%esp)
   hi = (unsigned char)((div >> 8) & 0xff);
c04007b5:	8b 44 24 10          	mov    0x10(%esp),%eax
c04007b9:	c1 e8 08             	shr    $0x8,%eax
c04007bc:	88 44 24 0f          	mov    %al,0xf(%esp)
	
   /* send the frequency divisor to channel 0 data port */
   x86_outportb(0x40, lo);
c04007c0:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
c04007c5:	50                   	push   %eax
c04007c6:	6a 40                	push   $0x40
c04007c8:	e8 29 ff ff ff       	call   c04006f6 <x86_outportb>
c04007cd:	83 c4 08             	add    $0x8,%esp
   x86_outportb(0x40, hi);
c04007d0:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c04007d5:	50                   	push   %eax
c04007d6:	6a 40                	push   $0x40
c04007d8:	e8 19 ff ff ff       	call   c04006f6 <x86_outportb>
c04007dd:	83 c4 08             	add    $0x8,%esp
}
c04007e0:	83 c4 14             	add    $0x14,%esp
c04007e3:	c3                   	ret    

c04007e4 <x86_load_cr3>:
   Reload the page directory base register with a new physical address
   => ptr = value to move into cr3
*/
void x86_load_cr3(void *ptr)
{
   __asm__ __volatile__("movl %%eax, %%cr3"
c04007e4:	8b 44 24 04          	mov    0x4(%esp),%eax
c04007e8:	0f 22 d8             	mov    %eax,%cr3
                        :
                        : "a"(ptr));
}
c04007eb:	c3                   	ret    

c04007ec <x86_read_cr2>:

/* x86_read_cr2
 <= return the contents of CR2 (faulting address reg)
 */
unsigned int x86_read_cr2(void)
{
c04007ec:	83 ec 10             	sub    $0x10,%esp
	unsigned int ret_val;
   __asm__ __volatile__("movl %%cr2, %%eax"
c04007ef:	0f 20 d0             	mov    %cr2,%eax
c04007f2:	89 44 24 0c          	mov    %eax,0xc(%esp)
                        : "=a" (ret_val));
	return ret_val;
c04007f6:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c04007fa:	83 c4 10             	add    $0x10,%esp
c04007fd:	c3                   	ret    

c04007fe <x86_proc_preinit>:

/* x86_proc_preinit
 Perform any port-specific pre-initialisation before we start the operating system.
 Assuming microkernel virtual memory model is now active */
void x86_proc_preinit(void)
{
c04007fe:	53                   	push   %ebx
c04007ff:	83 ec 08             	sub    $0x8,%esp
	/* grab a copy of the GDT pointers for the boot cpu */
	cpu_table[CPU_ID].gdtptr.size = ((unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT) - 1;
c0400802:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400808:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040080d:	3c 01                	cmp    $0x1,%al
c040080f:	76 0f                	jbe    c0400820 <x86_proc_preinit+0x22>
c0400811:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400816:	8b 00                	mov    (%eax),%eax
c0400818:	c1 e8 18             	shr    $0x18,%eax
c040081b:	c1 e0 06             	shl    $0x6,%eax
c040081e:	eb 0b                	jmp    c040082b <x86_proc_preinit+0x2d>
c0400820:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400825:	0f b6 c0             	movzbl %al,%eax
c0400828:	c1 e0 06             	shl    $0x6,%eax
c040082b:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c040082e:	b8 38 f0 40 c0       	mov    $0xc040f038,%eax
c0400833:	8d 50 ff             	lea    -0x1(%eax),%edx
c0400836:	b8 00 f0 40 c0       	mov    $0xc040f000,%eax
c040083b:	89 d3                	mov    %edx,%ebx
c040083d:	66 29 c3             	sub    %ax,%bx
c0400840:	89 d8                	mov    %ebx,%eax
c0400842:	66 89 41 34          	mov    %ax,0x34(%ecx)
	cpu_table[CPU_ID].gdtptr.ptr = (unsigned int)&KernelGDT;
c0400846:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040084c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400851:	3c 01                	cmp    $0x1,%al
c0400853:	76 0f                	jbe    c0400864 <x86_proc_preinit+0x66>
c0400855:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040085a:	8b 00                	mov    (%eax),%eax
c040085c:	c1 e8 18             	shr    $0x18,%eax
c040085f:	c1 e0 06             	shl    $0x6,%eax
c0400862:	eb 0b                	jmp    c040086f <x86_proc_preinit+0x71>
c0400864:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400869:	0f b6 c0             	movzbl %al,%eax
c040086c:	c1 e0 06             	shl    $0x6,%eax
c040086f:	01 c2                	add    %eax,%edx
c0400871:	b8 00 f0 40 c0       	mov    $0xc040f000,%eax
c0400876:	89 42 36             	mov    %eax,0x36(%edx)
	cpu_table[CPU_ID].tssentry = (gdt_entry *)&TSS_Selector;
c0400879:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040087f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400884:	3c 01                	cmp    $0x1,%al
c0400886:	76 0f                	jbe    c0400897 <x86_proc_preinit+0x99>
c0400888:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040088d:	8b 00                	mov    (%eax),%eax
c040088f:	c1 e8 18             	shr    $0x18,%eax
c0400892:	c1 e0 06             	shl    $0x6,%eax
c0400895:	eb 0b                	jmp    c04008a2 <x86_proc_preinit+0xa4>
c0400897:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040089c:	0f b6 c0             	movzbl %al,%eax
c040089f:	c1 e0 06             	shl    $0x6,%eax
c04008a2:	01 c2                	add    %eax,%edx
c04008a4:	b8 30 f0 40 c0       	mov    $0xc040f030,%eax
c04008a9:	89 42 3c             	mov    %eax,0x3c(%edx)
	
	BOOT_DEBUG(PORT_BANNER "\n[x86] i386 port initialised\n");
c04008ac:	83 ec 0c             	sub    $0xc,%esp
c04008af:	68 5c c2 40 c0       	push   $0xc040c25c
c04008b4:	e8 c9 b5 00 00       	call   c040be82 <debug_printf>
c04008b9:	83 c4 10             	add    $0x10,%esp
}
c04008bc:	83 c4 08             	add    $0x8,%esp
c04008bf:	5b                   	pop    %ebx
c04008c0:	c3                   	ret    

c04008c1 <x86_thread_switch>:
   => now = running thread to stop, or NULL for no thread
      next = thread to reload
      regs = pointer to kernel stack
*/
void x86_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
c04008c1:	83 ec 1c             	sub    $0x1c,%esp
	tss_descr *new_tss = (tss_descr *)&(next->tss);
c04008c4:	8b 44 24 24          	mov    0x24(%esp),%eax
c04008c8:	83 c0 38             	add    $0x38,%eax
c04008cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
	
	/* preserve state of the thread */
	vmm_memcpy(&(now->regs), regs, sizeof(int_registers_block));
c04008cf:	8b 44 24 20          	mov    0x20(%esp),%eax
c04008d3:	05 a0 00 00 00       	add    $0xa0,%eax
c04008d8:	83 ec 04             	sub    $0x4,%esp
c04008db:	6a 40                	push   $0x40
c04008dd:	ff 74 24 30          	pushl  0x30(%esp)
c04008e1:	50                   	push   %eax
c04008e2:	e8 82 41 00 00       	call   c0404a69 <vmm_memcpy>
c04008e7:	83 c4 10             	add    $0x10,%esp
	
	/* load state for new thread */
	vmm_memcpy(regs, &(next->regs), sizeof(int_registers_block));
c04008ea:	8b 44 24 24          	mov    0x24(%esp),%eax
c04008ee:	05 a0 00 00 00       	add    $0xa0,%eax
c04008f3:	83 ec 04             	sub    $0x4,%esp
c04008f6:	6a 40                	push   $0x40
c04008f8:	50                   	push   %eax
c04008f9:	ff 74 24 34          	pushl  0x34(%esp)
c04008fd:	e8 67 41 00 00       	call   c0404a69 <vmm_memcpy>
c0400902:	83 c4 10             	add    $0x10,%esp
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
	
	/* reload page directory if we're switching to a new address space */
	if(now->proc->pgdir != next->proc->pgdir)
c0400905:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400909:	8b 00                	mov    (%eax),%eax
c040090b:	8b 50 20             	mov    0x20(%eax),%edx
c040090e:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400912:	8b 00                	mov    (%eax),%eax
c0400914:	8b 40 20             	mov    0x20(%eax),%eax
c0400917:	39 c2                	cmp    %eax,%edx
c0400919:	74 1a                	je     c0400935 <x86_thread_switch+0x74>
		x86_load_cr3(KERNEL_LOG2PHYS(next->proc->pgdir));
c040091b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040091f:	8b 00                	mov    (%eax),%eax
c0400921:	8b 40 20             	mov    0x20(%eax),%eax
c0400924:	05 00 00 00 40       	add    $0x40000000,%eax
c0400929:	83 ec 0c             	sub    $0xc,%esp
c040092c:	50                   	push   %eax
c040092d:	e8 b2 fe ff ff       	call   c04007e4 <x86_load_cr3>
c0400932:	83 c4 10             	add    $0x10,%esp
	
	/* inform the CPU that things have changed */	
	new_tss->esp0 = next->kstackbase;
c0400935:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400939:	8b 50 30             	mov    0x30(%eax),%edx
c040093c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400940:	89 50 04             	mov    %edx,0x4(%eax)
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, new_tss);
c0400943:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400949:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040094e:	3c 01                	cmp    $0x1,%al
c0400950:	76 0f                	jbe    c0400961 <x86_thread_switch+0xa0>
c0400952:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400957:	8b 00                	mov    (%eax),%eax
c0400959:	c1 e8 18             	shr    $0x18,%eax
c040095c:	c1 e0 06             	shl    $0x6,%eax
c040095f:	eb 0b                	jmp    c040096c <x86_thread_switch+0xab>
c0400961:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400966:	0f b6 c0             	movzbl %al,%eax
c0400969:	c1 e0 06             	shl    $0x6,%eax
c040096c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040096f:	8b 40 3c             	mov    0x3c(%eax),%eax
c0400972:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0400978:	8a 15 1c 1d 41 c0    	mov    0xc0411d1c,%dl
c040097e:	80 fa 01             	cmp    $0x1,%dl
c0400981:	76 0f                	jbe    c0400992 <x86_thread_switch+0xd1>
c0400983:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c0400988:	8b 12                	mov    (%edx),%edx
c040098a:	c1 ea 18             	shr    $0x18,%edx
c040098d:	c1 e2 06             	shl    $0x6,%edx
c0400990:	eb 0c                	jmp    c040099e <x86_thread_switch+0xdd>
c0400992:	8a 15 1e 1d 41 c0    	mov    0xc0411d1e,%dl
c0400998:	0f b6 d2             	movzbl %dl,%edx
c040099b:	c1 e2 06             	shl    $0x6,%edx
c040099e:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c04009a1:	83 c2 34             	add    $0x34,%edx
c04009a4:	83 ec 04             	sub    $0x4,%esp
c04009a7:	ff 74 24 10          	pushl  0x10(%esp)
c04009ab:	50                   	push   %eax
c04009ac:	52                   	push   %edx
c04009ad:	e8 3d 03 00 00       	call   c0400cef <x86_change_tss>
c04009b2:	83 c4 10             	add    $0x10,%esp
}
c04009b5:	83 c4 1c             	add    $0x1c,%esp
c04009b8:	c3                   	ret    

c04009b9 <x86_init_tss>:

/* x86_init_tss
   Configure a thread's TSS for the first (and only) time */
void x86_init_tss(thread *toinit)
{
c04009b9:	83 ec 10             	sub    $0x10,%esp
	tss_descr *tss = (tss_descr *)&(toinit->tss);
c04009bc:	8b 44 24 14          	mov    0x14(%esp),%eax
c04009c0:	83 c0 38             	add    $0x38,%eax
c04009c3:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* initialise the correct registers */
	/* kernel data seg is 0x10, code seg is 0x18, ORd 0x3 for ring-3 access */
	tss->ss  = tss->ds = tss->es = tss->fs = tss->gs = 0x10 | 0x03;
c04009c7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009cb:	c7 40 5c 13 00 00 00 	movl   $0x13,0x5c(%eax)
c04009d2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009d6:	8b 50 5c             	mov    0x5c(%eax),%edx
c04009d9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009dd:	89 50 58             	mov    %edx,0x58(%eax)
c04009e0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009e4:	8b 50 58             	mov    0x58(%eax),%edx
c04009e7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009eb:	89 50 48             	mov    %edx,0x48(%eax)
c04009ee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009f2:	8b 50 48             	mov    0x48(%eax),%edx
c04009f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04009f9:	89 50 54             	mov    %edx,0x54(%eax)
c04009fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400a00:	8b 50 54             	mov    0x54(%eax),%edx
c0400a03:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400a07:	89 50 50             	mov    %edx,0x50(%eax)
	tss->cs  = 0x18 | 0x03;
c0400a0a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400a0e:	c7 40 4c 1b 00 00 00 	movl   $0x1b,0x4c(%eax)
	tss->ss0 = 0x10; /* kernel stack seg (aka data seg) for the IRQ handler */
c0400a15:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400a19:	c7 40 08 10 00 00 00 	movl   $0x10,0x8(%eax)
	tss->esp0 = toinit->kstackbase;
c0400a20:	8b 44 24 14          	mov    0x14(%esp),%eax
c0400a24:	8b 50 30             	mov    0x30(%eax),%edx
c0400a27:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400a2b:	89 50 04             	mov    %edx,0x4(%eax)
}
c0400a2e:	83 c4 10             	add    $0x10,%esp
c0400a31:	c3                   	ret    

c0400a32 <x86_warm_kickstart>:

/* x86_warm_kickstart
   Jumpstart the processor with its top queued thread that's already been put into usermode */
void x86_warm_kickstart(void)
{
c0400a32:	83 ec 1c             	sub    $0x1c,%esp
	thread *next = cpu_table[CPU_ID].queue_head;
c0400a35:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400a3b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400a40:	3c 01                	cmp    $0x1,%al
c0400a42:	76 0f                	jbe    c0400a53 <x86_warm_kickstart+0x21>
c0400a44:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400a49:	8b 00                	mov    (%eax),%eax
c0400a4b:	c1 e8 18             	shr    $0x18,%eax
c0400a4e:	c1 e0 06             	shl    $0x6,%eax
c0400a51:	eb 0b                	jmp    c0400a5e <x86_warm_kickstart+0x2c>
c0400a53:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400a58:	0f b6 c0             	movzbl %al,%eax
c0400a5b:	c1 e0 06             	shl    $0x6,%eax
c0400a5e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400a61:	8b 40 18             	mov    0x18(%eax),%eax
c0400a64:	89 44 24 04          	mov    %eax,0x4(%esp)
	int_registers_block *regs = &(next->regs);
c0400a68:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400a6c:	05 a0 00 00 00       	add    $0xa0,%eax
c0400a71:	89 44 24 08          	mov    %eax,0x8(%esp)
	tss_descr *next_tss = (tss_descr *)&(next->tss);
c0400a75:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400a79:	83 c0 38             	add    $0x38,%eax
c0400a7c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	LOLVL_DEBUG("[x86:%i] warm context: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
			  "      intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			  CPU_ID, regs->ds, regs->edi, regs->esi, regs->ebp, regs->esp, regs->ebx, regs->edx, regs->ecx, regs->eax,
			  regs->intnum, regs->errcode, regs->eip, regs->cs, regs->eflags, regs->useresp, regs->ss);
	/* load page directory */
	x86_load_cr3(KERNEL_LOG2PHYS(next->proc->pgdir));
c0400a80:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400a84:	8b 00                	mov    (%eax),%eax
c0400a86:	8b 40 20             	mov    0x20(%eax),%eax
c0400a89:	05 00 00 00 40       	add    $0x40000000,%eax
c0400a8e:	50                   	push   %eax
c0400a8f:	e8 50 fd ff ff       	call   c04007e4 <x86_load_cr3>
c0400a94:	83 c4 04             	add    $0x4,%esp
	
	/* inform the CPU that things have changed */	
	next_tss->esp0 = next->kstackbase;
c0400a97:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400a9b:	8b 50 30             	mov    0x30(%eax),%edx
c0400a9e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400aa2:	89 50 04             	mov    %edx,0x4(%eax)
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, next_tss);
c0400aa5:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400aab:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400ab0:	3c 01                	cmp    $0x1,%al
c0400ab2:	76 0f                	jbe    c0400ac3 <x86_warm_kickstart+0x91>
c0400ab4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400ab9:	8b 00                	mov    (%eax),%eax
c0400abb:	c1 e8 18             	shr    $0x18,%eax
c0400abe:	c1 e0 06             	shl    $0x6,%eax
c0400ac1:	eb 0b                	jmp    c0400ace <x86_warm_kickstart+0x9c>
c0400ac3:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400ac8:	0f b6 c0             	movzbl %al,%eax
c0400acb:	c1 e0 06             	shl    $0x6,%eax
c0400ace:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400ad1:	8b 40 3c             	mov    0x3c(%eax),%eax
c0400ad4:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0400ada:	8a 15 1c 1d 41 c0    	mov    0xc0411d1c,%dl
c0400ae0:	80 fa 01             	cmp    $0x1,%dl
c0400ae3:	76 0f                	jbe    c0400af4 <x86_warm_kickstart+0xc2>
c0400ae5:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c0400aea:	8b 12                	mov    (%edx),%edx
c0400aec:	c1 ea 18             	shr    $0x18,%edx
c0400aef:	c1 e2 06             	shl    $0x6,%edx
c0400af2:	eb 0c                	jmp    c0400b00 <x86_warm_kickstart+0xce>
c0400af4:	8a 15 1e 1d 41 c0    	mov    0xc0411d1e,%dl
c0400afa:	0f b6 d2             	movzbl %dl,%edx
c0400afd:	c1 e2 06             	shl    $0x6,%edx
c0400b00:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c0400b03:	83 c2 34             	add    $0x34,%edx
c0400b06:	83 ec 04             	sub    $0x4,%esp
c0400b09:	ff 74 24 10          	pushl  0x10(%esp)
c0400b0d:	50                   	push   %eax
c0400b0e:	52                   	push   %edx
c0400b0f:	e8 db 01 00 00       	call   c0400cef <x86_change_tss>
c0400b14:	83 c4 10             	add    $0x10,%esp

	/* now return to the usermode thread - all the registers are stacked up in the 
	   thread's reg block - see int_handler in locore.s for this return code */
	__asm__ __volatile__
c0400b17:	8b 44 24 08          	mov    0x8(%esp),%eax
c0400b1b:	89 c4                	mov    %eax,%esp
c0400b1d:	58                   	pop    %eax
c0400b1e:	8e d8                	mov    %eax,%ds
c0400b20:	8e c0                	mov    %eax,%es
c0400b22:	8e e0                	mov    %eax,%fs
c0400b24:	8e e8                	mov    %eax,%gs
c0400b26:	61                   	popa   
c0400b27:	83 c4 08             	add    $0x8,%esp
c0400b2a:	fb                   	sti    
c0400b2b:	cf                   	iret   
	  addl $8, %%esp; \
	  sti; \
	  iret;" : : "a" (regs));
	
	/* shouldn't reach here.. */
}
c0400b2c:	83 c4 1c             	add    $0x1c,%esp
c0400b2f:	c3                   	ret    

c0400b30 <x86_kickstart>:

/* x86_kickstart
   Jumpstart the processor by executing the top queued thread in usermode  */
void x86_kickstart(void)
{
c0400b30:	53                   	push   %ebx
c0400b31:	83 ec 18             	sub    $0x18,%esp
	thread *torun = cpu_table[CPU_ID].queue_head;
c0400b34:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400b3a:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400b3f:	3c 01                	cmp    $0x1,%al
c0400b41:	76 0f                	jbe    c0400b52 <x86_kickstart+0x22>
c0400b43:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400b48:	8b 00                	mov    (%eax),%eax
c0400b4a:	c1 e8 18             	shr    $0x18,%eax
c0400b4d:	c1 e0 06             	shl    $0x6,%eax
c0400b50:	eb 0b                	jmp    c0400b5d <x86_kickstart+0x2d>
c0400b52:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400b57:	0f b6 c0             	movzbl %al,%eax
c0400b5a:	c1 e0 06             	shl    $0x6,%eax
c0400b5d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400b60:	8b 40 18             	mov    0x18(%eax),%eax
c0400b63:	89 04 24             	mov    %eax,(%esp)
	process *proc;
	tss_descr *tss;
	unsigned int usresp;
	
	if(!torun)
c0400b66:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0400b6a:	75 33                	jne    c0400b9f <x86_kickstart+0x6f>
	{
		KOOPS_DEBUG("[x86:%i] OMGWTF: cannot find a thread to kickstart.\n", CPU_ID);
c0400b6c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400b71:	3c 01                	cmp    $0x1,%al
c0400b73:	76 0c                	jbe    c0400b81 <x86_kickstart+0x51>
c0400b75:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400b7a:	8b 00                	mov    (%eax),%eax
c0400b7c:	c1 e8 18             	shr    $0x18,%eax
c0400b7f:	eb 08                	jmp    c0400b89 <x86_kickstart+0x59>
c0400b81:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400b86:	0f b6 c0             	movzbl %al,%eax
c0400b89:	83 ec 08             	sub    $0x8,%esp
c0400b8c:	50                   	push   %eax
c0400b8d:	68 e8 c3 40 c0       	push   $0xc040c3e8
c0400b92:	e8 eb b2 00 00       	call   c040be82 <debug_printf>
c0400b97:	83 c4 10             	add    $0x10,%esp
		return;
c0400b9a:	e9 4b 01 00 00       	jmp    c0400cea <x86_kickstart+0x1ba>
	}
	
	/* has this thread already entered usermode? */
	if(torun->flags & THREAD_INUSERMODE)
c0400b9f:	8b 04 24             	mov    (%esp),%eax
c0400ba2:	8a 40 0c             	mov    0xc(%eax),%al
c0400ba5:	0f b6 c0             	movzbl %al,%eax
c0400ba8:	83 e0 01             	and    $0x1,%eax
c0400bab:	84 c0                	test   %al,%al
c0400bad:	74 0a                	je     c0400bb9 <x86_kickstart+0x89>
	{
		x86_warm_kickstart();
c0400baf:	e8 7e fe ff ff       	call   c0400a32 <x86_warm_kickstart>
		return;
c0400bb4:	e9 31 01 00 00       	jmp    c0400cea <x86_kickstart+0x1ba>
	}
	
	tss = (tss_descr *)&(torun->tss);
c0400bb9:	8b 04 24             	mov    (%esp),%eax
c0400bbc:	83 c0 38             	add    $0x38,%eax
c0400bbf:	89 44 24 08          	mov    %eax,0x8(%esp)
	proc = torun->proc;
c0400bc3:	8b 04 24             	mov    (%esp),%eax
c0400bc6:	8b 00                	mov    (%eax),%eax
c0400bc8:	89 44 24 04          	mov    %eax,0x4(%esp)
	
	LOLVL_DEBUG("[x86:%i] kickstarting cold thread %i (%p) of process %i (%p) stackbase %x kstackbase %x tss %x at EIP %x\n",
			  CPU_ID, torun->tid, torun, proc->pid, proc, torun->stackbase, torun->kstackbase, &(torun->tss), proc->entry);
	
	/* get page tables loaded, TSS initialised and GDT updated */
	x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c0400bcc:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400bd0:	8b 40 20             	mov    0x20(%eax),%eax
c0400bd3:	05 00 00 00 40       	add    $0x40000000,%eax
c0400bd8:	83 ec 0c             	sub    $0xc,%esp
c0400bdb:	50                   	push   %eax
c0400bdc:	e8 03 fc ff ff       	call   c04007e4 <x86_load_cr3>
c0400be1:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(torun);
c0400be4:	83 ec 0c             	sub    $0xc,%esp
c0400be7:	ff 74 24 0c          	pushl  0xc(%esp)
c0400beb:	e8 c9 fd ff ff       	call   c04009b9 <x86_init_tss>
c0400bf0:	83 c4 10             	add    $0x10,%esp
	x86_change_tss(&(cpu_table[CPU_ID].gdtptr), cpu_table[CPU_ID].tssentry, tss);
c0400bf3:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400bf9:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400bfe:	3c 01                	cmp    $0x1,%al
c0400c00:	76 0f                	jbe    c0400c11 <x86_kickstart+0xe1>
c0400c02:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400c07:	8b 00                	mov    (%eax),%eax
c0400c09:	c1 e8 18             	shr    $0x18,%eax
c0400c0c:	c1 e0 06             	shl    $0x6,%eax
c0400c0f:	eb 0b                	jmp    c0400c1c <x86_kickstart+0xec>
c0400c11:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400c16:	0f b6 c0             	movzbl %al,%eax
c0400c19:	c1 e0 06             	shl    $0x6,%eax
c0400c1c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400c1f:	8b 40 3c             	mov    0x3c(%eax),%eax
c0400c22:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0400c28:	8a 15 1c 1d 41 c0    	mov    0xc0411d1c,%dl
c0400c2e:	80 fa 01             	cmp    $0x1,%dl
c0400c31:	76 0f                	jbe    c0400c42 <x86_kickstart+0x112>
c0400c33:	ba 20 00 e0 fe       	mov    $0xfee00020,%edx
c0400c38:	8b 12                	mov    (%edx),%edx
c0400c3a:	c1 ea 18             	shr    $0x18,%edx
c0400c3d:	c1 e2 06             	shl    $0x6,%edx
c0400c40:	eb 0c                	jmp    c0400c4e <x86_kickstart+0x11e>
c0400c42:	8a 15 1e 1d 41 c0    	mov    0xc0411d1e,%dl
c0400c48:	0f b6 d2             	movzbl %dl,%edx
c0400c4b:	c1 e2 06             	shl    $0x6,%edx
c0400c4e:	8d 14 11             	lea    (%ecx,%edx,1),%edx
c0400c51:	83 c2 34             	add    $0x34,%edx
c0400c54:	83 ec 04             	sub    $0x4,%esp
c0400c57:	ff 74 24 0c          	pushl  0xc(%esp)
c0400c5b:	50                   	push   %eax
c0400c5c:	52                   	push   %edx
c0400c5d:	e8 8d 00 00 00       	call   c0400cef <x86_change_tss>
c0400c62:	83 c4 10             	add    $0x10,%esp
	
	/* keep the scheduler happy */
	torun->state = running;
c0400c65:	8b 04 24             	mov    (%esp),%eax
c0400c68:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	torun->timeslice = SCHED_TIMESLICE;
c0400c6f:	8b 04 24             	mov    (%esp),%eax
c0400c72:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	cpu_table[CPU_ID].current = torun;
c0400c76:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400c7c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400c81:	3c 01                	cmp    $0x1,%al
c0400c83:	76 0f                	jbe    c0400c94 <x86_kickstart+0x164>
c0400c85:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400c8a:	8b 00                	mov    (%eax),%eax
c0400c8c:	c1 e8 18             	shr    $0x18,%eax
c0400c8f:	c1 e0 06             	shl    $0x6,%eax
c0400c92:	eb 0b                	jmp    c0400c9f <x86_kickstart+0x16f>
c0400c94:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400c99:	0f b6 c0             	movzbl %al,%eax
c0400c9c:	c1 e0 06             	shl    $0x6,%eax
c0400c9f:	01 c2                	add    %eax,%edx
c0400ca1:	8b 04 24             	mov    (%esp),%eax
c0400ca4:	89 42 04             	mov    %eax,0x4(%edx)
	torun->flags = THREAD_INUSERMODE; /* well, we're about to be.. */
c0400ca7:	8b 04 24             	mov    (%esp),%eax
c0400caa:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
	
	/* assume we're going to kickstart an i386-elf, so prepare the stack pointer appropriately.
	   the page holding the stack will have been zero'd, so we just move the ptr down a few words
	   to keep the C-front end of the kick-started program from accessing stack that's not there */
	usresp = torun->stackbase - (4 * (sizeof(unsigned int)));
c0400cae:	8b 04 24             	mov    (%esp),%eax
c0400cb1:	8b 40 2c             	mov    0x2c(%eax),%eax
c0400cb4:	83 e8 10             	sub    $0x10,%eax
c0400cb7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	  or $0x200, %%eax; \
	  pushl %%eax; \
	  pushl $0x2B; \
	  movl %1, %%eax; \
	  pushl %%eax; \
	  iret;" : : "b" (usresp), "c" (proc->entry));
c0400cbb:	8b 44 24 04          	mov    0x4(%esp),%eax
c0400cbf:	8b 50 44             	mov    0x44(%eax),%edx
	
	/* x86 voodoo to switch to user mode and enable interrupts (eflags OR 0x200 in the code) */
	/* segment number 0x23 = 0x20 | 0x3 = user data seg 0x20 with ring3 bits set
	                  0x2B = 0x28 | 0x3 = user code seg 0x28 with ring3 bits set */
	/* also: pass new stack pointer and jump to the thread's entry point */
	__asm__ __volatile__
c0400cc2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400cc6:	89 c3                	mov    %eax,%ebx
c0400cc8:	89 d1                	mov    %edx,%ecx
c0400cca:	b8 23 00 00 00       	mov    $0x23,%eax
c0400ccf:	8e d8                	mov    %eax,%ds
c0400cd1:	8e c0                	mov    %eax,%es
c0400cd3:	8e e0                	mov    %eax,%fs
c0400cd5:	8e e8                	mov    %eax,%gs
c0400cd7:	89 d8                	mov    %ebx,%eax
c0400cd9:	6a 23                	push   $0x23
c0400cdb:	50                   	push   %eax
c0400cdc:	9c                   	pushf  
c0400cdd:	58                   	pop    %eax
c0400cde:	0d 00 02 00 00       	or     $0x200,%eax
c0400ce3:	50                   	push   %eax
c0400ce4:	6a 2b                	push   $0x2b
c0400ce6:	89 c8                	mov    %ecx,%eax
c0400ce8:	50                   	push   %eax
c0400ce9:	cf                   	iret   
	  movl %1, %%eax; \
	  pushl %%eax; \
	  iret;" : : "b" (usresp), "c" (proc->entry));
	
	/* execution shouldn't really return to here */
}
c0400cea:	83 c4 18             	add    $0x18,%esp
c0400ced:	5b                   	pop    %ebx
c0400cee:	c3                   	ret    

c0400cef <x86_change_tss>:

/* x86_change_tss
	Update the given tss and point to it from the given gdt entry */
void x86_change_tss(gdtptr_descr *cpugdt, gdt_entry *gdt, tss_descr *tss)
{
c0400cef:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int base = (unsigned int)tss;
c0400cf2:	8b 44 24 28          	mov    0x28(%esp),%eax
c0400cf6:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int limit = sizeof(tss_descr);
c0400cfa:	c7 44 24 0c 68 00 00 	movl   $0x68,0xc(%esp)
c0400d01:	00 
	
	LOLVL_DEBUG("[x86:%i] changing TSS: gdtptr %p (gdt base %x size %i bytes) entry %p tss %p\n",
			  CPU_ID, cpugdt, cpugdt->ptr, cpugdt->size, gdt, tss);
	
	gdt->base_low    = (base & 0xFFFF);
c0400d02:	8b 44 24 08          	mov    0x8(%esp),%eax
c0400d06:	8b 54 24 24          	mov    0x24(%esp),%edx
c0400d0a:	66 89 42 02          	mov    %ax,0x2(%edx)
   gdt->base_middle = (base >> 16) & 0xFF;
c0400d0e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0400d12:	c1 e8 10             	shr    $0x10,%eax
c0400d15:	88 c2                	mov    %al,%dl
c0400d17:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400d1b:	88 50 04             	mov    %dl,0x4(%eax)
   gdt->base_high   = (base >> 24) & 0xFF;
c0400d1e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0400d22:	c1 e8 18             	shr    $0x18,%eax
c0400d25:	88 c2                	mov    %al,%dl
c0400d27:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400d2b:	88 50 07             	mov    %dl,0x7(%eax)
   gdt->limit_low   = (limit & 0xFFFF);
c0400d2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d32:	8b 54 24 24          	mov    0x24(%esp),%edx
c0400d36:	66 89 02             	mov    %ax,(%edx)
   gdt->granularity = ((limit >> 16) & 0x0F) | 0x40; /* 32bit mode */
c0400d39:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0400d3d:	c1 e8 10             	shr    $0x10,%eax
c0400d40:	83 e0 0f             	and    $0xf,%eax
c0400d43:	88 c2                	mov    %al,%dl
c0400d45:	83 ca 40             	or     $0x40,%edx
c0400d48:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400d4c:	88 50 06             	mov    %dl,0x6(%eax)
   gdt->access      = 0x89; /* flags: present, executable, accessed */
c0400d4f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0400d53:	c6 40 05 89          	movb   $0x89,0x5(%eax)

	/* inform the cpu of changes */
	x86_load_gdtr((unsigned int)cpugdt);
c0400d57:	8b 44 24 20          	mov    0x20(%esp),%eax
c0400d5b:	83 ec 0c             	sub    $0xc,%esp
c0400d5e:	50                   	push   %eax
c0400d5f:	e8 e5 f6 ff ff       	call   c0400449 <x86_load_gdtr>
c0400d64:	83 c4 10             	add    $0x10,%esp
	x86_load_tss();
c0400d67:	e8 d5 f6 ff ff       	call   c0400441 <x86_load_tss>
}
c0400d6c:	83 c4 1c             	add    $0x1c,%esp
c0400d6f:	c3                   	ret    

c0400d70 <x86_pic_remap>:
	=> offset1 = vector offset for master PIC
					 vectors on the master become offset1 to offset1 + 7
	=> offset2 = same for slave PIC: offset2 to offset2 + 7
*/
void x86_pic_remap(unsigned int offset1, unsigned int offset2)
{
c0400d70:	83 ec 10             	sub    $0x10,%esp
	unsigned char a1, a2;
	
	/* save the masks */
	a1 = x86_inportb(PIC1_DATA);
c0400d73:	6a 21                	push   $0x21
c0400d75:	e8 5e f9 ff ff       	call   c04006d8 <x86_inportb>
c0400d7a:	83 c4 04             	add    $0x4,%esp
c0400d7d:	88 44 24 0e          	mov    %al,0xe(%esp)
	a2 = x86_inportb(PIC2_DATA);
c0400d81:	68 a1 00 00 00       	push   $0xa1
c0400d86:	e8 4d f9 ff ff       	call   c04006d8 <x86_inportb>
c0400d8b:	83 c4 04             	add    $0x4,%esp
c0400d8e:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	/* reinitialise the chipset */
	x86_outportb(PIC1_COMMAND, ICW1_INIT+ICW1_ICW4);
c0400d92:	6a 11                	push   $0x11
c0400d94:	6a 20                	push   $0x20
c0400d96:	e8 5b f9 ff ff       	call   c04006f6 <x86_outportb>
c0400d9b:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_COMMAND, ICW1_INIT+ICW1_ICW4);
c0400d9e:	6a 11                	push   $0x11
c0400da0:	68 a0 00 00 00       	push   $0xa0
c0400da5:	e8 4c f9 ff ff       	call   c04006f6 <x86_outportb>
c0400daa:	83 c4 08             	add    $0x8,%esp
	/* send the new offsets */
	x86_outportb(PIC1_DATA, offset1);
c0400dad:	ff 74 24 14          	pushl  0x14(%esp)
c0400db1:	6a 21                	push   $0x21
c0400db3:	e8 3e f9 ff ff       	call   c04006f6 <x86_outportb>
c0400db8:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, offset2);
c0400dbb:	ff 74 24 18          	pushl  0x18(%esp)
c0400dbf:	68 a1 00 00 00       	push   $0xa1
c0400dc4:	e8 2d f9 ff ff       	call   c04006f6 <x86_outportb>
c0400dc9:	83 c4 08             	add    $0x8,%esp
	/* complete the reinitialisation sequence */
	x86_outportb(PIC1_DATA, 4);
c0400dcc:	6a 04                	push   $0x4
c0400dce:	6a 21                	push   $0x21
c0400dd0:	e8 21 f9 ff ff       	call   c04006f6 <x86_outportb>
c0400dd5:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, 2);
c0400dd8:	6a 02                	push   $0x2
c0400dda:	68 a1 00 00 00       	push   $0xa1
c0400ddf:	e8 12 f9 ff ff       	call   c04006f6 <x86_outportb>
c0400de4:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC1_DATA, ICW4_8086);
c0400de7:	6a 01                	push   $0x1
c0400de9:	6a 21                	push   $0x21
c0400deb:	e8 06 f9 ff ff       	call   c04006f6 <x86_outportb>
c0400df0:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, ICW4_8086);
c0400df3:	6a 01                	push   $0x1
c0400df5:	68 a1 00 00 00       	push   $0xa1
c0400dfa:	e8 f7 f8 ff ff       	call   c04006f6 <x86_outportb>
c0400dff:	83 c4 08             	add    $0x8,%esp
	
	/* restore saved masks */
	x86_outportb(PIC1_DATA, a1);
c0400e02:	0f b6 44 24 0e       	movzbl 0xe(%esp),%eax
c0400e07:	50                   	push   %eax
c0400e08:	6a 21                	push   $0x21
c0400e0a:	e8 e7 f8 ff ff       	call   c04006f6 <x86_outportb>
c0400e0f:	83 c4 08             	add    $0x8,%esp
	x86_outportb(PIC2_DATA, a2);
c0400e12:	0f b6 44 24 0f       	movzbl 0xf(%esp),%eax
c0400e17:	50                   	push   %eax
c0400e18:	68 a1 00 00 00       	push   $0xa1
c0400e1d:	e8 d4 f8 ff ff       	call   c04006f6 <x86_outportb>
c0400e22:	83 c4 08             	add    $0x8,%esp
}
c0400e25:	83 c4 10             	add    $0x10,%esp
c0400e28:	c3                   	ret    

c0400e29 <x86_pic_reset>:
   Send an end-of-interrupt/reset signal to a PIC
	=> pic = 1 for master
            2 for slave
*/
void x86_pic_reset(unsigned char pic)
{
c0400e29:	83 ec 04             	sub    $0x4,%esp
c0400e2c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0400e30:	88 04 24             	mov    %al,(%esp)
	if(pic == 1)
c0400e33:	80 3c 24 01          	cmpb   $0x1,(%esp)
c0400e37:	75 0e                	jne    c0400e47 <x86_pic_reset+0x1e>
		x86_outportb(PIC1_COMMAND, 0x20);
c0400e39:	6a 20                	push   $0x20
c0400e3b:	6a 20                	push   $0x20
c0400e3d:	e8 b4 f8 ff ff       	call   c04006f6 <x86_outportb>
c0400e42:	83 c4 08             	add    $0x8,%esp
c0400e45:	eb 0f                	jmp    c0400e56 <x86_pic_reset+0x2d>
	else
		x86_outportb(PIC2_COMMAND, 0x20);
c0400e47:	6a 20                	push   $0x20
c0400e49:	68 a0 00 00 00       	push   $0xa0
c0400e4e:	e8 a3 f8 ff ff       	call   c04006f6 <x86_outportb>
c0400e53:	83 c4 08             	add    $0x8,%esp
}
c0400e56:	83 c4 04             	add    $0x4,%esp
c0400e59:	c3                   	ret    

c0400e5a <x86_enable_interrupts>:
 These functions enable and disable interrupt handling.
 Pending interrupts remain pending while handling is
 disabled */
void x86_enable_interrupts(void)
{
	__asm__ __volatile__("sti");
c0400e5a:	fb                   	sti    
}
c0400e5b:	c3                   	ret    

c0400e5c <x86_disable_interrupts>:
void x86_disable_interrupts(void)
{
	__asm__ __volatile__("cli");
c0400e5c:	fa                   	cli    
}
c0400e5d:	c3                   	ret    

c0400e5e <lowlevel_thread_switch>:


/* generic veneers */
void lowlevel_thread_switch(thread *now, thread *next, int_registers_block *regs)
{
c0400e5e:	83 ec 0c             	sub    $0xc,%esp
		while(1);
	}
	unlock_spin(&(now->proc->lock.spinlock));
#endif
	
	x86_thread_switch(now, next, regs);
c0400e61:	83 ec 04             	sub    $0x4,%esp
c0400e64:	ff 74 24 1c          	pushl  0x1c(%esp)
c0400e68:	ff 74 24 1c          	pushl  0x1c(%esp)
c0400e6c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0400e70:	e8 4c fa ff ff       	call   c04008c1 <x86_thread_switch>
c0400e75:	83 c4 10             	add    $0x10,%esp
}
c0400e78:	83 c4 0c             	add    $0xc,%esp
c0400e7b:	c3                   	ret    

c0400e7c <lowlevel_proc_preinit>:

void lowlevel_proc_preinit(void)
{
c0400e7c:	83 ec 0c             	sub    $0xc,%esp
	x86_proc_preinit();
c0400e7f:	e8 7a f9 ff ff       	call   c04007fe <x86_proc_preinit>
}
c0400e84:	83 c4 0c             	add    $0xc,%esp
c0400e87:	c3                   	ret    

c0400e88 <lowlevel_kickstart>:

void lowlevel_kickstart(void)
{
c0400e88:	83 ec 0c             	sub    $0xc,%esp
	x86_kickstart();
c0400e8b:	e8 a0 fc ff ff       	call   c0400b30 <x86_kickstart>
}
c0400e90:	83 c4 0c             	add    $0xc,%esp
c0400e93:	c3                   	ret    

c0400e94 <exception_handler>:
/* exception_handler
	Master exception + SWI handler -- investigate and delegate
	=> regs = pointer to stacked registers
*/
void exception_handler(int_registers_block regs)
{
c0400e94:	83 ec 1c             	sub    $0x1c,%esp
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
c0400e97:	e8 64 f8 ff ff       	call   c0400700 <x86_read_cyclecount>
c0400e9c:	89 44 24 08          	mov    %eax,0x8(%esp)
c0400ea0:	89 54 24 0c          	mov    %edx,0xc(%esp)
	XPT_DEBUG("[xpt:%i] IN: ds %x edi %x esi %x ebp %x esp %x ebx %x edx %x ecx %x eax %x\n"
			    "        intnum %x errcode %x eip %x cs %x eflags %x useresp %x ss %x\n",
			   CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
			   regs.intnum, regs.errcode, regs.eip, regs.cs, regs.eflags, regs.useresp, regs.ss);
	
	regs.intnum &= 0xff; /* just interested in the low byte */
c0400ea4:	8b 44 24 44          	mov    0x44(%esp),%eax
c0400ea8:	25 ff 00 00 00       	and    $0xff,%eax
c0400ead:	89 44 24 44          	mov    %eax,0x44(%esp)
	
	switch(regs.intnum)
c0400eb1:	8b 44 24 44          	mov    0x44(%esp),%eax
c0400eb5:	83 f8 0d             	cmp    $0xd,%eax
c0400eb8:	0f 84 a6 00 00 00    	je     c0400f64 <exception_handler+0xd0>
c0400ebe:	83 f8 0d             	cmp    $0xd,%eax
c0400ec1:	77 0a                	ja     c0400ecd <exception_handler+0x39>
c0400ec3:	83 f8 08             	cmp    $0x8,%eax
c0400ec6:	74 1e                	je     c0400ee6 <exception_handler+0x52>
					break;
			}
			break;
		
		default:
			XPT_DEBUG("[xpt:%i] unhandled exception %x/%x received!\n",
c0400ec8:	e9 37 04 00 00       	jmp    c0401304 <exception_handler+0x470>
			   CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
			   regs.intnum, regs.errcode, regs.eip, regs.cs, regs.eflags, regs.useresp, regs.ss);
	
	regs.intnum &= 0xff; /* just interested in the low byte */
	
	switch(regs.intnum)
c0400ecd:	83 f8 0e             	cmp    $0xe,%eax
c0400ed0:	0f 84 5f 02 00 00    	je     c0401135 <exception_handler+0x2a1>
c0400ed6:	3d 90 00 00 00       	cmp    $0x90,%eax
c0400edb:	0f 84 5e 03 00 00    	je     c040123f <exception_handler+0x3ab>
					break;
			}
			break;
		
		default:
			XPT_DEBUG("[xpt:%i] unhandled exception %x/%x received!\n",
c0400ee1:	e9 1e 04 00 00       	jmp    c0401304 <exception_handler+0x470>
		/* cpu exceptions */
		case INT_DOUBLEF: /* DOUBLE FAULT */
			XPT_DEBUG("[xpt:%i] DOUBLE FAULT: code %i (%x)\n",
						 CPU_ID, regs.errcode, regs.errcode & ((1 << 16) - 1));

			proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c0400ee6:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400eec:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400ef1:	3c 01                	cmp    $0x1,%al
c0400ef3:	76 0f                	jbe    c0400f04 <exception_handler+0x70>
c0400ef5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400efa:	8b 00                	mov    (%eax),%eax
c0400efc:	c1 e8 18             	shr    $0x18,%eax
c0400eff:	c1 e0 06             	shl    $0x6,%eax
c0400f02:	eb 0b                	jmp    c0400f0f <exception_handler+0x7b>
c0400f04:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400f09:	0f b6 c0             	movzbl %al,%eax
c0400f0c:	c1 e0 06             	shl    $0x6,%eax
c0400f0f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400f12:	8b 40 04             	mov    0x4(%eax),%eax
c0400f15:	8b 10                	mov    (%eax),%edx
c0400f17:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0400f1d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400f22:	3c 01                	cmp    $0x1,%al
c0400f24:	76 0f                	jbe    c0400f35 <exception_handler+0xa1>
c0400f26:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400f2b:	8b 00                	mov    (%eax),%eax
c0400f2d:	c1 e8 18             	shr    $0x18,%eax
c0400f30:	c1 e0 06             	shl    $0x6,%eax
c0400f33:	eb 0b                	jmp    c0400f40 <exception_handler+0xac>
c0400f35:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400f3a:	0f b6 c0             	movzbl %al,%eax
c0400f3d:	c1 e0 06             	shl    $0x6,%eax
c0400f40:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0400f43:	8b 40 04             	mov    0x4(%eax),%eax
c0400f46:	8b 00                	mov    (%eax),%eax
c0400f48:	8b 00                	mov    (%eax),%eax
c0400f4a:	83 ec 08             	sub    $0x8,%esp
c0400f4d:	52                   	push   %edx
c0400f4e:	50                   	push   %eax
c0400f4f:	e8 8b 86 00 00       	call   c04095df <proc_kill>
c0400f54:	83 c4 10             	add    $0x10,%esp
			regs.eip = 0; /* force a sched_pick() call */
c0400f57:	c7 44 24 4c 00 00 00 	movl   $0x0,0x4c(%esp)
c0400f5e:	00 
			break;
c0400f5f:	e9 a0 03 00 00       	jmp    c0401304 <exception_handler+0x470>
			
		case INT_GPF: /* GENERAL PROTECTION FAULT */
			if(regs.eip > KERNEL_SPACE_BASE)
c0400f64:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0400f68:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c0400f6d:	76 1a                	jbe    c0400f89 <exception_handler+0xf5>
						    "        ds %x edi %x ebp %x esp %x\n"
						    "        eax %x cs %x eflags %x useresp %x ss %x\n",
							 CPU_ID, regs.errcode, regs.errcode, regs.eip,
							 regs.ds, regs.edi, regs.ebp, regs.esp,
							 regs.eax, regs.cs, regs.eflags, regs.useresp, regs.ss);
				debug_stacktrace();
c0400f6f:	e8 ff a7 00 00       	call   c040b773 <debug_stacktrace>
				debug_panic("unhandled serious fault in the kernel");
c0400f74:	83 ec 0c             	sub    $0xc,%esp
c0400f77:	68 20 c4 40 c0       	push   $0xc040c420
c0400f7c:	e8 19 aa 00 00       	call   c040b99a <debug_panic>
c0400f81:	83 c4 10             	add    $0x10,%esp
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				}
			}
			break;
c0400f84:	e9 7b 03 00 00       	jmp    c0401304 <exception_handler+0x470>
			else
			{
				/* if this process was already trying to handle a GPF then kill it.
				   the kernel's signal code in msg.c will clear this bit when the
				   thread next */
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGBUS))
c0400f89:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400f8f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400f94:	3c 01                	cmp    $0x1,%al
c0400f96:	76 0f                	jbe    c0400fa7 <exception_handler+0x113>
c0400f98:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400f9d:	8b 00                	mov    (%eax),%eax
c0400f9f:	c1 e8 18             	shr    $0x18,%eax
c0400fa2:	c1 e0 06             	shl    $0x6,%eax
c0400fa5:	eb 0b                	jmp    c0400fb2 <exception_handler+0x11e>
c0400fa7:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400fac:	0f b6 c0             	movzbl %al,%eax
c0400faf:	c1 e0 06             	shl    $0x6,%eax
c0400fb2:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400fb5:	8b 40 04             	mov    0x4(%eax),%eax
c0400fb8:	8b 00                	mov    (%eax),%eax
c0400fba:	8b 40 58             	mov    0x58(%eax),%eax
c0400fbd:	25 00 04 00 00       	and    $0x400,%eax
c0400fc2:	85 c0                	test   %eax,%eax
c0400fc4:	74 76                	je     c040103c <exception_handler+0x1a8>
					proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c0400fc6:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0400fcc:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0400fd1:	3c 01                	cmp    $0x1,%al
c0400fd3:	76 0f                	jbe    c0400fe4 <exception_handler+0x150>
c0400fd5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0400fda:	8b 00                	mov    (%eax),%eax
c0400fdc:	c1 e8 18             	shr    $0x18,%eax
c0400fdf:	c1 e0 06             	shl    $0x6,%eax
c0400fe2:	eb 0b                	jmp    c0400fef <exception_handler+0x15b>
c0400fe4:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0400fe9:	0f b6 c0             	movzbl %al,%eax
c0400fec:	c1 e0 06             	shl    $0x6,%eax
c0400fef:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0400ff2:	8b 40 04             	mov    0x4(%eax),%eax
c0400ff5:	8b 10                	mov    (%eax),%edx
c0400ff7:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0400ffd:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401002:	3c 01                	cmp    $0x1,%al
c0401004:	76 0f                	jbe    c0401015 <exception_handler+0x181>
c0401006:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040100b:	8b 00                	mov    (%eax),%eax
c040100d:	c1 e8 18             	shr    $0x18,%eax
c0401010:	c1 e0 06             	shl    $0x6,%eax
c0401013:	eb 0b                	jmp    c0401020 <exception_handler+0x18c>
c0401015:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040101a:	0f b6 c0             	movzbl %al,%eax
c040101d:	c1 e0 06             	shl    $0x6,%eax
c0401020:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0401023:	8b 40 04             	mov    0x4(%eax),%eax
c0401026:	8b 00                	mov    (%eax),%eax
c0401028:	8b 00                	mov    (%eax),%eax
c040102a:	83 ec 08             	sub    $0x8,%esp
c040102d:	52                   	push   %edx
c040102e:	50                   	push   %eax
c040102f:	e8 ab 85 00 00       	call   c04095df <proc_kill>
c0401034:	83 c4 10             	add    $0x10,%esp
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				}
			}
			break;
c0401037:	e9 c8 02 00 00       	jmp    c0401304 <exception_handler+0x470>
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGBUS))
					proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				else
				{
					/* mark this process as attempting to handle the fault */
					cpu_table[CPU_ID].current->proc->signalsinprogress |= (1 << SIGBUS);
c040103c:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401042:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401047:	3c 01                	cmp    $0x1,%al
c0401049:	76 0f                	jbe    c040105a <exception_handler+0x1c6>
c040104b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401050:	8b 00                	mov    (%eax),%eax
c0401052:	c1 e8 18             	shr    $0x18,%eax
c0401055:	c1 e0 06             	shl    $0x6,%eax
c0401058:	eb 0b                	jmp    c0401065 <exception_handler+0x1d1>
c040105a:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040105f:	0f b6 c0             	movzbl %al,%eax
c0401062:	c1 e0 06             	shl    $0x6,%eax
c0401065:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401068:	8b 40 04             	mov    0x4(%eax),%eax
c040106b:	8b 00                	mov    (%eax),%eax
c040106d:	8b 50 58             	mov    0x58(%eax),%edx
c0401070:	80 ce 04             	or     $0x4,%dh
c0401073:	89 50 58             	mov    %edx,0x58(%eax)
					
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
c0401076:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040107c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401081:	3c 01                	cmp    $0x1,%al
c0401083:	76 0f                	jbe    c0401094 <exception_handler+0x200>
c0401085:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040108a:	8b 00                	mov    (%eax),%eax
c040108c:	c1 e8 18             	shr    $0x18,%eax
c040108f:	c1 e0 06             	shl    $0x6,%eax
c0401092:	eb 0b                	jmp    c040109f <exception_handler+0x20b>
c0401094:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401099:	0f b6 c0             	movzbl %al,%eax
c040109c:	c1 e0 06             	shl    $0x6,%eax
c040109f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04010a2:	8b 40 04             	mov    0x4(%eax),%eax
c04010a5:	8b 00                	mov    (%eax),%eax
c04010a7:	83 ec 04             	sub    $0x4,%esp
c04010aa:	6a 00                	push   $0x0
c04010ac:	6a 0a                	push   $0xa
c04010ae:	50                   	push   %eax
c04010af:	e8 88 11 00 00       	call   c040223c <msg_send_signal>
c04010b4:	83 c4 10             	add    $0x10,%esp
c04010b7:	85 c0                	test   %eax,%eax
c04010b9:	0f 84 3e 02 00 00    	je     c04012fd <exception_handler+0x469>
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
c04010bf:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04010c5:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04010ca:	3c 01                	cmp    $0x1,%al
c04010cc:	76 0f                	jbe    c04010dd <exception_handler+0x249>
c04010ce:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04010d3:	8b 00                	mov    (%eax),%eax
c04010d5:	c1 e8 18             	shr    $0x18,%eax
c04010d8:	c1 e0 06             	shl    $0x6,%eax
c04010db:	eb 0b                	jmp    c04010e8 <exception_handler+0x254>
c04010dd:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04010e2:	0f b6 c0             	movzbl %al,%eax
c04010e5:	c1 e0 06             	shl    $0x6,%eax
c04010e8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04010eb:	8b 40 04             	mov    0x4(%eax),%eax
c04010ee:	8b 10                	mov    (%eax),%edx
c04010f0:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c04010f6:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04010fb:	3c 01                	cmp    $0x1,%al
c04010fd:	76 0f                	jbe    c040110e <exception_handler+0x27a>
c04010ff:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401104:	8b 00                	mov    (%eax),%eax
c0401106:	c1 e8 18             	shr    $0x18,%eax
c0401109:	c1 e0 06             	shl    $0x6,%eax
c040110c:	eb 0b                	jmp    c0401119 <exception_handler+0x285>
c040110e:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401113:	0f b6 c0             	movzbl %al,%eax
c0401116:	c1 e0 06             	shl    $0x6,%eax
c0401119:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040111c:	8b 40 04             	mov    0x4(%eax),%eax
c040111f:	8b 00                	mov    (%eax),%eax
c0401121:	8b 00                	mov    (%eax),%eax
c0401123:	83 ec 08             	sub    $0x8,%esp
c0401126:	52                   	push   %edx
c0401127:	50                   	push   %eax
c0401128:	e8 b2 84 00 00       	call   c04095df <proc_kill>
c040112d:	83 c4 10             	add    $0x10,%esp
				}
			}
			break;
c0401130:	e9 cf 01 00 00       	jmp    c0401304 <exception_handler+0x470>
			
		case INT_PF: /* PAGE FAULT */
			if(pg_fault(&regs))
c0401135:	83 ec 0c             	sub    $0xc,%esp
c0401138:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c040113c:	50                   	push   %eax
c040113d:	e8 56 62 00 00       	call   c0407398 <pg_fault>
c0401142:	83 c4 10             	add    $0x10,%esp
c0401145:	85 c0                	test   %eax,%eax
c0401147:	0f 84 b3 01 00 00    	je     c0401300 <exception_handler+0x46c>
			/* something went wrong, so default action is to kill
			   the process - pg_fault() doesn't return if the kernel
			   hits an unhandled page fault */
			{
				/* kill the process if it in the middle of trying to fix-up a page fault */
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGSEGV))
c040114d:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401153:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401158:	3c 01                	cmp    $0x1,%al
c040115a:	76 0f                	jbe    c040116b <exception_handler+0x2d7>
c040115c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401161:	8b 00                	mov    (%eax),%eax
c0401163:	c1 e8 18             	shr    $0x18,%eax
c0401166:	c1 e0 06             	shl    $0x6,%eax
c0401169:	eb 0b                	jmp    c0401176 <exception_handler+0x2e2>
c040116b:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401170:	0f b6 c0             	movzbl %al,%eax
c0401173:	c1 e0 06             	shl    $0x6,%eax
c0401176:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401179:	8b 40 04             	mov    0x4(%eax),%eax
c040117c:	8b 00                	mov    (%eax),%eax
c040117e:	8b 40 58             	mov    0x58(%eax),%eax
c0401181:	25 00 08 00 00       	and    $0x800,%eax
c0401186:	85 c0                	test   %eax,%eax
c0401188:	74 15                	je     c040119f <exception_handler+0x30b>
					syscall_do_exit(&regs);
c040118a:	83 ec 0c             	sub    $0xc,%esp
c040118d:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401191:	50                   	push   %eax
c0401192:	e8 85 08 00 00       	call   c0401a1c <syscall_do_exit>
c0401197:	83 c4 10             	add    $0x10,%esp
						regs.eax = POSIX_GENERIC_FAILURE;
						syscall_do_exit(&regs);
					}
				}
			}
			break;
c040119a:	e9 65 01 00 00       	jmp    c0401304 <exception_handler+0x470>
				if(cpu_table[CPU_ID].current->proc->signalsinprogress & (1 << SIGSEGV))
					syscall_do_exit(&regs);
				else
				{
					/* mark this process as attempting to handle the fault */
					cpu_table[CPU_ID].current->proc->signalsinprogress |= (1 << SIGSEGV);			
c040119f:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04011a5:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04011aa:	3c 01                	cmp    $0x1,%al
c04011ac:	76 0f                	jbe    c04011bd <exception_handler+0x329>
c04011ae:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04011b3:	8b 00                	mov    (%eax),%eax
c04011b5:	c1 e8 18             	shr    $0x18,%eax
c04011b8:	c1 e0 06             	shl    $0x6,%eax
c04011bb:	eb 0b                	jmp    c04011c8 <exception_handler+0x334>
c04011bd:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04011c2:	0f b6 c0             	movzbl %al,%eax
c04011c5:	c1 e0 06             	shl    $0x6,%eax
c04011c8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04011cb:	8b 40 04             	mov    0x4(%eax),%eax
c04011ce:	8b 00                	mov    (%eax),%eax
c04011d0:	8b 50 58             	mov    0x58(%eax),%edx
c04011d3:	80 ce 08             	or     $0x8,%dh
c04011d6:	89 50 58             	mov    %edx,0x58(%eax)
	
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGSEGV, 0))
c04011d9:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04011df:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04011e4:	3c 01                	cmp    $0x1,%al
c04011e6:	76 0f                	jbe    c04011f7 <exception_handler+0x363>
c04011e8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04011ed:	8b 00                	mov    (%eax),%eax
c04011ef:	c1 e8 18             	shr    $0x18,%eax
c04011f2:	c1 e0 06             	shl    $0x6,%eax
c04011f5:	eb 0b                	jmp    c0401202 <exception_handler+0x36e>
c04011f7:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04011fc:	0f b6 c0             	movzbl %al,%eax
c04011ff:	c1 e0 06             	shl    $0x6,%eax
c0401202:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401205:	8b 40 04             	mov    0x4(%eax),%eax
c0401208:	8b 00                	mov    (%eax),%eax
c040120a:	83 ec 04             	sub    $0x4,%esp
c040120d:	6a 00                	push   $0x0
c040120f:	6a 0b                	push   $0xb
c0401211:	50                   	push   %eax
c0401212:	e8 25 10 00 00       	call   c040223c <msg_send_signal>
c0401217:	83 c4 10             	add    $0x10,%esp
c040121a:	85 c0                	test   %eax,%eax
c040121c:	0f 84 e1 00 00 00    	je     c0401303 <exception_handler+0x46f>
					{
						/* something went wrong, so shoot to kill */
						regs.eax = POSIX_GENERIC_FAILURE;
c0401222:	c7 44 24 40 ff ff ff 	movl   $0xffffffff,0x40(%esp)
c0401229:	ff 
						syscall_do_exit(&regs);
c040122a:	83 ec 0c             	sub    $0xc,%esp
c040122d:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401231:	50                   	push   %eax
c0401232:	e8 e5 07 00 00       	call   c0401a1c <syscall_do_exit>
c0401237:	83 c4 10             	add    $0x10,%esp
					}
				}
			}
			break;
c040123a:	e9 c5 00 00 00       	jmp    c0401304 <exception_handler+0x470>

		case INT_KERNEL_SWI: /* KERNEL SYSTEM CALL */
			/* kernel swi number in edx, params in eax-ecx */
			switch(regs.edx)
c040123f:	8b 44 24 38          	mov    0x38(%esp),%eax
c0401243:	83 f8 08             	cmp    $0x8,%eax
c0401246:	0f 87 ae 00 00 00    	ja     c04012fa <exception_handler+0x466>
c040124c:	8b 04 85 48 c4 40 c0 	mov    -0x3fbf3bb8(,%eax,4),%eax
c0401253:	ff e0                	jmp    *%eax
			{
				case SYSCALL_EXIT:
					syscall_do_exit(&regs);
c0401255:	83 ec 0c             	sub    $0xc,%esp
c0401258:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c040125c:	50                   	push   %eax
c040125d:	e8 ba 07 00 00       	call   c0401a1c <syscall_do_exit>
c0401262:	83 c4 10             	add    $0x10,%esp
					break;
c0401265:	e9 91 00 00 00       	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_FORK:
					syscall_do_fork(&regs);
c040126a:	83 ec 0c             	sub    $0xc,%esp
c040126d:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401271:	50                   	push   %eax
c0401272:	e8 30 08 00 00       	call   c0401aa7 <syscall_do_fork>
c0401277:	83 c4 10             	add    $0x10,%esp
					break;
c040127a:	eb 7f                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_KILL:
					syscall_do_kill(&regs);
c040127c:	83 ec 0c             	sub    $0xc,%esp
c040127f:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401283:	50                   	push   %eax
c0401284:	e8 5f 09 00 00       	call   c0401be8 <syscall_do_kill>
c0401289:	83 c4 10             	add    $0x10,%esp
					break;
c040128c:	eb 6d                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_YIELD:
					syscall_do_yield(&regs);
c040128e:	83 ec 0c             	sub    $0xc,%esp
c0401291:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401295:	50                   	push   %eax
c0401296:	e8 03 0a 00 00       	call   c0401c9e <syscall_do_yield>
c040129b:	83 c4 10             	add    $0x10,%esp
					break; /* we will poke the scheduler below */
c040129e:	eb 5b                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_THREAD_EXIT:
					syscall_do_thread_exit(&regs);
c04012a0:	83 ec 0c             	sub    $0xc,%esp
c04012a3:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c04012a7:	50                   	push   %eax
c04012a8:	e8 8a 0a 00 00       	call   c0401d37 <syscall_do_thread_exit>
c04012ad:	83 c4 10             	add    $0x10,%esp
					break;
c04012b0:	eb 49                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_THREAD_FORK:
					syscall_do_thread_fork(&regs);
c04012b2:	83 ec 0c             	sub    $0xc,%esp
c04012b5:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c04012b9:	50                   	push   %eax
c04012ba:	e8 50 0b 00 00       	call   c0401e0f <syscall_do_thread_fork>
c04012bf:	83 c4 10             	add    $0x10,%esp
					break;
c04012c2:	eb 37                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_THREAD_KILL:
					syscall_do_thread_kill(&regs);
c04012c4:	83 ec 0c             	sub    $0xc,%esp
c04012c7:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c04012cb:	50                   	push   %eax
c04012cc:	e8 d1 0c 00 00       	call   c0401fa2 <syscall_do_thread_kill>
c04012d1:	83 c4 10             	add    $0x10,%esp
					break;
c04012d4:	eb 25                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_MSG_SEND:
					syscall_do_msg_send(&regs);
c04012d6:	83 ec 0c             	sub    $0xc,%esp
c04012d9:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c04012dd:	50                   	push   %eax
c04012de:	e8 f2 0d 00 00       	call   c04020d5 <syscall_do_msg_send>
c04012e3:	83 c4 10             	add    $0x10,%esp
					break;
c04012e6:	eb 13                	jmp    c04012fb <exception_handler+0x467>
					
				case SYSCALL_MSG_RECV:
					syscall_do_msg_recv(&regs);
c04012e8:	83 ec 0c             	sub    $0xc,%esp
c04012eb:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c04012ef:	50                   	push   %eax
c04012f0:	e8 c8 0e 00 00       	call   c04021bd <syscall_do_msg_recv>
c04012f5:	83 c4 10             	add    $0x10,%esp
					break;
c04012f8:	eb 01                	jmp    c04012fb <exception_handler+0x467>
		

				default:
					XPT_DEBUG("[xpt:%i] unknown syscall %x by thread %i in process %i\n",
c04012fa:	90                   	nop
								 CPU_ID, regs.edx, cpu_table[CPU_ID].current->tid,
								 cpu_table[CPU_ID].current->proc->pid);
					break;
			}
			break;
c04012fb:	eb 07                	jmp    c0401304 <exception_handler+0x470>
					if(msg_send_signal(cpu_table[CPU_ID].current->proc, SIGBUS, 0))
						/* something went wrong, so default action is shoot to kill */
						proc_kill(cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc);
				}
			}
			break;
c04012fd:	90                   	nop
c04012fe:	eb 04                	jmp    c0401304 <exception_handler+0x470>
						regs.eax = POSIX_GENERIC_FAILURE;
						syscall_do_exit(&regs);
					}
				}
			}
			break;
c0401300:	90                   	nop
c0401301:	eb 01                	jmp    c0401304 <exception_handler+0x470>
c0401303:	90                   	nop
		
	/* there might be a thread of a higher-priority waiting to be run or the current process
	   may not exist - so prod the scheduler to switch to another thread if need be -
	   but only if we're returning to usermode, ie: don't try to switch out if we just
		handled a kernel->kernel exception */
	if(regs.eip < KERNEL_SPACE_BASE)
c0401304:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0401308:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c040130d:	77 10                	ja     c040131f <exception_handler+0x48b>
		sched_pick(&regs);
c040130f:	83 ec 0c             	sub    $0xc,%esp
c0401312:	8d 44 24 2c          	lea    0x2c(%esp),%eax
c0401316:	50                   	push   %eax
c0401317:	e8 1b 1f 00 00       	call   c0403237 <sched_pick>
c040131c:	83 c4 10             	add    $0x10,%esp
				 CPU_ID, regs.ds, regs.edi, regs.esi, regs.ebp, regs.esp, regs.ebx, regs.edx, regs.ecx, regs.eax,
				 regs.intnum, regs.errcode, regs.eip, regs.cs, regs.eflags, regs.useresp, regs.ss);
	
	PERFORMANCE_DEBUG("[xpt:%i] software interrupt %x took about %i cycles to process\n", CPU_ID,
							regs.intnum, (unsigned int)(x86_read_cyclecount() - debug_cycles));
}
c040131f:	83 c4 1c             	add    $0x1c,%esp
c0401322:	c3                   	ret    

c0401323 <exceptions_initialise>:
	laboriously setup the basic exception handlers
	kernel code segment is the 4th entry in the GDT,
	hence (4 - 1) * (sizeof GDT entry) = 3 * 8 = 24 = 0x18
	flags of 0x83 = int gate, 32bit wide, present */
void exceptions_initialise(void)
{
c0401323:	83 ec 0c             	sub    $0xc,%esp
	XPT_DEBUG("[xpt:%i] initialising common x86 exception handlers...\n", CPU_ID);
	
	int_set_gate(0,  (unsigned int)isr0,  0x18, 0x8E, 0);
c0401326:	b8 d7 00 40 c0       	mov    $0xc04000d7,%eax
c040132b:	83 ec 0c             	sub    $0xc,%esp
c040132e:	6a 00                	push   $0x0
c0401330:	68 8e 00 00 00       	push   $0x8e
c0401335:	6a 18                	push   $0x18
c0401337:	50                   	push   %eax
c0401338:	6a 00                	push   $0x0
c040133a:	e8 a9 94 00 00       	call   c040a7e8 <int_set_gate>
c040133f:	83 c4 20             	add    $0x20,%esp
	int_set_gate(1,  (unsigned int)isr1,  0x18, 0x8E, 0);
c0401342:	b8 e1 00 40 c0       	mov    $0xc04000e1,%eax
c0401347:	83 ec 0c             	sub    $0xc,%esp
c040134a:	6a 00                	push   $0x0
c040134c:	68 8e 00 00 00       	push   $0x8e
c0401351:	6a 18                	push   $0x18
c0401353:	50                   	push   %eax
c0401354:	6a 01                	push   $0x1
c0401356:	e8 8d 94 00 00       	call   c040a7e8 <int_set_gate>
c040135b:	83 c4 20             	add    $0x20,%esp
	int_set_gate(2,  (unsigned int)isr2,  0x18, 0x8E, 0);
c040135e:	b8 eb 00 40 c0       	mov    $0xc04000eb,%eax
c0401363:	83 ec 0c             	sub    $0xc,%esp
c0401366:	6a 00                	push   $0x0
c0401368:	68 8e 00 00 00       	push   $0x8e
c040136d:	6a 18                	push   $0x18
c040136f:	50                   	push   %eax
c0401370:	6a 02                	push   $0x2
c0401372:	e8 71 94 00 00       	call   c040a7e8 <int_set_gate>
c0401377:	83 c4 20             	add    $0x20,%esp
	int_set_gate(3,  (unsigned int)isr3,  0x18, 0x8E, 0);
c040137a:	b8 f5 00 40 c0       	mov    $0xc04000f5,%eax
c040137f:	83 ec 0c             	sub    $0xc,%esp
c0401382:	6a 00                	push   $0x0
c0401384:	68 8e 00 00 00       	push   $0x8e
c0401389:	6a 18                	push   $0x18
c040138b:	50                   	push   %eax
c040138c:	6a 03                	push   $0x3
c040138e:	e8 55 94 00 00       	call   c040a7e8 <int_set_gate>
c0401393:	83 c4 20             	add    $0x20,%esp
	int_set_gate(4,  (unsigned int)isr4,  0x18, 0x8E, 0);
c0401396:	b8 ff 00 40 c0       	mov    $0xc04000ff,%eax
c040139b:	83 ec 0c             	sub    $0xc,%esp
c040139e:	6a 00                	push   $0x0
c04013a0:	68 8e 00 00 00       	push   $0x8e
c04013a5:	6a 18                	push   $0x18
c04013a7:	50                   	push   %eax
c04013a8:	6a 04                	push   $0x4
c04013aa:	e8 39 94 00 00       	call   c040a7e8 <int_set_gate>
c04013af:	83 c4 20             	add    $0x20,%esp
	int_set_gate(5,  (unsigned int)isr5,  0x18, 0x8E, 0);
c04013b2:	b8 09 01 40 c0       	mov    $0xc0400109,%eax
c04013b7:	83 ec 0c             	sub    $0xc,%esp
c04013ba:	6a 00                	push   $0x0
c04013bc:	68 8e 00 00 00       	push   $0x8e
c04013c1:	6a 18                	push   $0x18
c04013c3:	50                   	push   %eax
c04013c4:	6a 05                	push   $0x5
c04013c6:	e8 1d 94 00 00       	call   c040a7e8 <int_set_gate>
c04013cb:	83 c4 20             	add    $0x20,%esp
	int_set_gate(6,  (unsigned int)isr6,  0x18, 0x8E, 0);
c04013ce:	b8 13 01 40 c0       	mov    $0xc0400113,%eax
c04013d3:	83 ec 0c             	sub    $0xc,%esp
c04013d6:	6a 00                	push   $0x0
c04013d8:	68 8e 00 00 00       	push   $0x8e
c04013dd:	6a 18                	push   $0x18
c04013df:	50                   	push   %eax
c04013e0:	6a 06                	push   $0x6
c04013e2:	e8 01 94 00 00       	call   c040a7e8 <int_set_gate>
c04013e7:	83 c4 20             	add    $0x20,%esp
	int_set_gate(7,  (unsigned int)isr7,  0x18, 0x8E, 0);
c04013ea:	b8 1d 01 40 c0       	mov    $0xc040011d,%eax
c04013ef:	83 ec 0c             	sub    $0xc,%esp
c04013f2:	6a 00                	push   $0x0
c04013f4:	68 8e 00 00 00       	push   $0x8e
c04013f9:	6a 18                	push   $0x18
c04013fb:	50                   	push   %eax
c04013fc:	6a 07                	push   $0x7
c04013fe:	e8 e5 93 00 00       	call   c040a7e8 <int_set_gate>
c0401403:	83 c4 20             	add    $0x20,%esp
	int_set_gate(8,  (unsigned int)isr8,  0x18, 0x8E, 0);
c0401406:	b8 27 01 40 c0       	mov    $0xc0400127,%eax
c040140b:	83 ec 0c             	sub    $0xc,%esp
c040140e:	6a 00                	push   $0x0
c0401410:	68 8e 00 00 00       	push   $0x8e
c0401415:	6a 18                	push   $0x18
c0401417:	50                   	push   %eax
c0401418:	6a 08                	push   $0x8
c040141a:	e8 c9 93 00 00       	call   c040a7e8 <int_set_gate>
c040141f:	83 c4 20             	add    $0x20,%esp
	int_set_gate(9,  (unsigned int)isr9,  0x18, 0x8E, 0);
c0401422:	b8 2f 01 40 c0       	mov    $0xc040012f,%eax
c0401427:	83 ec 0c             	sub    $0xc,%esp
c040142a:	6a 00                	push   $0x0
c040142c:	68 8e 00 00 00       	push   $0x8e
c0401431:	6a 18                	push   $0x18
c0401433:	50                   	push   %eax
c0401434:	6a 09                	push   $0x9
c0401436:	e8 ad 93 00 00       	call   c040a7e8 <int_set_gate>
c040143b:	83 c4 20             	add    $0x20,%esp
	int_set_gate(10, (unsigned int)isr10, 0x18, 0x8E, 0);
c040143e:	b8 39 01 40 c0       	mov    $0xc0400139,%eax
c0401443:	83 ec 0c             	sub    $0xc,%esp
c0401446:	6a 00                	push   $0x0
c0401448:	68 8e 00 00 00       	push   $0x8e
c040144d:	6a 18                	push   $0x18
c040144f:	50                   	push   %eax
c0401450:	6a 0a                	push   $0xa
c0401452:	e8 91 93 00 00       	call   c040a7e8 <int_set_gate>
c0401457:	83 c4 20             	add    $0x20,%esp
	int_set_gate(11, (unsigned int)isr11, 0x18, 0x8E, 0);
c040145a:	b8 41 01 40 c0       	mov    $0xc0400141,%eax
c040145f:	83 ec 0c             	sub    $0xc,%esp
c0401462:	6a 00                	push   $0x0
c0401464:	68 8e 00 00 00       	push   $0x8e
c0401469:	6a 18                	push   $0x18
c040146b:	50                   	push   %eax
c040146c:	6a 0b                	push   $0xb
c040146e:	e8 75 93 00 00       	call   c040a7e8 <int_set_gate>
c0401473:	83 c4 20             	add    $0x20,%esp
	int_set_gate(12, (unsigned int)isr12, 0x18, 0x8E, 0);
c0401476:	b8 49 01 40 c0       	mov    $0xc0400149,%eax
c040147b:	83 ec 0c             	sub    $0xc,%esp
c040147e:	6a 00                	push   $0x0
c0401480:	68 8e 00 00 00       	push   $0x8e
c0401485:	6a 18                	push   $0x18
c0401487:	50                   	push   %eax
c0401488:	6a 0c                	push   $0xc
c040148a:	e8 59 93 00 00       	call   c040a7e8 <int_set_gate>
c040148f:	83 c4 20             	add    $0x20,%esp
	int_set_gate(13, (unsigned int)isr13, 0x18, 0x8E, 0);
c0401492:	b8 51 01 40 c0       	mov    $0xc0400151,%eax
c0401497:	83 ec 0c             	sub    $0xc,%esp
c040149a:	6a 00                	push   $0x0
c040149c:	68 8e 00 00 00       	push   $0x8e
c04014a1:	6a 18                	push   $0x18
c04014a3:	50                   	push   %eax
c04014a4:	6a 0d                	push   $0xd
c04014a6:	e8 3d 93 00 00       	call   c040a7e8 <int_set_gate>
c04014ab:	83 c4 20             	add    $0x20,%esp
	int_set_gate(14, (unsigned int)isr14, 0x18, 0x8E, 0);
c04014ae:	b8 59 01 40 c0       	mov    $0xc0400159,%eax
c04014b3:	83 ec 0c             	sub    $0xc,%esp
c04014b6:	6a 00                	push   $0x0
c04014b8:	68 8e 00 00 00       	push   $0x8e
c04014bd:	6a 18                	push   $0x18
c04014bf:	50                   	push   %eax
c04014c0:	6a 0e                	push   $0xe
c04014c2:	e8 21 93 00 00       	call   c040a7e8 <int_set_gate>
c04014c7:	83 c4 20             	add    $0x20,%esp
	int_set_gate(15, (unsigned int)isr15, 0x18, 0x8E, 0);
c04014ca:	b8 61 01 40 c0       	mov    $0xc0400161,%eax
c04014cf:	83 ec 0c             	sub    $0xc,%esp
c04014d2:	6a 00                	push   $0x0
c04014d4:	68 8e 00 00 00       	push   $0x8e
c04014d9:	6a 18                	push   $0x18
c04014db:	50                   	push   %eax
c04014dc:	6a 0f                	push   $0xf
c04014de:	e8 05 93 00 00       	call   c040a7e8 <int_set_gate>
c04014e3:	83 c4 20             	add    $0x20,%esp
	int_set_gate(16, (unsigned int)isr16, 0x18, 0x8E, 0);
c04014e6:	b8 6b 01 40 c0       	mov    $0xc040016b,%eax
c04014eb:	83 ec 0c             	sub    $0xc,%esp
c04014ee:	6a 00                	push   $0x0
c04014f0:	68 8e 00 00 00       	push   $0x8e
c04014f5:	6a 18                	push   $0x18
c04014f7:	50                   	push   %eax
c04014f8:	6a 10                	push   $0x10
c04014fa:	e8 e9 92 00 00       	call   c040a7e8 <int_set_gate>
c04014ff:	83 c4 20             	add    $0x20,%esp
	int_set_gate(17, (unsigned int)isr17, 0x18, 0x8E, 0);
c0401502:	b8 75 01 40 c0       	mov    $0xc0400175,%eax
c0401507:	83 ec 0c             	sub    $0xc,%esp
c040150a:	6a 00                	push   $0x0
c040150c:	68 8e 00 00 00       	push   $0x8e
c0401511:	6a 18                	push   $0x18
c0401513:	50                   	push   %eax
c0401514:	6a 11                	push   $0x11
c0401516:	e8 cd 92 00 00       	call   c040a7e8 <int_set_gate>
c040151b:	83 c4 20             	add    $0x20,%esp
	int_set_gate(18, (unsigned int)isr18, 0x18, 0x8E, 0);
c040151e:	b8 7f 01 40 c0       	mov    $0xc040017f,%eax
c0401523:	83 ec 0c             	sub    $0xc,%esp
c0401526:	6a 00                	push   $0x0
c0401528:	68 8e 00 00 00       	push   $0x8e
c040152d:	6a 18                	push   $0x18
c040152f:	50                   	push   %eax
c0401530:	6a 12                	push   $0x12
c0401532:	e8 b1 92 00 00       	call   c040a7e8 <int_set_gate>
c0401537:	83 c4 20             	add    $0x20,%esp
	int_set_gate(19, (unsigned int)isr19, 0x18, 0x8E, 0);
c040153a:	b8 89 01 40 c0       	mov    $0xc0400189,%eax
c040153f:	83 ec 0c             	sub    $0xc,%esp
c0401542:	6a 00                	push   $0x0
c0401544:	68 8e 00 00 00       	push   $0x8e
c0401549:	6a 18                	push   $0x18
c040154b:	50                   	push   %eax
c040154c:	6a 13                	push   $0x13
c040154e:	e8 95 92 00 00       	call   c040a7e8 <int_set_gate>
c0401553:	83 c4 20             	add    $0x20,%esp
	int_set_gate(20, (unsigned int)isr20, 0x18, 0x8E, 0);
c0401556:	b8 93 01 40 c0       	mov    $0xc0400193,%eax
c040155b:	83 ec 0c             	sub    $0xc,%esp
c040155e:	6a 00                	push   $0x0
c0401560:	68 8e 00 00 00       	push   $0x8e
c0401565:	6a 18                	push   $0x18
c0401567:	50                   	push   %eax
c0401568:	6a 14                	push   $0x14
c040156a:	e8 79 92 00 00       	call   c040a7e8 <int_set_gate>
c040156f:	83 c4 20             	add    $0x20,%esp
	int_set_gate(21, (unsigned int)isr21, 0x18, 0x8E, 0);
c0401572:	b8 9d 01 40 c0       	mov    $0xc040019d,%eax
c0401577:	83 ec 0c             	sub    $0xc,%esp
c040157a:	6a 00                	push   $0x0
c040157c:	68 8e 00 00 00       	push   $0x8e
c0401581:	6a 18                	push   $0x18
c0401583:	50                   	push   %eax
c0401584:	6a 15                	push   $0x15
c0401586:	e8 5d 92 00 00       	call   c040a7e8 <int_set_gate>
c040158b:	83 c4 20             	add    $0x20,%esp
	int_set_gate(22, (unsigned int)isr22, 0x18, 0x8E, 0);
c040158e:	b8 a7 01 40 c0       	mov    $0xc04001a7,%eax
c0401593:	83 ec 0c             	sub    $0xc,%esp
c0401596:	6a 00                	push   $0x0
c0401598:	68 8e 00 00 00       	push   $0x8e
c040159d:	6a 18                	push   $0x18
c040159f:	50                   	push   %eax
c04015a0:	6a 16                	push   $0x16
c04015a2:	e8 41 92 00 00       	call   c040a7e8 <int_set_gate>
c04015a7:	83 c4 20             	add    $0x20,%esp
	int_set_gate(23, (unsigned int)isr23, 0x18, 0x8E, 0);
c04015aa:	b8 b1 01 40 c0       	mov    $0xc04001b1,%eax
c04015af:	83 ec 0c             	sub    $0xc,%esp
c04015b2:	6a 00                	push   $0x0
c04015b4:	68 8e 00 00 00       	push   $0x8e
c04015b9:	6a 18                	push   $0x18
c04015bb:	50                   	push   %eax
c04015bc:	6a 17                	push   $0x17
c04015be:	e8 25 92 00 00       	call   c040a7e8 <int_set_gate>
c04015c3:	83 c4 20             	add    $0x20,%esp
	int_set_gate(24, (unsigned int)isr24, 0x18, 0x8E, 0);
c04015c6:	b8 bb 01 40 c0       	mov    $0xc04001bb,%eax
c04015cb:	83 ec 0c             	sub    $0xc,%esp
c04015ce:	6a 00                	push   $0x0
c04015d0:	68 8e 00 00 00       	push   $0x8e
c04015d5:	6a 18                	push   $0x18
c04015d7:	50                   	push   %eax
c04015d8:	6a 18                	push   $0x18
c04015da:	e8 09 92 00 00       	call   c040a7e8 <int_set_gate>
c04015df:	83 c4 20             	add    $0x20,%esp
	int_set_gate(25, (unsigned int)isr25, 0x18, 0x8E, 0);
c04015e2:	b8 c5 01 40 c0       	mov    $0xc04001c5,%eax
c04015e7:	83 ec 0c             	sub    $0xc,%esp
c04015ea:	6a 00                	push   $0x0
c04015ec:	68 8e 00 00 00       	push   $0x8e
c04015f1:	6a 18                	push   $0x18
c04015f3:	50                   	push   %eax
c04015f4:	6a 19                	push   $0x19
c04015f6:	e8 ed 91 00 00       	call   c040a7e8 <int_set_gate>
c04015fb:	83 c4 20             	add    $0x20,%esp
	int_set_gate(26, (unsigned int)isr26, 0x18, 0x8E, 0);
c04015fe:	b8 cf 01 40 c0       	mov    $0xc04001cf,%eax
c0401603:	83 ec 0c             	sub    $0xc,%esp
c0401606:	6a 00                	push   $0x0
c0401608:	68 8e 00 00 00       	push   $0x8e
c040160d:	6a 18                	push   $0x18
c040160f:	50                   	push   %eax
c0401610:	6a 1a                	push   $0x1a
c0401612:	e8 d1 91 00 00       	call   c040a7e8 <int_set_gate>
c0401617:	83 c4 20             	add    $0x20,%esp
	int_set_gate(27, (unsigned int)isr27, 0x18, 0x8E, 0);
c040161a:	b8 d9 01 40 c0       	mov    $0xc04001d9,%eax
c040161f:	83 ec 0c             	sub    $0xc,%esp
c0401622:	6a 00                	push   $0x0
c0401624:	68 8e 00 00 00       	push   $0x8e
c0401629:	6a 18                	push   $0x18
c040162b:	50                   	push   %eax
c040162c:	6a 1b                	push   $0x1b
c040162e:	e8 b5 91 00 00       	call   c040a7e8 <int_set_gate>
c0401633:	83 c4 20             	add    $0x20,%esp
	int_set_gate(28, (unsigned int)isr28, 0x18, 0x8E, 0);
c0401636:	b8 e3 01 40 c0       	mov    $0xc04001e3,%eax
c040163b:	83 ec 0c             	sub    $0xc,%esp
c040163e:	6a 00                	push   $0x0
c0401640:	68 8e 00 00 00       	push   $0x8e
c0401645:	6a 18                	push   $0x18
c0401647:	50                   	push   %eax
c0401648:	6a 1c                	push   $0x1c
c040164a:	e8 99 91 00 00       	call   c040a7e8 <int_set_gate>
c040164f:	83 c4 20             	add    $0x20,%esp
	int_set_gate(29, (unsigned int)isr29, 0x18, 0x8E, 0);
c0401652:	b8 ed 01 40 c0       	mov    $0xc04001ed,%eax
c0401657:	83 ec 0c             	sub    $0xc,%esp
c040165a:	6a 00                	push   $0x0
c040165c:	68 8e 00 00 00       	push   $0x8e
c0401661:	6a 18                	push   $0x18
c0401663:	50                   	push   %eax
c0401664:	6a 1d                	push   $0x1d
c0401666:	e8 7d 91 00 00       	call   c040a7e8 <int_set_gate>
c040166b:	83 c4 20             	add    $0x20,%esp
	int_set_gate(30, (unsigned int)isr30, 0x18, 0x8E, 0);
c040166e:	b8 f7 01 40 c0       	mov    $0xc04001f7,%eax
c0401673:	83 ec 0c             	sub    $0xc,%esp
c0401676:	6a 00                	push   $0x0
c0401678:	68 8e 00 00 00       	push   $0x8e
c040167d:	6a 18                	push   $0x18
c040167f:	50                   	push   %eax
c0401680:	6a 1e                	push   $0x1e
c0401682:	e8 61 91 00 00       	call   c040a7e8 <int_set_gate>
c0401687:	83 c4 20             	add    $0x20,%esp
	int_set_gate(31, (unsigned int)isr31, 0x18, 0x8E, 0);
c040168a:	b8 01 02 40 c0       	mov    $0xc0400201,%eax
c040168f:	83 ec 0c             	sub    $0xc,%esp
c0401692:	6a 00                	push   $0x0
c0401694:	68 8e 00 00 00       	push   $0x8e
c0401699:	6a 18                	push   $0x18
c040169b:	50                   	push   %eax
c040169c:	6a 1f                	push   $0x1f
c040169e:	e8 45 91 00 00       	call   c040a7e8 <int_set_gate>
c04016a3:	83 c4 20             	add    $0x20,%esp
	
	/* define the software interrupt vector - starting from 0x90 (144)
	 OR flags with 0x60 to set DPL to ring3, so userland can call them */
	int_set_gate(INT_KERNEL_SWI, (unsigned int)isr144, 0x18, 0x8E | 0x60, 1); /* reload idt */
c04016a6:	b8 e1 03 40 c0       	mov    $0xc04003e1,%eax
c04016ab:	83 ec 0c             	sub    $0xc,%esp
c04016ae:	6a 01                	push   $0x1
c04016b0:	68 ee 00 00 00       	push   $0xee
c04016b5:	6a 18                	push   $0x18
c04016b7:	50                   	push   %eax
c04016b8:	68 90 00 00 00       	push   $0x90
c04016bd:	e8 26 91 00 00       	call   c040a7e8 <int_set_gate>
c04016c2:	83 c4 20             	add    $0x20,%esp
}
c04016c5:	83 c4 0c             	add    $0xc,%esp
c04016c8:	c3                   	ret    
c04016c9:	00 00                	add    %al,(%eax)
	...

c04016cc <irq_handler>:
/* irq_handler
 Master interrupt handler -- investigate and delegate
 => r = pointer to stacked registers
 */
void irq_handler(int_registers_block *regs)
{	
c04016cc:	83 ec 1c             	sub    $0x1c,%esp
#ifdef PERFORMANCE_DEBUG
	unsigned long long debug_cycles = x86_read_cyclecount();
c04016cf:	e8 2c f0 ff ff       	call   c0400700 <x86_read_cyclecount>
c04016d4:	89 04 24             	mov    %eax,(%esp)
c04016d7:	89 54 24 04          	mov    %edx,0x4(%esp)
#endif

	irq_driver_entry *driver;
	
	/* make sure we only consider the low byte, which contains the irq number */
	regs->intnum = regs->intnum % IRQ_MAX_LINES;
c04016db:	8b 44 24 20          	mov    0x20(%esp),%eax
c04016df:	8b 40 24             	mov    0x24(%eax),%eax
c04016e2:	0f b6 d0             	movzbl %al,%edx
c04016e5:	8b 44 24 20          	mov    0x20(%esp),%eax
c04016e9:	89 50 24             	mov    %edx,0x24(%eax)

	IRQ_DEBUG("[irq:%i] processing IRQ %i (registers at %p)\n", CPU_ID, regs->intnum, regs);

	lock_gate(&irq_lock, LOCK_READ);
c04016ec:	83 ec 08             	sub    $0x8,%esp
c04016ef:	6a 00                	push   $0x0
c04016f1:	68 60 f4 40 c0       	push   $0xc040f460
c04016f6:	e8 9d ed ff ff       	call   c0400498 <lock_gate>
c04016fb:	83 c4 10             	add    $0x10,%esp
	
	/* find the registered drivers */
	driver = irq_drivers[regs->intnum];
c04016fe:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401702:	8b 40 24             	mov    0x24(%eax),%eax
c0401705:	8b 04 85 60 f0 40 c0 	mov    -0x3fbf0fa0(,%eax,4),%eax
c040170c:	89 44 24 08          	mov    %eax,0x8(%esp)
	while(driver)
c0401710:	eb 75                	jmp    c0401787 <irq_handler+0xbb>
	{
		switch(driver->flags & IRQ_DRIVER_TYPEMASK)
c0401712:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401716:	8b 00                	mov    (%eax),%eax
c0401718:	83 e0 03             	and    $0x3,%eax
c040171b:	83 f8 01             	cmp    $0x1,%eax
c040171e:	74 25                	je     c0401745 <irq_handler+0x79>
c0401720:	83 f8 02             	cmp    $0x2,%eax
c0401723:	75 57                	jne    c040177c <irq_handler+0xb0>
		{
			case IRQ_DRIVER_FUNCTION:
				/* call the kernel function */
				(driver->func)(regs->intnum, regs);
c0401725:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401729:	8b 50 08             	mov    0x8(%eax),%edx
c040172c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401730:	8b 40 24             	mov    0x24(%eax),%eax
c0401733:	0f b6 c0             	movzbl %al,%eax
c0401736:	83 ec 08             	sub    $0x8,%esp
c0401739:	ff 74 24 28          	pushl  0x28(%esp)
c040173d:	50                   	push   %eax
c040173e:	ff d2                	call   *%edx
c0401740:	83 c4 10             	add    $0x10,%esp
				break;
c0401743:	eb 37                	jmp    c040177c <irq_handler+0xb0>
				
			case IRQ_DRIVER_PROCESS:
			{
				/* poke the driver process */
				process *target = proc_find_proc(driver->pid);
c0401745:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401749:	8b 40 04             	mov    0x4(%eax),%eax
c040174c:	83 ec 0c             	sub    $0xc,%esp
c040174f:	50                   	push   %eax
c0401750:	e8 b3 76 00 00       	call   c0408e08 <proc_find_proc>
c0401755:	83 c4 10             	add    $0x10,%esp
c0401758:	89 44 24 0c          	mov    %eax,0xc(%esp)
				if(target)
c040175c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0401761:	74 19                	je     c040177c <irq_handler+0xb0>
					msg_send_signal(target, SIGXIRQ, regs->intnum);
c0401763:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401767:	8b 40 24             	mov    0x24(%eax),%eax
c040176a:	83 ec 04             	sub    $0x4,%esp
c040176d:	50                   	push   %eax
c040176e:	6a 25                	push   $0x25
c0401770:	ff 74 24 18          	pushl  0x18(%esp)
c0401774:	e8 c3 0a 00 00       	call   c040223c <msg_send_signal>
c0401779:	83 c4 10             	add    $0x10,%esp
			}
			break;
		}
		
		driver = driver->next;
c040177c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401780:	8b 40 10             	mov    0x10(%eax),%eax
c0401783:	89 44 24 08          	mov    %eax,0x8(%esp)

	lock_gate(&irq_lock, LOCK_READ);
	
	/* find the registered drivers */
	driver = irq_drivers[regs->intnum];
	while(driver)
c0401787:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c040178c:	75 84                	jne    c0401712 <irq_handler+0x46>
		}
		
		driver = driver->next;
	}
		
	unlock_gate(&irq_lock, LOCK_READ);
c040178e:	83 ec 08             	sub    $0x8,%esp
c0401791:	6a 00                	push   $0x0
c0401793:	68 60 f4 40 c0       	push   $0xc040f460
c0401798:	e8 7a ee ff ff       	call   c0400617 <unlock_gate>
c040179d:	83 c4 10             	add    $0x10,%esp
	
	PERFORMANCE_DEBUG("[irq:%i] hardware interrupt %x took about %i cycles to process\n",
							CPU_ID, regs->intnum, (unsigned int)(x86_read_cyclecount() - debug_cycles));
}
c04017a0:	83 c4 1c             	add    $0x1c,%esp
c04017a3:	c3                   	ret    

c04017a4 <irq_find_driver>:
   <= pointer to structure or NULL for no match
*/
irq_driver_entry *irq_find_driver(unsigned int irq_num, unsigned int type,
											 unsigned int pid,
											 kresult (*func)(unsigned char intnum, int_registers_block *regs))
{
c04017a4:	83 ec 1c             	sub    $0x1c,%esp
	irq_driver_entry *search;
	
	/* bail out on a wild irq_num */
	if(irq_num >= IRQ_MAX_LINES) return NULL;
c04017a7:	81 7c 24 20 ff 00 00 	cmpl   $0xff,0x20(%esp)
c04017ae:	00 
c04017af:	76 0a                	jbe    c04017bb <irq_find_driver+0x17>
c04017b1:	b8 00 00 00 00       	mov    $0x0,%eax
c04017b6:	e9 80 00 00 00       	jmp    c040183b <irq_find_driver+0x97>
	
	/* protect the data structure during read */
	lock_gate(&irq_lock, LOCK_READ);
c04017bb:	83 ec 08             	sub    $0x8,%esp
c04017be:	6a 00                	push   $0x0
c04017c0:	68 60 f4 40 c0       	push   $0xc040f460
c04017c5:	e8 ce ec ff ff       	call   c0400498 <lock_gate>
c04017ca:	83 c4 10             	add    $0x10,%esp
	
	search = irq_drivers[irq_num];
c04017cd:	8b 44 24 20          	mov    0x20(%esp),%eax
c04017d1:	8b 04 85 60 f0 40 c0 	mov    -0x3fbf0fa0(,%eax,4),%eax
c04017d8:	89 44 24 0c          	mov    %eax,0xc(%esp)
	while(search)
c04017dc:	eb 3d                	jmp    c040181b <irq_find_driver+0x77>
	{
		switch(search->flags & IRQ_DRIVER_TYPEMASK)
c04017de:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04017e2:	8b 00                	mov    (%eax),%eax
c04017e4:	83 e0 03             	and    $0x3,%eax
c04017e7:	83 f8 01             	cmp    $0x1,%eax
c04017ea:	74 14                	je     c0401800 <irq_find_driver+0x5c>
c04017ec:	83 f8 02             	cmp    $0x2,%eax
c04017ef:	75 1f                	jne    c0401810 <irq_find_driver+0x6c>
		{
			case IRQ_DRIVER_FUNCTION:
				if(search->func == func) goto irq_driver_entry_exit;
c04017f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04017f5:	8b 40 08             	mov    0x8(%eax),%eax
c04017f8:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
c04017fc:	75 11                	jne    c040180f <irq_find_driver+0x6b>
c04017fe:	eb 25                	jmp    c0401825 <irq_find_driver+0x81>
				break;
				
			case IRQ_DRIVER_PROCESS:
				if(search->pid == pid) goto irq_driver_entry_exit;
c0401800:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401804:	8b 40 04             	mov    0x4(%eax),%eax
c0401807:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040180b:	74 17                	je     c0401824 <irq_find_driver+0x80>
c040180d:	eb 01                	jmp    c0401810 <irq_find_driver+0x6c>
	{
		switch(search->flags & IRQ_DRIVER_TYPEMASK)
		{
			case IRQ_DRIVER_FUNCTION:
				if(search->func == func) goto irq_driver_entry_exit;
				break;
c040180f:	90                   	nop
				if(search->pid == pid) goto irq_driver_entry_exit;
				break;
		}
		
		/* the search continues */
		search = search->next;
c0401810:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401814:	8b 40 10             	mov    0x10(%eax),%eax
c0401817:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* protect the data structure during read */
	lock_gate(&irq_lock, LOCK_READ);
	
	search = irq_drivers[irq_num];
	while(search)
c040181b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0401820:	75 bc                	jne    c04017de <irq_find_driver+0x3a>
c0401822:	eb 01                	jmp    c0401825 <irq_find_driver+0x81>
			case IRQ_DRIVER_FUNCTION:
				if(search->func == func) goto irq_driver_entry_exit;
				break;
				
			case IRQ_DRIVER_PROCESS:
				if(search->pid == pid) goto irq_driver_entry_exit;
c0401824:	90                   	nop
		/* the search continues */
		search = search->next;
	}
	
irq_driver_entry_exit:
	unlock_gate(&irq_lock, LOCK_READ);
c0401825:	83 ec 08             	sub    $0x8,%esp
c0401828:	6a 00                	push   $0x0
c040182a:	68 60 f4 40 c0       	push   $0xc040f460
c040182f:	e8 e3 ed ff ff       	call   c0400617 <unlock_gate>
c0401834:	83 c4 10             	add    $0x10,%esp
	return search;
c0401837:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040183b:	83 c4 1c             	add    $0x1c,%esp
c040183e:	c3                   	ret    

c040183f <irq_deregister_driver>:
	 <= 0 for success or else an error code 
*/
kresult irq_deregister_driver(unsigned int irq_num, unsigned int type,
										unsigned int pid, 
										kresult (*func)(unsigned char intnum, int_registers_block *regs))
{
c040183f:	83 ec 1c             	sub    $0x1c,%esp
	irq_driver_entry *victim;
	
	/* bail out on a wild irq_num */
	if(irq_num >= IRQ_MAX_LINES) return e_bad_params;
c0401842:	81 7c 24 20 ff 00 00 	cmpl   $0xff,0x20(%esp)
c0401849:	00 
c040184a:	76 0a                	jbe    c0401856 <irq_deregister_driver+0x17>
c040184c:	b8 15 00 00 00       	mov    $0x15,%eax
c0401851:	e9 b1 00 00 00       	jmp    c0401907 <irq_deregister_driver+0xc8>
	
	/* locate the victim and bail out if we can't find what we're looking for */
	victim = irq_find_driver(irq_num, type, pid, func);
c0401856:	ff 74 24 2c          	pushl  0x2c(%esp)
c040185a:	ff 74 24 2c          	pushl  0x2c(%esp)
c040185e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0401862:	ff 74 24 2c          	pushl  0x2c(%esp)
c0401866:	e8 39 ff ff ff       	call   c04017a4 <irq_find_driver>
c040186b:	83 c4 10             	add    $0x10,%esp
c040186e:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(!victim) return e_bad_params;
c0401872:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0401877:	75 0a                	jne    c0401883 <irq_deregister_driver+0x44>
c0401879:	b8 15 00 00 00       	mov    $0x15,%eax
c040187e:	e9 84 00 00 00       	jmp    c0401907 <irq_deregister_driver+0xc8>
	
	lock_gate(&irq_lock, LOCK_WRITE);
c0401883:	83 ec 08             	sub    $0x8,%esp
c0401886:	6a 01                	push   $0x1
c0401888:	68 60 f4 40 c0       	push   $0xc040f460
c040188d:	e8 06 ec ff ff       	call   c0400498 <lock_gate>
c0401892:	83 c4 10             	add    $0x10,%esp
	
	/* remove it from the table */
	if(victim->next)
c0401895:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401899:	8b 40 10             	mov    0x10(%eax),%eax
c040189c:	85 c0                	test   %eax,%eax
c040189e:	74 11                	je     c04018b1 <irq_deregister_driver+0x72>
		victim->next->previous = victim->previous;
c04018a0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04018a4:	8b 40 10             	mov    0x10(%eax),%eax
c04018a7:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04018ab:	8b 52 0c             	mov    0xc(%edx),%edx
c04018ae:	89 50 0c             	mov    %edx,0xc(%eax)
	if(victim->previous)
c04018b1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04018b5:	8b 40 0c             	mov    0xc(%eax),%eax
c04018b8:	85 c0                	test   %eax,%eax
c04018ba:	74 13                	je     c04018cf <irq_deregister_driver+0x90>
		victim->previous->next = victim->next;
c04018bc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04018c0:	8b 40 0c             	mov    0xc(%eax),%eax
c04018c3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04018c7:	8b 52 10             	mov    0x10(%edx),%edx
c04018ca:	89 50 10             	mov    %edx,0x10(%eax)
c04018cd:	eb 12                	jmp    c04018e1 <irq_deregister_driver+0xa2>
	else
		/* we were the irq line head, so fix up */
		irq_drivers[irq_num] = victim->next;
c04018cf:	8b 44 24 20          	mov    0x20(%esp),%eax
c04018d3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04018d7:	8b 52 10             	mov    0x10(%edx),%edx
c04018da:	89 14 85 60 f0 40 c0 	mov    %edx,-0x3fbf0fa0(,%eax,4)

	vmm_free(victim);
c04018e1:	83 ec 0c             	sub    $0xc,%esp
c04018e4:	ff 74 24 18          	pushl  0x18(%esp)
c04018e8:	e8 22 26 00 00       	call   c0403f0f <vmm_free>
c04018ed:	83 c4 10             	add    $0x10,%esp
	
	unlock_gate(&irq_lock, LOCK_WRITE);
c04018f0:	83 ec 08             	sub    $0x8,%esp
c04018f3:	6a 01                	push   $0x1
c04018f5:	68 60 f4 40 c0       	push   $0xc040f460
c04018fa:	e8 18 ed ff ff       	call   c0400617 <unlock_gate>
c04018ff:	83 c4 10             	add    $0x10,%esp
	
	IRQ_DEBUG("[irq:%i] deregistered driver %p from IRQ %i\n", CPU_ID,
				 victim, irq_num);
	
	return success;
c0401902:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0401907:	83 c4 1c             	add    $0x1c,%esp
c040190a:	c3                   	ret    

c040190b <irq_register_driver>:
   <= 0 for success or else an error code 
*/
kresult irq_register_driver(unsigned int irq_num, unsigned int flags,
									 unsigned int pid,
									 kresult (*func)(unsigned char intnum, int_registers_block *regs))
{
c040190b:	83 ec 1c             	sub    $0x1c,%esp
	kresult err;
	irq_driver_entry *new, *head;
	
	/* bail out on a wild irq_num */
	if(irq_num >= IRQ_MAX_LINES) return e_bad_params;
c040190e:	81 7c 24 20 ff 00 00 	cmpl   $0xff,0x20(%esp)
c0401915:	00 
c0401916:	76 0a                	jbe    c0401922 <irq_register_driver+0x17>
c0401918:	b8 15 00 00 00       	mov    $0x15,%eax
c040191d:	e9 c1 00 00 00       	jmp    c04019e3 <irq_register_driver+0xd8>
	
	/* allocate memory for the new driver entry and zero it */
	err = vmm_malloc((void **)&new, sizeof(irq_driver_entry));
c0401922:	8d 44 24 04          	lea    0x4(%esp),%eax
c0401926:	83 ec 08             	sub    $0x8,%esp
c0401929:	6a 14                	push   $0x14
c040192b:	50                   	push   %eax
c040192c:	e8 b7 21 00 00       	call   c0403ae8 <vmm_malloc>
c0401931:	83 c4 10             	add    $0x10,%esp
c0401934:	89 44 24 08          	mov    %eax,0x8(%esp)
	if(err) return err;
c0401938:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c040193d:	74 09                	je     c0401948 <irq_register_driver+0x3d>
c040193f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401943:	e9 9b 00 00 00       	jmp    c04019e3 <irq_register_driver+0xd8>
	vmm_memset((void *)&new, 0, sizeof(irq_driver_entry));
c0401948:	83 ec 04             	sub    $0x4,%esp
c040194b:	6a 14                	push   $0x14
c040194d:	6a 00                	push   $0x0
c040194f:	8d 44 24 10          	lea    0x10(%esp),%eax
c0401953:	50                   	push   %eax
c0401954:	e8 d3 30 00 00       	call   c0404a2c <vmm_memset>
c0401959:	83 c4 10             	add    $0x10,%esp
	
	/* fill in the blanks */
	if(flags & IRQ_DRIVER_FUNCTION)
c040195c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0401960:	83 e0 02             	and    $0x2,%eax
c0401963:	85 c0                	test   %eax,%eax
c0401965:	74 0d                	je     c0401974 <irq_register_driver+0x69>
		new->func = func; /* driver is a kernel function */
c0401967:	8b 44 24 04          	mov    0x4(%esp),%eax
c040196b:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c040196f:	89 50 08             	mov    %edx,0x8(%eax)
c0401972:	eb 0b                	jmp    c040197f <irq_register_driver+0x74>
	else
		new->pid = pid; /* driver is a userspace process */
c0401974:	8b 44 24 04          	mov    0x4(%esp),%eax
c0401978:	8b 54 24 28          	mov    0x28(%esp),%edx
c040197c:	89 50 04             	mov    %edx,0x4(%eax)
	
	/* protect the data structure during update */
	lock_gate(&irq_lock, LOCK_WRITE);
c040197f:	83 ec 08             	sub    $0x8,%esp
c0401982:	6a 01                	push   $0x1
c0401984:	68 60 f4 40 c0       	push   $0xc040f460
c0401989:	e8 0a eb ff ff       	call   c0400498 <lock_gate>
c040198e:	83 c4 10             	add    $0x10,%esp
	
	/* attach the driver entry to the head of the list for the chosen IRQ line */
	head = irq_drivers[irq_num];
c0401991:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401995:	8b 04 85 60 f0 40 c0 	mov    -0x3fbf0fa0(,%eax,4),%eax
c040199c:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(head)
c04019a0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04019a5:	74 16                	je     c04019bd <irq_register_driver+0xb2>
	{
		/* update the old head */
		new->next = head;
c04019a7:	8b 44 24 04          	mov    0x4(%esp),%eax
c04019ab:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04019af:	89 50 10             	mov    %edx,0x10(%eax)
		head->previous = new;
c04019b2:	8b 54 24 04          	mov    0x4(%esp),%edx
c04019b6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04019ba:	89 50 0c             	mov    %edx,0xc(%eax)
	}
	
	irq_drivers[irq_num] = new;
c04019bd:	8b 44 24 20          	mov    0x20(%esp),%eax
c04019c1:	8b 54 24 04          	mov    0x4(%esp),%edx
c04019c5:	89 14 85 60 f0 40 c0 	mov    %edx,-0x3fbf0fa0(,%eax,4)
	
	unlock_gate(&irq_lock, LOCK_WRITE);
c04019cc:	83 ec 08             	sub    $0x8,%esp
c04019cf:	6a 01                	push   $0x1
c04019d1:	68 60 f4 40 c0       	push   $0xc040f460
c04019d6:	e8 3c ec ff ff       	call   c0400617 <unlock_gate>
c04019db:	83 c4 10             	add    $0x10,%esp
	
	IRQ_DEBUG("[irq:%i] registered driver %p to IRQ %i (pid %i func %p flags %x)\n", CPU_ID,
				 new, irq_num, pid, func, flags);
	
	return success;
c04019de:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04019e3:	83 c4 1c             	add    $0x1c,%esp
c04019e6:	c3                   	ret    

c04019e7 <irq_initialise>:

/* prepare the IRQ handling system */
void irq_initialise(void)
{
c04019e7:	83 ec 0c             	sub    $0xc,%esp
	/* zero the table of IRQ pointers and the lock */
	vmm_memset((void *)&irq_drivers, 0, sizeof(irq_driver_entry *) * IRQ_MAX_LINES);
c04019ea:	83 ec 04             	sub    $0x4,%esp
c04019ed:	68 00 04 00 00       	push   $0x400
c04019f2:	6a 00                	push   $0x0
c04019f4:	68 60 f0 40 c0       	push   $0xc040f060
c04019f9:	e8 2e 30 00 00       	call   c0404a2c <vmm_memset>
c04019fe:	83 c4 10             	add    $0x10,%esp
	vmm_memset((void *)&irq_lock, 0, sizeof(rw_gate));
c0401a01:	83 ec 04             	sub    $0x4,%esp
c0401a04:	6a 10                	push   $0x10
c0401a06:	6a 00                	push   $0x0
c0401a08:	68 60 f4 40 c0       	push   $0xc040f460
c0401a0d:	e8 1a 30 00 00       	call   c0404a2c <vmm_memset>
c0401a12:	83 c4 10             	add    $0x10,%esp
}
c0401a15:	83 c4 0c             	add    $0xc,%esp
c0401a18:	c3                   	ret    
c0401a19:	00 00                	add    %al,(%eax)
	...

c0401a1c <syscall_do_exit>:

#include <portdefs.h>

/* syscall: exit - terminate execution of the current process */
void syscall_do_exit(int_registers_block *regs)
{
c0401a1c:	83 ec 0c             	sub    $0xc,%esp
	SYSCALL_DEBUG("[sys:%i] SYSCALL_EXIT called by process %i (%p) (thread %i)\n",
				  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				  cpu_table[CPU_ID].current->tid);

	/* request to be killed by the system executive */
	msg_send_signal(proc_sys_executive, SIGXPROCEXIT, cpu_table[CPU_ID].current->proc->pid);
c0401a1f:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401a25:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401a2a:	3c 01                	cmp    $0x1,%al
c0401a2c:	76 0f                	jbe    c0401a3d <syscall_do_exit+0x21>
c0401a2e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401a33:	8b 00                	mov    (%eax),%eax
c0401a35:	c1 e8 18             	shr    $0x18,%eax
c0401a38:	c1 e0 06             	shl    $0x6,%eax
c0401a3b:	eb 0b                	jmp    c0401a48 <syscall_do_exit+0x2c>
c0401a3d:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401a42:	0f b6 c0             	movzbl %al,%eax
c0401a45:	c1 e0 06             	shl    $0x6,%eax
c0401a48:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401a4b:	8b 40 04             	mov    0x4(%eax),%eax
c0401a4e:	8b 00                	mov    (%eax),%eax
c0401a50:	8b 10                	mov    (%eax),%edx
c0401a52:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c0401a57:	83 ec 04             	sub    $0x4,%esp
c0401a5a:	52                   	push   %edx
c0401a5b:	6a 22                	push   $0x22
c0401a5d:	50                   	push   %eax
c0401a5e:	e8 d9 07 00 00       	call   c040223c <msg_send_signal>
c0401a63:	83 c4 10             	add    $0x10,%esp

	/* remove from the run queue and mark as dying */
	sched_remove(cpu_table[CPU_ID].current, dead);
c0401a66:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401a6c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401a71:	3c 01                	cmp    $0x1,%al
c0401a73:	76 0f                	jbe    c0401a84 <syscall_do_exit+0x68>
c0401a75:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401a7a:	8b 00                	mov    (%eax),%eax
c0401a7c:	c1 e8 18             	shr    $0x18,%eax
c0401a7f:	c1 e0 06             	shl    $0x6,%eax
c0401a82:	eb 0b                	jmp    c0401a8f <syscall_do_exit+0x73>
c0401a84:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401a89:	0f b6 c0             	movzbl %al,%eax
c0401a8c:	c1 e0 06             	shl    $0x6,%eax
c0401a8f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401a92:	8b 40 04             	mov    0x4(%eax),%eax
c0401a95:	83 ec 08             	sub    $0x8,%esp
c0401a98:	6a 06                	push   $0x6
c0401a9a:	50                   	push   %eax
c0401a9b:	e8 f7 1c 00 00       	call   c0403797 <sched_remove>
c0401aa0:	83 c4 10             	add    $0x10,%esp
}
c0401aa3:	83 c4 0c             	add    $0xc,%esp
c0401aa6:	c3                   	ret    

c0401aa7 <syscall_do_fork>:

/* syscall: fork - duplicate the currently running process as per:
	http://www.opengroup.org/onlinepubs/009695399/functions/fork.html
   <= eax = -1 for failure, 0 for the child or the new child's PID for the parent */
void syscall_do_fork(int_registers_block *regs)
{
c0401aa7:	83 ec 1c             	sub    $0x1c,%esp
	
	SYSCALL_DEBUG("[sys:%i] SYSCALL_FORK called by process %i (%p) (thread %i)\n",
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);
	
	new = proc_new(cpu_table[CPU_ID].current->proc, cpu_table[CPU_ID].current);
c0401aaa:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401ab0:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401ab5:	3c 01                	cmp    $0x1,%al
c0401ab7:	76 0f                	jbe    c0401ac8 <syscall_do_fork+0x21>
c0401ab9:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401abe:	8b 00                	mov    (%eax),%eax
c0401ac0:	c1 e8 18             	shr    $0x18,%eax
c0401ac3:	c1 e0 06             	shl    $0x6,%eax
c0401ac6:	eb 0b                	jmp    c0401ad3 <syscall_do_fork+0x2c>
c0401ac8:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401acd:	0f b6 c0             	movzbl %al,%eax
c0401ad0:	c1 e0 06             	shl    $0x6,%eax
c0401ad3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401ad6:	8b 50 04             	mov    0x4(%eax),%edx
c0401ad9:	8b 0d e8 fc 40 c0    	mov    0xc040fce8,%ecx
c0401adf:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401ae4:	3c 01                	cmp    $0x1,%al
c0401ae6:	76 0f                	jbe    c0401af7 <syscall_do_fork+0x50>
c0401ae8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401aed:	8b 00                	mov    (%eax),%eax
c0401aef:	c1 e8 18             	shr    $0x18,%eax
c0401af2:	c1 e0 06             	shl    $0x6,%eax
c0401af5:	eb 0b                	jmp    c0401b02 <syscall_do_fork+0x5b>
c0401af7:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401afc:	0f b6 c0             	movzbl %al,%eax
c0401aff:	c1 e0 06             	shl    $0x6,%eax
c0401b02:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0401b05:	8b 40 04             	mov    0x4(%eax),%eax
c0401b08:	8b 00                	mov    (%eax),%eax
c0401b0a:	83 ec 08             	sub    $0x8,%esp
c0401b0d:	52                   	push   %edx
c0401b0e:	50                   	push   %eax
c0401b0f:	e8 0b 77 00 00       	call   c040921f <proc_new>
c0401b14:	83 c4 10             	add    $0x10,%esp
c0401b17:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	/* return the right info */
	if(!new) SYSCALL_RETURN(POSIX_GENERIC_FAILURE); /* POSIX_GENERIC_FAILURE == -1 */
c0401b1b:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0401b20:	75 10                	jne    c0401b32 <syscall_do_fork+0x8b>
c0401b22:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401b26:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0401b2d:	e9 b2 00 00 00       	jmp    c0401be4 <syscall_do_fork+0x13d>

	thread *tnew;

	tnew = thread_find_thread(new, cpu_table[CPU_ID].current->tid);
c0401b32:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401b38:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401b3d:	3c 01                	cmp    $0x1,%al
c0401b3f:	76 0f                	jbe    c0401b50 <syscall_do_fork+0xa9>
c0401b41:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401b46:	8b 00                	mov    (%eax),%eax
c0401b48:	c1 e8 18             	shr    $0x18,%eax
c0401b4b:	c1 e0 06             	shl    $0x6,%eax
c0401b4e:	eb 0b                	jmp    c0401b5b <syscall_do_fork+0xb4>
c0401b50:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401b55:	0f b6 c0             	movzbl %al,%eax
c0401b58:	c1 e0 06             	shl    $0x6,%eax
c0401b5b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401b5e:	8b 40 04             	mov    0x4(%eax),%eax
c0401b61:	8b 40 04             	mov    0x4(%eax),%eax
c0401b64:	83 ec 08             	sub    $0x8,%esp
c0401b67:	50                   	push   %eax
c0401b68:	ff 74 24 14          	pushl  0x14(%esp)
c0401b6c:	e8 df 67 00 00       	call   c0408350 <thread_find_thread>
c0401b71:	83 c4 10             	add    $0x10,%esp
c0401b74:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* don't forget to init the tss for the new thread in the new process and duplicate the 
	   state of the current thread */
	vmm_memcpy(&(tnew->regs), regs, sizeof(int_registers_block));
c0401b78:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401b7c:	05 a0 00 00 00       	add    $0xa0,%eax
c0401b81:	83 ec 04             	sub    $0x4,%esp
c0401b84:	6a 40                	push   $0x40
c0401b86:	ff 74 24 28          	pushl  0x28(%esp)
c0401b8a:	50                   	push   %eax
c0401b8b:	e8 d9 2e 00 00       	call   c0404a69 <vmm_memcpy>
c0401b90:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(tnew);
c0401b93:	83 ec 0c             	sub    $0xc,%esp
c0401b96:	ff 74 24 18          	pushl  0x18(%esp)
c0401b9a:	e8 1a ee ff ff       	call   c04009b9 <x86_init_tss>
c0401b9f:	83 c4 10             	add    $0x10,%esp
	
	/* zero eax on the new thread and set the child PID in eax for the parent */
	tnew->regs.eax = 0;
c0401ba2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401ba6:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
c0401bad:	00 00 00 
	regs->eax = new->pid;
c0401bb0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401bb4:	8b 10                	mov    (%eax),%edx
c0401bb6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401bba:	89 50 20             	mov    %edx,0x20(%eax)
	
	/* run the new thread */
	sched_add(tnew->proc->cpu, tnew->priority, tnew);
c0401bbd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401bc1:	8a 40 0e             	mov    0xe(%eax),%al
c0401bc4:	0f b6 d0             	movzbl %al,%edx
c0401bc7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401bcb:	8b 00                	mov    (%eax),%eax
c0401bcd:	8a 40 0c             	mov    0xc(%eax),%al
c0401bd0:	0f b6 c0             	movzbl %al,%eax
c0401bd3:	83 ec 04             	sub    $0x4,%esp
c0401bd6:	ff 74 24 10          	pushl  0x10(%esp)
c0401bda:	52                   	push   %edx
c0401bdb:	50                   	push   %eax
c0401bdc:	e8 e6 19 00 00       	call   c04035c7 <sched_add>
c0401be1:	83 c4 10             	add    $0x10,%esp
}
c0401be4:	83 c4 1c             	add    $0x1c,%esp
c0401be7:	c3                   	ret    

c0401be8 <syscall_do_kill>:
	to terminate itself, it should ask the executive or its parent via syscall:exit
	=> eax = PID for the process to kill
	<= eax = 0 for success or -1 for a failure
*/
void syscall_do_kill(int_registers_block *regs)
{
c0401be8:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int victim = regs->eax;
c0401beb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401bef:	8b 40 20             	mov    0x20(%eax),%eax
c0401bf2:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	SYSCALL_DEBUG("[sys:%i] SYSCALL_KILL(%i) called by process %i (%p) (thread %i)\n",
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
	
	regs->eax = proc_kill(victim, cpu_table[CPU_ID].current->proc);
c0401bf6:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401bfc:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401c01:	3c 01                	cmp    $0x1,%al
c0401c03:	76 0f                	jbe    c0401c14 <syscall_do_kill+0x2c>
c0401c05:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401c0a:	8b 00                	mov    (%eax),%eax
c0401c0c:	c1 e8 18             	shr    $0x18,%eax
c0401c0f:	c1 e0 06             	shl    $0x6,%eax
c0401c12:	eb 0b                	jmp    c0401c1f <syscall_do_kill+0x37>
c0401c14:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401c19:	0f b6 c0             	movzbl %al,%eax
c0401c1c:	c1 e0 06             	shl    $0x6,%eax
c0401c1f:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401c22:	8b 40 04             	mov    0x4(%eax),%eax
c0401c25:	8b 00                	mov    (%eax),%eax
c0401c27:	83 ec 08             	sub    $0x8,%esp
c0401c2a:	50                   	push   %eax
c0401c2b:	ff 74 24 18          	pushl  0x18(%esp)
c0401c2f:	e8 ab 79 00 00       	call   c04095df <proc_kill>
c0401c34:	83 c4 10             	add    $0x10,%esp
c0401c37:	8b 54 24 20          	mov    0x20(%esp),%edx
c0401c3b:	89 42 20             	mov    %eax,0x20(%edx)
	
	if(!(regs->eax) && cpu_table[CPU_ID].current->proc != proc_sys_executive)
c0401c3e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401c42:	8b 40 20             	mov    0x20(%eax),%eax
c0401c45:	85 c0                	test   %eax,%eax
c0401c47:	75 51                	jne    c0401c9a <syscall_do_kill+0xb2>
c0401c49:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401c4f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401c54:	3c 01                	cmp    $0x1,%al
c0401c56:	76 0f                	jbe    c0401c67 <syscall_do_kill+0x7f>
c0401c58:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401c5d:	8b 00                	mov    (%eax),%eax
c0401c5f:	c1 e8 18             	shr    $0x18,%eax
c0401c62:	c1 e0 06             	shl    $0x6,%eax
c0401c65:	eb 0b                	jmp    c0401c72 <syscall_do_kill+0x8a>
c0401c67:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401c6c:	0f b6 c0             	movzbl %al,%eax
c0401c6f:	c1 e0 06             	shl    $0x6,%eax
c0401c72:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401c75:	8b 40 04             	mov    0x4(%eax),%eax
c0401c78:	8b 10                	mov    (%eax),%edx
c0401c7a:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c0401c7f:	39 c2                	cmp    %eax,%edx
c0401c81:	74 17                	je     c0401c9a <syscall_do_kill+0xb2>
		/* inform the system executive that a process has been killed */
		msg_send_signal(proc_sys_executive, SIGXPROCKILLED, victim);
c0401c83:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c0401c88:	83 ec 04             	sub    $0x4,%esp
c0401c8b:	ff 74 24 10          	pushl  0x10(%esp)
c0401c8f:	6a 20                	push   $0x20
c0401c91:	50                   	push   %eax
c0401c92:	e8 a5 05 00 00       	call   c040223c <msg_send_signal>
c0401c97:	83 c4 10             	add    $0x10,%esp
}
c0401c9a:	83 c4 1c             	add    $0x1c,%esp
c0401c9d:	c3                   	ret    

c0401c9e <syscall_do_yield>:
   NOTE: this syscall should really be called thread_yield :-/
	=> no parameters required
	<= all registers preserved
*/
void syscall_do_yield(int_registers_block *regs)
{
c0401c9e:	83 ec 0c             	sub    $0xc,%esp
	SYSCALL_DEBUG("[sys:%i] SYSCALL_YIELD called by process %i (%p) (thread %i)\n",
				CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
				cpu_table[CPU_ID].current->tid);

	sched_move_to_end(CPU_ID, cpu_table[CPU_ID].current->priority, cpu_table[CPU_ID].current);
c0401ca1:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401ca7:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401cac:	3c 01                	cmp    $0x1,%al
c0401cae:	76 0f                	jbe    c0401cbf <syscall_do_yield+0x21>
c0401cb0:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401cb5:	8b 00                	mov    (%eax),%eax
c0401cb7:	c1 e8 18             	shr    $0x18,%eax
c0401cba:	c1 e0 06             	shl    $0x6,%eax
c0401cbd:	eb 0b                	jmp    c0401cca <syscall_do_yield+0x2c>
c0401cbf:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401cc4:	0f b6 c0             	movzbl %al,%eax
c0401cc7:	c1 e0 06             	shl    $0x6,%eax
c0401cca:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401ccd:	8b 48 04             	mov    0x4(%eax),%ecx
c0401cd0:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401cd6:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401cdb:	3c 01                	cmp    $0x1,%al
c0401cdd:	76 0f                	jbe    c0401cee <syscall_do_yield+0x50>
c0401cdf:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401ce4:	8b 00                	mov    (%eax),%eax
c0401ce6:	c1 e8 18             	shr    $0x18,%eax
c0401ce9:	c1 e0 06             	shl    $0x6,%eax
c0401cec:	eb 0b                	jmp    c0401cf9 <syscall_do_yield+0x5b>
c0401cee:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401cf3:	0f b6 c0             	movzbl %al,%eax
c0401cf6:	c1 e0 06             	shl    $0x6,%eax
c0401cf9:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401cfc:	8b 40 04             	mov    0x4(%eax),%eax
c0401cff:	8a 40 0e             	mov    0xe(%eax),%al
c0401d02:	0f b6 d0             	movzbl %al,%edx
c0401d05:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401d0a:	3c 01                	cmp    $0x1,%al
c0401d0c:	76 0f                	jbe    c0401d1d <syscall_do_yield+0x7f>
c0401d0e:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401d13:	8b 00                	mov    (%eax),%eax
c0401d15:	c1 e8 18             	shr    $0x18,%eax
c0401d18:	0f b6 c0             	movzbl %al,%eax
c0401d1b:	eb 08                	jmp    c0401d25 <syscall_do_yield+0x87>
c0401d1d:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401d22:	0f b6 c0             	movzbl %al,%eax
c0401d25:	83 ec 04             	sub    $0x4,%esp
c0401d28:	51                   	push   %ecx
c0401d29:	52                   	push   %edx
c0401d2a:	50                   	push   %eax
c0401d2b:	e8 cf 16 00 00       	call   c04033ff <sched_move_to_end>
c0401d30:	83 c4 10             	add    $0x10,%esp

	/* the syscall dispatch will call sched_pick() for us */
}
c0401d33:	83 c4 0c             	add    $0xc,%esp
c0401d36:	c3                   	ret    

c0401d37 <syscall_do_thread_exit>:

/* syscall thread_exit - end termination of the currently running thread.
   if it's the only thread in the process, the whole process will exit */
void syscall_do_thread_exit(int_registers_block *regs)
{
c0401d37:	83 ec 0c             	sub    $0xc,%esp
	SYSCALL_DEBUG("[sys:%i] SYSCALL_THREAD_EXIT called by process %i (%p) (thread %i threads %i)\n",
			  CPU_ID, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid, cpu_table[CPU_ID].current->proc->thread_count);
	
	/* check to see if this process has only one thread */
	if(cpu_table[CPU_ID].current->proc->thread_count < 2)
c0401d3a:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401d40:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401d45:	3c 01                	cmp    $0x1,%al
c0401d47:	76 0f                	jbe    c0401d58 <syscall_do_thread_exit+0x21>
c0401d49:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401d4e:	8b 00                	mov    (%eax),%eax
c0401d50:	c1 e8 18             	shr    $0x18,%eax
c0401d53:	c1 e0 06             	shl    $0x6,%eax
c0401d56:	eb 0b                	jmp    c0401d63 <syscall_do_thread_exit+0x2c>
c0401d58:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401d5d:	0f b6 c0             	movzbl %al,%eax
c0401d60:	c1 e0 06             	shl    $0x6,%eax
c0401d63:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401d66:	8b 40 04             	mov    0x4(%eax),%eax
c0401d69:	8b 00                	mov    (%eax),%eax
c0401d6b:	8b 40 3c             	mov    0x3c(%eax),%eax
c0401d6e:	83 f8 01             	cmp    $0x1,%eax
c0401d71:	77 14                	ja     c0401d87 <syscall_do_thread_exit+0x50>
	{
		syscall_do_exit(regs);
c0401d73:	83 ec 0c             	sub    $0xc,%esp
c0401d76:	ff 74 24 1c          	pushl  0x1c(%esp)
c0401d7a:	e8 9d fc ff ff       	call   c0401a1c <syscall_do_exit>
c0401d7f:	83 c4 10             	add    $0x10,%esp
		return;
c0401d82:	e9 84 00 00 00       	jmp    c0401e0b <syscall_do_thread_exit+0xd4>
	}
	
	/* request to be killed by the system executive */
	msg_send_signal(proc_sys_executive, SIGXTHREADEXIT, cpu_table[CPU_ID].current->proc->pid);
c0401d87:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401d8d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401d92:	3c 01                	cmp    $0x1,%al
c0401d94:	76 0f                	jbe    c0401da5 <syscall_do_thread_exit+0x6e>
c0401d96:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401d9b:	8b 00                	mov    (%eax),%eax
c0401d9d:	c1 e8 18             	shr    $0x18,%eax
c0401da0:	c1 e0 06             	shl    $0x6,%eax
c0401da3:	eb 0b                	jmp    c0401db0 <syscall_do_thread_exit+0x79>
c0401da5:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401daa:	0f b6 c0             	movzbl %al,%eax
c0401dad:	c1 e0 06             	shl    $0x6,%eax
c0401db0:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401db3:	8b 40 04             	mov    0x4(%eax),%eax
c0401db6:	8b 00                	mov    (%eax),%eax
c0401db8:	8b 10                	mov    (%eax),%edx
c0401dba:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c0401dbf:	83 ec 04             	sub    $0x4,%esp
c0401dc2:	52                   	push   %edx
c0401dc3:	6a 24                	push   $0x24
c0401dc5:	50                   	push   %eax
c0401dc6:	e8 71 04 00 00       	call   c040223c <msg_send_signal>
c0401dcb:	83 c4 10             	add    $0x10,%esp
	
	/* remove from the run queue and mark as dying */
	sched_remove(cpu_table[CPU_ID].current, dead);	
c0401dce:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401dd4:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401dd9:	3c 01                	cmp    $0x1,%al
c0401ddb:	76 0f                	jbe    c0401dec <syscall_do_thread_exit+0xb5>
c0401ddd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401de2:	8b 00                	mov    (%eax),%eax
c0401de4:	c1 e8 18             	shr    $0x18,%eax
c0401de7:	c1 e0 06             	shl    $0x6,%eax
c0401dea:	eb 0b                	jmp    c0401df7 <syscall_do_thread_exit+0xc0>
c0401dec:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401df1:	0f b6 c0             	movzbl %al,%eax
c0401df4:	c1 e0 06             	shl    $0x6,%eax
c0401df7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401dfa:	8b 40 04             	mov    0x4(%eax),%eax
c0401dfd:	83 ec 08             	sub    $0x8,%esp
c0401e00:	6a 06                	push   $0x6
c0401e02:	50                   	push   %eax
c0401e03:	e8 8f 19 00 00       	call   c0403797 <sched_remove>
c0401e08:	83 c4 10             	add    $0x10,%esp
}
c0401e0b:	83 c4 0c             	add    $0xc,%esp
c0401e0e:	c3                   	ret    

c0401e0f <syscall_do_thread_fork>:

/* syscall: thread_fork - duplicate the current thread inside the currently-running
	process, much like a process fork()
   <= eax = -1 for failure, 0 for the new thread or the new thread's TID for the caller */
void syscall_do_thread_fork(int_registers_block *regs)
{
c0401e0f:	53                   	push   %ebx
c0401e10:	83 ec 18             	sub    $0x18,%esp
	thread *new, *current = cpu_table[CPU_ID].current;
c0401e13:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401e19:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401e1e:	3c 01                	cmp    $0x1,%al
c0401e20:	76 0f                	jbe    c0401e31 <syscall_do_thread_fork+0x22>
c0401e22:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401e27:	8b 00                	mov    (%eax),%eax
c0401e29:	c1 e8 18             	shr    $0x18,%eax
c0401e2c:	c1 e0 06             	shl    $0x6,%eax
c0401e2f:	eb 0b                	jmp    c0401e3c <syscall_do_thread_fork+0x2d>
c0401e31:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401e36:	0f b6 c0             	movzbl %al,%eax
c0401e39:	c1 e0 06             	shl    $0x6,%eax
c0401e3c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401e3f:	8b 40 04             	mov    0x4(%eax),%eax
c0401e42:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	SYSCALL_DEBUG("[sys:%i] SYSCALL_THREAD_FORK called by process %i (%p) (thread %i usresp %x)\n",
			  CPU_ID, current->proc->pid, current->proc, current->tid, regs->useresp);

	/* create new thread and mark it as ready to run in usermode */
	new = thread_new(current->proc);
c0401e46:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401e4a:	8b 00                	mov    (%eax),%eax
c0401e4c:	83 ec 0c             	sub    $0xc,%esp
c0401e4f:	50                   	push   %eax
c0401e50:	e8 c8 69 00 00       	call   c040881d <thread_new>
c0401e55:	83 c4 10             	add    $0x10,%esp
c0401e58:	89 44 24 08          	mov    %eax,0x8(%esp)
	if(!new) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0401e5c:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0401e61:	75 10                	jne    c0401e73 <syscall_do_thread_fork+0x64>
c0401e63:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401e67:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c0401e6e:	e9 2a 01 00 00       	jmp    c0401f9d <syscall_do_thread_fork+0x18e>
	new->flags |= THREAD_INUSERMODE;
c0401e73:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401e77:	8a 40 0c             	mov    0xc(%eax),%al
c0401e7a:	88 c2                	mov    %al,%dl
c0401e7c:	83 ca 01             	or     $0x1,%edx
c0401e7f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401e83:	88 50 0c             	mov    %dl,0xc(%eax)
	
	/* copy the state of the caller thread into the state of the new thread */
	vmm_memcpy(&(new->regs), regs, sizeof(int_registers_block));
c0401e86:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401e8a:	05 a0 00 00 00       	add    $0xa0,%eax
c0401e8f:	83 ec 04             	sub    $0x4,%esp
c0401e92:	6a 40                	push   $0x40
c0401e94:	ff 74 24 28          	pushl  0x28(%esp)
c0401e98:	50                   	push   %eax
c0401e99:	e8 cb 2b 00 00       	call   c0404a69 <vmm_memcpy>
c0401e9e:	83 c4 10             	add    $0x10,%esp
	x86_init_tss(new);
c0401ea1:	83 ec 0c             	sub    $0xc,%esp
c0401ea4:	ff 74 24 14          	pushl  0x14(%esp)
c0401ea8:	e8 0c eb ff ff       	call   c04009b9 <x86_init_tss>
c0401ead:	83 c4 10             	add    $0x10,%esp

	/* fix up the stack pointer and duplicate the stack  - only fix up the
		ebp if it looks like an active frame pointer, ugh :( */
	new->regs.useresp = new->stackbase - (current->stackbase - regs->useresp);
c0401eb0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401eb4:	8b 50 2c             	mov    0x2c(%eax),%edx
c0401eb7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401ebb:	8b 48 38             	mov    0x38(%eax),%ecx
c0401ebe:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401ec2:	8b 40 2c             	mov    0x2c(%eax),%eax
c0401ec5:	89 cb                	mov    %ecx,%ebx
c0401ec7:	29 c3                	sub    %eax,%ebx
c0401ec9:	89 d8                	mov    %ebx,%eax
c0401ecb:	01 c2                	add    %eax,%edx
c0401ecd:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401ed1:	89 90 d8 00 00 00    	mov    %edx,0xd8(%eax)
	
	if((regs->ebp <= new->stackbase) &&
c0401ed7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401edb:	8b 50 0c             	mov    0xc(%eax),%edx
c0401ede:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401ee2:	8b 40 2c             	mov    0x2c(%eax),%eax
c0401ee5:	39 c2                	cmp    %eax,%edx
c0401ee7:	77 3e                	ja     c0401f27 <syscall_do_thread_fork+0x118>
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
c0401ee9:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401eed:	8b 50 0c             	mov    0xc(%eax),%edx
c0401ef0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401ef4:	8b 40 2c             	mov    0x2c(%eax),%eax
c0401ef7:	2d 00 40 00 00       	sub    $0x4000,%eax

	/* fix up the stack pointer and duplicate the stack  - only fix up the
		ebp if it looks like an active frame pointer, ugh :( */
	new->regs.useresp = new->stackbase - (current->stackbase - regs->useresp);
	
	if((regs->ebp <= new->stackbase) &&
c0401efc:	39 c2                	cmp    %eax,%edx
c0401efe:	76 27                	jbe    c0401f27 <syscall_do_thread_fork+0x118>
		(regs->ebp > (new->stackbase - (THREAD_MAX_STACK * MEM_PGSIZE))))
		new->regs.ebp = new->stackbase - (current->stackbase - regs->ebp);
c0401f00:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f04:	8b 50 2c             	mov    0x2c(%eax),%edx
c0401f07:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401f0b:	8b 48 0c             	mov    0xc(%eax),%ecx
c0401f0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401f12:	8b 40 2c             	mov    0x2c(%eax),%eax
c0401f15:	89 cb                	mov    %ecx,%ebx
c0401f17:	29 c3                	sub    %eax,%ebx
c0401f19:	89 d8                	mov    %ebx,%eax
c0401f1b:	01 c2                	add    %eax,%edx
c0401f1d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f21:	89 90 ac 00 00 00    	mov    %edx,0xac(%eax)

	SYSCALL_DEBUG("[sys:%i] cloning stack: target esp %x source esp %x (%i bytes) (target stackbase %x source stackbase %x)\n",
			  CPU_ID, new->regs.useresp, regs->useresp, current->stackbase - regs->useresp, new->stackbase, current->stackbase);
	
	vmm_memcpy((void *)(new->regs.useresp), (void *)(regs->useresp), current->stackbase - regs->useresp);
c0401f27:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0401f2b:	8b 50 2c             	mov    0x2c(%eax),%edx
c0401f2e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401f32:	8b 40 38             	mov    0x38(%eax),%eax
c0401f35:	89 d1                	mov    %edx,%ecx
c0401f37:	29 c1                	sub    %eax,%ecx
c0401f39:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401f3d:	8b 40 38             	mov    0x38(%eax),%eax
c0401f40:	89 c2                	mov    %eax,%edx
c0401f42:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f46:	8b 80 d8 00 00 00    	mov    0xd8(%eax),%eax
c0401f4c:	83 ec 04             	sub    $0x4,%esp
c0401f4f:	51                   	push   %ecx
c0401f50:	52                   	push   %edx
c0401f51:	50                   	push   %eax
c0401f52:	e8 12 2b 00 00       	call   c0404a69 <vmm_memcpy>
c0401f57:	83 c4 10             	add    $0x10,%esp
	
	/* zero eax on the new thread and set the child PID in eax for the parent */
	new->regs.eax = 0;
c0401f5a:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f5e:	c7 80 c0 00 00 00 00 	movl   $0x0,0xc0(%eax)
c0401f65:	00 00 00 
	regs->eax = new->tid;
c0401f68:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f6c:	8b 50 04             	mov    0x4(%eax),%edx
c0401f6f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401f73:	89 50 20             	mov    %edx,0x20(%eax)
	
	/* run the new thred */
	sched_add(new->proc->cpu, new->priority, new);	
c0401f76:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f7a:	8a 40 0e             	mov    0xe(%eax),%al
c0401f7d:	0f b6 d0             	movzbl %al,%edx
c0401f80:	8b 44 24 08          	mov    0x8(%esp),%eax
c0401f84:	8b 00                	mov    (%eax),%eax
c0401f86:	8a 40 0c             	mov    0xc(%eax),%al
c0401f89:	0f b6 c0             	movzbl %al,%eax
c0401f8c:	83 ec 04             	sub    $0x4,%esp
c0401f8f:	ff 74 24 0c          	pushl  0xc(%esp)
c0401f93:	52                   	push   %edx
c0401f94:	50                   	push   %eax
c0401f95:	e8 2d 16 00 00       	call   c04035c7 <sched_add>
c0401f9a:	83 c4 10             	add    $0x10,%esp
}
c0401f9d:	83 c4 18             	add    $0x18,%esp
c0401fa0:	5b                   	pop    %ebx
c0401fa1:	c3                   	ret    

c0401fa2 <syscall_do_thread_kill>:
   itself, it should ask the executive via syscall:thread_exit
	=> eax = TID for the thread to kill
	<= eax = 0 for success or -1 for a failure
*/
void syscall_do_thread_kill(int_registers_block *regs)
{
c0401fa2:	83 ec 1c             	sub    $0x1c,%esp
	kresult err;
	process *owner = cpu_table[CPU_ID].current->proc;
c0401fa5:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0401fab:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0401fb0:	3c 01                	cmp    $0x1,%al
c0401fb2:	76 0f                	jbe    c0401fc3 <syscall_do_thread_kill+0x21>
c0401fb4:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0401fb9:	8b 00                	mov    (%eax),%eax
c0401fbb:	c1 e8 18             	shr    $0x18,%eax
c0401fbe:	c1 e0 06             	shl    $0x6,%eax
c0401fc1:	eb 0b                	jmp    c0401fce <syscall_do_thread_kill+0x2c>
c0401fc3:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0401fc8:	0f b6 c0             	movzbl %al,%eax
c0401fcb:	c1 e0 06             	shl    $0x6,%eax
c0401fce:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0401fd1:	8b 40 04             	mov    0x4(%eax),%eax
c0401fd4:	8b 00                	mov    (%eax),%eax
c0401fd6:	89 44 24 08          	mov    %eax,0x8(%esp)
	thread *victim = thread_find_thread(owner, regs->eax);
c0401fda:	8b 44 24 20          	mov    0x20(%esp),%eax
c0401fde:	8b 40 20             	mov    0x20(%eax),%eax
c0401fe1:	83 ec 08             	sub    $0x8,%esp
c0401fe4:	50                   	push   %eax
c0401fe5:	ff 74 24 14          	pushl  0x14(%esp)
c0401fe9:	e8 62 63 00 00       	call   c0408350 <thread_find_thread>
c0401fee:	83 c4 10             	add    $0x10,%esp
c0401ff1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	SYSCALL_DEBUG("[sys:%i] SYSCALL_THREAD_KILL(%i) called by process %i (%p) (thread %i)\n",
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);			
	
	/* bail out if we can't find the given thread or we're trying to kill ourselves */
	if(!victim || (victim == cpu_table[CPU_ID].current)) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0401ff5:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0401ffa:	74 35                	je     c0402031 <syscall_do_thread_kill+0x8f>
c0401ffc:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0402002:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402007:	3c 01                	cmp    $0x1,%al
c0402009:	76 0f                	jbe    c040201a <syscall_do_thread_kill+0x78>
c040200b:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402010:	8b 00                	mov    (%eax),%eax
c0402012:	c1 e8 18             	shr    $0x18,%eax
c0402015:	c1 e0 06             	shl    $0x6,%eax
c0402018:	eb 0b                	jmp    c0402025 <syscall_do_thread_kill+0x83>
c040201a:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040201f:	0f b6 c0             	movzbl %al,%eax
c0402022:	c1 e0 06             	shl    $0x6,%eax
c0402025:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0402028:	8b 40 04             	mov    0x4(%eax),%eax
c040202b:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040202f:	75 10                	jne    c0402041 <syscall_do_thread_kill+0x9f>
c0402031:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402035:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c040203c:	e9 90 00 00 00       	jmp    c04020d1 <syscall_do_thread_kill+0x12f>
	
	/* remove the thread */
	err = thread_kill(owner, victim);
c0402041:	83 ec 08             	sub    $0x8,%esp
c0402044:	ff 74 24 14          	pushl  0x14(%esp)
c0402048:	ff 74 24 14          	pushl  0x14(%esp)
c040204c:	e8 0b 6b 00 00       	call   c0408b5c <thread_kill>
c0402051:	83 c4 10             	add    $0x10,%esp
c0402054:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(err) SYSCALL_RETURN(POSIX_GENERIC_FAILURE);
c0402058:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c040205d:	74 0d                	je     c040206c <syscall_do_thread_kill+0xca>
c040205f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402063:	c7 40 20 ff ff ff ff 	movl   $0xffffffff,0x20(%eax)
c040206a:	eb 65                	jmp    c04020d1 <syscall_do_thread_kill+0x12f>

	/* stop this thread from running and mark it as dying for the sysexec to clear up */
	sched_remove(victim, dead);
c040206c:	83 ec 08             	sub    $0x8,%esp
c040206f:	6a 06                	push   $0x6
c0402071:	ff 74 24 18          	pushl  0x18(%esp)
c0402075:	e8 1d 17 00 00       	call   c0403797 <sched_remove>
c040207a:	83 c4 10             	add    $0x10,%esp
	
	if(cpu_table[CPU_ID].current->proc != proc_sys_executive)
c040207d:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0402083:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402088:	3c 01                	cmp    $0x1,%al
c040208a:	76 0f                	jbe    c040209b <syscall_do_thread_kill+0xf9>
c040208c:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402091:	8b 00                	mov    (%eax),%eax
c0402093:	c1 e8 18             	shr    $0x18,%eax
c0402096:	c1 e0 06             	shl    $0x6,%eax
c0402099:	eb 0b                	jmp    c04020a6 <syscall_do_thread_kill+0x104>
c040209b:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04020a0:	0f b6 c0             	movzbl %al,%eax
c04020a3:	c1 e0 06             	shl    $0x6,%eax
c04020a6:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04020a9:	8b 40 04             	mov    0x4(%eax),%eax
c04020ac:	8b 10                	mov    (%eax),%edx
c04020ae:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c04020b3:	39 c2                	cmp    %eax,%edx
c04020b5:	74 1a                	je     c04020d1 <syscall_do_thread_kill+0x12f>
		/* inform the system executive that a thread has been killed */
		msg_send_signal(proc_sys_executive, SIGXTHREADKILLED, owner->pid);
c04020b7:	8b 44 24 08          	mov    0x8(%esp),%eax
c04020bb:	8b 10                	mov    (%eax),%edx
c04020bd:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c04020c2:	83 ec 04             	sub    $0x4,%esp
c04020c5:	52                   	push   %edx
c04020c6:	6a 23                	push   $0x23
c04020c8:	50                   	push   %eax
c04020c9:	e8 6e 01 00 00       	call   c040223c <msg_send_signal>
c04020ce:	83 c4 10             	add    $0x10,%esp
}
c04020d1:	83 c4 1c             	add    $0x1c,%esp
c04020d4:	c3                   	ret    

c04020d5 <syscall_do_msg_send>:
/* syscall:msg_send - send a message to a process and block until a reply is received
	=> eax = pointer to message description block
   <= eax = 0 for success or a diosix-specific error code
*/
void syscall_do_msg_send(int_registers_block *regs)
{
c04020d5:	83 ec 1c             	sub    $0x1c,%esp
	thread *current = cpu_table[CPU_ID].current;
c04020d8:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04020de:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04020e3:	3c 01                	cmp    $0x1,%al
c04020e5:	76 0f                	jbe    c04020f6 <syscall_do_msg_send+0x21>
c04020e7:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04020ec:	8b 00                	mov    (%eax),%eax
c04020ee:	c1 e8 18             	shr    $0x18,%eax
c04020f1:	c1 e0 06             	shl    $0x6,%eax
c04020f4:	eb 0b                	jmp    c0402101 <syscall_do_msg_send+0x2c>
c04020f6:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04020fb:	0f b6 c0             	movzbl %al,%eax
c04020fe:	c1 e0 06             	shl    $0x6,%eax
c0402101:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0402104:	8b 40 04             	mov    0x4(%eax),%eax
c0402107:	89 44 24 04          	mov    %eax,0x4(%esp)
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
c040210b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040210f:	8b 40 20             	mov    0x20(%eax),%eax
c0402112:	89 44 24 08          	mov    %eax,0x8(%esp)
	SYSCALL_DEBUG("[sys:%i] SYSCALL_MSG_SEND(%x) called by process %i (%p) (thread %i)\n",
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);

	/* sanitise the input data while we're here */
	if(!msg || ((unsigned int)msg >= KERNEL_SPACE_BASE)) SYSCALL_RETURN(e_bad_address);
c0402116:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c040211b:	74 0b                	je     c0402128 <syscall_do_msg_send+0x53>
c040211d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402121:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0402126:	76 10                	jbe    c0402138 <syscall_do_msg_send+0x63>
c0402128:	8b 44 24 20          	mov    0x20(%esp),%eax
c040212c:	c7 40 20 11 00 00 00 	movl   $0x11,0x20(%eax)
c0402133:	e9 81 00 00 00       	jmp    c04021b9 <syscall_do_msg_send+0xe4>
	
	/* do the actual sending */
	send_result = msg_send(current, msg);
c0402138:	83 ec 08             	sub    $0x8,%esp
c040213b:	ff 74 24 10          	pushl  0x10(%esp)
c040213f:	ff 74 24 10          	pushl  0x10(%esp)
c0402143:	e8 05 05 00 00       	call   c040264d <msg_send>
c0402148:	83 c4 10             	add    $0x10,%esp
c040214b:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* should we wait for a follow-up message if this was a reply? */
	if(!send_result && (msg->flags & DIOSIX_MSG_REPLY) && (msg->flags & DIOSIX_MSG_RECVONREPLY))
c040214f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0402154:	75 58                	jne    c04021ae <syscall_do_msg_send+0xd9>
c0402156:	8b 44 24 08          	mov    0x8(%esp),%eax
c040215a:	8b 40 08             	mov    0x8(%eax),%eax
c040215d:	85 c0                	test   %eax,%eax
c040215f:	79 4d                	jns    c04021ae <syscall_do_msg_send+0xd9>
c0402161:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402165:	8b 40 08             	mov    0x8(%eax),%eax
c0402168:	25 00 00 00 20       	and    $0x20000000,%eax
c040216d:	85 c0                	test   %eax,%eax
c040216f:	74 3d                	je     c04021ae <syscall_do_msg_send+0xd9>
	{
		/* clear message flags to perform a recv */
		msg->flags &= DIOSIX_MSG_TYPEMASK;
c0402171:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402175:	8b 40 08             	mov    0x8(%eax),%eax
c0402178:	89 c2                	mov    %eax,%edx
c040217a:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
c0402180:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402184:	89 50 08             	mov    %edx,0x8(%eax)
		
		/* zero the send info and preserve everything else */
		msg->send_size = 0;
c0402187:	8b 44 24 08          	mov    0x8(%esp),%eax
c040218b:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
		msg->send = NULL;
c0402192:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402196:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
		
		syscall_do_msg_recv(regs); /* will update eax when it returns */		
c040219d:	83 ec 0c             	sub    $0xc,%esp
c04021a0:	ff 74 24 2c          	pushl  0x2c(%esp)
c04021a4:	e8 14 00 00 00       	call   c04021bd <syscall_do_msg_recv>
c04021a9:	83 c4 10             	add    $0x10,%esp
	
	/* do the actual sending */
	send_result = msg_send(current, msg);
	
	/* should we wait for a follow-up message if this was a reply? */
	if(!send_result && (msg->flags & DIOSIX_MSG_REPLY) && (msg->flags & DIOSIX_MSG_RECVONREPLY))
c04021ac:	eb 0b                	jmp    c04021b9 <syscall_do_msg_send+0xe4>
		msg->send = NULL;
		
		syscall_do_msg_recv(regs); /* will update eax when it returns */		
	}
	else
		regs->eax = send_result;
c04021ae:	8b 44 24 20          	mov    0x20(%esp),%eax
c04021b2:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04021b6:	89 50 20             	mov    %edx,0x20(%eax)
}
c04021b9:	83 c4 1c             	add    $0x1c,%esp
c04021bc:	c3                   	ret    

c04021bd <syscall_do_msg_recv>:
/* syscall:msg_recv - receive a message or block until a message is received
   => eax = pointer to message description block
   <= eax = 0 for success or a diosix-specific error code
*/
void syscall_do_msg_recv(int_registers_block *regs)
{
c04021bd:	83 ec 1c             	sub    $0x1c,%esp
	thread *current = cpu_table[CPU_ID].current;
c04021c0:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04021c6:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04021cb:	3c 01                	cmp    $0x1,%al
c04021cd:	76 0f                	jbe    c04021de <syscall_do_msg_recv+0x21>
c04021cf:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04021d4:	8b 00                	mov    (%eax),%eax
c04021d6:	c1 e8 18             	shr    $0x18,%eax
c04021d9:	c1 e0 06             	shl    $0x6,%eax
c04021dc:	eb 0b                	jmp    c04021e9 <syscall_do_msg_recv+0x2c>
c04021de:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04021e3:	0f b6 c0             	movzbl %al,%eax
c04021e6:	c1 e0 06             	shl    $0x6,%eax
c04021e9:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04021ec:	8b 40 04             	mov    0x4(%eax),%eax
c04021ef:	89 44 24 08          	mov    %eax,0x8(%esp)
	diosix_msg_info *msg = (diosix_msg_info *)regs->eax;
c04021f3:	8b 44 24 20          	mov    0x20(%esp),%eax
c04021f7:	8b 40 20             	mov    0x20(%eax),%eax
c04021fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
	SYSCALL_DEBUG("[sys:%i] SYSCALL_MSG_RECV(%x) called by process %i (%p) (thread %i)\n",
			  CPU_ID, regs->eax, cpu_table[CPU_ID].current->proc->pid, cpu_table[CPU_ID].current->proc,
			  cpu_table[CPU_ID].current->tid);
	
	/* sanitise the input data while we're here */
	if(!msg || ((unsigned int)msg >= KERNEL_SPACE_BASE)) SYSCALL_RETURN(e_bad_address);
c04021fe:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0402203:	74 0b                	je     c0402210 <syscall_do_msg_recv+0x53>
c0402205:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402209:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c040220e:	76 0d                	jbe    c040221d <syscall_do_msg_recv+0x60>
c0402210:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402214:	c7 40 20 11 00 00 00 	movl   $0x11,0x20(%eax)
c040221b:	eb 1a                	jmp    c0402237 <syscall_do_msg_recv+0x7a>
	
	/* do the actual receiving */
	regs->eax = msg_recv(current, msg);
c040221d:	83 ec 08             	sub    $0x8,%esp
c0402220:	ff 74 24 14          	pushl  0x14(%esp)
c0402224:	ff 74 24 14          	pushl  0x14(%esp)
c0402228:	e8 32 07 00 00       	call   c040295f <msg_recv>
c040222d:	83 c4 10             	add    $0x10,%esp
c0402230:	8b 54 24 20          	mov    0x20(%esp),%edx
c0402234:	89 42 20             	mov    %eax,0x20(%edx)
}
c0402237:	83 c4 1c             	add    $0x1c,%esp
c040223a:	c3                   	ret    
	...

c040223c <msg_send_signal>:
		signum  = signal code to send
      sigcode = additional reason code
   <= 0 for success or an error reason code */
kresult msg_send_signal(process *target, unsigned int signum, unsigned int sigcode)
{
	return e_no_handler;
c040223c:	b8 05 00 00 00       	mov    $0x5,%eax
}
c0402241:	c3                   	ret    

c0402242 <msg_test_receiver>:
      target = thread message is trying to be sent to
      msg = message block trying to be sent
   <= 0 for success, or an error code
*/
kresult msg_test_receiver(thread *sender, thread *target, diosix_msg_info *msg)
{
c0402242:	83 ec 1c             	sub    $0x1c,%esp
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
c0402245:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040224a:	74 0e                	je     c040225a <msg_test_receiver+0x18>
c040224c:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0402251:	74 07                	je     c040225a <msg_test_receiver+0x18>
c0402253:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0402258:	75 44                	jne    c040229e <msg_test_receiver+0x5c>
	{
		KOOPS_DEBUG("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
				      CPU_ID, sender, target, msg);
c040225a:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
	{
		KOOPS_DEBUG("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
c040225f:	3c 01                	cmp    $0x1,%al
c0402261:	76 0c                	jbe    c040226f <msg_test_receiver+0x2d>
				      CPU_ID, sender, target, msg);
c0402263:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402268:	8b 00                	mov    (%eax),%eax
	diosix_msg_info *tmsg;
	
	/* sanity check */
	if(!sender || !target || !msg)
	{
		KOOPS_DEBUG("[msg:%i] OMGWTF msg_test_receiver() called with sender %p target %p msg %p\n",
c040226a:	c1 e8 18             	shr    $0x18,%eax
c040226d:	eb 08                	jmp    c0402277 <msg_test_receiver+0x35>
c040226f:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0402274:	0f b6 c0             	movzbl %al,%eax
c0402277:	83 ec 0c             	sub    $0xc,%esp
c040227a:	ff 74 24 34          	pushl  0x34(%esp)
c040227e:	ff 74 24 34          	pushl  0x34(%esp)
c0402282:	ff 74 24 34          	pushl  0x34(%esp)
c0402286:	50                   	push   %eax
c0402287:	68 6c c4 40 c0       	push   $0xc040c46c
c040228c:	e8 f1 9b 00 00       	call   c040be82 <debug_printf>
c0402291:	83 c4 20             	add    $0x20,%esp
				      CPU_ID, sender, target, msg);
		return e_failure;
c0402294:	b8 01 00 00 00       	mov    $0x1,%eax
c0402299:	e9 11 01 00 00       	jmp    c04023af <msg_test_receiver+0x16d>
	}
	
	/* protect us from changes to the target's metadata */
	lock_gate(&(target->lock), LOCK_READ);
c040229e:	8b 44 24 24          	mov    0x24(%esp),%eax
c04022a2:	83 c0 1c             	add    $0x1c,%eax
c04022a5:	83 ec 08             	sub    $0x8,%esp
c04022a8:	6a 00                	push   $0x0
c04022aa:	50                   	push   %eax
c04022ab:	e8 e8 e1 ff ff       	call   c0400498 <lock_gate>
c04022b0:	83 c4 10             	add    $0x10,%esp
	
	/* threads can only recieve messages if they are in a layer below the sender - unless it's a 
		reply. we check below whether this is a legit reply */
	if((target->proc->layer >= sender->proc->layer) && !(msg->flags & DIOSIX_MSG_REPLY))
c04022b3:	8b 44 24 24          	mov    0x24(%esp),%eax
c04022b7:	8b 00                	mov    (%eax),%eax
c04022b9:	8a 50 50             	mov    0x50(%eax),%dl
c04022bc:	8b 44 24 20          	mov    0x20(%esp),%eax
c04022c0:	8b 00                	mov    (%eax),%eax
c04022c2:	8a 40 50             	mov    0x50(%eax),%al
c04022c5:	38 c2                	cmp    %al,%dl
c04022c7:	72 0f                	jb     c04022d8 <msg_test_receiver+0x96>
c04022c9:	8b 44 24 28          	mov    0x28(%esp),%eax
c04022cd:	8b 40 08             	mov    0x8(%eax),%eax
c04022d0:	85 c0                	test   %eax,%eax
c04022d2:	0f 89 99 00 00 00    	jns    c0402371 <msg_test_receiver+0x12f>
		goto msg_test_receiver_failure;
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c04022d8:	8b 44 24 24          	mov    0x24(%esp),%eax
c04022dc:	8b 40 10             	mov    0x10(%eax),%eax
c04022df:	83 f8 03             	cmp    $0x3,%eax
c04022e2:	75 1c                	jne    c0402300 <msg_test_receiver+0xbe>
		(msg->flags & DIOSIX_MSG_REPLY) &&
c04022e4:	8b 44 24 28          	mov    0x28(%esp),%eax
c04022e8:	8b 40 08             	mov    0x8(%eax),%eax
		reply. we check below whether this is a legit reply */
	if((target->proc->layer >= sender->proc->layer) && !(msg->flags & DIOSIX_MSG_REPLY))
		goto msg_test_receiver_failure;
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c04022eb:	85 c0                	test   %eax,%eax
c04022ed:	79 11                	jns    c0402300 <msg_test_receiver+0xbe>
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
c04022ef:	8b 44 24 24          	mov    0x24(%esp),%eax
c04022f3:	8b 40 14             	mov    0x14(%eax),%eax
		reply. we check below whether this is a legit reply */
	if((target->proc->layer >= sender->proc->layer) && !(msg->flags & DIOSIX_MSG_REPLY))
		goto msg_test_receiver_failure;
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
c04022f6:	3b 44 24 20          	cmp    0x20(%esp),%eax
c04022fa:	0f 84 91 00 00 00    	je     c0402391 <msg_test_receiver+0x14f>
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
		goto msg_test_receiver_success;
	
	/* is the target thread willing to accept the message type? */
	if(target->msg)
c0402300:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402304:	8b 40 18             	mov    0x18(%eax),%eax
c0402307:	85 c0                	test   %eax,%eax
c0402309:	74 4a                	je     c0402355 <msg_test_receiver+0x113>
	{
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
c040230b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040230f:	8b 08                	mov    (%eax),%ecx
c0402311:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402315:	8b 40 18             	mov    0x18(%eax),%eax
c0402318:	89 c2                	mov    %eax,%edx
c040231a:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040231e:	83 ec 04             	sub    $0x4,%esp
c0402321:	51                   	push   %ecx
c0402322:	52                   	push   %edx
c0402323:	50                   	push   %eax
c0402324:	e8 63 58 00 00       	call   c0407b8c <pg_user2kernel>
c0402329:	83 c4 10             	add    $0x10,%esp
c040232c:	85 c0                	test   %eax,%eax
c040232e:	75 44                	jne    c0402374 <msg_test_receiver+0x132>
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
c0402330:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402334:	8b 40 10             	mov    0x10(%eax),%eax
c0402337:	83 f8 04             	cmp    $0x4,%eax
c040233a:	75 19                	jne    c0402355 <msg_test_receiver+0x113>
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
c040233c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0402340:	8b 50 08             	mov    0x8(%eax),%edx
c0402343:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402347:	8b 40 08             	mov    0x8(%eax),%eax
c040234a:	21 d0                	and    %edx,%eax
c040234c:	25 ff 0f 00 00       	and    $0xfff,%eax
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
c0402351:	85 c0                	test   %eax,%eax
c0402353:	75 3f                	jne    c0402394 <msg_test_receiver+0x152>
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
			goto msg_test_receiver_success;
	}
	
	/* give up */
	unlock_gate(&(target->lock), LOCK_READ);
c0402355:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402359:	83 c0 1c             	add    $0x1c,%eax
c040235c:	83 ec 08             	sub    $0x8,%esp
c040235f:	6a 00                	push   $0x0
c0402361:	50                   	push   %eax
c0402362:	e8 b0 e2 ff ff       	call   c0400617 <unlock_gate>
c0402367:	83 c4 10             	add    $0x10,%esp
	return e_no_receiver;
c040236a:	b8 07 00 00 00       	mov    $0x7,%eax
c040236f:	eb 3e                	jmp    c04023af <msg_test_receiver+0x16d>
	lock_gate(&(target->lock), LOCK_READ);
	
	/* threads can only recieve messages if they are in a layer below the sender - unless it's a 
		reply. we check below whether this is a legit reply */
	if((target->proc->layer >= sender->proc->layer) && !(msg->flags & DIOSIX_MSG_REPLY))
		goto msg_test_receiver_failure;
c0402371:	90                   	nop
c0402372:	eb 01                	jmp    c0402375 <msg_test_receiver+0x133>
	if(target->msg)
	{
		/* don't forget that within the context of the sending thread we can't access the
		 receiver's msg structure unless we go via a kernel mapping.. */
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
c0402374:	90                   	nop
	/* give up */
	unlock_gate(&(target->lock), LOCK_READ);
	return e_no_receiver;
	
msg_test_receiver_failure:
	unlock_gate(&(target->lock), LOCK_READ);
c0402375:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402379:	83 c0 1c             	add    $0x1c,%eax
c040237c:	83 ec 08             	sub    $0x8,%esp
c040237f:	6a 00                	push   $0x0
c0402381:	50                   	push   %eax
c0402382:	e8 90 e2 ff ff       	call   c0400617 <unlock_gate>
c0402387:	83 c4 10             	add    $0x10,%esp
	return e_failure;
c040238a:	b8 01 00 00 00       	mov    $0x1,%eax
c040238f:	eb 1e                	jmp    c04023af <msg_test_receiver+0x16d>
	
	/* is this message waiting on a reply from this thread? */
	if((target->state == waitingforreply) &&
		(msg->flags & DIOSIX_MSG_REPLY) &&
		(target->replysource == sender))
		goto msg_test_receiver_success;
c0402391:	90                   	nop
c0402392:	eb 01                	jmp    c0402395 <msg_test_receiver+0x153>
		if(pg_user2kernel((unsigned int *)&tmsg, (unsigned int)(target->msg), target->proc))
			goto msg_test_receiver_failure;		
		
		if((target->state == waitingformsg) &&
			((msg->flags & DIOSIX_MSG_TYPEMASK) & tmsg->flags))
			goto msg_test_receiver_success;
c0402394:	90                   	nop
	unlock_gate(&(target->lock), LOCK_READ);
	return e_failure;
	
	/* unlock and escape with success */
msg_test_receiver_success:
	unlock_gate(&(target->lock), LOCK_READ);
c0402395:	8b 44 24 24          	mov    0x24(%esp),%eax
c0402399:	83 c0 1c             	add    $0x1c,%eax
c040239c:	83 ec 08             	sub    $0x8,%esp
c040239f:	6a 00                	push   $0x0
c04023a1:	50                   	push   %eax
c04023a2:	e8 70 e2 ff ff       	call   c0400617 <unlock_gate>
c04023a7:	83 c4 10             	add    $0x10,%esp
	return success;
c04023aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04023af:	83 c4 1c             	add    $0x1c,%esp
c04023b2:	c3                   	ret    

c04023b3 <msg_find_receiver>:
   => sender = thread trying to send the message
      msg = message block trying to be sent
   <= pointer to thread to send the message to, or NULL for none
*/
thread *msg_find_receiver(thread *sender, diosix_msg_info *msg)
{
c04023b3:	83 ec 1c             	sub    $0x1c,%esp
	process *proc;
	thread *recv;
	
	/* start with basic checks */
	if(!msg) return NULL;
c04023b6:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04023bb:	75 0a                	jne    c04023c7 <msg_find_receiver+0x14>
c04023bd:	b8 00 00 00 00       	mov    $0x0,%eax
c04023c2:	e9 16 01 00 00       	jmp    c04024dd <msg_find_receiver+0x12a>
	proc = proc_find_proc(msg->pid);
c04023c7:	8b 44 24 24          	mov    0x24(%esp),%eax
c04023cb:	8b 00                	mov    (%eax),%eax
c04023cd:	83 ec 0c             	sub    $0xc,%esp
c04023d0:	50                   	push   %eax
c04023d1:	e8 32 6a 00 00       	call   c0408e08 <proc_find_proc>
c04023d6:	83 c4 10             	add    $0x10,%esp
c04023d9:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(!proc) return NULL;
c04023dd:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c04023e2:	75 0a                	jne    c04023ee <msg_find_receiver+0x3b>
c04023e4:	b8 00 00 00 00       	mov    $0x0,%eax
c04023e9:	e9 ef 00 00 00       	jmp    c04024dd <msg_find_receiver+0x12a>
	MSG_DEBUG("[msg:%i] trying to find a receiver, sender=[tid %i pid %i] msg %p target=[tid %i pid %i]\n",
			    CPU_ID, sender->tid, sender->proc->pid, msg, msg->tid, msg->pid);
#endif
	
	/* if a specific tid is given, then try that one */ 
	if(msg->tid != DIOSIX_MSG_ANY_THREAD)
c04023ee:	8b 44 24 24          	mov    0x24(%esp),%eax
c04023f2:	8b 40 04             	mov    0x4(%eax),%eax
c04023f5:	85 c0                	test   %eax,%eax
c04023f7:	74 43                	je     c040243c <msg_find_receiver+0x89>
	{
		recv = thread_find_thread(proc, msg->tid);
c04023f9:	8b 44 24 24          	mov    0x24(%esp),%eax
c04023fd:	8b 40 04             	mov    0x4(%eax),%eax
c0402400:	83 ec 08             	sub    $0x8,%esp
c0402403:	50                   	push   %eax
c0402404:	ff 74 24 10          	pushl  0x10(%esp)
c0402408:	e8 43 5f 00 00       	call   c0408350 <thread_find_thread>
c040240d:	83 c4 10             	add    $0x10,%esp
c0402410:	89 44 24 08          	mov    %eax,0x8(%esp)
		if(msg_test_receiver(sender, recv, msg) == success) return recv;
c0402414:	83 ec 04             	sub    $0x4,%esp
c0402417:	ff 74 24 28          	pushl  0x28(%esp)
c040241b:	ff 74 24 10          	pushl  0x10(%esp)
c040241f:	ff 74 24 2c          	pushl  0x2c(%esp)
c0402423:	e8 1a fe ff ff       	call   c0402242 <msg_test_receiver>
c0402428:	83 c4 10             	add    $0x10,%esp
c040242b:	85 c0                	test   %eax,%eax
c040242d:	0f 85 a4 00 00 00    	jne    c04024d7 <msg_find_receiver+0x124>
c0402433:	8b 44 24 08          	mov    0x8(%esp),%eax
c0402437:	e9 a1 00 00 00       	jmp    c04024dd <msg_find_receiver+0x12a>
		/* otherwise search the targetted process for a thread that's blocking on
		 receive */
		unsigned int loop;
		
		/* protect us from process table changes */
		lock_gate(&proc_lock, LOCK_READ);
c040243c:	83 ec 08             	sub    $0x8,%esp
c040243f:	6a 00                	push   $0x0
c0402441:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0402446:	e8 4d e0 ff ff       	call   c0400498 <lock_gate>
c040244b:	83 c4 10             	add    $0x10,%esp
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c040244e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0402455:	00 
c0402456:	eb 64                	jmp    c04024bc <msg_find_receiver+0x109>
		{
			recv = proc->threads[loop];
c0402458:	8b 44 24 04          	mov    0x4(%esp),%eax
c040245c:	8b 40 38             	mov    0x38(%eax),%eax
c040245f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0402463:	c1 e2 02             	shl    $0x2,%edx
c0402466:	01 d0                	add    %edx,%eax
c0402468:	8b 00                	mov    (%eax),%eax
c040246a:	89 44 24 08          	mov    %eax,0x8(%esp)
			while(recv)
c040246e:	eb 41                	jmp    c04024b1 <msg_find_receiver+0xfe>
			{
				if(msg_test_receiver(sender, recv, msg) == success)
c0402470:	83 ec 04             	sub    $0x4,%esp
c0402473:	ff 74 24 28          	pushl  0x28(%esp)
c0402477:	ff 74 24 10          	pushl  0x10(%esp)
c040247b:	ff 74 24 2c          	pushl  0x2c(%esp)
c040247f:	e8 be fd ff ff       	call   c0402242 <msg_test_receiver>
c0402484:	83 c4 10             	add    $0x10,%esp
c0402487:	85 c0                	test   %eax,%eax
c0402489:	75 18                	jne    c04024a3 <msg_find_receiver+0xf0>
				{
					unlock_gate(&proc_lock, LOCK_READ);
c040248b:	83 ec 08             	sub    $0x8,%esp
c040248e:	6a 00                	push   $0x0
c0402490:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0402495:	e8 7d e1 ff ff       	call   c0400617 <unlock_gate>
c040249a:	83 c4 10             	add    $0x10,%esp
					return recv;
c040249d:	8b 44 24 08          	mov    0x8(%esp),%eax
c04024a1:	eb 3a                	jmp    c04024dd <msg_find_receiver+0x12a>
				}
				recv = recv->hash_next;
c04024a3:	8b 44 24 08          	mov    0x8(%esp),%eax
c04024a7:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c04024ad:	89 44 24 08          	mov    %eax,0x8(%esp)
		lock_gate(&proc_lock, LOCK_READ);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
		{
			recv = proc->threads[loop];
			while(recv)
c04024b1:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c04024b6:	75 b8                	jne    c0402470 <msg_find_receiver+0xbd>
		unsigned int loop;
		
		/* protect us from process table changes */
		lock_gate(&proc_lock, LOCK_READ);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c04024b8:	ff 44 24 0c          	incl   0xc(%esp)
c04024bc:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
c04024c1:	76 95                	jbe    c0402458 <msg_find_receiver+0xa5>
				}
				recv = recv->hash_next;
			}
		}
		
		unlock_gate(&proc_lock, LOCK_READ);
c04024c3:	83 ec 08             	sub    $0x8,%esp
c04024c6:	6a 00                	push   $0x0
c04024c8:	68 a0 f4 40 c0       	push   $0xc040f4a0
c04024cd:	e8 45 e1 ff ff       	call   c0400617 <unlock_gate>
c04024d2:	83 c4 10             	add    $0x10,%esp
c04024d5:	eb 01                	jmp    c04024d8 <msg_find_receiver+0x125>
	
	/* if a specific tid is given, then try that one */ 
	if(msg->tid != DIOSIX_MSG_ANY_THREAD)
	{
		recv = thread_find_thread(proc, msg->tid);
		if(msg_test_receiver(sender, recv, msg) == success) return recv;
c04024d7:	90                   	nop
		
		unlock_gate(&proc_lock, LOCK_READ);
	}
	
	/* fall through to returning with nothing */
	return NULL;
c04024d8:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04024dd:	83 c4 1c             	add    $0x1c,%esp
c04024e0:	c3                   	ret    

c04024e1 <msg_copy>:
               NB: this function updates this word to contain the offset after the copied data
      sender = thread sending the message
   <= 0 for success, or an error code
*/
kresult msg_copy(thread *receiver, void *data, unsigned int size, unsigned int *offset, thread *sender)
{
c04024e1:	83 ec 1c             	sub    $0x1c,%esp
	diosix_msg_info *rmsg;
	unsigned int recv;
	unsigned int recv_base;
	
	/* protect us from metadata changes */
	lock_gate(&(receiver->lock), LOCK_READ);
c04024e4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04024e8:	83 c0 1c             	add    $0x1c,%eax
c04024eb:	83 ec 08             	sub    $0x8,%esp
c04024ee:	6a 00                	push   $0x0
c04024f0:	50                   	push   %eax
c04024f1:	e8 a2 df ff ff       	call   c0400498 <lock_gate>
c04024f6:	83 c4 10             	add    $0x10,%esp
	
	/* don't forget that within the context of the sending thread we can't access the
	 receiver's msg structure unless we go via a kernel mapping.. */
	if(pg_user2kernel((unsigned int *)&rmsg, (unsigned int)(receiver->msg), receiver->proc))
c04024f9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04024fd:	8b 08                	mov    (%eax),%ecx
c04024ff:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402503:	8b 40 18             	mov    0x18(%eax),%eax
c0402506:	89 c2                	mov    %eax,%edx
c0402508:	8d 44 24 04          	lea    0x4(%esp),%eax
c040250c:	83 ec 04             	sub    $0x4,%esp
c040250f:	51                   	push   %ecx
c0402510:	52                   	push   %edx
c0402511:	50                   	push   %eax
c0402512:	e8 75 56 00 00       	call   c0407b8c <pg_user2kernel>
c0402517:	83 c4 10             	add    $0x10,%esp
c040251a:	85 c0                	test   %eax,%eax
c040251c:	74 1f                	je     c040253d <msg_copy+0x5c>
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c040251e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402522:	83 c0 1c             	add    $0x1c,%eax
c0402525:	83 ec 08             	sub    $0x8,%esp
c0402528:	6a 00                	push   $0x0
c040252a:	50                   	push   %eax
c040252b:	e8 e7 e0 ff ff       	call   c0400617 <unlock_gate>
c0402530:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402533:	b8 01 00 00 00       	mov    $0x1,%eax
c0402538:	e9 0c 01 00 00       	jmp    c0402649 <msg_copy+0x168>
	}
	
	recv = (unsigned int)rmsg->recv;
c040253d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0402541:	8b 40 1c             	mov    0x1c(%eax),%eax
c0402544:	89 44 24 08          	mov    %eax,0x8(%esp)
	recv_base = recv + (*(offset));
c0402548:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040254c:	8b 00                	mov    (%eax),%eax
c040254e:	03 44 24 08          	add    0x8(%esp),%eax
c0402552:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* stop abusive processes trying to smash out of a recv buffer */
	if((size > DIOSIX_MSG_MAX_SIZE) ||
c0402556:	81 7c 24 28 00 40 00 	cmpl   $0x4000,0x28(%esp)
c040255d:	00 
c040255e:	77 19                	ja     c0402579 <msg_copy+0x98>
		((recv_base + size) > (recv + rmsg->recv_max_size)))
c0402560:	8b 44 24 28          	mov    0x28(%esp),%eax
c0402564:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0402568:	01 c2                	add    %eax,%edx
c040256a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040256e:	8b 40 14             	mov    0x14(%eax),%eax
c0402571:	03 44 24 08          	add    0x8(%esp),%eax
	
	recv = (unsigned int)rmsg->recv;
	recv_base = recv + (*(offset));
	
	/* stop abusive processes trying to smash out of a recv buffer */
	if((size > DIOSIX_MSG_MAX_SIZE) ||
c0402575:	39 c2                	cmp    %eax,%edx
c0402577:	76 1f                	jbe    c0402598 <msg_copy+0xb7>
		((recv_base + size) > (recv + rmsg->recv_max_size)))
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c0402579:	8b 44 24 20          	mov    0x20(%esp),%eax
c040257d:	83 c0 1c             	add    $0x1c,%eax
c0402580:	83 ec 08             	sub    $0x8,%esp
c0402583:	6a 00                	push   $0x0
c0402585:	50                   	push   %eax
c0402586:	e8 8c e0 ff ff       	call   c0400617 <unlock_gate>
c040258b:	83 c4 10             	add    $0x10,%esp
		return e_too_big;
c040258e:	b8 0c 00 00 00       	mov    $0xc,%eax
c0402593:	e9 b1 00 00 00       	jmp    c0402649 <msg_copy+0x168>
	}
	
	lock_gate(&(sender->lock), LOCK_READ);
c0402598:	8b 44 24 30          	mov    0x30(%esp),%eax
c040259c:	83 c0 1c             	add    $0x1c,%eax
c040259f:	83 ec 08             	sub    $0x8,%esp
c04025a2:	6a 00                	push   $0x0
c04025a4:	50                   	push   %eax
c04025a5:	e8 ee de ff ff       	call   c0400498 <lock_gate>
c04025aa:	83 c4 10             	add    $0x10,%esp
	
	/* hand it over to the vmm to copy process-to-process - it'll sanity check the addresses */
	if(vmm_memcpyuser((void *)recv_base, receiver->proc, data, sender->proc, size))
c04025ad:	8b 44 24 30          	mov    0x30(%esp),%eax
c04025b1:	8b 08                	mov    (%eax),%ecx
c04025b3:	8b 44 24 20          	mov    0x20(%esp),%eax
c04025b7:	8b 10                	mov    (%eax),%edx
c04025b9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04025bd:	83 ec 0c             	sub    $0xc,%esp
c04025c0:	ff 74 24 34          	pushl  0x34(%esp)
c04025c4:	51                   	push   %ecx
c04025c5:	ff 74 24 38          	pushl  0x38(%esp)
c04025c9:	52                   	push   %edx
c04025ca:	50                   	push   %eax
c04025cb:	e8 e1 24 00 00       	call   c0404ab1 <vmm_memcpyuser>
c04025d0:	83 c4 20             	add    $0x20,%esp
c04025d3:	85 c0                	test   %eax,%eax
c04025d5:	74 31                	je     c0402608 <msg_copy+0x127>
	{
		unlock_gate(&(sender->lock), LOCK_READ);
c04025d7:	8b 44 24 30          	mov    0x30(%esp),%eax
c04025db:	83 c0 1c             	add    $0x1c,%eax
c04025de:	83 ec 08             	sub    $0x8,%esp
c04025e1:	6a 00                	push   $0x0
c04025e3:	50                   	push   %eax
c04025e4:	e8 2e e0 ff ff       	call   c0400617 <unlock_gate>
c04025e9:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(receiver->lock), LOCK_READ);
c04025ec:	8b 44 24 20          	mov    0x20(%esp),%eax
c04025f0:	83 c0 1c             	add    $0x1c,%eax
c04025f3:	83 ec 08             	sub    $0x8,%esp
c04025f6:	6a 00                	push   $0x0
c04025f8:	50                   	push   %eax
c04025f9:	e8 19 e0 ff ff       	call   c0400617 <unlock_gate>
c04025fe:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402601:	b8 01 00 00 00       	mov    $0x1,%eax
c0402606:	eb 41                	jmp    c0402649 <msg_copy+0x168>
	}
	
	/* update offset */
	*(offset) += size;
c0402608:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040260c:	8b 00                	mov    (%eax),%eax
c040260e:	89 c2                	mov    %eax,%edx
c0402610:	03 54 24 28          	add    0x28(%esp),%edx
c0402614:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0402618:	89 10                	mov    %edx,(%eax)
	
	unlock_gate(&(sender->lock), LOCK_READ);
c040261a:	8b 44 24 30          	mov    0x30(%esp),%eax
c040261e:	83 c0 1c             	add    $0x1c,%eax
c0402621:	83 ec 08             	sub    $0x8,%esp
c0402624:	6a 00                	push   $0x0
c0402626:	50                   	push   %eax
c0402627:	e8 eb df ff ff       	call   c0400617 <unlock_gate>
c040262c:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(receiver->lock), LOCK_READ);
c040262f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402633:	83 c0 1c             	add    $0x1c,%eax
c0402636:	83 ec 08             	sub    $0x8,%esp
c0402639:	6a 00                	push   $0x0
c040263b:	50                   	push   %eax
c040263c:	e8 d6 df ff ff       	call   c0400617 <unlock_gate>
c0402641:	83 c4 10             	add    $0x10,%esp
	return success;
c0402644:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0402649:	83 c4 1c             	add    $0x1c,%esp
c040264c:	c3                   	ret    

c040264d <msg_send>:
   => sender = thread trying to send the message
      msg = message block
   <= 0 for success, or an error code
*/
kresult msg_send(thread *sender, diosix_msg_info *msg)
{
c040264d:	83 ec 2c             	sub    $0x2c,%esp
	thread *receiver;
	kresult err;
	unsigned int bytes_copied = 0, priority;
c0402650:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0402657:	00 
	diosix_msg_info *rmsg;

	/* sanity check the msg data */
	if(!msg || !sender) return e_bad_address;
c0402658:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c040265d:	74 07                	je     c0402666 <msg_send+0x19>
c040265f:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0402664:	75 0a                	jne    c0402670 <msg_send+0x23>
c0402666:	b8 11 00 00 00       	mov    $0x11,%eax
c040266b:	e9 eb 02 00 00       	jmp    c040295b <msg_send+0x30e>
	
	/* identify the receiver */
	receiver = msg_find_receiver(sender, msg);
c0402670:	83 ec 08             	sub    $0x8,%esp
c0402673:	ff 74 24 3c          	pushl  0x3c(%esp)
c0402677:	ff 74 24 3c          	pushl  0x3c(%esp)
c040267b:	e8 33 fd ff ff       	call   c04023b3 <msg_find_receiver>
c0402680:	83 c4 10             	add    $0x10,%esp
c0402683:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(!receiver) return e_no_receiver;
c0402687:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040268c:	75 0a                	jne    c0402698 <msg_send+0x4b>
c040268e:	b8 07 00 00 00       	mov    $0x7,%eax
c0402693:	e9 c3 02 00 00       	jmp    c040295b <msg_send+0x30e>
	
	/* copy the message data */
	if(msg->flags & DIOSIX_MSG_MULTIPART)
c0402698:	8b 44 24 34          	mov    0x34(%esp),%eax
c040269c:	8b 40 08             	mov    0x8(%eax),%eax
c040269f:	25 00 00 00 40       	and    $0x40000000,%eax
c04026a4:	85 c0                	test   %eax,%eax
c04026a6:	0f 84 99 00 00 00    	je     c0402745 <msg_send+0xf8>
	{
		/* gather the multipart message blocks */
		unsigned int loop;
		
		diosix_msg_multipart *parts = msg->send;
c04026ac:	8b 44 24 34          	mov    0x34(%esp),%eax
c04026b0:	8b 40 10             	mov    0x10(%eax),%eax
c04026b3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
c04026b7:	8b 44 24 34          	mov    0x34(%esp),%eax
c04026bb:	8b 40 0c             	mov    0xc(%eax),%eax
c04026be:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c04026c5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04026c9:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04026cc:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c04026d1:	76 0a                	jbe    c04026dd <msg_send+0x90>
			return e_bad_address;
c04026d3:	b8 11 00 00 00       	mov    $0x11,%eax
c04026d8:	e9 7e 02 00 00       	jmp    c040295b <msg_send+0x30e>
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c04026dd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c04026e4:	00 
c04026e5:	eb 4f                	jmp    c0402736 <msg_send+0xe9>
		{
			err = msg_copy(receiver, parts[loop].data, parts[loop].size, &bytes_copied, sender);
c04026e7:	8b 44 24 18          	mov    0x18(%esp),%eax
c04026eb:	c1 e0 03             	shl    $0x3,%eax
c04026ee:	03 44 24 1c          	add    0x1c(%esp),%eax
c04026f2:	8b 10                	mov    (%eax),%edx
c04026f4:	8b 44 24 18          	mov    0x18(%esp),%eax
c04026f8:	c1 e0 03             	shl    $0x3,%eax
c04026fb:	03 44 24 1c          	add    0x1c(%esp),%eax
c04026ff:	8b 40 04             	mov    0x4(%eax),%eax
c0402702:	83 ec 0c             	sub    $0xc,%esp
c0402705:	ff 74 24 3c          	pushl  0x3c(%esp)
c0402709:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c040270d:	51                   	push   %ecx
c040270e:	52                   	push   %edx
c040270f:	50                   	push   %eax
c0402710:	ff 74 24 28          	pushl  0x28(%esp)
c0402714:	e8 c8 fd ff ff       	call   c04024e1 <msg_copy>
c0402719:	83 c4 20             	add    $0x20,%esp
c040271c:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(err || (bytes_copied > DIOSIX_MSG_MAX_SIZE)) break;
c0402720:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0402725:	75 4c                	jne    c0402773 <msg_send+0x126>
c0402727:	8b 44 24 08          	mov    0x8(%esp),%eax
c040272b:	3d 00 40 00 00       	cmp    $0x4000,%eax
c0402730:	77 44                	ja     c0402776 <msg_send+0x129>
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
			return e_bad_address;
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c0402732:	ff 44 24 18          	incl   0x18(%esp)
c0402736:	8b 44 24 34          	mov    0x34(%esp),%eax
c040273a:	8b 40 0c             	mov    0xc(%eax),%eax
c040273d:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0402741:	77 a4                	ja     c04026e7 <msg_send+0x9a>
c0402743:	eb 32                	jmp    c0402777 <msg_send+0x12a>
			if(err || (bytes_copied > DIOSIX_MSG_MAX_SIZE)) break;
		}
	}
	else
		/* do a simple message copy */
		err = msg_copy(receiver, msg->send, msg->send_size, &bytes_copied, sender);
c0402745:	8b 44 24 34          	mov    0x34(%esp),%eax
c0402749:	8b 50 0c             	mov    0xc(%eax),%edx
c040274c:	8b 44 24 34          	mov    0x34(%esp),%eax
c0402750:	8b 40 10             	mov    0x10(%eax),%eax
c0402753:	83 ec 0c             	sub    $0xc,%esp
c0402756:	ff 74 24 3c          	pushl  0x3c(%esp)
c040275a:	8d 4c 24 18          	lea    0x18(%esp),%ecx
c040275e:	51                   	push   %ecx
c040275f:	52                   	push   %edx
c0402760:	50                   	push   %eax
c0402761:	ff 74 24 28          	pushl  0x28(%esp)
c0402765:	e8 77 fd ff ff       	call   c04024e1 <msg_copy>
c040276a:	83 c4 20             	add    $0x20,%esp
c040276d:	89 44 24 10          	mov    %eax,0x10(%esp)
c0402771:	eb 04                	jmp    c0402777 <msg_send+0x12a>
		/* check that the multipart pointer isn't bogus */
		if(((unsigned int)parts + (msg->send_size * sizeof(diosix_msg_multipart))) >= KERNEL_SPACE_BASE)
			return e_bad_address;
		
		/* do the multipart copy */
		for(loop = 0; loop < msg->send_size; loop++)
c0402773:	90                   	nop
c0402774:	eb 01                	jmp    c0402777 <msg_send+0x12a>
c0402776:	90                   	nop
	}
	else
		/* do a simple message copy */
		err = msg_copy(receiver, msg->send, msg->send_size, &bytes_copied, sender);
	
	if(err) return err;
c0402777:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040277c:	74 09                	je     c0402787 <msg_send+0x13a>
c040277e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0402782:	e9 d4 01 00 00       	jmp    c040295b <msg_send+0x30e>
	
	/* protect us from changes to the receiver's metadata */
	lock_gate(&(receiver->lock), LOCK_READ);
c0402787:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040278b:	83 c0 1c             	add    $0x1c,%eax
c040278e:	83 ec 08             	sub    $0x8,%esp
c0402791:	6a 00                	push   $0x0
c0402793:	50                   	push   %eax
c0402794:	e8 ff dc ff ff       	call   c0400498 <lock_gate>
c0402799:	83 c4 10             	add    $0x10,%esp
	
	/* update the sender's and receiver's message block*/
	msg->pid = receiver->proc->pid;
c040279c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04027a0:	8b 00                	mov    (%eax),%eax
c04027a2:	8b 10                	mov    (%eax),%edx
c04027a4:	8b 44 24 34          	mov    0x34(%esp),%eax
c04027a8:	89 10                	mov    %edx,(%eax)
	msg->tid = receiver->tid;
c04027aa:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04027ae:	8b 50 04             	mov    0x4(%eax),%edx
c04027b1:	8b 44 24 34          	mov    0x34(%esp),%eax
c04027b5:	89 50 04             	mov    %edx,0x4(%eax)
	
	/* don't forget that within the context of the sending thread we can't access the
	 receiver's msg structure unless we go via a kernel mapping.. */
	if(pg_user2kernel((unsigned int *)&rmsg, (unsigned int)(receiver->msg), receiver->proc))
c04027b8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04027bc:	8b 08                	mov    (%eax),%ecx
c04027be:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04027c2:	8b 40 18             	mov    0x18(%eax),%eax
c04027c5:	89 c2                	mov    %eax,%edx
c04027c7:	8d 44 24 04          	lea    0x4(%esp),%eax
c04027cb:	83 ec 04             	sub    $0x4,%esp
c04027ce:	51                   	push   %ecx
c04027cf:	52                   	push   %edx
c04027d0:	50                   	push   %eax
c04027d1:	e8 b6 53 00 00       	call   c0407b8c <pg_user2kernel>
c04027d6:	83 c4 10             	add    $0x10,%esp
c04027d9:	85 c0                	test   %eax,%eax
c04027db:	74 1f                	je     c04027fc <msg_send+0x1af>
	{
		unlock_gate(&(receiver->lock), LOCK_READ);
c04027dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04027e1:	83 c0 1c             	add    $0x1c,%eax
c04027e4:	83 ec 08             	sub    $0x8,%esp
c04027e7:	6a 00                	push   $0x0
c04027e9:	50                   	push   %eax
c04027ea:	e8 28 de ff ff       	call   c0400617 <unlock_gate>
c04027ef:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c04027f2:	b8 01 00 00 00       	mov    $0x1,%eax
c04027f7:	e9 5f 01 00 00       	jmp    c040295b <msg_send+0x30e>
	}

	/* protect us from changes to the sender's metadata */
	lock_gate(&(sender->lock), LOCK_READ);
c04027fc:	8b 44 24 30          	mov    0x30(%esp),%eax
c0402800:	83 c0 1c             	add    $0x1c,%eax
c0402803:	83 ec 08             	sub    $0x8,%esp
c0402806:	6a 00                	push   $0x0
c0402808:	50                   	push   %eax
c0402809:	e8 8a dc ff ff       	call   c0400498 <lock_gate>
c040280e:	83 c4 10             	add    $0x10,%esp
	
	rmsg->recv_size = bytes_copied;
c0402811:	8b 44 24 04          	mov    0x4(%esp),%eax
c0402815:	8b 54 24 08          	mov    0x8(%esp),%edx
c0402819:	89 50 18             	mov    %edx,0x18(%eax)
	rmsg->pid = sender->proc->pid;
c040281c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0402820:	8b 54 24 30          	mov    0x30(%esp),%edx
c0402824:	8b 12                	mov    (%edx),%edx
c0402826:	8b 12                	mov    (%edx),%edx
c0402828:	89 10                	mov    %edx,(%eax)
	rmsg->tid = sender->tid;
c040282a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040282e:	8b 54 24 30          	mov    0x30(%esp),%edx
c0402832:	8b 52 04             	mov    0x4(%edx),%edx
c0402835:	89 50 04             	mov    %edx,0x4(%eax)
	
	/* was the send a reply or an actual send? */
	if(msg->flags & DIOSIX_MSG_REPLY)
c0402838:	8b 44 24 34          	mov    0x34(%esp),%eax
c040283c:	8b 40 08             	mov    0x8(%eax),%eax
c040283f:	85 c0                	test   %eax,%eax
c0402841:	79 38                	jns    c040287b <msg_send+0x22e>
	{
		/* restore the receiver's priority if it was bumped up to send this reply */
		if(receiver->prev_priority > receiver->priority)
c0402843:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402847:	8a 50 0f             	mov    0xf(%eax),%dl
c040284a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040284e:	8a 40 0e             	mov    0xe(%eax),%al
c0402851:	38 c2                	cmp    %al,%dl
c0402853:	76 13                	jbe    c0402868 <msg_send+0x21b>
			priority = receiver->prev_priority;
c0402855:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402859:	8a 40 0f             	mov    0xf(%eax),%al
c040285c:	0f b6 c0             	movzbl %al,%eax
c040285f:	89 44 24 14          	mov    %eax,0x14(%esp)
		else
			priority = receiver->priority;
c0402863:	e9 a2 00 00 00       	jmp    c040290a <msg_send+0x2bd>
c0402868:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040286c:	8a 40 0e             	mov    0xe(%eax),%al
c040286f:	0f b6 c0             	movzbl %al,%eax
c0402872:	89 44 24 14          	mov    %eax,0x14(%esp)
c0402876:	e9 8f 00 00 00       	jmp    c040290a <msg_send+0x2bd>
	}
	else
	{		
		/* if the sent message wasn't a reply, block sending thread to wait for a reply */
		sched_remove(sender, waitingforreply);
c040287b:	83 ec 08             	sub    $0x8,%esp
c040287e:	6a 03                	push   $0x3
c0402880:	ff 74 24 3c          	pushl  0x3c(%esp)
c0402884:	e8 0e 0f 00 00       	call   c0403797 <sched_remove>
c0402889:	83 c4 10             	add    $0x10,%esp
		
		lock_gate(&(sender->lock), LOCK_WRITE);
c040288c:	8b 44 24 30          	mov    0x30(%esp),%eax
c0402890:	83 c0 1c             	add    $0x1c,%eax
c0402893:	83 ec 08             	sub    $0x8,%esp
c0402896:	6a 01                	push   $0x1
c0402898:	50                   	push   %eax
c0402899:	e8 fa db ff ff       	call   c0400498 <lock_gate>
c040289e:	83 c4 10             	add    $0x10,%esp

		sender->replysource = receiver;
c04028a1:	8b 44 24 30          	mov    0x30(%esp),%eax
c04028a5:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04028a9:	89 50 14             	mov    %edx,0x14(%eax)
		
		/* take a copy of the message block ptr */
		sender->msg = msg;
c04028ac:	8b 44 24 30          	mov    0x30(%esp),%eax
c04028b0:	8b 54 24 34          	mov    0x34(%esp),%edx
c04028b4:	89 50 18             	mov    %edx,0x18(%eax)

		unlock_gate(&(sender->lock), LOCK_WRITE);
c04028b7:	8b 44 24 30          	mov    0x30(%esp),%eax
c04028bb:	83 c0 1c             	add    $0x1c,%eax
c04028be:	83 ec 08             	sub    $0x8,%esp
c04028c1:	6a 01                	push   $0x1
c04028c3:	50                   	push   %eax
c04028c4:	e8 4e dd ff ff       	call   c0400617 <unlock_gate>
c04028c9:	83 c4 10             	add    $0x10,%esp
		
		/* bump the receiver's priority up if the sender has a higher priority to
		   avoid priority inversion */
		receiver->prev_priority = receiver->priority;
c04028cc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04028d0:	8a 50 0e             	mov    0xe(%eax),%dl
c04028d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04028d7:	88 50 0f             	mov    %dl,0xf(%eax)
		if(sender->priority < receiver->priority)
c04028da:	8b 44 24 30          	mov    0x30(%esp),%eax
c04028de:	8a 50 0e             	mov    0xe(%eax),%dl
c04028e1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04028e5:	8a 40 0e             	mov    0xe(%eax),%al
c04028e8:	38 c2                	cmp    %al,%dl
c04028ea:	73 10                	jae    c04028fc <msg_send+0x2af>
			priority = sender->priority;
c04028ec:	8b 44 24 30          	mov    0x30(%esp),%eax
c04028f0:	8a 40 0e             	mov    0xe(%eax),%al
c04028f3:	0f b6 c0             	movzbl %al,%eax
c04028f6:	89 44 24 14          	mov    %eax,0x14(%esp)
c04028fa:	eb 0e                	jmp    c040290a <msg_send+0x2bd>
		else
			priority = receiver->priority;		
c04028fc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402900:	8a 40 0e             	mov    0xe(%eax),%al
c0402903:	0f b6 c0             	movzbl %al,%eax
c0402906:	89 44 24 14          	mov    %eax,0x14(%esp)
	}

	unlock_gate(&(sender->lock), LOCK_READ);
c040290a:	8b 44 24 30          	mov    0x30(%esp),%eax
c040290e:	83 c0 1c             	add    $0x1c,%eax
c0402911:	83 ec 08             	sub    $0x8,%esp
c0402914:	6a 00                	push   $0x0
c0402916:	50                   	push   %eax
c0402917:	e8 fb dc ff ff       	call   c0400617 <unlock_gate>
c040291c:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(receiver->lock), LOCK_READ);
c040291f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0402923:	83 c0 1c             	add    $0x1c,%eax
c0402926:	83 ec 08             	sub    $0x8,%esp
c0402929:	6a 00                	push   $0x0
c040292b:	50                   	push   %eax
c040292c:	e8 e6 dc ff ff       	call   c0400617 <unlock_gate>
c0402931:	83 c4 10             	add    $0x10,%esp
	
	/* wake up the receiving thread */
	sched_add(receiver->cpu, priority, receiver);
c0402934:	8b 44 24 14          	mov    0x14(%esp),%eax
c0402938:	0f b6 d0             	movzbl %al,%edx
c040293b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040293f:	8b 40 08             	mov    0x8(%eax),%eax
c0402942:	0f b6 c0             	movzbl %al,%eax
c0402945:	83 ec 04             	sub    $0x4,%esp
c0402948:	ff 74 24 10          	pushl  0x10(%esp)
c040294c:	52                   	push   %edx
c040294d:	50                   	push   %eax
c040294e:	e8 74 0c 00 00       	call   c04035c7 <sched_add>
c0402953:	83 c4 10             	add    $0x10,%esp

	MSG_DEBUG("[msg:%x] thread %i of process %i sent message %x (%i bytes first word %x) to thread %i of process %i\n",
			    CPU_ID, sender->tid, sender->proc->pid, msg->send, msg->send_size, *((unsigned int *)msg->send),
			    receiver->tid, receiver->proc->pid);
	
	return success;
c0402956:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040295b:	83 c4 2c             	add    $0x2c,%esp
c040295e:	c3                   	ret    

c040295f <msg_recv>:
   => receiver = thread waiting to receive
		info = block to fill with received message details
   <= success or an error code
*/
kresult msg_recv(thread *receiver, diosix_msg_info *msg)
{
c040295f:	83 ec 0c             	sub    $0xc,%esp
	/* basic sanity checks */
	if(!receiver || !msg) return e_bad_address;
c0402962:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0402967:	74 07                	je     c0402970 <msg_recv+0x11>
c0402969:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c040296e:	75 07                	jne    c0402977 <msg_recv+0x18>
c0402970:	b8 11 00 00 00       	mov    $0x11,%eax
c0402975:	eb 7d                	jmp    c04029f4 <msg_recv+0x95>
	if(((unsigned int)msg + sizeof(diosix_msg_info)) >= KERNEL_SPACE_BASE)
c0402977:	8b 44 24 14          	mov    0x14(%esp),%eax
c040297b:	83 c0 20             	add    $0x20,%eax
c040297e:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0402983:	76 07                	jbe    c040298c <msg_recv+0x2d>
		return e_bad_address;
c0402985:	b8 11 00 00 00       	mov    $0x11,%eax
c040298a:	eb 68                	jmp    c04029f4 <msg_recv+0x95>
	if(!(msg->recv) || !(msg->recv_max_size)) return e_bad_address;
c040298c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0402990:	8b 40 1c             	mov    0x1c(%eax),%eax
c0402993:	85 c0                	test   %eax,%eax
c0402995:	74 0b                	je     c04029a2 <msg_recv+0x43>
c0402997:	8b 44 24 14          	mov    0x14(%esp),%eax
c040299b:	8b 40 14             	mov    0x14(%eax),%eax
c040299e:	85 c0                	test   %eax,%eax
c04029a0:	75 07                	jne    c04029a9 <msg_recv+0x4a>
c04029a2:	b8 11 00 00 00       	mov    $0x11,%eax
c04029a7:	eb 4b                	jmp    c04029f4 <msg_recv+0x95>
	
	/* keep a copy of this pointer */
	lock_gate(&(receiver->lock), LOCK_WRITE);
c04029a9:	8b 44 24 10          	mov    0x10(%esp),%eax
c04029ad:	83 c0 1c             	add    $0x1c,%eax
c04029b0:	83 ec 08             	sub    $0x8,%esp
c04029b3:	6a 01                	push   $0x1
c04029b5:	50                   	push   %eax
c04029b6:	e8 dd da ff ff       	call   c0400498 <lock_gate>
c04029bb:	83 c4 10             	add    $0x10,%esp
	receiver->msg = msg;
c04029be:	8b 44 24 10          	mov    0x10(%esp),%eax
c04029c2:	8b 54 24 14          	mov    0x14(%esp),%edx
c04029c6:	89 50 18             	mov    %edx,0x18(%eax)
	unlock_gate(&(receiver->lock), LOCK_WRITE);
c04029c9:	8b 44 24 10          	mov    0x10(%esp),%eax
c04029cd:	83 c0 1c             	add    $0x1c,%eax
c04029d0:	83 ec 08             	sub    $0x8,%esp
c04029d3:	6a 01                	push   $0x1
c04029d5:	50                   	push   %eax
c04029d6:	e8 3c dc ff ff       	call   c0400617 <unlock_gate>
c04029db:	83 c4 10             	add    $0x10,%esp

	/* remove receiver from the queue until a message comes in */
	sched_remove(receiver, waitingformsg);
c04029de:	83 ec 08             	sub    $0x8,%esp
c04029e1:	6a 04                	push   $0x4
c04029e3:	ff 74 24 1c          	pushl  0x1c(%esp)
c04029e7:	e8 ab 0d 00 00       	call   c0403797 <sched_remove>
c04029ec:	83 c4 10             	add    $0x10,%esp
	
	MSG_DEBUG("[msg:%i] tid %i pid %i now receiving (%p)\n", CPU_ID, receiver->tid, receiver->proc->pid, msg);

	return success;
c04029ef:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04029f4:	83 c4 0c             	add    $0xc,%esp
c04029f7:	c3                   	ret    

c04029f8 <sched_inc_queued_threads>:
unsigned int sched_total_queued = 0; /* number of threads queued */

/* sched_inc_queued_threads
 Increment the number of queued threads total in a thread-safe manner */
void sched_inc_queued_threads(void)
{	
c04029f8:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(sched_lock), LOCK_WRITE);
c04029fb:	83 ec 08             	sub    $0x8,%esp
c04029fe:	6a 01                	push   $0x1
c0402a00:	68 70 f4 40 c0       	push   $0xc040f470
c0402a05:	e8 8e da ff ff       	call   c0400498 <lock_gate>
c0402a0a:	83 c4 10             	add    $0x10,%esp
	sched_total_queued++;
c0402a0d:	a1 f0 1c 41 c0       	mov    0xc0411cf0,%eax
c0402a12:	40                   	inc    %eax
c0402a13:	a3 f0 1c 41 c0       	mov    %eax,0xc0411cf0
	unlock_gate(&(sched_lock), LOCK_WRITE);
c0402a18:	83 ec 08             	sub    $0x8,%esp
c0402a1b:	6a 01                	push   $0x1
c0402a1d:	68 70 f4 40 c0       	push   $0xc040f470
c0402a22:	e8 f0 db ff ff       	call   c0400617 <unlock_gate>
c0402a27:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] total queued threads now: %i (up one)\n", CPU_ID, sched_total_queued);
}
c0402a2a:	83 c4 0c             	add    $0xc,%esp
c0402a2d:	c3                   	ret    

c0402a2e <sched_dec_queued_threads>:

/* sched_dec_queued_threads
   Decrement the number of queued threads total in a thread-safe manner */
void sched_dec_queued_threads(void)
{
c0402a2e:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(sched_lock), LOCK_WRITE);
c0402a31:	83 ec 08             	sub    $0x8,%esp
c0402a34:	6a 01                	push   $0x1
c0402a36:	68 70 f4 40 c0       	push   $0xc040f470
c0402a3b:	e8 58 da ff ff       	call   c0400498 <lock_gate>
c0402a40:	83 c4 10             	add    $0x10,%esp
	sched_total_queued--;
c0402a43:	a1 f0 1c 41 c0       	mov    0xc0411cf0,%eax
c0402a48:	48                   	dec    %eax
c0402a49:	a3 f0 1c 41 c0       	mov    %eax,0xc0411cf0
	unlock_gate(&(sched_lock), LOCK_WRITE);
c0402a4e:	83 ec 08             	sub    $0x8,%esp
c0402a51:	6a 01                	push   $0x1
c0402a53:	68 70 f4 40 c0       	push   $0xc040f470
c0402a58:	e8 ba db ff ff       	call   c0400617 <unlock_gate>
c0402a5d:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] total queued threads now: %i (down one)\n", CPU_ID, sched_total_queued);
}
c0402a60:	83 c4 0c             	add    $0xc,%esp
c0402a63:	c3                   	ret    

c0402a64 <sched_lock_thread>:
 on exit from this function.
 => victim = thread to pause
 <= success or a failure code
 */
kresult sched_lock_thread(thread *victim)
{
c0402a64:	83 ec 1c             	sub    $0x1c,%esp
	unsigned char id = CPU_ID;
c0402a67:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402a6c:	3c 01                	cmp    $0x1,%al
c0402a6e:	76 0c                	jbe    c0402a7c <sched_lock_thread+0x18>
c0402a70:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402a75:	8b 00                	mov    (%eax),%eax
c0402a77:	c1 e8 18             	shr    $0x18,%eax
c0402a7a:	eb 05                	jmp    c0402a81 <sched_lock_thread+0x1d>
c0402a7c:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0402a81:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!victim) return e_failure;
c0402a85:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0402a8a:	75 0a                	jne    c0402a96 <sched_lock_thread+0x32>
c0402a8c:	b8 01 00 00 00       	mov    $0x1,%eax
c0402a91:	e9 cb 00 00 00       	jmp    c0402b61 <sched_lock_thread+0xfd>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402a96:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402a9b:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402aa0:	c1 e2 06             	shl    $0x6,%edx
c0402aa3:	01 d0                	add    %edx,%eax
c0402aa5:	83 c0 08             	add    $0x8,%eax
c0402aa8:	83 ec 08             	sub    $0x8,%esp
c0402aab:	6a 00                	push   $0x0
c0402aad:	50                   	push   %eax
c0402aae:	e8 e5 d9 ff ff       	call   c0400498 <lock_gate>
c0402ab3:	83 c4 10             	add    $0x10,%esp
	
	if(victim == cpu_table[id].current)
c0402ab6:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402abb:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402ac0:	c1 e2 06             	shl    $0x6,%edx
c0402ac3:	01 d0                	add    %edx,%eax
c0402ac5:	8b 40 04             	mov    0x4(%eax),%eax
c0402ac8:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0402acc:	75 27                	jne    c0402af5 <sched_lock_thread+0x91>
	{
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402ace:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402ad3:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402ad8:	c1 e2 06             	shl    $0x6,%edx
c0402adb:	01 d0                	add    %edx,%eax
c0402add:	83 c0 08             	add    $0x8,%eax
c0402ae0:	83 ec 08             	sub    $0x8,%esp
c0402ae3:	6a 00                	push   $0x0
c0402ae5:	50                   	push   %eax
c0402ae6:	e8 2c db ff ff       	call   c0400617 <unlock_gate>
c0402aeb:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402aee:	b8 01 00 00 00       	mov    $0x1,%eax
c0402af3:	eb 6c                	jmp    c0402b61 <sched_lock_thread+0xfd>
	}
	
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402af5:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402afa:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402aff:	c1 e2 06             	shl    $0x6,%edx
c0402b02:	01 d0                	add    %edx,%eax
c0402b04:	83 c0 08             	add    $0x8,%eax
c0402b07:	83 ec 08             	sub    $0x8,%esp
c0402b0a:	6a 00                	push   $0x0
c0402b0c:	50                   	push   %eax
c0402b0d:	e8 05 db ff ff       	call   c0400617 <unlock_gate>
c0402b12:	83 c4 10             	add    $0x10,%esp
	
	/* if the process is running then interrupt the other cpu */
	lock_gate(&(victim->lock), LOCK_READ);
c0402b15:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402b19:	83 c0 1c             	add    $0x1c,%eax
c0402b1c:	83 ec 08             	sub    $0x8,%esp
c0402b1f:	6a 00                	push   $0x0
c0402b21:	50                   	push   %eax
c0402b22:	e8 71 d9 ff ff       	call   c0400498 <lock_gate>
c0402b27:	83 c4 10             	add    $0x10,%esp
	
	if(victim->state == inrunqueue)
c0402b2a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402b2e:	8b 40 10             	mov    0x10(%eax),%eax
c0402b31:	83 f8 01             	cmp    $0x1,%eax
c0402b34:	75 11                	jne    c0402b47 <sched_lock_thread+0xe3>
		sched_remove(victim, held);
c0402b36:	83 ec 08             	sub    $0x8,%esp
c0402b39:	6a 05                	push   $0x5
c0402b3b:	ff 74 24 2c          	pushl  0x2c(%esp)
c0402b3f:	e8 53 0c 00 00       	call   c0403797 <sched_remove>
c0402b44:	83 c4 10             	add    $0x10,%esp
	
	unlock_gate(&(victim->lock), LOCK_READ);
c0402b47:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402b4b:	83 c0 1c             	add    $0x1c,%eax
c0402b4e:	83 ec 08             	sub    $0x8,%esp
c0402b51:	6a 00                	push   $0x0
c0402b53:	50                   	push   %eax
c0402b54:	e8 be da ff ff       	call   c0400617 <unlock_gate>
c0402b59:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0402b5c:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0402b61:	83 c4 1c             	add    $0x1c,%esp
c0402b64:	c3                   	ret    

c0402b65 <sched_lock_proc>:
	on exit from this function.
	=> proc = process to pause
   <= success or a failure code
*/
kresult sched_lock_proc(process *proc)
{
c0402b65:	83 ec 1c             	sub    $0x1c,%esp
	thread *t;
	unsigned char id = CPU_ID;
c0402b68:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402b6d:	3c 01                	cmp    $0x1,%al
c0402b6f:	76 0c                	jbe    c0402b7d <sched_lock_proc+0x18>
c0402b71:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402b76:	8b 00                	mov    (%eax),%eax
c0402b78:	c1 e8 18             	shr    $0x18,%eax
c0402b7b:	eb 05                	jmp    c0402b82 <sched_lock_proc+0x1d>
c0402b7d:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0402b82:	88 44 24 07          	mov    %al,0x7(%esp)
	unsigned int loop, tfound;
	
	if(!proc) return e_failure;
c0402b86:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0402b8b:	75 0a                	jne    c0402b97 <sched_lock_proc+0x32>
c0402b8d:	b8 01 00 00 00       	mov    $0x1,%eax
c0402b92:	e9 b8 01 00 00       	jmp    c0402d4f <sched_lock_proc+0x1ea>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402b97:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402b9c:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402ba1:	c1 e2 06             	shl    $0x6,%edx
c0402ba4:	01 d0                	add    %edx,%eax
c0402ba6:	83 c0 08             	add    $0x8,%eax
c0402ba9:	83 ec 08             	sub    $0x8,%esp
c0402bac:	6a 00                	push   $0x0
c0402bae:	50                   	push   %eax
c0402baf:	e8 e4 d8 ff ff       	call   c0400498 <lock_gate>
c0402bb4:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402bb7:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402bbc:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402bc1:	c1 e2 06             	shl    $0x6,%edx
c0402bc4:	01 d0                	add    %edx,%eax
c0402bc6:	8b 40 04             	mov    0x4(%eax),%eax
c0402bc9:	83 c0 1c             	add    $0x1c,%eax
c0402bcc:	83 ec 08             	sub    $0x8,%esp
c0402bcf:	6a 00                	push   $0x0
c0402bd1:	50                   	push   %eax
c0402bd2:	e8 c1 d8 ff ff       	call   c0400498 <lock_gate>
c0402bd7:	83 c4 10             	add    $0x10,%esp
	
	if(proc == cpu_table[id].current->proc)
c0402bda:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402bdf:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402be4:	c1 e2 06             	shl    $0x6,%edx
c0402be7:	01 d0                	add    %edx,%eax
c0402be9:	8b 40 04             	mov    0x4(%eax),%eax
c0402bec:	8b 00                	mov    (%eax),%eax
c0402bee:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0402bf2:	75 4d                	jne    c0402c41 <sched_lock_proc+0xdc>
	{
		unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402bf4:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402bf9:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402bfe:	c1 e2 06             	shl    $0x6,%edx
c0402c01:	01 d0                	add    %edx,%eax
c0402c03:	8b 40 04             	mov    0x4(%eax),%eax
c0402c06:	83 c0 1c             	add    $0x1c,%eax
c0402c09:	83 ec 08             	sub    $0x8,%esp
c0402c0c:	6a 00                	push   $0x0
c0402c0e:	50                   	push   %eax
c0402c0f:	e8 03 da ff ff       	call   c0400617 <unlock_gate>
c0402c14:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402c17:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402c1c:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402c21:	c1 e2 06             	shl    $0x6,%edx
c0402c24:	01 d0                	add    %edx,%eax
c0402c26:	83 c0 08             	add    $0x8,%eax
c0402c29:	83 ec 08             	sub    $0x8,%esp
c0402c2c:	6a 00                	push   $0x0
c0402c2e:	50                   	push   %eax
c0402c2f:	e8 e3 d9 ff ff       	call   c0400617 <unlock_gate>
c0402c34:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402c37:	b8 01 00 00 00       	mov    $0x1,%eax
c0402c3c:	e9 0e 01 00 00       	jmp    c0402d4f <sched_lock_proc+0x1ea>
	}

	unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402c41:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402c46:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402c4b:	c1 e2 06             	shl    $0x6,%edx
c0402c4e:	01 d0                	add    %edx,%eax
c0402c50:	8b 40 04             	mov    0x4(%eax),%eax
c0402c53:	83 c0 1c             	add    $0x1c,%eax
c0402c56:	83 ec 08             	sub    $0x8,%esp
c0402c59:	6a 00                	push   $0x0
c0402c5b:	50                   	push   %eax
c0402c5c:	e8 b6 d9 ff ff       	call   c0400617 <unlock_gate>
c0402c61:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402c64:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402c69:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c0402c6e:	c1 e2 06             	shl    $0x6,%edx
c0402c71:	01 d0                	add    %edx,%eax
c0402c73:	83 c0 08             	add    $0x8,%eax
c0402c76:	83 ec 08             	sub    $0x8,%esp
c0402c79:	6a 00                	push   $0x0
c0402c7b:	50                   	push   %eax
c0402c7c:	e8 96 d9 ff ff       	call   c0400617 <unlock_gate>
c0402c81:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] locking process %i (%p)\n", CPU_ID, proc->pid, proc);
	
	/* make sure we're the only one's updating this process */
	lock_gate(&(proc->lock), LOCK_WRITE);
c0402c84:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402c88:	83 c0 10             	add    $0x10,%eax
c0402c8b:	83 ec 08             	sub    $0x8,%esp
c0402c8e:	6a 01                	push   $0x1
c0402c90:	50                   	push   %eax
c0402c91:	e8 02 d8 ff ff       	call   c0400498 <lock_gate>
c0402c96:	83 c4 10             	add    $0x10,%esp
	
	/* warn the scheduler not to run threads in this process */
	proc->flags |= PROC_FLAG_RUNLOCKED;
c0402c99:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402c9d:	8a 40 0d             	mov    0xd(%eax),%al
c0402ca0:	88 c2                	mov    %al,%dl
c0402ca2:	83 ca 01             	or     $0x1,%edx
c0402ca5:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402ca9:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0402cac:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0402cb3:	00 
c0402cb4:	eb 75                	jmp    c0402d2b <sched_lock_proc+0x1c6>
	{
		t = proc->threads[loop];
c0402cb6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402cba:	8b 40 38             	mov    0x38(%eax),%eax
c0402cbd:	8b 54 24 08          	mov    0x8(%esp),%edx
c0402cc1:	c1 e2 02             	shl    $0x2,%edx
c0402cc4:	01 d0                	add    %edx,%eax
c0402cc6:	8b 00                	mov    (%eax),%eax
c0402cc8:	89 04 24             	mov    %eax,(%esp)
		while(t)
c0402ccb:	eb 47                	jmp    c0402d14 <sched_lock_proc+0x1af>
		{
			
			sched_lock_thread(t);
c0402ccd:	83 ec 0c             	sub    $0xc,%esp
c0402cd0:	ff 74 24 0c          	pushl  0xc(%esp)
c0402cd4:	e8 8b fd ff ff       	call   c0402a64 <sched_lock_thread>
c0402cd9:	83 c4 10             	add    $0x10,%esp
			tfound++;
c0402cdc:	ff 44 24 0c          	incl   0xc(%esp)
			
			/* try the next thread */
			lock_gate(&(t->lock), LOCK_READ);
c0402ce0:	8b 04 24             	mov    (%esp),%eax
c0402ce3:	83 c0 1c             	add    $0x1c,%eax
c0402ce6:	83 ec 08             	sub    $0x8,%esp
c0402ce9:	6a 00                	push   $0x0
c0402ceb:	50                   	push   %eax
c0402cec:	e8 a7 d7 ff ff       	call   c0400498 <lock_gate>
c0402cf1:	83 c4 10             	add    $0x10,%esp
			t = t->hash_next;
c0402cf4:	8b 04 24             	mov    (%esp),%eax
c0402cf7:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0402cfd:	89 04 24             	mov    %eax,(%esp)
			unlock_gate(&(t->lock), LOCK_READ);
c0402d00:	8b 04 24             	mov    (%esp),%eax
c0402d03:	83 c0 1c             	add    $0x1c,%eax
c0402d06:	83 ec 08             	sub    $0x8,%esp
c0402d09:	6a 00                	push   $0x0
c0402d0b:	50                   	push   %eax
c0402d0c:	e8 06 d9 ff ff       	call   c0400617 <unlock_gate>
c0402d11:	83 c4 10             	add    $0x10,%esp
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
	{
		t = proc->threads[loop];
		while(t)
c0402d14:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0402d18:	75 b3                	jne    c0402ccd <sched_lock_proc+0x168>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0402d1a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402d1e:	8b 40 3c             	mov    0x3c(%eax),%eax
c0402d21:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0402d25:	76 0d                	jbe    c0402d34 <sched_lock_proc+0x1cf>
	
	/* warn the scheduler not to run threads in this process */
	proc->flags |= PROC_FLAG_RUNLOCKED;
	
	/* loop through the threads making sure none are running */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0402d27:	ff 44 24 08          	incl   0x8(%esp)
c0402d2b:	83 7c 24 08 3f       	cmpl   $0x3f,0x8(%esp)
c0402d30:	76 84                	jbe    c0402cb6 <sched_lock_proc+0x151>
c0402d32:	eb 01                	jmp    c0402d35 <sched_lock_proc+0x1d0>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0402d34:	90                   	nop
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0402d35:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402d39:	83 c0 10             	add    $0x10,%eax
c0402d3c:	83 ec 08             	sub    $0x8,%esp
c0402d3f:	6a 01                	push   $0x1
c0402d41:	50                   	push   %eax
c0402d42:	e8 d0 d8 ff ff       	call   c0400617 <unlock_gate>
c0402d47:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0402d4a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0402d4f:	83 c4 1c             	add    $0x1c,%esp
c0402d52:	c3                   	ret    

c0402d53 <sched_unlock_thread>:
 somehow wake itself up.
 => proc = process to release
 <= success or a failure code
 */
kresult sched_unlock_thread(thread *towake)
{
c0402d53:	83 ec 1c             	sub    $0x1c,%esp
	unsigned char id = CPU_ID;
c0402d56:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402d5b:	3c 01                	cmp    $0x1,%al
c0402d5d:	76 0c                	jbe    c0402d6b <sched_unlock_thread+0x18>
c0402d5f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402d64:	8b 00                	mov    (%eax),%eax
c0402d66:	c1 e8 18             	shr    $0x18,%eax
c0402d69:	eb 05                	jmp    c0402d70 <sched_unlock_thread+0x1d>
c0402d6b:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0402d70:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!towake) return e_failure;
c0402d74:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0402d79:	75 0a                	jne    c0402d85 <sched_unlock_thread+0x32>
c0402d7b:	b8 01 00 00 00       	mov    $0x1,%eax
c0402d80:	e9 13 01 00 00       	jmp    c0402e98 <sched_unlock_thread+0x145>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402d85:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402d8a:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402d8f:	c1 e2 06             	shl    $0x6,%edx
c0402d92:	01 d0                	add    %edx,%eax
c0402d94:	83 c0 08             	add    $0x8,%eax
c0402d97:	83 ec 08             	sub    $0x8,%esp
c0402d9a:	6a 00                	push   $0x0
c0402d9c:	50                   	push   %eax
c0402d9d:	e8 f6 d6 ff ff       	call   c0400498 <lock_gate>
c0402da2:	83 c4 10             	add    $0x10,%esp
	
	if(towake == cpu_table[id].current)
c0402da5:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402daa:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402daf:	c1 e2 06             	shl    $0x6,%edx
c0402db2:	01 d0                	add    %edx,%eax
c0402db4:	8b 40 04             	mov    0x4(%eax),%eax
c0402db7:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0402dbb:	75 2a                	jne    c0402de7 <sched_unlock_thread+0x94>
	{
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402dbd:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402dc2:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402dc7:	c1 e2 06             	shl    $0x6,%edx
c0402dca:	01 d0                	add    %edx,%eax
c0402dcc:	83 c0 08             	add    $0x8,%eax
c0402dcf:	83 ec 08             	sub    $0x8,%esp
c0402dd2:	6a 00                	push   $0x0
c0402dd4:	50                   	push   %eax
c0402dd5:	e8 3d d8 ff ff       	call   c0400617 <unlock_gate>
c0402dda:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402ddd:	b8 01 00 00 00       	mov    $0x1,%eax
c0402de2:	e9 b1 00 00 00       	jmp    c0402e98 <sched_unlock_thread+0x145>
	}
	
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402de7:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402dec:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402df1:	c1 e2 06             	shl    $0x6,%edx
c0402df4:	01 d0                	add    %edx,%eax
c0402df6:	83 c0 08             	add    $0x8,%eax
c0402df9:	83 ec 08             	sub    $0x8,%esp
c0402dfc:	6a 00                	push   $0x0
c0402dfe:	50                   	push   %eax
c0402dff:	e8 13 d8 ff ff       	call   c0400617 <unlock_gate>
c0402e04:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(towake->lock), LOCK_READ);
c0402e07:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e0b:	83 c0 1c             	add    $0x1c,%eax
c0402e0e:	83 ec 08             	sub    $0x8,%esp
c0402e11:	6a 00                	push   $0x0
c0402e13:	50                   	push   %eax
c0402e14:	e8 7f d6 ff ff       	call   c0400498 <lock_gate>
c0402e19:	83 c4 10             	add    $0x10,%esp
	
	/* if the thread is held then put it back on the run queue, but 
	   don't requeue if the whole process is blocked */
	if(towake->state == held && !(towake->proc->flags & PROC_FLAG_RUNLOCKED))
c0402e1c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e20:	8b 40 10             	mov    0x10(%eax),%eax
c0402e23:	83 f8 05             	cmp    $0x5,%eax
c0402e26:	75 56                	jne    c0402e7e <sched_unlock_thread+0x12b>
c0402e28:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e2c:	8b 00                	mov    (%eax),%eax
c0402e2e:	8a 40 0d             	mov    0xd(%eax),%al
c0402e31:	0f b6 c0             	movzbl %al,%eax
c0402e34:	83 e0 01             	and    $0x1,%eax
c0402e37:	85 c0                	test   %eax,%eax
c0402e39:	75 43                	jne    c0402e7e <sched_unlock_thread+0x12b>
		sched_add(towake->proc->cpu, towake->priority, towake);
c0402e3b:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e3f:	8a 40 0e             	mov    0xe(%eax),%al
c0402e42:	0f b6 d0             	movzbl %al,%edx
c0402e45:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e49:	8b 00                	mov    (%eax),%eax
c0402e4b:	8a 40 0c             	mov    0xc(%eax),%al
c0402e4e:	0f b6 c0             	movzbl %al,%eax
c0402e51:	83 ec 04             	sub    $0x4,%esp
c0402e54:	ff 74 24 24          	pushl  0x24(%esp)
c0402e58:	52                   	push   %edx
c0402e59:	50                   	push   %eax
c0402e5a:	e8 68 07 00 00       	call   c04035c7 <sched_add>
c0402e5f:	83 c4 10             	add    $0x10,%esp
	{
		unlock_gate(&(towake->lock), LOCK_READ);
		return e_failure;
	}

	unlock_gate(&(towake->lock), LOCK_READ);
c0402e62:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e66:	83 c0 1c             	add    $0x1c,%eax
c0402e69:	83 ec 08             	sub    $0x8,%esp
c0402e6c:	6a 00                	push   $0x0
c0402e6e:	50                   	push   %eax
c0402e6f:	e8 a3 d7 ff ff       	call   c0400617 <unlock_gate>
c0402e74:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0402e77:	b8 00 00 00 00       	mov    $0x0,%eax
c0402e7c:	eb 1a                	jmp    c0402e98 <sched_unlock_thread+0x145>
	   don't requeue if the whole process is blocked */
	if(towake->state == held && !(towake->proc->flags & PROC_FLAG_RUNLOCKED))
		sched_add(towake->proc->cpu, towake->priority, towake);
	else
	{
		unlock_gate(&(towake->lock), LOCK_READ);
c0402e7e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402e82:	83 c0 1c             	add    $0x1c,%eax
c0402e85:	83 ec 08             	sub    $0x8,%esp
c0402e88:	6a 00                	push   $0x0
c0402e8a:	50                   	push   %eax
c0402e8b:	e8 87 d7 ff ff       	call   c0400617 <unlock_gate>
c0402e90:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402e93:	b8 01 00 00 00       	mov    $0x1,%eax
	}

	unlock_gate(&(towake->lock), LOCK_READ);
	
	return success;
}
c0402e98:	83 c4 1c             	add    $0x1c,%esp
c0402e9b:	c3                   	ret    

c0402e9c <sched_unlock_proc>:
   somehow wake itself up.
   => proc = process to release
   <= success or a failure code
*/
kresult sched_unlock_proc(process *proc)
{
c0402e9c:	83 ec 1c             	sub    $0x1c,%esp
	thread *t;
	unsigned int loop, tfound;
	unsigned char id = CPU_ID;
c0402e9f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0402ea4:	3c 01                	cmp    $0x1,%al
c0402ea6:	76 0c                	jbe    c0402eb4 <sched_unlock_proc+0x18>
c0402ea8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0402ead:	8b 00                	mov    (%eax),%eax
c0402eaf:	c1 e8 18             	shr    $0x18,%eax
c0402eb2:	eb 05                	jmp    c0402eb9 <sched_unlock_proc+0x1d>
c0402eb4:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0402eb9:	88 44 24 0f          	mov    %al,0xf(%esp)
	
	if(!proc) return e_failure;
c0402ebd:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0402ec2:	75 0a                	jne    c0402ece <sched_unlock_proc+0x32>
c0402ec4:	b8 01 00 00 00       	mov    $0x1,%eax
c0402ec9:	e9 b8 01 00 00       	jmp    c0403086 <sched_unlock_proc+0x1ea>
	
	lock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402ece:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402ed3:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402ed8:	c1 e2 06             	shl    $0x6,%edx
c0402edb:	01 d0                	add    %edx,%eax
c0402edd:	83 c0 08             	add    $0x8,%eax
c0402ee0:	83 ec 08             	sub    $0x8,%esp
c0402ee3:	6a 00                	push   $0x0
c0402ee5:	50                   	push   %eax
c0402ee6:	e8 ad d5 ff ff       	call   c0400498 <lock_gate>
c0402eeb:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402eee:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402ef3:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402ef8:	c1 e2 06             	shl    $0x6,%edx
c0402efb:	01 d0                	add    %edx,%eax
c0402efd:	8b 40 04             	mov    0x4(%eax),%eax
c0402f00:	83 c0 1c             	add    $0x1c,%eax
c0402f03:	83 ec 08             	sub    $0x8,%esp
c0402f06:	6a 00                	push   $0x0
c0402f08:	50                   	push   %eax
c0402f09:	e8 8a d5 ff ff       	call   c0400498 <lock_gate>
c0402f0e:	83 c4 10             	add    $0x10,%esp
	
	if(proc == cpu_table[id].current->proc)
c0402f11:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402f16:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402f1b:	c1 e2 06             	shl    $0x6,%edx
c0402f1e:	01 d0                	add    %edx,%eax
c0402f20:	8b 40 04             	mov    0x4(%eax),%eax
c0402f23:	8b 00                	mov    (%eax),%eax
c0402f25:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0402f29:	75 4d                	jne    c0402f78 <sched_unlock_proc+0xdc>
	{
		unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402f2b:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402f30:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402f35:	c1 e2 06             	shl    $0x6,%edx
c0402f38:	01 d0                	add    %edx,%eax
c0402f3a:	8b 40 04             	mov    0x4(%eax),%eax
c0402f3d:	83 c0 1c             	add    $0x1c,%eax
c0402f40:	83 ec 08             	sub    $0x8,%esp
c0402f43:	6a 00                	push   $0x0
c0402f45:	50                   	push   %eax
c0402f46:	e8 cc d6 ff ff       	call   c0400617 <unlock_gate>
c0402f4b:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402f4e:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402f53:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402f58:	c1 e2 06             	shl    $0x6,%edx
c0402f5b:	01 d0                	add    %edx,%eax
c0402f5d:	83 c0 08             	add    $0x8,%eax
c0402f60:	83 ec 08             	sub    $0x8,%esp
c0402f63:	6a 00                	push   $0x0
c0402f65:	50                   	push   %eax
c0402f66:	e8 ac d6 ff ff       	call   c0400617 <unlock_gate>
c0402f6b:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0402f6e:	b8 01 00 00 00       	mov    $0x1,%eax
c0402f73:	e9 0e 01 00 00       	jmp    c0403086 <sched_unlock_proc+0x1ea>
	}
	
	unlock_gate(&(cpu_table[id].current->lock), LOCK_READ);
c0402f78:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402f7d:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402f82:	c1 e2 06             	shl    $0x6,%edx
c0402f85:	01 d0                	add    %edx,%eax
c0402f87:	8b 40 04             	mov    0x4(%eax),%eax
c0402f8a:	83 c0 1c             	add    $0x1c,%eax
c0402f8d:	83 ec 08             	sub    $0x8,%esp
c0402f90:	6a 00                	push   $0x0
c0402f92:	50                   	push   %eax
c0402f93:	e8 7f d6 ff ff       	call   c0400617 <unlock_gate>
c0402f98:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[id].lock), LOCK_READ);
c0402f9b:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0402fa0:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
c0402fa5:	c1 e2 06             	shl    $0x6,%edx
c0402fa8:	01 d0                	add    %edx,%eax
c0402faa:	83 c0 08             	add    $0x8,%eax
c0402fad:	83 ec 08             	sub    $0x8,%esp
c0402fb0:	6a 00                	push   $0x0
c0402fb2:	50                   	push   %eax
c0402fb3:	e8 5f d6 ff ff       	call   c0400617 <unlock_gate>
c0402fb8:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] unlocking process %i (%p)\n", CPU_ID, proc->pid, proc);
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c0402fbb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402fbf:	83 c0 10             	add    $0x10,%eax
c0402fc2:	83 ec 08             	sub    $0x8,%esp
c0402fc5:	6a 01                	push   $0x1
c0402fc7:	50                   	push   %eax
c0402fc8:	e8 cb d4 ff ff       	call   c0400498 <lock_gate>
c0402fcd:	83 c4 10             	add    $0x10,%esp
	
	/* clear the blocked flag */
	proc->flags &= ~PROC_FLAG_RUNLOCKED;
c0402fd0:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402fd4:	8a 40 0d             	mov    0xd(%eax),%al
c0402fd7:	88 c2                	mov    %al,%dl
c0402fd9:	83 e2 fe             	and    $0xfffffffe,%edx
c0402fdc:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402fe0:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0402fe3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c0402fea:	00 
c0402feb:	eb 75                	jmp    c0403062 <sched_unlock_proc+0x1c6>
	{
		t = proc->threads[loop];
c0402fed:	8b 44 24 20          	mov    0x20(%esp),%eax
c0402ff1:	8b 40 38             	mov    0x38(%eax),%eax
c0402ff4:	8b 54 24 04          	mov    0x4(%esp),%edx
c0402ff8:	c1 e2 02             	shl    $0x2,%edx
c0402ffb:	01 d0                	add    %edx,%eax
c0402ffd:	8b 00                	mov    (%eax),%eax
c0402fff:	89 04 24             	mov    %eax,(%esp)
		while(t)
c0403002:	eb 47                	jmp    c040304b <sched_unlock_proc+0x1af>
		{
			sched_unlock_thread(t);
c0403004:	83 ec 0c             	sub    $0xc,%esp
c0403007:	ff 74 24 0c          	pushl  0xc(%esp)
c040300b:	e8 43 fd ff ff       	call   c0402d53 <sched_unlock_thread>
c0403010:	83 c4 10             	add    $0x10,%esp
			tfound++;
c0403013:	ff 44 24 08          	incl   0x8(%esp)
			
			/* try the next thread */
			lock_gate(&(t->lock), LOCK_READ);
c0403017:	8b 04 24             	mov    (%esp),%eax
c040301a:	83 c0 1c             	add    $0x1c,%eax
c040301d:	83 ec 08             	sub    $0x8,%esp
c0403020:	6a 00                	push   $0x0
c0403022:	50                   	push   %eax
c0403023:	e8 70 d4 ff ff       	call   c0400498 <lock_gate>
c0403028:	83 c4 10             	add    $0x10,%esp
			t = t->hash_next;
c040302b:	8b 04 24             	mov    (%esp),%eax
c040302e:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0403034:	89 04 24             	mov    %eax,(%esp)
			unlock_gate(&(t->lock), LOCK_READ);
c0403037:	8b 04 24             	mov    (%esp),%eax
c040303a:	83 c0 1c             	add    $0x1c,%eax
c040303d:	83 ec 08             	sub    $0x8,%esp
c0403040:	6a 00                	push   $0x0
c0403042:	50                   	push   %eax
c0403043:	e8 cf d5 ff ff       	call   c0400617 <unlock_gate>
c0403048:	83 c4 10             	add    $0x10,%esp
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
	{
		t = proc->threads[loop];
		while(t)
c040304b:	83 3c 24 00          	cmpl   $0x0,(%esp)
c040304f:	75 b3                	jne    c0403004 <sched_unlock_proc+0x168>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c0403051:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403055:	8b 40 3c             	mov    0x3c(%eax),%eax
c0403058:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040305c:	76 0d                	jbe    c040306b <sched_unlock_proc+0x1cf>
	
	/* clear the blocked flag */
	proc->flags &= ~PROC_FLAG_RUNLOCKED;
	
	/* loop through the threads to run any that are held */
	for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c040305e:	ff 44 24 04          	incl   0x4(%esp)
c0403062:	83 7c 24 04 3f       	cmpl   $0x3f,0x4(%esp)
c0403067:	76 84                	jbe    c0402fed <sched_unlock_proc+0x151>
c0403069:	eb 01                	jmp    c040306c <sched_unlock_proc+0x1d0>
			t = t->hash_next;
			unlock_gate(&(t->lock), LOCK_READ);
		}
		
		/* avoid scanning the whole hash space */
		if(tfound >= proc->thread_count) break;
c040306b:	90                   	nop
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c040306c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403070:	83 c0 10             	add    $0x10,%eax
c0403073:	83 ec 08             	sub    $0x8,%esp
c0403076:	6a 01                	push   $0x1
c0403078:	50                   	push   %eax
c0403079:	e8 99 d5 ff ff       	call   c0400617 <unlock_gate>
c040307e:	83 c4 10             	add    $0x10,%esp
	
	return success;
c0403081:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0403086:	83 c4 1c             	add    $0x1c,%esp
c0403089:	c3                   	ret    

c040308a <sched_caretaker>:
   quieter one. don't move running threads around for fear of
   cache performance issues */
void sched_caretaker(void)
{
	SCHED_DEBUG("[sched:%i] caretaker tick\n", CPU_ID);
}
c040308a:	c3                   	ret    

c040308b <sched_tick>:
/* sched_tick
	Called 100 times a second (SCHED_FREQUENCY). Pick a new
   thread, if necessary.
*/
void sched_tick(int_registers_block *regs)
{
c040308b:	83 ec 1c             	sub    $0x1c,%esp
	mp_core *cpu = &cpu_table[CPU_ID];
c040308e:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0403094:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403099:	3c 01                	cmp    $0x1,%al
c040309b:	76 0f                	jbe    c04030ac <sched_tick+0x21>
c040309d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04030a2:	8b 00                	mov    (%eax),%eax
c04030a4:	c1 e8 18             	shr    $0x18,%eax
c04030a7:	c1 e0 06             	shl    $0x6,%eax
c04030aa:	eb 0b                	jmp    c04030b7 <sched_tick+0x2c>
c04030ac:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04030b1:	0f b6 c0             	movzbl %al,%eax
c04030b4:	c1 e0 06             	shl    $0x6,%eax
c04030b7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04030ba:	89 44 24 0c          	mov    %eax,0xc(%esp)

	/* give up if no thread running */
	if(!(cpu->current)) return;
c04030be:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04030c2:	8b 40 04             	mov    0x4(%eax),%eax
c04030c5:	85 c0                	test   %eax,%eax
c04030c7:	0f 84 65 01 00 00    	je     c0403232 <sched_tick+0x1a7>
	
	/* check to see if it's time for maintanence */
	/* make sure only the boot cpu runs this? */
	if(CPU_ID == mp_boot_cpu)
c04030cd:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04030d2:	3c 01                	cmp    $0x1,%al
c04030d4:	76 0c                	jbe    c04030e2 <sched_tick+0x57>
c04030d6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04030db:	8b 00                	mov    (%eax),%eax
c04030dd:	c1 e8 18             	shr    $0x18,%eax
c04030e0:	eb 08                	jmp    c04030ea <sched_tick+0x5f>
c04030e2:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04030e7:	0f b6 c0             	movzbl %al,%eax
c04030ea:	8a 15 1e 1d 41 c0    	mov    0xc0411d1e,%dl
c04030f0:	0f b6 d2             	movzbl %dl,%edx
c04030f3:	39 d0                	cmp    %edx,%eax
c04030f5:	75 25                	jne    c040311c <sched_tick+0x91>
	{
		if(tick)
c04030f7:	a1 44 f0 40 c0       	mov    0xc040f044,%eax
c04030fc:	85 c0                	test   %eax,%eax
c04030fe:	74 0d                	je     c040310d <sched_tick+0x82>
			tick--;
c0403100:	a1 44 f0 40 c0       	mov    0xc040f044,%eax
c0403105:	48                   	dec    %eax
c0403106:	a3 44 f0 40 c0       	mov    %eax,0xc040f044
c040310b:	eb 0f                	jmp    c040311c <sched_tick+0x91>
		else
		{
			sched_caretaker();
c040310d:	e8 78 ff ff ff       	call   c040308a <sched_caretaker>
			tick = SCHED_CARETAKER;
c0403112:	c7 05 44 f0 40 c0 e8 	movl   $0x3e8,0xc040f044
c0403119:	03 00 00 
		}
	}
	
	lock_gate(&(cpu->lock), LOCK_READ);
c040311c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403120:	83 c0 08             	add    $0x8,%eax
c0403123:	83 ec 08             	sub    $0x8,%esp
c0403126:	6a 00                	push   $0x0
c0403128:	50                   	push   %eax
c0403129:	e8 6a d3 ff ff       	call   c0400498 <lock_gate>
c040312e:	83 c4 10             	add    $0x10,%esp
	/* bail out if we're not running anything */
	if(!(cpu->current))
c0403131:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403135:	8b 40 04             	mov    0x4(%eax),%eax
c0403138:	85 c0                	test   %eax,%eax
c040313a:	75 1a                	jne    c0403156 <sched_tick+0xcb>
	{
		unlock_gate(&(cpu->lock), LOCK_READ);
c040313c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403140:	83 c0 08             	add    $0x8,%eax
c0403143:	83 ec 08             	sub    $0x8,%esp
c0403146:	6a 00                	push   $0x0
c0403148:	50                   	push   %eax
c0403149:	e8 c9 d4 ff ff       	call   c0400617 <unlock_gate>
c040314e:	83 c4 10             	add    $0x10,%esp
		return;
c0403151:	e9 dd 00 00 00       	jmp    c0403233 <sched_tick+0x1a8>
	}
	unlock_gate(&(cpu->lock), LOCK_READ);
c0403156:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040315a:	83 c0 08             	add    $0x8,%eax
c040315d:	83 ec 08             	sub    $0x8,%esp
c0403160:	6a 00                	push   $0x0
c0403162:	50                   	push   %eax
c0403163:	e8 af d4 ff ff       	call   c0400617 <unlock_gate>
c0403168:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(cpu->current->lock), LOCK_WRITE);
c040316b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040316f:	8b 40 04             	mov    0x4(%eax),%eax
c0403172:	83 c0 1c             	add    $0x1c,%eax
c0403175:	83 ec 08             	sub    $0x8,%esp
c0403178:	6a 01                	push   $0x1
c040317a:	50                   	push   %eax
c040317b:	e8 18 d3 ff ff       	call   c0400498 <lock_gate>
c0403180:	83 c4 10             	add    $0x10,%esp
	
	/* decrement timeslice */
	if(cpu->current->timeslice)
c0403183:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403187:	8b 40 04             	mov    0x4(%eax),%eax
c040318a:	8a 40 0d             	mov    0xd(%eax),%al
c040318d:	84 c0                	test   %al,%al
c040318f:	74 0e                	je     c040319f <sched_tick+0x114>
		cpu->current->timeslice--;
c0403191:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403195:	8b 40 04             	mov    0x4(%eax),%eax
c0403198:	8a 50 0d             	mov    0xd(%eax),%dl
c040319b:	4a                   	dec    %edx
c040319c:	88 50 0d             	mov    %dl,0xd(%eax)
	
	/* reschedule if thread is out of time */
	if(cpu->current->timeslice == 0)
c040319f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04031a3:	8b 40 04             	mov    0x4(%eax),%eax
c04031a6:	8a 40 0d             	mov    0xd(%eax),%al
c04031a9:	84 c0                	test   %al,%al
c04031ab:	75 6b                	jne    c0403218 <sched_tick+0x18d>
	{
		SCHED_DEBUG("[sched:%i] timeslice for thread %i of process %i expired\n",
				  CPU_ID, cpu->current->tid, cpu->current->proc->pid);
		
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
c04031ad:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04031b1:	8b 40 04             	mov    0x4(%eax),%eax
c04031b4:	83 c0 1c             	add    $0x1c,%eax
c04031b7:	83 ec 08             	sub    $0x8,%esp
c04031ba:	6a 01                	push   $0x1
c04031bc:	50                   	push   %eax
c04031bd:	e8 55 d4 ff ff       	call   c0400617 <unlock_gate>
c04031c2:	83 c4 10             	add    $0x10,%esp
		
		sched_move_to_end(CPU_ID, cpu->current->priority, cpu->current);
c04031c5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04031c9:	8b 48 04             	mov    0x4(%eax),%ecx
c04031cc:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04031d0:	8b 40 04             	mov    0x4(%eax),%eax
c04031d3:	8a 40 0e             	mov    0xe(%eax),%al
c04031d6:	0f b6 d0             	movzbl %al,%edx
c04031d9:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04031de:	3c 01                	cmp    $0x1,%al
c04031e0:	76 0f                	jbe    c04031f1 <sched_tick+0x166>
c04031e2:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04031e7:	8b 00                	mov    (%eax),%eax
c04031e9:	c1 e8 18             	shr    $0x18,%eax
c04031ec:	0f b6 c0             	movzbl %al,%eax
c04031ef:	eb 08                	jmp    c04031f9 <sched_tick+0x16e>
c04031f1:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04031f6:	0f b6 c0             	movzbl %al,%eax
c04031f9:	83 ec 04             	sub    $0x4,%esp
c04031fc:	51                   	push   %ecx
c04031fd:	52                   	push   %edx
c04031fe:	50                   	push   %eax
c04031ff:	e8 fb 01 00 00       	call   c04033ff <sched_move_to_end>
c0403204:	83 c4 10             	add    $0x10,%esp
		sched_pick(regs);
c0403207:	83 ec 0c             	sub    $0xc,%esp
c040320a:	ff 74 24 2c          	pushl  0x2c(%esp)
c040320e:	e8 24 00 00 00       	call   c0403237 <sched_pick>
c0403213:	83 c4 10             	add    $0x10,%esp
c0403216:	eb 1b                	jmp    c0403233 <sched_tick+0x1a8>
	}
	else
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
c0403218:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040321c:	8b 40 04             	mov    0x4(%eax),%eax
c040321f:	83 c0 1c             	add    $0x1c,%eax
c0403222:	83 ec 08             	sub    $0x8,%esp
c0403225:	6a 01                	push   $0x1
c0403227:	50                   	push   %eax
c0403228:	e8 ea d3 ff ff       	call   c0400617 <unlock_gate>
c040322d:	83 c4 10             	add    $0x10,%esp
c0403230:	eb 01                	jmp    c0403233 <sched_tick+0x1a8>
void sched_tick(int_registers_block *regs)
{
	mp_core *cpu = &cpu_table[CPU_ID];

	/* give up if no thread running */
	if(!(cpu->current)) return;
c0403232:	90                   	nop
		sched_move_to_end(CPU_ID, cpu->current->priority, cpu->current);
		sched_pick(regs);
	}
	else
		unlock_gate(&(cpu->current->lock), LOCK_WRITE);
}
c0403233:	83 c4 1c             	add    $0x1c,%esp
c0403236:	c3                   	ret    

c0403237 <sched_pick>:
/* sched_pick
   Check the run queues for new higher prority threads to run
   => pointer to the interrupted thread's kernel stack
*/
void sched_pick(int_registers_block *regs)
{
c0403237:	83 ec 1c             	sub    $0x1c,%esp
	thread *now, *next;

	mp_core *cpu = &cpu_table[CPU_ID];
c040323a:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0403240:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403245:	3c 01                	cmp    $0x1,%al
c0403247:	76 0f                	jbe    c0403258 <sched_pick+0x21>
c0403249:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040324e:	8b 00                	mov    (%eax),%eax
c0403250:	c1 e8 18             	shr    $0x18,%eax
c0403253:	c1 e0 06             	shl    $0x6,%eax
c0403256:	eb 0b                	jmp    c0403263 <sched_pick+0x2c>
c0403258:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040325d:	0f b6 c0             	movzbl %al,%eax
c0403260:	c1 e0 06             	shl    $0x6,%eax
c0403263:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0403266:	89 44 24 08          	mov    %eax,0x8(%esp)
	
#ifdef SCHED_DEBUG
	{
		thread *t = cpu->queue_head;
c040326a:	8b 44 24 08          	mov    0x8(%esp),%eax
c040326e:	8b 40 18             	mov    0x18(%eax),%eax
c0403271:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(!t)
c0403275:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040327a:	75 10                	jne    c040328c <sched_pick+0x55>
c040327c:	eb 1e                	jmp    c040329c <sched_pick+0x65>
			SCHED_DEBUG("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
					      CPU_ID, CPU_ID, t->tid, t->proc->pid);
			while(t)
			{
				SCHED_DEBUG("(t%i p%i) ", t->tid, t->proc->pid);
				t = t->queue_next;
c040327e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403282:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c0403288:	89 44 24 0c          	mov    %eax,0xc(%esp)
		}
		else
		{
			SCHED_DEBUG("[sched:%i] picking from cpu %i queue: start[t%i p%i] ",
					      CPU_ID, CPU_ID, t->tid, t->proc->pid);
			while(t)
c040328c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0403291:	75 eb                	jne    c040327e <sched_pick+0x47>
			{
				SCHED_DEBUG("(t%i p%i) ", t->tid, t->proc->pid);
				t = t->queue_next;
			}
			if(cpu->queue_tail)
c0403293:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403297:	8b 40 1c             	mov    0x1c(%eax),%eax
c040329a:	85 c0                	test   %eax,%eax
		}
	}
#endif	

	/* this is the state of play */
	lock_gate(&(cpu->lock), LOCK_READ);
c040329c:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032a0:	83 c0 08             	add    $0x8,%eax
c04032a3:	83 ec 08             	sub    $0x8,%esp
c04032a6:	6a 00                	push   $0x0
c04032a8:	50                   	push   %eax
c04032a9:	e8 ea d1 ff ff       	call   c0400498 <lock_gate>
c04032ae:	83 c4 10             	add    $0x10,%esp
	now = cpu->current;
c04032b1:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032b5:	8b 40 04             	mov    0x4(%eax),%eax
c04032b8:	89 04 24             	mov    %eax,(%esp)
	unlock_gate(&(cpu->lock), LOCK_READ);
c04032bb:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032bf:	83 c0 08             	add    $0x8,%eax
c04032c2:	83 ec 08             	sub    $0x8,%esp
c04032c5:	6a 00                	push   $0x0
c04032c7:	50                   	push   %eax
c04032c8:	e8 4a d3 ff ff       	call   c0400617 <unlock_gate>
c04032cd:	83 c4 10             	add    $0x10,%esp
	
	/* if the queue head is empty, then spin until it's there */
	do
	{
		lock_gate(&(cpu->lock), LOCK_READ);
c04032d0:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032d4:	83 c0 08             	add    $0x8,%eax
c04032d7:	83 ec 08             	sub    $0x8,%esp
c04032da:	6a 00                	push   $0x0
c04032dc:	50                   	push   %eax
c04032dd:	e8 b6 d1 ff ff       	call   c0400498 <lock_gate>
c04032e2:	83 c4 10             	add    $0x10,%esp
		next = (volatile thread *)(cpu->queue_head);
c04032e5:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032e9:	8b 40 18             	mov    0x18(%eax),%eax
c04032ec:	89 44 24 04          	mov    %eax,0x4(%esp)
		unlock_gate(&(cpu->lock), LOCK_READ);
c04032f0:	8b 44 24 08          	mov    0x8(%esp),%eax
c04032f4:	83 c0 08             	add    $0x8,%eax
c04032f7:	83 ec 08             	sub    $0x8,%esp
c04032fa:	6a 00                	push   $0x0
c04032fc:	50                   	push   %eax
c04032fd:	e8 15 d3 ff ff       	call   c0400617 <unlock_gate>
c0403302:	83 c4 10             	add    $0x10,%esp
	}
	while (!next);
c0403305:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c040330a:	74 c4                	je     c04032d0 <sched_pick+0x99>
	
	if(next == now) return; /* easy quick switch back to where we were */
c040330c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403310:	3b 04 24             	cmp    (%esp),%eax
c0403313:	0f 84 e1 00 00 00    	je     c04033fa <sched_pick+0x1c3>
	
	/* update thread states */
	lock_gate(&(now->lock), LOCK_WRITE);
c0403319:	8b 04 24             	mov    (%esp),%eax
c040331c:	83 c0 1c             	add    $0x1c,%eax
c040331f:	83 ec 08             	sub    $0x8,%esp
c0403322:	6a 01                	push   $0x1
c0403324:	50                   	push   %eax
c0403325:	e8 6e d1 ff ff       	call   c0400498 <lock_gate>
c040332a:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(next->lock), LOCK_WRITE);
c040332d:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403331:	83 c0 1c             	add    $0x1c,%eax
c0403334:	83 ec 08             	sub    $0x8,%esp
c0403337:	6a 01                	push   $0x1
c0403339:	50                   	push   %eax
c040333a:	e8 59 d1 ff ff       	call   c0400498 <lock_gate>
c040333f:	83 c4 10             	add    $0x10,%esp
	
	if(now->state == running) now->state = inrunqueue;
c0403342:	8b 04 24             	mov    (%esp),%eax
c0403345:	8b 40 10             	mov    0x10(%eax),%eax
c0403348:	83 f8 02             	cmp    $0x2,%eax
c040334b:	75 0a                	jne    c0403357 <sched_pick+0x120>
c040334d:	8b 04 24             	mov    (%esp),%eax
c0403350:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	next->cpu = CPU_ID;
c0403357:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040335c:	3c 01                	cmp    $0x1,%al
c040335e:	76 0c                	jbe    c040336c <sched_pick+0x135>
c0403360:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403365:	8b 00                	mov    (%eax),%eax
c0403367:	c1 e8 18             	shr    $0x18,%eax
c040336a:	eb 08                	jmp    c0403374 <sched_pick+0x13d>
c040336c:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0403371:	0f b6 c0             	movzbl %al,%eax
c0403374:	8b 54 24 04          	mov    0x4(%esp),%edx
c0403378:	89 42 08             	mov    %eax,0x8(%edx)
	next->state = running;
c040337b:	8b 44 24 04          	mov    0x4(%esp),%eax
c040337f:	c7 40 10 02 00 00 00 	movl   $0x2,0x10(%eax)
	
	unlock_gate(&(next->lock), LOCK_WRITE);
c0403386:	8b 44 24 04          	mov    0x4(%esp),%eax
c040338a:	83 c0 1c             	add    $0x1c,%eax
c040338d:	83 ec 08             	sub    $0x8,%esp
c0403390:	6a 01                	push   $0x1
c0403392:	50                   	push   %eax
c0403393:	e8 7f d2 ff ff       	call   c0400617 <unlock_gate>
c0403398:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(now->lock), LOCK_WRITE);
c040339b:	8b 04 24             	mov    (%esp),%eax
c040339e:	83 c0 1c             	add    $0x1c,%eax
c04033a1:	83 ec 08             	sub    $0x8,%esp
c04033a4:	6a 01                	push   $0x1
c04033a6:	50                   	push   %eax
c04033a7:	e8 6b d2 ff ff       	call   c0400617 <unlock_gate>
c04033ac:	83 c4 10             	add    $0x10,%esp

	/* this is the only place in core that we change cpu->current. the (un)lock_gate
		code relies on cpu->current not changing between lock-unlock pairs for a
	   given kernel thread. so we have to use a basic low-level spin lock on the
	   cpu's gate while we update this */	
	lock_spin(&(cpu->lock.spinlock));
c04033af:	8b 44 24 08          	mov    0x8(%esp),%eax
c04033b3:	83 c0 08             	add    $0x8,%eax
c04033b6:	83 ec 0c             	sub    $0xc,%esp
c04033b9:	50                   	push   %eax
c04033ba:	e8 a1 d0 ff ff       	call   c0400460 <lock_spin>
c04033bf:	83 c4 10             	add    $0x10,%esp
	cpu->current = next;
c04033c2:	8b 44 24 08          	mov    0x8(%esp),%eax
c04033c6:	8b 54 24 04          	mov    0x4(%esp),%edx
c04033ca:	89 50 04             	mov    %edx,0x4(%eax)
	unlock_spin(&(cpu->lock.spinlock));
c04033cd:	8b 44 24 08          	mov    0x8(%esp),%eax
c04033d1:	83 c0 08             	add    $0x8,%eax
c04033d4:	83 ec 0c             	sub    $0xc,%esp
c04033d7:	50                   	push   %eax
c04033d8:	e8 b0 d0 ff ff       	call   c040048d <unlock_spin>
c04033dd:	83 c4 10             	add    $0x10,%esp

	lowlevel_thread_switch(now, next, regs);
c04033e0:	83 ec 04             	sub    $0x4,%esp
c04033e3:	ff 74 24 24          	pushl  0x24(%esp)
c04033e7:	ff 74 24 0c          	pushl  0xc(%esp)
c04033eb:	ff 74 24 0c          	pushl  0xc(%esp)
c04033ef:	e8 6a da ff ff       	call   c0400e5e <lowlevel_thread_switch>
c04033f4:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
c04033f7:	90                   	nop
c04033f8:	eb 01                	jmp    c04033fb <sched_pick+0x1c4>
		next = (volatile thread *)(cpu->queue_head);
		unlock_gate(&(cpu->lock), LOCK_READ);
	}
	while (!next);
	
	if(next == now) return; /* easy quick switch back to where we were */
c04033fa:	90                   	nop

	lowlevel_thread_switch(now, next, regs);
	
	SCHED_DEBUG("[sched:%i] switched thread %i of process %i (%p) for thread %i of process %i (%p)\n",
			  CPU_ID, now->tid, now->proc->pid, now, next->tid, next->proc->pid, next);
}
c04033fb:	83 c4 1c             	add    $0x1c,%esp
c04033fe:	c3                   	ret    

c04033ff <sched_move_to_end>:
   => cpu = id of per-cpu run queue
      priority = priority queue to use
      toqueue = thread to queue up
*/
void sched_move_to_end(unsigned char cpu, unsigned char priority, thread *toqueue)
{
c04033ff:	83 ec 1c             	sub    $0x1c,%esp
c0403402:	8b 54 24 20          	mov    0x20(%esp),%edx
c0403406:	8b 44 24 24          	mov    0x24(%esp),%eax
c040340a:	88 54 24 0c          	mov    %dl,0xc(%esp)
c040340e:	88 44 24 08          	mov    %al,0x8(%esp)
	if((cpu > mp_cpus) || !toqueue)
c0403412:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403417:	38 44 24 0c          	cmp    %al,0xc(%esp)
c040341b:	0f 87 9e 01 00 00    	ja     c04035bf <sched_move_to_end+0x1c0>
c0403421:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0403426:	0f 84 96 01 00 00    	je     c04035c2 <sched_move_to_end+0x1c3>
		return; /* bail if parameters are insane */
	
	lock_gate(&(toqueue->lock), LOCK_WRITE);
c040342c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403430:	83 c0 1c             	add    $0x1c,%eax
c0403433:	83 ec 08             	sub    $0x8,%esp
c0403436:	6a 01                	push   $0x1
c0403438:	50                   	push   %eax
c0403439:	e8 5a d0 ff ff       	call   c0400498 <lock_gate>
c040343e:	83 c4 10             	add    $0x10,%esp
	
	/* remove from the run queue if present */
	if(toqueue->state == running || toqueue->state == inrunqueue)
c0403441:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403445:	8b 40 10             	mov    0x10(%eax),%eax
c0403448:	83 f8 02             	cmp    $0x2,%eax
c040344b:	74 0c                	je     c0403459 <sched_move_to_end+0x5a>
c040344d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403451:	8b 40 10             	mov    0x10(%eax),%eax
c0403454:	83 f8 01             	cmp    $0x1,%eax
c0403457:	75 11                	jne    c040346a <sched_move_to_end+0x6b>
		sched_remove(toqueue, held);
c0403459:	83 ec 08             	sub    $0x8,%esp
c040345c:	6a 05                	push   $0x5
c040345e:	ff 74 24 34          	pushl  0x34(%esp)
c0403462:	e8 30 03 00 00       	call   c0403797 <sched_remove>
c0403467:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c040346a:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040346f:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403474:	c1 e2 06             	shl    $0x6,%edx
c0403477:	01 d0                	add    %edx,%eax
c0403479:	83 c0 08             	add    $0x8,%eax
c040347c:	83 ec 08             	sub    $0x8,%esp
c040347f:	6a 01                	push   $0x1
c0403481:	50                   	push   %eax
c0403482:	e8 11 d0 ff ff       	call   c0400498 <lock_gate>
c0403487:	83 c4 10             	add    $0x10,%esp
	
	/* add it to the end of the queue */
	if(cpu_table[cpu].queue_tail)
c040348a:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040348f:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403494:	c1 e2 06             	shl    $0x6,%edx
c0403497:	01 d0                	add    %edx,%eax
c0403499:	8b 40 1c             	mov    0x1c(%eax),%eax
c040349c:	85 c0                	test   %eax,%eax
c040349e:	74 1c                	je     c04034bc <sched_move_to_end+0xbd>
		cpu_table[cpu].queue_tail->queue_next = toqueue;
c04034a0:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04034a5:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04034aa:	c1 e2 06             	shl    $0x6,%edx
c04034ad:	01 d0                	add    %edx,%eax
c04034af:	8b 40 1c             	mov    0x1c(%eax),%eax
c04034b2:	8b 54 24 28          	mov    0x28(%esp),%edx
c04034b6:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)

	toqueue->queue_prev = cpu_table[cpu].queue_tail;
c04034bc:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04034c1:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04034c6:	c1 e2 06             	shl    $0x6,%edx
c04034c9:	01 d0                	add    %edx,%eax
c04034cb:	8b 50 1c             	mov    0x1c(%eax),%edx
c04034ce:	8b 44 24 28          	mov    0x28(%esp),%eax
c04034d2:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
	
	/* if the head is empty, then fix up */
	if(cpu_table[cpu].queue_head == NULL)
c04034d8:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04034dd:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04034e2:	c1 e2 06             	shl    $0x6,%edx
c04034e5:	01 d0                	add    %edx,%eax
c04034e7:	8b 40 18             	mov    0x18(%eax),%eax
c04034ea:	85 c0                	test   %eax,%eax
c04034ec:	75 17                	jne    c0403505 <sched_move_to_end+0x106>
		cpu_table[cpu].queue_head = toqueue;
c04034ee:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04034f3:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04034f8:	c1 e2 06             	shl    $0x6,%edx
c04034fb:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04034fe:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403502:	89 42 18             	mov    %eax,0x18(%edx)
	
	cpu_table[cpu].queue_tail = toqueue;
c0403505:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040350a:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040350f:	c1 e2 06             	shl    $0x6,%edx
c0403512:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0403515:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403519:	89 42 1c             	mov    %eax,0x1c(%edx)
	toqueue->queue_next = NULL;
c040351c:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403520:	c7 80 e4 00 00 00 00 	movl   $0x0,0xe4(%eax)
c0403527:	00 00 00 
	
	/* cap out-of-control priorities */
	if(priority >= SCHED_PRIORITY_LEVELS)
c040352a:	80 7c 24 08 03       	cmpb   $0x3,0x8(%esp)
c040352f:	76 05                	jbe    c0403536 <sched_move_to_end+0x137>
		priority = SCHED_PRIORITY_LEVELS - 1;
c0403531:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)
	
	/* update accounting */
	if(toqueue->state != running && toqueue->state != inrunqueue)
c0403536:	8b 44 24 28          	mov    0x28(%esp),%eax
c040353a:	8b 40 10             	mov    0x10(%eax),%eax
c040353d:	83 f8 02             	cmp    $0x2,%eax
c0403540:	74 27                	je     c0403569 <sched_move_to_end+0x16a>
c0403542:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403546:	8b 40 10             	mov    0x10(%eax),%eax
c0403549:	83 f8 01             	cmp    $0x1,%eax
c040354c:	74 1b                	je     c0403569 <sched_move_to_end+0x16a>
	{
		cpu_table[cpu].queued++;
c040354e:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403553:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403558:	c1 e2 06             	shl    $0x6,%edx
c040355b:	01 d0                	add    %edx,%eax
c040355d:	8b 50 30             	mov    0x30(%eax),%edx
c0403560:	42                   	inc    %edx
c0403561:	89 50 30             	mov    %edx,0x30(%eax)
		sched_inc_queued_threads();
c0403564:	e8 8f f4 ff ff       	call   c04029f8 <sched_inc_queued_threads>
	}

	toqueue->priority  = priority;
c0403569:	8b 44 24 28          	mov    0x28(%esp),%eax
c040356d:	8a 54 24 08          	mov    0x8(%esp),%dl
c0403571:	88 50 0e             	mov    %dl,0xe(%eax)
	toqueue->state     = inrunqueue;
c0403574:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403578:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	toqueue->timeslice = SCHED_TIMESLICE;
c040357f:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403583:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0403587:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040358c:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403591:	c1 e2 06             	shl    $0x6,%edx
c0403594:	01 d0                	add    %edx,%eax
c0403596:	83 c0 08             	add    $0x8,%eax
c0403599:	83 ec 08             	sub    $0x8,%esp
c040359c:	6a 01                	push   $0x1
c040359e:	50                   	push   %eax
c040359f:	e8 73 d0 ff ff       	call   c0400617 <unlock_gate>
c04035a4:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
c04035a7:	8b 44 24 28          	mov    0x28(%esp),%eax
c04035ab:	83 c0 1c             	add    $0x1c,%eax
c04035ae:	83 ec 08             	sub    $0x8,%esp
c04035b1:	6a 01                	push   $0x1
c04035b3:	50                   	push   %eax
c04035b4:	e8 5e d0 ff ff       	call   c0400617 <unlock_gate>
c04035b9:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
c04035bc:	90                   	nop
c04035bd:	eb 04                	jmp    c04035c3 <sched_move_to_end+0x1c4>
      toqueue = thread to queue up
*/
void sched_move_to_end(unsigned char cpu, unsigned char priority, thread *toqueue)
{
	if((cpu > mp_cpus) || !toqueue)
		return; /* bail if parameters are insane */
c04035bf:	90                   	nop
c04035c0:	eb 01                	jmp    c04035c3 <sched_move_to_end+0x1c4>
c04035c2:	90                   	nop
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
	unlock_gate(&(toqueue->lock), LOCK_WRITE);
	
	SCHED_DEBUG("[sched:%i] moved thread %i (%p) of process %i to end of cpu %i queue, priority %i\n",
			  CPU_ID, toqueue->tid, toqueue, toqueue->proc->pid, cpu, priority);
}
c04035c3:	83 c4 1c             	add    $0x1c,%esp
c04035c6:	c3                   	ret    

c04035c7 <sched_add>:
	=> cpu = id of the requested per-cpu run queue
      priority = the priority level of the process
      torun = the thread to add
*/
void sched_add(unsigned char cpu, unsigned char priority, thread *torun)
{
c04035c7:	83 ec 1c             	sub    $0x1c,%esp
c04035ca:	8b 54 24 20          	mov    0x20(%esp),%edx
c04035ce:	8b 44 24 24          	mov    0x24(%esp),%eax
c04035d2:	88 54 24 0c          	mov    %dl,0xc(%esp)
c04035d6:	88 44 24 08          	mov    %al,0x8(%esp)
	if((cpu > mp_cpus) || !torun)
c04035da:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04035df:	38 44 24 0c          	cmp    %al,0xc(%esp)
c04035e3:	0f 87 a6 01 00 00    	ja     c040378f <sched_add+0x1c8>
c04035e9:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04035ee:	0f 84 9e 01 00 00    	je     c0403792 <sched_add+0x1cb>
		return; /* bail if parameters are insane */

	/* perform some load balancing */
	cpu = sched_pick_queue(cpu);
c04035f4:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c04035f9:	83 ec 0c             	sub    $0xc,%esp
c04035fc:	50                   	push   %eax
c04035fd:	e8 d8 02 00 00       	call   c04038da <sched_pick_queue>
c0403602:	83 c4 10             	add    $0x10,%esp
c0403605:	88 44 24 0c          	mov    %al,0xc(%esp)
		
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c0403609:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040360e:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403613:	c1 e2 06             	shl    $0x6,%edx
c0403616:	01 d0                	add    %edx,%eax
c0403618:	83 c0 08             	add    $0x8,%eax
c040361b:	83 ec 08             	sub    $0x8,%esp
c040361e:	6a 01                	push   $0x1
c0403620:	50                   	push   %eax
c0403621:	e8 72 ce ff ff       	call   c0400498 <lock_gate>
c0403626:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(torun->lock), LOCK_WRITE);
c0403629:	8b 44 24 28          	mov    0x28(%esp),%eax
c040362d:	83 c0 1c             	add    $0x1c,%eax
c0403630:	83 ec 08             	sub    $0x8,%esp
c0403633:	6a 01                	push   $0x1
c0403635:	50                   	push   %eax
c0403636:	e8 5d ce ff ff       	call   c0400498 <lock_gate>
c040363b:	83 c4 10             	add    $0x10,%esp
		
	/* add it to the start of the queue */
	if(cpu_table[cpu].queue_head)
c040363e:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403643:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403648:	c1 e2 06             	shl    $0x6,%edx
c040364b:	01 d0                	add    %edx,%eax
c040364d:	8b 40 18             	mov    0x18(%eax),%eax
c0403650:	85 c0                	test   %eax,%eax
c0403652:	74 3a                	je     c040368e <sched_add+0xc7>
	{
		cpu_table[cpu].queue_head->queue_prev = torun;
c0403654:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403659:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040365e:	c1 e2 06             	shl    $0x6,%edx
c0403661:	01 d0                	add    %edx,%eax
c0403663:	8b 40 18             	mov    0x18(%eax),%eax
c0403666:	8b 54 24 28          	mov    0x28(%esp),%edx
c040366a:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
		torun->queue_next = cpu_table[cpu].queue_head;
c0403670:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403675:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040367a:	c1 e2 06             	shl    $0x6,%edx
c040367d:	01 d0                	add    %edx,%eax
c040367f:	8b 50 18             	mov    0x18(%eax),%edx
c0403682:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403686:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)
c040368c:	eb 0e                	jmp    c040369c <sched_add+0xd5>
	}
	else
	{
		torun->queue_next = NULL;
c040368e:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403692:	c7 80 e4 00 00 00 00 	movl   $0x0,0xe4(%eax)
c0403699:	00 00 00 
	}
	/* if the tail is empty, then fix up */
	if(!(cpu_table[cpu].queue_tail))
c040369c:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04036a1:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04036a6:	c1 e2 06             	shl    $0x6,%edx
c04036a9:	01 d0                	add    %edx,%eax
c04036ab:	8b 40 1c             	mov    0x1c(%eax),%eax
c04036ae:	85 c0                	test   %eax,%eax
c04036b0:	75 17                	jne    c04036c9 <sched_add+0x102>
		cpu_table[cpu].queue_tail = torun;
c04036b2:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04036b7:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04036bc:	c1 e2 06             	shl    $0x6,%edx
c04036bf:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04036c2:	8b 44 24 28          	mov    0x28(%esp),%eax
c04036c6:	89 42 1c             	mov    %eax,0x1c(%edx)
	
	cpu_table[cpu].queue_head = torun;
c04036c9:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04036ce:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04036d3:	c1 e2 06             	shl    $0x6,%edx
c04036d6:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04036d9:	8b 44 24 28          	mov    0x28(%esp),%eax
c04036dd:	89 42 18             	mov    %eax,0x18(%edx)
	torun->queue_prev = NULL;
c04036e0:	8b 44 24 28          	mov    0x28(%esp),%eax
c04036e4:	c7 80 e0 00 00 00 00 	movl   $0x0,0xe0(%eax)
c04036eb:	00 00 00 
		
	/* cap out-of-control priorities */
	if(priority >= SCHED_PRIORITY_LEVELS)
c04036ee:	80 7c 24 08 03       	cmpb   $0x3,0x8(%esp)
c04036f3:	76 05                	jbe    c04036fa <sched_add+0x133>
		priority = SCHED_PRIORITY_LEVELS - 1;
c04036f5:	c6 44 24 08 03       	movb   $0x3,0x8(%esp)
	
	/* update accounting */
	if(torun->state != running && torun->state != inrunqueue)
c04036fa:	8b 44 24 28          	mov    0x28(%esp),%eax
c04036fe:	8b 40 10             	mov    0x10(%eax),%eax
c0403701:	83 f8 02             	cmp    $0x2,%eax
c0403704:	74 27                	je     c040372d <sched_add+0x166>
c0403706:	8b 44 24 28          	mov    0x28(%esp),%eax
c040370a:	8b 40 10             	mov    0x10(%eax),%eax
c040370d:	83 f8 01             	cmp    $0x1,%eax
c0403710:	74 1b                	je     c040372d <sched_add+0x166>
	{
		cpu_table[cpu].queued++;
c0403712:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403717:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040371c:	c1 e2 06             	shl    $0x6,%edx
c040371f:	01 d0                	add    %edx,%eax
c0403721:	8b 50 30             	mov    0x30(%eax),%edx
c0403724:	42                   	inc    %edx
c0403725:	89 50 30             	mov    %edx,0x30(%eax)
		sched_inc_queued_threads();
c0403728:	e8 cb f2 ff ff       	call   c04029f8 <sched_inc_queued_threads>
	}

	torun->priority  = priority;
c040372d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403731:	8a 54 24 08          	mov    0x8(%esp),%dl
c0403735:	88 50 0e             	mov    %dl,0xe(%eax)
	torun->state     = inrunqueue;
c0403738:	8b 44 24 28          	mov    0x28(%esp),%eax
c040373c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	torun->timeslice = SCHED_TIMESLICE;
c0403743:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403747:	c6 40 0d 05          	movb   $0x5,0xd(%eax)
	torun->cpu		  = cpu;
c040374b:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403750:	8b 44 24 28          	mov    0x28(%esp),%eax
c0403754:	89 50 08             	mov    %edx,0x8(%eax)
	
	unlock_gate(&(torun->lock), LOCK_WRITE);
c0403757:	8b 44 24 28          	mov    0x28(%esp),%eax
c040375b:	83 c0 1c             	add    $0x1c,%eax
c040375e:	83 ec 08             	sub    $0x8,%esp
c0403761:	6a 01                	push   $0x1
c0403763:	50                   	push   %eax
c0403764:	e8 ae ce ff ff       	call   c0400617 <unlock_gate>
c0403769:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c040376c:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403771:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403776:	c1 e2 06             	shl    $0x6,%edx
c0403779:	01 d0                	add    %edx,%eax
c040377b:	83 c0 08             	add    $0x8,%eax
c040377e:	83 ec 08             	sub    $0x8,%esp
c0403781:	6a 01                	push   $0x1
c0403783:	50                   	push   %eax
c0403784:	e8 8e ce ff ff       	call   c0400617 <unlock_gate>
c0403789:	83 c4 10             	add    $0x10,%esp
		
	SCHED_DEBUG("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
c040378c:	90                   	nop
c040378d:	eb 04                	jmp    c0403793 <sched_add+0x1cc>
      torun = the thread to add
*/
void sched_add(unsigned char cpu, unsigned char priority, thread *torun)
{
	if((cpu > mp_cpus) || !torun)
		return; /* bail if parameters are insane */
c040378f:	90                   	nop
c0403790:	eb 01                	jmp    c0403793 <sched_add+0x1cc>
c0403792:	90                   	nop
	unlock_gate(&(torun->lock), LOCK_WRITE);
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
		
	SCHED_DEBUG("[sched:%i] added thread %i (%p) of process %i to cpu %i queue, priority %i\n",
			  CPU_ID, torun->tid, torun, torun->proc->pid, cpu, priority);
}
c0403793:	83 c4 1c             	add    $0x1c,%esp
c0403796:	c3                   	ret    

c0403797 <sched_remove>:
	Remove a thread from a run queue for a cpu
   => victim = the thread to remove
      state = new thread state
*/
void sched_remove(thread *victim, thread_state state)
{
c0403797:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int cpu = victim->cpu;
c040379a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040379e:	8b 40 08             	mov    0x8(%eax),%eax
c04037a1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	lock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c04037a5:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04037aa:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04037ae:	c1 e2 06             	shl    $0x6,%edx
c04037b1:	01 d0                	add    %edx,%eax
c04037b3:	83 c0 08             	add    $0x8,%eax
c04037b6:	83 ec 08             	sub    $0x8,%esp
c04037b9:	6a 01                	push   $0x1
c04037bb:	50                   	push   %eax
c04037bc:	e8 d7 cc ff ff       	call   c0400498 <lock_gate>
c04037c1:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(victim->lock), LOCK_WRITE);
c04037c4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04037c8:	83 c0 1c             	add    $0x1c,%eax
c04037cb:	83 ec 08             	sub    $0x8,%esp
c04037ce:	6a 01                	push   $0x1
c04037d0:	50                   	push   %eax
c04037d1:	e8 c2 cc ff ff       	call   c0400498 <lock_gate>
c04037d6:	83 c4 10             	add    $0x10,%esp
	
	/* remove it from the queue */
	if(victim->queue_next)
c04037d9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04037dd:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c04037e3:	85 c0                	test   %eax,%eax
c04037e5:	74 1c                	je     c0403803 <sched_remove+0x6c>
		victim->queue_next->queue_prev = victim->queue_prev;
c04037e7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04037eb:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c04037f1:	8b 54 24 20          	mov    0x20(%esp),%edx
c04037f5:	8b 92 e0 00 00 00    	mov    0xe0(%edx),%edx
c04037fb:	89 90 e0 00 00 00    	mov    %edx,0xe0(%eax)
c0403801:	eb 1c                	jmp    c040381f <sched_remove+0x88>
	else
		/* we were the tail, so fix up */
		cpu_table[cpu].queue_tail = victim->queue_prev;
c0403803:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403808:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040380c:	c1 e2 06             	shl    $0x6,%edx
c040380f:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0403812:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403816:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c040381c:	89 42 1c             	mov    %eax,0x1c(%edx)
	if(victim->queue_prev)
c040381f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403823:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c0403829:	85 c0                	test   %eax,%eax
c040382b:	74 1c                	je     c0403849 <sched_remove+0xb2>
		victim->queue_prev->queue_next = victim->queue_next;
c040382d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403831:	8b 80 e0 00 00 00    	mov    0xe0(%eax),%eax
c0403837:	8b 54 24 20          	mov    0x20(%esp),%edx
c040383b:	8b 92 e4 00 00 00    	mov    0xe4(%edx),%edx
c0403841:	89 90 e4 00 00 00    	mov    %edx,0xe4(%eax)
c0403847:	eb 1c                	jmp    c0403865 <sched_remove+0xce>
	else
	/* we were the queue head, so fixup pointers */
		cpu_table[cpu].queue_head = victim->queue_next;
c0403849:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040384e:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0403852:	c1 e2 06             	shl    $0x6,%edx
c0403855:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0403858:	8b 44 24 20          	mov    0x20(%esp),%eax
c040385c:	8b 80 e4 00 00 00    	mov    0xe4(%eax),%eax
c0403862:	89 42 18             	mov    %eax,0x18(%edx)
	
	/* update accounting */
	if(victim->state == running || victim->state == inrunqueue)
c0403865:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403869:	8b 40 10             	mov    0x10(%eax),%eax
c040386c:	83 f8 02             	cmp    $0x2,%eax
c040386f:	74 0c                	je     c040387d <sched_remove+0xe6>
c0403871:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403875:	8b 40 10             	mov    0x10(%eax),%eax
c0403878:	83 f8 01             	cmp    $0x1,%eax
c040387b:	75 1a                	jne    c0403897 <sched_remove+0x100>
	{
		cpu_table[cpu].queued--;
c040387d:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403882:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0403886:	c1 e2 06             	shl    $0x6,%edx
c0403889:	01 d0                	add    %edx,%eax
c040388b:	8b 50 30             	mov    0x30(%eax),%edx
c040388e:	4a                   	dec    %edx
c040388f:	89 50 30             	mov    %edx,0x30(%eax)
		sched_dec_queued_threads();
c0403892:	e8 97 f1 ff ff       	call   c0402a2e <sched_dec_queued_threads>
	}

	victim->state = state;
c0403897:	8b 44 24 20          	mov    0x20(%esp),%eax
c040389b:	8b 54 24 24          	mov    0x24(%esp),%edx
c040389f:	89 50 10             	mov    %edx,0x10(%eax)
	
	unlock_gate(&(victim->lock), LOCK_WRITE);	
c04038a2:	8b 44 24 20          	mov    0x20(%esp),%eax
c04038a6:	83 c0 1c             	add    $0x1c,%eax
c04038a9:	83 ec 08             	sub    $0x8,%esp
c04038ac:	6a 01                	push   $0x1
c04038ae:	50                   	push   %eax
c04038af:	e8 63 cd ff ff       	call   c0400617 <unlock_gate>
c04038b4:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[cpu].lock), LOCK_WRITE);
c04038b7:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04038bc:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04038c0:	c1 e2 06             	shl    $0x6,%edx
c04038c3:	01 d0                	add    %edx,%eax
c04038c5:	83 c0 08             	add    $0x8,%eax
c04038c8:	83 ec 08             	sub    $0x8,%esp
c04038cb:	6a 01                	push   $0x1
c04038cd:	50                   	push   %eax
c04038ce:	e8 44 cd ff ff       	call   c0400617 <unlock_gate>
c04038d3:	83 c4 10             	add    $0x10,%esp
	
	SCHED_DEBUG("[sched:%i] removed thread %i (%p) of process %i from cpu %i queue, priority %i\n",
			  CPU_ID, victim->tid, victim, victim->proc->pid, cpu, victim->priority);
}
c04038d6:	83 c4 1c             	add    $0x1c,%esp
c04038d9:	c3                   	ret    

c04038da <sched_pick_queue>:
	to run on, biased in favour of the hinted cpu queue
   => hint = hinted cpu queue 
   <= cpu queue to use
*/
unsigned char sched_pick_queue(unsigned char hint)
{
c04038da:	83 ec 2c             	sub    $0x2c,%esp
c04038dd:	8b 44 24 30          	mov    0x30(%esp),%eax
c04038e1:	88 44 24 0c          	mov    %al,0xc(%esp)
	unsigned char picked;
	unsigned int max_fair_share, original_sched_next;
	
	/* use the boot cpu queue if it's the only cpu */
	if(mp_cpus == 1) return mp_boot_cpu;
c04038e5:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04038ea:	3c 01                	cmp    $0x1,%al
c04038ec:	75 0a                	jne    c04038f8 <sched_pick_queue+0x1e>
c04038ee:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04038f3:	e9 98 01 00 00       	jmp    c0403a90 <sched_pick_queue+0x1b6>
	
	/* use the boot cpu queue if the hint is wild */
	if(hint >= mp_cpus) hint = mp_boot_cpu;
c04038f8:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04038fd:	38 44 24 0c          	cmp    %al,0xc(%esp)
c0403901:	72 09                	jb     c040390c <sched_pick_queue+0x32>
c0403903:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0403908:	88 44 24 0c          	mov    %al,0xc(%esp)
	
	/* protect the scheduler's critical section right here */
	lock_gate(&(sched_lock), LOCK_WRITE);
c040390c:	83 ec 08             	sub    $0x8,%esp
c040390f:	6a 01                	push   $0x1
c0403911:	68 70 f4 40 c0       	push   $0xc040f470
c0403916:	e8 7d cb ff ff       	call   c0400498 <lock_gate>
c040391b:	83 c4 10             	add    $0x10,%esp

	/* the number of threads per cpu queue that's 'fair' to run
		is simply the total number of threads divided by cpu queues 
	   available */
	max_fair_share = sched_total_queued / mp_cpus;
c040391e:	a1 f0 1c 41 c0       	mov    0xc0411cf0,%eax
c0403923:	8a 15 1c 1d 41 c0    	mov    0xc0411d1c,%dl
c0403929:	0f b6 d2             	movzbl %dl,%edx
c040392c:	89 d1                	mov    %edx,%ecx
c040392e:	ba 00 00 00 00       	mov    $0x0,%edx
c0403933:	f7 f1                	div    %ecx
c0403935:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(!max_fair_share) max_fair_share = 1; /* ensure a sane value */
c0403939:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c040393e:	75 08                	jne    c0403948 <sched_pick_queue+0x6e>
c0403940:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c0403947:	00 

	/* ensure next_queue is sane */
	if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
c0403948:	8a 15 ec 1c 41 c0    	mov    0xc0411cec,%dl
c040394e:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403953:	38 c2                	cmp    %al,%dl
c0403955:	72 07                	jb     c040395e <sched_pick_queue+0x84>
c0403957:	c6 05 ec 1c 41 c0 00 	movb   $0x0,0xc0411cec
	
	/* make sure the next queue is not the hinted queue */
	if(sched_next_queue == hint)
c040395e:	a0 ec 1c 41 c0       	mov    0xc0411cec,%al
c0403963:	3a 44 24 0c          	cmp    0xc(%esp),%al
c0403967:	75 21                	jne    c040398a <sched_pick_queue+0xb0>
	{
		sched_next_queue++;
c0403969:	a0 ec 1c 41 c0       	mov    0xc0411cec,%al
c040396e:	40                   	inc    %eax
c040396f:	a2 ec 1c 41 c0       	mov    %al,0xc0411cec
		if(sched_next_queue >= mp_cpus) sched_next_queue = 0;
c0403974:	8a 15 ec 1c 41 c0    	mov    0xc0411cec,%dl
c040397a:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040397f:	38 c2                	cmp    %al,%dl
c0403981:	72 07                	jb     c040398a <sched_pick_queue+0xb0>
c0403983:	c6 05 ec 1c 41 c0 00 	movb   $0x0,0xc0411cec
					hint, cpu_table[hint].queued, sched_total_queued);
	
	/* the strategy is thus: use the hinted queue unless it has more than its
	   fair share of threads or the next queue is empty. in which case, use the next queue if possible and advance it if
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
c040398a:	a0 ec 1c 41 c0       	mov    0xc0411cec,%al
c040398f:	0f b6 c0             	movzbl %al,%eax
c0403992:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
c0403996:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040399b:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04039a0:	c1 e2 06             	shl    $0x6,%edx
c04039a3:	01 d0                	add    %edx,%eax
c04039a5:	83 c0 08             	add    $0x8,%eax
c04039a8:	83 ec 08             	sub    $0x8,%esp
c04039ab:	6a 00                	push   $0x0
c04039ad:	50                   	push   %eax
c04039ae:	e8 e5 ca ff ff       	call   c0400498 <lock_gate>
c04039b3:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
c04039b6:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04039bb:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04039bf:	c1 e2 06             	shl    $0x6,%edx
c04039c2:	01 d0                	add    %edx,%eax
c04039c4:	83 c0 08             	add    $0x8,%eax
c04039c7:	83 ec 08             	sub    $0x8,%esp
c04039ca:	6a 00                	push   $0x0
c04039cc:	50                   	push   %eax
c04039cd:	e8 c6 ca ff ff       	call   c0400498 <lock_gate>
c04039d2:	83 c4 10             	add    $0x10,%esp
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c04039d5:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04039da:	8a 15 ec 1c 41 c0    	mov    0xc0411cec,%dl
c04039e0:	0f b6 d2             	movzbl %dl,%edx
c04039e3:	c1 e2 06             	shl    $0x6,%edx
c04039e6:	01 d0                	add    %edx,%eax
c04039e8:	8b 40 30             	mov    0x30(%eax),%eax
c04039eb:	85 c0                	test   %eax,%eax
c04039ed:	74 18                	je     c0403a07 <sched_pick_queue+0x12d>
		 (cpu_table[hint].queued > max_fair_share)) &&
c04039ef:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04039f4:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c04039f9:	c1 e2 06             	shl    $0x6,%edx
c04039fc:	01 d0                	add    %edx,%eax
c04039fe:	8b 40 30             	mov    0x30(%eax),%eax
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0403a01:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0403a05:	76 2c                	jbe    c0403a33 <sched_pick_queue+0x159>
		 (cpu_table[hint].queued > max_fair_share)) &&
		(cpu_table[hint].queued != 0))
c0403a07:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403a0c:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403a11:	c1 e2 06             	shl    $0x6,%edx
c0403a14:	01 d0                	add    %edx,%eax
c0403a16:	8b 40 30             	mov    0x30(%eax),%eax
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0403a19:	85 c0                	test   %eax,%eax
c0403a1b:	74 16                	je     c0403a33 <sched_pick_queue+0x159>
		 (cpu_table[hint].queued > max_fair_share)) &&
		(cpu_table[hint].queued != 0))
	{
		picked = sched_next_queue;
c0403a1d:	a0 ec 1c 41 c0       	mov    0xc0411cec,%al
c0403a22:	88 44 24 17          	mov    %al,0x17(%esp)
		sched_next_queue++;
c0403a26:	a0 ec 1c 41 c0       	mov    0xc0411cec,%al
c0403a2b:	40                   	inc    %eax
c0403a2c:	a2 ec 1c 41 c0       	mov    %al,0xc0411cec
	   successful. if the hinted queue is empty, then use that */
	original_sched_next = sched_next_queue;
	lock_gate(&(cpu_table[hint].lock), LOCK_READ);
	lock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
	
	if(((cpu_table[sched_next_queue].queued == 0) ||
c0403a31:	eb 08                	jmp    c0403a3b <sched_pick_queue+0x161>
	{
		picked = sched_next_queue;
		sched_next_queue++;
	}
	else
		picked = hint;
c0403a33:	8a 44 24 0c          	mov    0xc(%esp),%al
c0403a37:	88 44 24 17          	mov    %al,0x17(%esp)

	SCHED_DEBUG("[sched:%i] load balancing: selected queue: %i\n",
			      CPU_ID, picked);
	
	unlock_gate(&(cpu_table[original_sched_next].lock), LOCK_READ);
c0403a3b:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403a40:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0403a44:	c1 e2 06             	shl    $0x6,%edx
c0403a47:	01 d0                	add    %edx,%eax
c0403a49:	83 c0 08             	add    $0x8,%eax
c0403a4c:	83 ec 08             	sub    $0x8,%esp
c0403a4f:	6a 00                	push   $0x0
c0403a51:	50                   	push   %eax
c0403a52:	e8 c0 cb ff ff       	call   c0400617 <unlock_gate>
c0403a57:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(cpu_table[hint].lock), LOCK_READ);			
c0403a5a:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c0403a5f:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0403a64:	c1 e2 06             	shl    $0x6,%edx
c0403a67:	01 d0                	add    %edx,%eax
c0403a69:	83 c0 08             	add    $0x8,%eax
c0403a6c:	83 ec 08             	sub    $0x8,%esp
c0403a6f:	6a 00                	push   $0x0
c0403a71:	50                   	push   %eax
c0403a72:	e8 a0 cb ff ff       	call   c0400617 <unlock_gate>
c0403a77:	83 c4 10             	add    $0x10,%esp

	unlock_gate(&(sched_lock), LOCK_WRITE);
c0403a7a:	83 ec 08             	sub    $0x8,%esp
c0403a7d:	6a 01                	push   $0x1
c0403a7f:	68 70 f4 40 c0       	push   $0xc040f470
c0403a84:	e8 8e cb ff ff       	call   c0400617 <unlock_gate>
c0403a89:	83 c4 10             	add    $0x10,%esp
	
	return picked;
c0403a8c:	8a 44 24 17          	mov    0x17(%esp),%al
}
c0403a90:	83 c4 2c             	add    $0x2c,%esp
c0403a93:	c3                   	ret    

c0403a94 <sched_pre_initalise>:

/* sched_pre_initalise
   Perform initialisation prior to any sched_*() calls */
void sched_pre_initalise(void)
{
c0403a94:	83 ec 0c             	sub    $0xc,%esp
	/* initialise lock */
	vmm_memset(&sched_lock, 0, sizeof(rw_gate));	
c0403a97:	83 ec 04             	sub    $0x4,%esp
c0403a9a:	6a 10                	push   $0x10
c0403a9c:	6a 00                	push   $0x0
c0403a9e:	68 70 f4 40 c0       	push   $0xc040f470
c0403aa3:	e8 84 0f 00 00       	call   c0404a2c <vmm_memset>
c0403aa8:	83 c4 10             	add    $0x10,%esp
}
c0403aab:	83 c4 0c             	add    $0xc,%esp
c0403aae:	c3                   	ret    

c0403aaf <sched_initialise>:

/* sched_initialise
	Prepare the default scheduler for action */
void sched_initialise(void)
{
c0403aaf:	83 ec 0c             	sub    $0xc,%esp
	BOOT_DEBUG("[sched:%i] starting operating system...\n", CPU_ID);
c0403ab2:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403ab7:	3c 01                	cmp    $0x1,%al
c0403ab9:	76 0c                	jbe    c0403ac7 <sched_initialise+0x18>
c0403abb:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403ac0:	8b 00                	mov    (%eax),%eax
c0403ac2:	c1 e8 18             	shr    $0x18,%eax
c0403ac5:	eb 08                	jmp    c0403acf <sched_initialise+0x20>
c0403ac7:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0403acc:	0f b6 c0             	movzbl %al,%eax
c0403acf:	83 ec 08             	sub    $0x8,%esp
c0403ad2:	50                   	push   %eax
c0403ad3:	68 b8 c4 40 c0       	push   $0xc040c4b8
c0403ad8:	e8 a5 83 00 00       	call   c040be82 <debug_printf>
c0403add:	83 c4 10             	add    $0x10,%esp

	/* start running process 1, thread 1 in user mode, which
	   should spawn system managers and continue the boot process */
	while(1) lowlevel_kickstart();
c0403ae0:	e8 a3 d3 ff ff       	call   c0400e88 <lowlevel_kickstart>
c0403ae5:	eb f9                	jmp    c0403ae0 <sched_initialise+0x31>
	...

c0403ae8 <vmm_malloc>:
             be written. the address will be a kernel logical one.
      size = size of block required.
   <= 0 for success, or result code
*/
kresult vmm_malloc(void **addr, unsigned int size)
{
c0403ae8:	83 ec 2c             	sub    $0x2c,%esp
   unsigned int safe_size, *addr_word = (unsigned int *)addr;
c0403aeb:	8b 44 24 30          	mov    0x30(%esp),%eax
c0403aef:	89 44 24 0c          	mov    %eax,0xc(%esp)
   kheap_block *block, *extra;
	
	lock_gate(&(vmm_lock), LOCK_WRITE);
c0403af3:	83 ec 08             	sub    $0x8,%esp
c0403af6:	6a 01                	push   $0x1
c0403af8:	68 8c f4 40 c0       	push   $0xc040f48c
c0403afd:	e8 96 c9 ff ff       	call   c0400498 <lock_gate>
c0403b02:	83 c4 10             	add    $0x10,%esp
	
   /* adjust size to include our block header plus enough memory to tack
      a header onto any left over memory - we round up to a set size
	   (default 64 bytes) to reduce fragmentation and aid quick realloc'ing */
   size += sizeof(kheap_block);
c0403b05:	83 44 24 34 10       	addl   $0x10,0x34(%esp)
   safe_size = size + sizeof(kheap_block);
c0403b0a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0403b0e:	83 c0 10             	add    $0x10,%eax
c0403b11:	89 44 24 08          	mov    %eax,0x8(%esp)
	safe_size = KHEAP_PAD(safe_size);
c0403b15:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403b19:	83 c0 40             	add    $0x40,%eax
c0403b1c:	83 e0 c0             	and    $0xffffffc0,%eax
c0403b1f:	89 44 24 08          	mov    %eax,0x8(%esp)
   
   /* scan through free list to find the first block that will fit the
      requested size */
   block = kheap_free;
c0403b23:	a1 fc 1c 41 c0       	mov    0xc0411cfc,%eax
c0403b28:	89 44 24 04          	mov    %eax,0x4(%esp)
   while(block)
c0403b2c:	eb 18                	jmp    c0403b46 <vmm_malloc+0x5e>
   {
      if(block->size > safe_size)
c0403b2e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b32:	8b 40 04             	mov    0x4(%eax),%eax
c0403b35:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0403b39:	77 15                	ja     c0403b50 <vmm_malloc+0x68>
         break;
      block = block->next;
c0403b3b:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b3f:	8b 40 0c             	mov    0xc(%eax),%eax
c0403b42:	89 44 24 04          	mov    %eax,0x4(%esp)
	safe_size = KHEAP_PAD(safe_size);
   
   /* scan through free list to find the first block that will fit the
      requested size */
   block = kheap_free;
   while(block)
c0403b46:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b4a:	85 c0                	test   %eax,%eax
c0403b4c:	75 e0                	jne    c0403b2e <vmm_malloc+0x46>
c0403b4e:	eb 01                	jmp    c0403b51 <vmm_malloc+0x69>
   {
      if(block->size > safe_size)
         break;
c0403b50:	90                   	nop
      block = block->next;
   }

   /* if the block is set, then we've found something suitable in the free
      list. remove it from the free list */
   if(block)
c0403b51:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b55:	85 c0                	test   %eax,%eax
c0403b57:	74 52                	je     c0403bab <vmm_malloc+0xc3>
   {
      if(block->previous)
c0403b59:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b5d:	8b 40 08             	mov    0x8(%eax),%eax
c0403b60:	85 c0                	test   %eax,%eax
c0403b62:	74 11                	je     c0403b75 <vmm_malloc+0x8d>
         block->previous->next = block->next;
c0403b64:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b68:	8b 40 08             	mov    0x8(%eax),%eax
c0403b6b:	8b 54 24 04          	mov    0x4(%esp),%edx
c0403b6f:	8b 52 0c             	mov    0xc(%edx),%edx
c0403b72:	89 50 0c             	mov    %edx,0xc(%eax)
      
      if(block->next)
c0403b75:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b79:	8b 40 0c             	mov    0xc(%eax),%eax
c0403b7c:	85 c0                	test   %eax,%eax
c0403b7e:	74 11                	je     c0403b91 <vmm_malloc+0xa9>
         block->next->previous = block->previous;
c0403b80:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b84:	8b 40 0c             	mov    0xc(%eax),%eax
c0403b87:	8b 54 24 04          	mov    0x4(%esp),%edx
c0403b8b:	8b 52 08             	mov    0x8(%edx),%edx
c0403b8e:	89 50 08             	mov    %edx,0x8(%eax)
      
      if(kheap_free == block)
c0403b91:	8b 15 fc 1c 41 c0    	mov    0xc0411cfc,%edx
c0403b97:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403b9b:	39 c2                	cmp    %eax,%edx
c0403b9d:	75 0c                	jne    c0403bab <vmm_malloc+0xc3>
         kheap_free = block->next;
c0403b9f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403ba3:	8b 40 0c             	mov    0xc(%eax),%eax
c0403ba6:	a3 fc 1c 41 c0       	mov    %eax,0xc0411cfc
   }

   /* if block is unset then we haven't found a suitable block (or the free
      list is empty). so allocate enough pages for the request */
   if(!block)
c0403bab:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403baf:	85 c0                	test   %eax,%eax
c0403bb1:	0f 85 e4 00 00 00    	jne    c0403c9b <vmm_malloc+0x1b3>
   {
      int pg_count, type = MEM_HIGH_PG;
c0403bb7:	c7 44 24 18 02 00 00 	movl   $0x2,0x18(%esp)
c0403bbe:	00 
      kresult result = vmm_ensure_pgs(safe_size, type);
c0403bbf:	83 ec 08             	sub    $0x8,%esp
c0403bc2:	ff 74 24 20          	pushl  0x20(%esp)
c0403bc6:	ff 74 24 14          	pushl  0x14(%esp)
c0403bca:	e8 4b 09 00 00       	call   c040451a <vmm_ensure_pgs>
c0403bcf:	83 c4 10             	add    $0x10,%esp
c0403bd2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
      if(result)
c0403bd6:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0403bdb:	74 41                	je     c0403c1e <vmm_malloc+0x136>
      {
         /* try using low memory */
         type = MEM_LOW_PG;
c0403bdd:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0403be4:	00 
         result = vmm_ensure_pgs(safe_size, type);
c0403be5:	83 ec 08             	sub    $0x8,%esp
c0403be8:	ff 74 24 20          	pushl  0x20(%esp)
c0403bec:	ff 74 24 14          	pushl  0x14(%esp)
c0403bf0:	e8 25 09 00 00       	call   c040451a <vmm_ensure_pgs>
c0403bf5:	83 c4 10             	add    $0x10,%esp
c0403bf8:	89 44 24 1c          	mov    %eax,0x1c(%esp)
         if(result)
c0403bfc:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0403c01:	74 1b                	je     c0403c1e <vmm_malloc+0x136>
			{
				VMM_DEBUG("[vmm:%i] failed to grab physical pages for kernel heap (req size %i bytes)\n",
						  CPU_ID, safe_size);
				unlock_gate(&(vmm_lock), LOCK_WRITE);
c0403c03:	83 ec 08             	sub    $0x8,%esp
c0403c06:	6a 01                	push   $0x1
c0403c08:	68 8c f4 40 c0       	push   $0xc040f48c
c0403c0d:	e8 05 ca ff ff       	call   c0400617 <unlock_gate>
c0403c12:	83 c4 10             	add    $0x10,%esp
				return result; /* give up otherwise */
c0403c15:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0403c19:	e9 25 01 00 00       	jmp    c0403d43 <vmm_malloc+0x25b>
			}
      }
		
      /* by now, we've verified that we have a run of pages so grab them */
      for(pg_count = 0; pg_count < ((safe_size / MEM_PGSIZE) + 1); pg_count++)
c0403c1e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0403c25:	00 
c0403c26:	eb 3e                	jmp    c0403c66 <vmm_malloc+0x17e>
      {
         result = vmm_req_phys_pg((void **)&block, type); /* get pages in reverse order */
c0403c28:	8d 44 24 04          	lea    0x4(%esp),%eax
c0403c2c:	83 ec 08             	sub    $0x8,%esp
c0403c2f:	ff 74 24 20          	pushl  0x20(%esp)
c0403c33:	50                   	push   %eax
c0403c34:	e8 02 06 00 00       	call   c040423b <vmm_req_phys_pg>
c0403c39:	83 c4 10             	add    $0x10,%esp
c0403c3c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
         if(result)
c0403c40:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0403c45:	74 1b                	je     c0403c62 <vmm_malloc+0x17a>
			{
				VMM_DEBUG("[vmm:%i] failed to grab physical page for kernel heap\n", CPU_ID);
				unlock_gate(&(vmm_lock), LOCK_WRITE);
c0403c47:	83 ec 08             	sub    $0x8,%esp
c0403c4a:	6a 01                	push   $0x1
c0403c4c:	68 8c f4 40 c0       	push   $0xc040f48c
c0403c51:	e8 c1 c9 ff ff       	call   c0400617 <unlock_gate>
c0403c56:	83 c4 10             	add    $0x10,%esp
				return result; /* XXX shouldn't happen - memory leak */
c0403c59:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0403c5d:	e9 e1 00 00 00       	jmp    c0403d43 <vmm_malloc+0x25b>
				return result; /* give up otherwise */
			}
      }
		
      /* by now, we've verified that we have a run of pages so grab them */
      for(pg_count = 0; pg_count < ((safe_size / MEM_PGSIZE) + 1); pg_count++)
c0403c62:	ff 44 24 14          	incl   0x14(%esp)
c0403c66:	8b 44 24 14          	mov    0x14(%esp),%eax
c0403c6a:	8b 54 24 08          	mov    0x8(%esp),%edx
c0403c6e:	c1 ea 0c             	shr    $0xc,%edx
c0403c71:	42                   	inc    %edx
c0403c72:	39 d0                	cmp    %edx,%eax
c0403c74:	72 b2                	jb     c0403c28 <vmm_malloc+0x140>
#ifdef VMM_DEBUG
		VMM_DEBUG("[vmm:%i] asked for a block of pages for %i bytes: %p\n", CPU_ID, safe_size, block);
#endif
		
      /* don't forget to convert from physical to kernel's logical */
      block = KERNEL_PHYS2LOG(block);
c0403c76:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403c7a:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0403c7f:	89 44 24 04          	mov    %eax,0x4(%esp)
      block->size = (unsigned int)MEM_PGALIGN(safe_size) + MEM_PGSIZE;
c0403c83:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403c87:	8b 54 24 08          	mov    0x8(%esp),%edx
c0403c8b:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0403c91:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0403c97:	89 50 04             	mov    %edx,0x4(%eax)
#ifdef VMM_DEBUG
      VMM_DEBUG("[vmm:%i] grabbed %i bytes from mem %p for heap\n", CPU_ID, block->size, block); 
c0403c9a:	90                   	nop
#endif
   }

   /* trim off excess memory and add this to the free list */
   extra = (kheap_block *)((unsigned int)block + size);
c0403c9b:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403c9f:	03 44 24 34          	add    0x34(%esp),%eax
c0403ca3:	89 44 24 10          	mov    %eax,0x10(%esp)
   extra->magic = KHEAP_FREE;
c0403ca7:	8b 44 24 10          	mov    0x10(%esp),%eax
c0403cab:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)
   extra->size = block->size - size;
c0403cb1:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403cb5:	8b 40 04             	mov    0x4(%eax),%eax
c0403cb8:	89 c2                	mov    %eax,%edx
c0403cba:	2b 54 24 34          	sub    0x34(%esp),%edx
c0403cbe:	8b 44 24 10          	mov    0x10(%esp),%eax
c0403cc2:	89 50 04             	mov    %edx,0x4(%eax)
   vmm_heap_add_to_free(extra);
c0403cc5:	83 ec 0c             	sub    $0xc,%esp
c0403cc8:	ff 74 24 1c          	pushl  0x1c(%esp)
c0403ccc:	e8 ac 00 00 00       	call   c0403d7d <vmm_heap_add_to_free>
c0403cd1:	83 c4 10             	add    $0x10,%esp

   /* write pointer to the start of data and the block's header details */
   *addr_word = (unsigned int)block + sizeof(kheap_block);
c0403cd4:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403cd8:	8d 50 10             	lea    0x10(%eax),%edx
c0403cdb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403cdf:	89 10                	mov    %edx,(%eax)
   block->magic = KHEAP_INUSE;
c0403ce1:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403ce5:	c7 00 68 42 6c 6b    	movl   $0x6b6c4268,(%eax)
   block->size = size; /* the true size of the requested block inc header */
c0403ceb:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403cef:	8b 54 24 34          	mov    0x34(%esp),%edx
c0403cf3:	89 50 04             	mov    %edx,0x4(%eax)

   /* add to head of allocated link list */
   block->next = kheap_allocated;
c0403cf6:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403cfa:	8b 15 00 1d 41 c0    	mov    0xc0411d00,%edx
c0403d00:	89 50 0c             	mov    %edx,0xc(%eax)
   if(kheap_allocated) kheap_allocated->previous = block;
c0403d03:	a1 00 1d 41 c0       	mov    0xc0411d00,%eax
c0403d08:	85 c0                	test   %eax,%eax
c0403d0a:	74 0c                	je     c0403d18 <vmm_malloc+0x230>
c0403d0c:	a1 00 1d 41 c0       	mov    0xc0411d00,%eax
c0403d11:	8b 54 24 04          	mov    0x4(%esp),%edx
c0403d15:	89 50 08             	mov    %edx,0x8(%eax)
   block->previous = NULL;
c0403d18:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403d1c:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
   kheap_allocated = block;
c0403d23:	8b 44 24 04          	mov    0x4(%esp),%eax
c0403d27:	a3 00 1d 41 c0       	mov    %eax,0xc0411d00

	unlock_gate(&(vmm_lock), LOCK_WRITE);
c0403d2c:	83 ec 08             	sub    $0x8,%esp
c0403d2f:	6a 01                	push   $0x1
c0403d31:	68 8c f4 40 c0       	push   $0xc040f48c
c0403d36:	e8 dc c8 ff ff       	call   c0400617 <unlock_gate>
c0403d3b:	83 c4 10             	add    $0x10,%esp
   return success;
c0403d3e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0403d43:	83 c4 2c             	add    $0x2c,%esp
c0403d46:	c3                   	ret    

c0403d47 <vmm_malloc_read_size>:

/* vmm_malloc_read_size
	Return the allocated size of a given block in bytes or 0 for bad block */
unsigned int vmm_malloc_read_size(void *addr)
{
c0403d47:	83 ec 10             	sub    $0x10,%esp
	kheap_block *block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));
c0403d4a:	8b 44 24 14          	mov    0x14(%esp),%eax
c0403d4e:	83 e8 10             	sub    $0x10,%eax
c0403d51:	89 44 24 0c          	mov    %eax,0xc(%esp)
	return block->size;
c0403d55:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403d59:	8b 40 04             	mov    0x4(%eax),%eax
}
c0403d5c:	83 c4 10             	add    $0x10,%esp
c0403d5f:	c3                   	ret    

c0403d60 <vmm_malloc_write_size>:

/* vmm_malloc_write_size
   Update the allocated size of a given block in bytes */
void vmm_malloc_write_size(void *addr, unsigned int size)
{
c0403d60:	83 ec 10             	sub    $0x10,%esp
	kheap_block *block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));
c0403d63:	8b 44 24 14          	mov    0x14(%esp),%eax
c0403d67:	83 e8 10             	sub    $0x10,%eax
c0403d6a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	block->size = size;
c0403d6e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403d72:	8b 54 24 18          	mov    0x18(%esp),%edx
c0403d76:	89 50 04             	mov    %edx,0x4(%eax)
}
c0403d79:	83 c4 10             	add    $0x10,%esp
c0403d7c:	c3                   	ret    

c0403d7d <vmm_heap_add_to_free>:
   base address, lowest first (at the head) and ascending. Then, scan the free
   list and merge adjoining blocks together.
   => pointer to heap block
*/
void vmm_heap_add_to_free(kheap_block *block)
{
c0403d7d:	83 ec 1c             	sub    $0x1c,%esp
	lock_gate(&(vmm_lock), LOCK_WRITE);
c0403d80:	83 ec 08             	sub    $0x8,%esp
c0403d83:	6a 01                	push   $0x1
c0403d85:	68 8c f4 40 c0       	push   $0xc040f48c
c0403d8a:	e8 09 c7 ff ff       	call   c0400498 <lock_gate>
c0403d8f:	83 c4 10             	add    $0x10,%esp
	
   kheap_block *block_loop = kheap_free;
c0403d92:	a1 fc 1c 41 c0       	mov    0xc0411cfc,%eax
c0403d97:	89 44 24 08          	mov    %eax,0x8(%esp)

   while(block_loop)
c0403d9b:	e9 96 00 00 00       	jmp    c0403e36 <vmm_heap_add_to_free+0xb9>
   {
      /* insert block in front of block_loop */
      if(block < block_loop)
c0403da0:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403da4:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0403da8:	73 53                	jae    c0403dfd <vmm_heap_add_to_free+0x80>
      {
         block->next = block_loop;
c0403daa:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403dae:	8b 54 24 08          	mov    0x8(%esp),%edx
c0403db2:	89 50 0c             	mov    %edx,0xc(%eax)
         block->previous = block_loop->previous;
c0403db5:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403db9:	8b 50 08             	mov    0x8(%eax),%edx
c0403dbc:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403dc0:	89 50 08             	mov    %edx,0x8(%eax)
         if(!block->previous) kheap_free = block; /* connect to head if first */
c0403dc3:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403dc7:	8b 40 08             	mov    0x8(%eax),%eax
c0403dca:	85 c0                	test   %eax,%eax
c0403dcc:	75 09                	jne    c0403dd7 <vmm_heap_add_to_free+0x5a>
c0403dce:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403dd2:	a3 fc 1c 41 c0       	mov    %eax,0xc0411cfc

         if(block_loop->previous)
c0403dd7:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ddb:	8b 40 08             	mov    0x8(%eax),%eax
c0403dde:	85 c0                	test   %eax,%eax
c0403de0:	74 0e                	je     c0403df0 <vmm_heap_add_to_free+0x73>
            block_loop->previous->next = block;
c0403de2:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403de6:	8b 40 08             	mov    0x8(%eax),%eax
c0403de9:	8b 54 24 20          	mov    0x20(%esp),%edx
c0403ded:	89 50 0c             	mov    %edx,0xc(%eax)

         block_loop->previous = block;
c0403df0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403df4:	8b 54 24 20          	mov    0x20(%esp),%edx
c0403df8:	89 50 08             	mov    %edx,0x8(%eax)
         break;
c0403dfb:	eb 44                	jmp    c0403e41 <vmm_heap_add_to_free+0xc4>
      }

      /* add to end of the free list */
      if(!block_loop->next)
c0403dfd:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e01:	8b 40 0c             	mov    0xc(%eax),%eax
c0403e04:	85 c0                	test   %eax,%eax
c0403e06:	75 23                	jne    c0403e2b <vmm_heap_add_to_free+0xae>
      {
         block_loop->next = block;
c0403e08:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e0c:	8b 54 24 20          	mov    0x20(%esp),%edx
c0403e10:	89 50 0c             	mov    %edx,0xc(%eax)
         block->next = NULL;
c0403e13:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e17:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
         block->previous = block_loop;
c0403e1e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e22:	8b 54 24 08          	mov    0x8(%esp),%edx
c0403e26:	89 50 08             	mov    %edx,0x8(%eax)
         break;
c0403e29:	eb 16                	jmp    c0403e41 <vmm_heap_add_to_free+0xc4>
      }

      block_loop = block_loop->next;
c0403e2b:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e2f:	8b 40 0c             	mov    0xc(%eax),%eax
c0403e32:	89 44 24 08          	mov    %eax,0x8(%esp)
{
	lock_gate(&(vmm_lock), LOCK_WRITE);
	
   kheap_block *block_loop = kheap_free;

   while(block_loop)
c0403e36:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0403e3b:	0f 85 5f ff ff ff    	jne    c0403da0 <vmm_heap_add_to_free+0x23>

      block_loop = block_loop->next;
   }

   /* if list is empty, then start it with block */
   if(!kheap_free)
c0403e41:	a1 fc 1c 41 c0       	mov    0xc0411cfc,%eax
c0403e46:	85 c0                	test   %eax,%eax
c0403e48:	75 1f                	jne    c0403e69 <vmm_heap_add_to_free+0xec>
   {
      block->next = NULL;
c0403e4a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e4e:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
      block->previous = NULL;
c0403e55:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e59:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      kheap_free = block;
c0403e60:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e64:	a3 fc 1c 41 c0       	mov    %eax,0xc0411cfc
   }

   block->magic = KHEAP_FREE;
c0403e69:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403e6d:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)

   /* merge adjoining blocks */
   block_loop = kheap_free;
c0403e73:	a1 fc 1c 41 c0       	mov    0xc0411cfc,%eax
c0403e78:	89 44 24 08          	mov    %eax,0x8(%esp)
   while(block_loop)
c0403e7c:	eb 71                	jmp    c0403eef <vmm_heap_add_to_free+0x172>
   {
      kheap_block *target = block_loop->next;
c0403e7e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e82:	8b 40 0c             	mov    0xc(%eax),%eax
c0403e85:	89 44 24 0c          	mov    %eax,0xc(%esp)
      if(!target) break; /* sanity check next ptr */
c0403e89:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0403e8e:	74 68                	je     c0403ef8 <vmm_heap_add_to_free+0x17b>

      if((unsigned int)target == ((unsigned int)block_loop + block_loop->size))
c0403e90:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0403e94:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e98:	8b 48 04             	mov    0x4(%eax),%ecx
c0403e9b:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403e9f:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0403ea2:	39 c2                	cmp    %eax,%edx
c0403ea4:	75 3e                	jne    c0403ee4 <vmm_heap_add_to_free+0x167>
      {
         block_loop->next = target->next;
c0403ea6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403eaa:	8b 50 0c             	mov    0xc(%eax),%edx
c0403ead:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403eb1:	89 50 0c             	mov    %edx,0xc(%eax)
         if(target->next)
c0403eb4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403eb8:	8b 40 0c             	mov    0xc(%eax),%eax
c0403ebb:	85 c0                	test   %eax,%eax
c0403ebd:	74 0e                	je     c0403ecd <vmm_heap_add_to_free+0x150>
            target->next->previous = block_loop;
c0403ebf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403ec3:	8b 40 0c             	mov    0xc(%eax),%eax
c0403ec6:	8b 54 24 08          	mov    0x8(%esp),%edx
c0403eca:	89 50 08             	mov    %edx,0x8(%eax)
         block_loop->size += target->size;
c0403ecd:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ed1:	8b 50 04             	mov    0x4(%eax),%edx
c0403ed4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403ed8:	8b 40 04             	mov    0x4(%eax),%eax
c0403edb:	01 c2                	add    %eax,%edx
c0403edd:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ee1:	89 50 04             	mov    %edx,0x4(%eax)
      }
      block_loop = block_loop->next;
c0403ee4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0403ee8:	8b 40 0c             	mov    0xc(%eax),%eax
c0403eeb:	89 44 24 08          	mov    %eax,0x8(%esp)

   block->magic = KHEAP_FREE;

   /* merge adjoining blocks */
   block_loop = kheap_free;
   while(block_loop)
c0403eef:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0403ef4:	75 88                	jne    c0403e7e <vmm_heap_add_to_free+0x101>
c0403ef6:	eb 01                	jmp    c0403ef9 <vmm_heap_add_to_free+0x17c>
   {
      kheap_block *target = block_loop->next;
      if(!target) break; /* sanity check next ptr */
c0403ef8:	90                   	nop
         block_loop->size += target->size;
      }
      block_loop = block_loop->next;
   }
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c0403ef9:	83 ec 08             	sub    $0x8,%esp
c0403efc:	6a 01                	push   $0x1
c0403efe:	68 8c f4 40 c0       	push   $0xc040f48c
c0403f03:	e8 0f c7 ff ff       	call   c0400617 <unlock_gate>
c0403f08:	83 c4 10             	add    $0x10,%esp
}
c0403f0b:	83 c4 1c             	add    $0x1c,%esp
c0403f0e:	c3                   	ret    

c0403f0f <vmm_free>:
   free lists. the address of the block must be a kernel logical one.
   => addr = base of block to free up
   <= 0 for success, or result code
*/
kresult vmm_free(void *addr)
{
c0403f0f:	83 ec 1c             	sub    $0x1c,%esp
   kheap_block *block;

   /* get out now if the addr is insane */
   if((unsigned int)addr < KERNEL_VIRTUAL_BASE) /* XXX assumes high knl */
c0403f12:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403f16:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c0403f1b:	77 41                	ja     c0403f5e <vmm_free+0x4f>
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_free: given nonsense address %x\n", CPU_ID, addr);
c0403f1d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0403f22:	3c 01                	cmp    $0x1,%al
c0403f24:	76 0c                	jbe    c0403f32 <vmm_free+0x23>
c0403f26:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403f2b:	8b 00                	mov    (%eax),%eax
c0403f2d:	c1 e8 18             	shr    $0x18,%eax
c0403f30:	eb 08                	jmp    c0403f3a <vmm_free+0x2b>
c0403f32:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0403f37:	0f b6 c0             	movzbl %al,%eax
c0403f3a:	83 ec 04             	sub    $0x4,%esp
c0403f3d:	ff 74 24 24          	pushl  0x24(%esp)
c0403f41:	50                   	push   %eax
c0403f42:	68 e4 c4 40 c0       	push   $0xc040c4e4
c0403f47:	e8 36 7f 00 00       	call   c040be82 <debug_printf>
c0403f4c:	83 c4 10             	add    $0x10,%esp
		debug_stacktrace();
c0403f4f:	e8 1f 78 00 00       	call   c040b773 <debug_stacktrace>
      return e_bad_address;
c0403f54:	b8 11 00 00 00       	mov    $0x11,%eax
c0403f59:	e9 ee 00 00 00       	jmp    c040404c <vmm_free+0x13d>
   }

   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));
c0403f5e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0403f62:	83 e8 10             	sub    $0x10,%eax
c0403f65:	89 44 24 0c          	mov    %eax,0xc(%esp)

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
c0403f69:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403f6d:	8b 00                	mov    (%eax),%eax
c0403f6f:	3d 68 42 6c 6b       	cmp    $0x6b6c4268,%eax
c0403f74:	74 45                	je     c0403fbb <vmm_free+0xac>
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n",
c0403f76:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403f7a:	8b 10                	mov    (%eax),%edx
              CPU_ID, block, block->magic);
c0403f7c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n",
c0403f81:	3c 01                	cmp    $0x1,%al
c0403f83:	76 0c                	jbe    c0403f91 <vmm_free+0x82>
              CPU_ID, block, block->magic);
c0403f85:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0403f8a:	8b 00                	mov    (%eax),%eax
   block = (kheap_block *)((unsigned int)addr - sizeof(kheap_block));

   /* sanity check the block */
   if(block->magic != KHEAP_INUSE)
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_free: block %x has wrong magic %x\n",
c0403f8c:	c1 e8 18             	shr    $0x18,%eax
c0403f8f:	eb 08                	jmp    c0403f99 <vmm_free+0x8a>
c0403f91:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0403f96:	0f b6 c0             	movzbl %al,%eax
c0403f99:	52                   	push   %edx
c0403f9a:	ff 74 24 10          	pushl  0x10(%esp)
c0403f9e:	50                   	push   %eax
c0403f9f:	68 1c c5 40 c0       	push   $0xc040c51c
c0403fa4:	e8 d9 7e 00 00       	call   c040be82 <debug_printf>
c0403fa9:	83 c4 10             	add    $0x10,%esp
              CPU_ID, block, block->magic);
		debug_stacktrace();
c0403fac:	e8 c2 77 00 00       	call   c040b773 <debug_stacktrace>
      return e_bad_magic;
c0403fb1:	b8 12 00 00 00       	mov    $0x12,%eax
c0403fb6:	e9 91 00 00 00       	jmp    c040404c <vmm_free+0x13d>
   }

	lock_gate(&(vmm_lock), LOCK_WRITE);
c0403fbb:	83 ec 08             	sub    $0x8,%esp
c0403fbe:	6a 01                	push   $0x1
c0403fc0:	68 8c f4 40 c0       	push   $0xc040f48c
c0403fc5:	e8 ce c4 ff ff       	call   c0400498 <lock_gate>
c0403fca:	83 c4 10             	add    $0x10,%esp
	
   /* update magic */
   block->magic = KHEAP_FREE;
c0403fcd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403fd1:	c7 00 ad de ad de    	movl   $0xdeaddead,(%eax)

   /* remove from allocated linked list */
   if(block->previous)
c0403fd7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403fdb:	8b 40 08             	mov    0x8(%eax),%eax
c0403fde:	85 c0                	test   %eax,%eax
c0403fe0:	74 11                	je     c0403ff3 <vmm_free+0xe4>
      block->previous->next = block->next;
c0403fe2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403fe6:	8b 40 08             	mov    0x8(%eax),%eax
c0403fe9:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0403fed:	8b 52 0c             	mov    0xc(%edx),%edx
c0403ff0:	89 50 0c             	mov    %edx,0xc(%eax)

   if(block->next)
c0403ff3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0403ff7:	8b 40 0c             	mov    0xc(%eax),%eax
c0403ffa:	85 c0                	test   %eax,%eax
c0403ffc:	74 11                	je     c040400f <vmm_free+0x100>
      block->next->previous = block->previous;
c0403ffe:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404002:	8b 40 0c             	mov    0xc(%eax),%eax
c0404005:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0404009:	8b 52 08             	mov    0x8(%edx),%edx
c040400c:	89 50 08             	mov    %edx,0x8(%eax)

   if(kheap_allocated == block)
c040400f:	a1 00 1d 41 c0       	mov    0xc0411d00,%eax
c0404014:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0404018:	75 0c                	jne    c0404026 <vmm_free+0x117>
      kheap_allocated = block->next;
c040401a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040401e:	8b 40 0c             	mov    0xc(%eax),%eax
c0404021:	a3 00 1d 41 c0       	mov    %eax,0xc0411d00

   /* add to head of free list */
   vmm_heap_add_to_free(block);
c0404026:	83 ec 0c             	sub    $0xc,%esp
c0404029:	ff 74 24 18          	pushl  0x18(%esp)
c040402d:	e8 4b fd ff ff       	call   c0403d7d <vmm_heap_add_to_free>
c0404032:	83 c4 10             	add    $0x10,%esp

	unlock_gate(&(vmm_lock), LOCK_WRITE);
c0404035:	83 ec 08             	sub    $0x8,%esp
c0404038:	6a 01                	push   $0x1
c040403a:	68 8c f4 40 c0       	push   $0xc040f48c
c040403f:	e8 d3 c5 ff ff       	call   c0400617 <unlock_gate>
c0404044:	83 c4 10             	add    $0x10,%esp
	
   return success;
c0404047:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040404c:	83 c4 1c             	add    $0x1c,%esp
c040404f:	c3                   	ret    

c0404050 <vmm_realloc>:
   <= pointer to new block pointer if it had to be moved, or the original
      block pointer if no move was required, or NULL for failure. The original
      block will remain in-tact if the reallocation fails for whatever reason.
*/
void *vmm_realloc(void *addr, signed int change)
{
c0404050:	83 ec 1c             	sub    $0x1c,%esp
	void *new;
	unsigned int size;
	
	if(!addr)
c0404053:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0404058:	75 3c                	jne    c0404096 <vmm_realloc+0x46>
	{
		KOOPS_DEBUG("[vmm:%i] OMGWTF tried to alter size of a dereferenced block by %i bytes\n",
				      CPU_ID, change);
c040405a:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	void *new;
	unsigned int size;
	
	if(!addr)
	{
		KOOPS_DEBUG("[vmm:%i] OMGWTF tried to alter size of a dereferenced block by %i bytes\n",
c040405f:	3c 01                	cmp    $0x1,%al
c0404061:	76 0c                	jbe    c040406f <vmm_realloc+0x1f>
				      CPU_ID, change);
c0404063:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404068:	8b 00                	mov    (%eax),%eax
	void *new;
	unsigned int size;
	
	if(!addr)
	{
		KOOPS_DEBUG("[vmm:%i] OMGWTF tried to alter size of a dereferenced block by %i bytes\n",
c040406a:	c1 e8 18             	shr    $0x18,%eax
c040406d:	eb 08                	jmp    c0404077 <vmm_realloc+0x27>
c040406f:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0404074:	0f b6 c0             	movzbl %al,%eax
c0404077:	83 ec 04             	sub    $0x4,%esp
c040407a:	ff 74 24 28          	pushl  0x28(%esp)
c040407e:	50                   	push   %eax
c040407f:	68 54 c5 40 c0       	push   $0xc040c554
c0404084:	e8 f9 7d 00 00       	call   c040be82 <debug_printf>
c0404089:	83 c4 10             	add    $0x10,%esp
				      CPU_ID, change);
		return NULL; /* failed */
c040408c:	b8 00 00 00 00       	mov    $0x0,%eax
c0404091:	e9 a1 01 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
	}
	
	/* read the size of the block in bytes - if the size is zero (because the block
		was not found), then treat as a malloc */
	size = vmm_malloc_read_size(addr);
c0404096:	83 ec 0c             	sub    $0xc,%esp
c0404099:	ff 74 24 2c          	pushl  0x2c(%esp)
c040409d:	e8 a5 fc ff ff       	call   c0403d47 <vmm_malloc_read_size>
c04040a2:	83 c4 10             	add    $0x10,%esp
c04040a5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(!size)
c04040a9:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04040ae:	75 74                	jne    c0404124 <vmm_realloc+0xd4>
	{
		/* we can't decrease or unchange a block that didn't exist... */
		if(change < 1)
c04040b0:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04040b5:	7f 41                	jg     c04040f8 <vmm_realloc+0xa8>
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a non-existent block by %i bytes\n",
c04040b7:	8b 44 24 24          	mov    0x24(%esp),%eax
c04040bb:	89 c2                	mov    %eax,%edx
c04040bd:	f7 da                	neg    %edx
							CPU_ID, 0 - change);
c04040bf:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	if(!size)
	{
		/* we can't decrease or unchange a block that didn't exist... */
		if(change < 1)
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a non-existent block by %i bytes\n",
c04040c4:	3c 01                	cmp    $0x1,%al
c04040c6:	76 0c                	jbe    c04040d4 <vmm_realloc+0x84>
							CPU_ID, 0 - change);
c04040c8:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04040cd:	8b 00                	mov    (%eax),%eax
	if(!size)
	{
		/* we can't decrease or unchange a block that didn't exist... */
		if(change < 1)
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a non-existent block by %i bytes\n",
c04040cf:	c1 e8 18             	shr    $0x18,%eax
c04040d2:	eb 08                	jmp    c04040dc <vmm_realloc+0x8c>
c04040d4:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04040d9:	0f b6 c0             	movzbl %al,%eax
c04040dc:	83 ec 04             	sub    $0x4,%esp
c04040df:	52                   	push   %edx
c04040e0:	50                   	push   %eax
c04040e1:	68 a0 c5 40 c0       	push   $0xc040c5a0
c04040e6:	e8 97 7d 00 00       	call   c040be82 <debug_printf>
c04040eb:	83 c4 10             	add    $0x10,%esp
							CPU_ID, 0 - change);
			return NULL; /* failed */			
c04040ee:	b8 00 00 00 00       	mov    $0x0,%eax
c04040f3:	e9 3f 01 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
		}
		
		if(vmm_malloc(&new, change) == success)
c04040f8:	8b 44 24 24          	mov    0x24(%esp),%eax
c04040fc:	83 ec 08             	sub    $0x8,%esp
c04040ff:	50                   	push   %eax
c0404100:	8d 44 24 14          	lea    0x14(%esp),%eax
c0404104:	50                   	push   %eax
c0404105:	e8 de f9 ff ff       	call   c0403ae8 <vmm_malloc>
c040410a:	83 c4 10             	add    $0x10,%esp
c040410d:	85 c0                	test   %eax,%eax
c040410f:	75 09                	jne    c040411a <vmm_realloc+0xca>
			return new; /* we succeeded, send back the pointer */
c0404111:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404115:	e9 1d 01 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
		else
			return NULL; /* failed to allocate */
c040411a:	b8 00 00 00 00       	mov    $0x0,%eax
c040411f:	e9 13 01 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
	}
	
	/* a change of zero bytes will always be successful once we've ascertained that the
	   block pointer is valid */
	if(change == 0) return addr;
c0404124:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0404129:	75 09                	jne    c0404134 <vmm_realloc+0xe4>
c040412b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040412f:	e9 03 01 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
	
	/* we can't shrink a block to and beyond zero */
	if(change < 1)
c0404134:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0404139:	7f 4e                	jg     c0404189 <vmm_realloc+0x139>
	{
		if((0 - change) >= size)
c040413b:	8b 44 24 24          	mov    0x24(%esp),%eax
c040413f:	f7 d8                	neg    %eax
c0404141:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0404145:	72 42                	jb     c0404189 <vmm_realloc+0x139>
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a block of size %i by %i bytes\n",
c0404147:	8b 44 24 24          	mov    0x24(%esp),%eax
c040414b:	89 c2                	mov    %eax,%edx
c040414d:	f7 da                	neg    %edx
							CPU_ID, size, 0 - change);
c040414f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* we can't shrink a block to and beyond zero */
	if(change < 1)
	{
		if((0 - change) >= size)
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a block of size %i by %i bytes\n",
c0404154:	3c 01                	cmp    $0x1,%al
c0404156:	76 0c                	jbe    c0404164 <vmm_realloc+0x114>
							CPU_ID, size, 0 - change);
c0404158:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040415d:	8b 00                	mov    (%eax),%eax
	/* we can't shrink a block to and beyond zero */
	if(change < 1)
	{
		if((0 - change) >= size)
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF tried to shrink a block of size %i by %i bytes\n",
c040415f:	c1 e8 18             	shr    $0x18,%eax
c0404162:	eb 08                	jmp    c040416c <vmm_realloc+0x11c>
c0404164:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0404169:	0f b6 c0             	movzbl %al,%eax
c040416c:	52                   	push   %edx
c040416d:	ff 74 24 10          	pushl  0x10(%esp)
c0404171:	50                   	push   %eax
c0404172:	68 e4 c5 40 c0       	push   $0xc040c5e4
c0404177:	e8 06 7d 00 00       	call   c040be82 <debug_printf>
c040417c:	83 c4 10             	add    $0x10,%esp
							CPU_ID, size, 0 - change);
			return NULL; /* failed */
c040417f:	b8 00 00 00 00       	mov    $0x0,%eax
c0404184:	e9 ae 00 00 00       	jmp    c0404237 <vmm_realloc+0x1e7>
		}
	}

	/* sanity checks passed, try to grow/shrink the block within the padding of the block */
	if((size + change) <= KHEAP_PAD_SAFE(size))
c0404189:	8b 44 24 24          	mov    0x24(%esp),%eax
c040418d:	03 44 24 0c          	add    0xc(%esp),%eax
c0404191:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0404195:	83 c2 40             	add    $0x40,%edx
c0404198:	83 e2 c0             	and    $0xffffffc0,%edx
c040419b:	83 ea 20             	sub    $0x20,%edx
c040419e:	39 d0                	cmp    %edx,%eax
c04041a0:	77 1e                	ja     c04041c0 <vmm_realloc+0x170>
	{
		/* update the size stats and return the same pointer */
		vmm_malloc_write_size(addr, size + change);
c04041a2:	8b 44 24 24          	mov    0x24(%esp),%eax
c04041a6:	03 44 24 0c          	add    0xc(%esp),%eax
c04041aa:	83 ec 08             	sub    $0x8,%esp
c04041ad:	50                   	push   %eax
c04041ae:	ff 74 24 2c          	pushl  0x2c(%esp)
c04041b2:	e8 a9 fb ff ff       	call   c0403d60 <vmm_malloc_write_size>
c04041b7:	83 c4 10             	add    $0x10,%esp
		return addr;
c04041ba:	8b 44 24 20          	mov    0x20(%esp),%eax
c04041be:	eb 77                	jmp    c0404237 <vmm_realloc+0x1e7>
	}
	
	/* we can't extend within our block padding so it's time to malloc-copy-free */
	if(vmm_malloc((void **)&new, size + change) == success)
c04041c0:	8b 44 24 24          	mov    0x24(%esp),%eax
c04041c4:	03 44 24 0c          	add    0xc(%esp),%eax
c04041c8:	83 ec 08             	sub    $0x8,%esp
c04041cb:	50                   	push   %eax
c04041cc:	8d 44 24 14          	lea    0x14(%esp),%eax
c04041d0:	50                   	push   %eax
c04041d1:	e8 12 f9 ff ff       	call   c0403ae8 <vmm_malloc>
c04041d6:	83 c4 10             	add    $0x10,%esp
c04041d9:	85 c0                	test   %eax,%eax
c04041db:	75 55                	jne    c0404232 <vmm_realloc+0x1e2>
	{
		/* so far so good, copy the contents of the old block to the new one,
		   free the old block and return the new pointer */
		if(change > 0)
c04041dd:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04041e2:	7e 1a                	jle    c04041fe <vmm_realloc+0x1ae>
			vmm_memcpy(new, addr, size);
c04041e4:	8b 44 24 08          	mov    0x8(%esp),%eax
c04041e8:	83 ec 04             	sub    $0x4,%esp
c04041eb:	ff 74 24 10          	pushl  0x10(%esp)
c04041ef:	ff 74 24 28          	pushl  0x28(%esp)
c04041f3:	50                   	push   %eax
c04041f4:	e8 70 08 00 00       	call   c0404a69 <vmm_memcpy>
c04041f9:	83 c4 10             	add    $0x10,%esp
c04041fc:	eb 1f                	jmp    c040421d <vmm_realloc+0x1cd>
		else
			vmm_memcpy(new, addr, size + change);
c04041fe:	8b 44 24 24          	mov    0x24(%esp),%eax
c0404202:	89 c2                	mov    %eax,%edx
c0404204:	03 54 24 0c          	add    0xc(%esp),%edx
c0404208:	8b 44 24 08          	mov    0x8(%esp),%eax
c040420c:	83 ec 04             	sub    $0x4,%esp
c040420f:	52                   	push   %edx
c0404210:	ff 74 24 28          	pushl  0x28(%esp)
c0404214:	50                   	push   %eax
c0404215:	e8 4f 08 00 00       	call   c0404a69 <vmm_memcpy>
c040421a:	83 c4 10             	add    $0x10,%esp
		vmm_free(addr);
c040421d:	83 ec 0c             	sub    $0xc,%esp
c0404220:	ff 74 24 2c          	pushl  0x2c(%esp)
c0404224:	e8 e6 fc ff ff       	call   c0403f0f <vmm_free>
c0404229:	83 c4 10             	add    $0x10,%esp
		return new;
c040422c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404230:	eb 05                	jmp    c0404237 <vmm_realloc+0x1e7>
	}
	
	/* fall through to a malloc failure */
	return NULL;
c0404232:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404237:	83 c4 1c             	add    $0x1c,%esp
c040423a:	c3                   	ret    

c040423b <vmm_req_phys_pg>:
      pref = 0 to request a page from below the DMA marker, otherwise 1 for no
             preference.
   <= 0 for success or error code
*/
kresult vmm_req_phys_pg(void **addr, int pref)
{	
c040423b:	83 ec 0c             	sub    $0xc,%esp
	lock_gate(&(vmm_lock), LOCK_WRITE);
c040423e:	83 ec 08             	sub    $0x8,%esp
c0404241:	6a 01                	push   $0x1
c0404243:	68 8c f4 40 c0       	push   $0xc040f48c
c0404248:	e8 4b c2 ff ff       	call   c0400498 <lock_gate>
c040424d:	83 c4 10             	add    $0x10,%esp
	
   /* is a DMA-able physical page requested? */
   if(pref == MEM_LOW_PG)
c0404250:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0404255:	75 2b                	jne    c0404282 <vmm_req_phys_pg+0x47>
   {
      /* if ptr is above the base, then the stack's empty */
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
c0404257:	8b 15 88 f4 40 c0    	mov    0xc040f488,%edx
c040425d:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c0404262:	39 c2                	cmp    %eax,%edx
c0404264:	76 5f                	jbe    c04042c5 <vmm_req_phys_pg+0x8a>
		{
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c0404266:	83 ec 08             	sub    $0x8,%esp
c0404269:	6a 01                	push   $0x1
c040426b:	68 8c f4 40 c0       	push   $0xc040f48c
c0404270:	e8 a2 c3 ff ff       	call   c0400617 <unlock_gate>
c0404275:	83 c4 10             	add    $0x10,%esp
         return e_no_phys_pgs;
c0404278:	b8 04 00 00 00       	mov    $0x4,%eax
c040427d:	e9 a3 00 00 00       	jmp    c0404325 <vmm_req_phys_pg+0xea>
      /* otherwise, hand out a page frame */
      goto get_low_page;
   }

   /* try to get a 'normal' phys page frame first, then try low */
   if(phys_pg_stack_high_ptr > phys_pg_stack_high_base)
c0404282:	8b 15 80 f4 40 c0    	mov    0xc040f480,%edx
c0404288:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c040428d:	39 c2                	cmp    %eax,%edx
c040428f:	76 16                	jbe    c04042a7 <vmm_req_phys_pg+0x6c>
   {
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
c0404291:	8b 15 88 f4 40 c0    	mov    0xc040f488,%edx
c0404297:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c040429c:	39 c2                	cmp    %eax,%edx
c040429e:	76 28                	jbe    c04042c8 <vmm_req_phys_pg+0x8d>
         return e_no_phys_pgs;
c04042a0:	b8 04 00 00 00       	mov    $0x4,%eax
c04042a5:	eb 7e                	jmp    c0404325 <vmm_req_phys_pg+0xea>
      else
         goto get_low_page;
   }
   /* fall through to getting a high page */

   *addr = (unsigned int *)*phys_pg_stack_high_ptr;
c04042a7:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c04042ac:	8b 00                	mov    (%eax),%eax
c04042ae:	89 c2                	mov    %eax,%edx
c04042b0:	8b 44 24 10          	mov    0x10(%esp),%eax
c04042b4:	89 10                	mov    %edx,(%eax)
   phys_pg_stack_high_ptr++;
c04042b6:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c04042bb:	83 c0 04             	add    $0x4,%eax
c04042be:	a3 80 f4 40 c0       	mov    %eax,0xc040f480
   goto get_page_success;
c04042c3:	eb 20                	jmp    c04042e5 <vmm_req_phys_pg+0xaa>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
         return e_no_phys_pgs;
		}

      /* otherwise, hand out a page frame */
      goto get_low_page;
c04042c5:	90                   	nop
c04042c6:	eb 01                	jmp    c04042c9 <vmm_req_phys_pg+0x8e>
   if(phys_pg_stack_high_ptr > phys_pg_stack_high_base)
   {
      if(phys_pg_stack_low_ptr > phys_pg_stack_low_base)
         return e_no_phys_pgs;
      else
         goto get_low_page;
c04042c8:	90                   	nop
   phys_pg_stack_high_ptr++;
   goto get_page_success;

   /* are these gotos ugly? */
get_low_page:
   *addr = (unsigned int *)*phys_pg_stack_low_ptr;
c04042c9:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c04042ce:	8b 00                	mov    (%eax),%eax
c04042d0:	89 c2                	mov    %eax,%edx
c04042d2:	8b 44 24 10          	mov    0x10(%esp),%eax
c04042d6:	89 10                	mov    %edx,(%eax)
   phys_pg_stack_low_ptr++;
c04042d8:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c04042dd:	83 c0 04             	add    $0x4,%eax
c04042e0:	a3 88 f4 40 c0       	mov    %eax,0xc040f488
   /* fall through to success */

get_page_success:
   phys_pg_reqed++; /* update accounting totals */
c04042e5:	a1 f8 1c 41 c0       	mov    0xc0411cf8,%eax
c04042ea:	40                   	inc    %eax
c04042eb:	a3 f8 1c 41 c0       	mov    %eax,0xc0411cf8
	/* we don't clean the page at this stage - it has
	   to be mapped in first */
	
	/* would be nice to clean this page */
	vmm_memset(KERNEL_PHYS2LOG(*addr), 0, MEM_PGSIZE);
c04042f0:	8b 44 24 10          	mov    0x10(%esp),%eax
c04042f4:	8b 00                	mov    (%eax),%eax
c04042f6:	2d 00 00 00 40       	sub    $0x40000000,%eax
c04042fb:	83 ec 04             	sub    $0x4,%esp
c04042fe:	68 00 10 00 00       	push   $0x1000
c0404303:	6a 00                	push   $0x0
c0404305:	50                   	push   %eax
c0404306:	e8 21 07 00 00       	call   c0404a2c <vmm_memset>
c040430b:	83 c4 10             	add    $0x10,%esp
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c040430e:	83 ec 08             	sub    $0x8,%esp
c0404311:	6a 01                	push   $0x1
c0404313:	68 8c f4 40 c0       	push   $0xc040f48c
c0404318:	e8 fa c2 ff ff       	call   c0400617 <unlock_gate>
c040431d:	83 c4 10             	add    $0x10,%esp
   return success;
c0404320:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404325:	83 c4 0c             	add    $0xc,%esp
c0404328:	c3                   	ret    

c0404329 <vmm_return_phys_pg>:
   reused.
   => addr = physical page frame base address
   <= 0 for success or error code
*/
kresult vmm_return_phys_pg(void *addr)
{	
c0404329:	83 ec 0c             	sub    $0xc,%esp
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
c040432c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404330:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0404335:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0404339:	74 41                	je     c040437c <vmm_return_phys_pg+0x53>
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
                  "%x not page aligned!\n", CPU_ID, addr);
c040433b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
kresult vmm_return_phys_pg(void *addr)
{	
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
c0404340:	3c 01                	cmp    $0x1,%al
c0404342:	76 0c                	jbe    c0404350 <vmm_return_phys_pg+0x27>
                  "%x not page aligned!\n", CPU_ID, addr);
c0404344:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404349:	8b 00                	mov    (%eax),%eax
kresult vmm_return_phys_pg(void *addr)
{	
   /* if the address is not mmu page align then things are up the swanny */
   if(MEM_PGALIGN(addr) != addr)
   {
      KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: physical stack frame "
c040434b:	c1 e8 18             	shr    $0x18,%eax
c040434e:	eb 08                	jmp    c0404358 <vmm_return_phys_pg+0x2f>
c0404350:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0404355:	0f b6 c0             	movzbl %al,%eax
c0404358:	83 ec 04             	sub    $0x4,%esp
c040435b:	ff 74 24 14          	pushl  0x14(%esp)
c040435f:	50                   	push   %eax
c0404360:	68 24 c6 40 c0       	push   $0xc040c624
c0404365:	e8 18 7b 00 00       	call   c040be82 <debug_printf>
c040436a:	83 c4 10             	add    $0x10,%esp
                  "%x not page aligned!\n", CPU_ID, addr);
		debug_stacktrace();
c040436d:	e8 01 74 00 00       	call   c040b773 <debug_stacktrace>
      return e_not_pg_aligned;
c0404372:	b8 08 00 00 00       	mov    $0x8,%eax
c0404377:	e9 2a 01 00 00       	jmp    c04044a6 <vmm_return_phys_pg+0x17d>
   }

	lock_gate(&(vmm_lock), LOCK_WRITE);
c040437c:	83 ec 08             	sub    $0x8,%esp
c040437f:	6a 01                	push   $0x1
c0404381:	68 8c f4 40 c0       	push   $0xc040f48c
c0404386:	e8 0d c1 ff ff       	call   c0400498 <lock_gate>
c040438b:	83 c4 10             	add    $0x10,%esp
	
   /* decide which stack we're going to return this page frame onto */
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
c040438e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404392:	3d ff ff ff 00       	cmp    $0xffffff,%eax
c0404397:	77 78                	ja     c0404411 <vmm_return_phys_pg+0xe8>
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
c0404399:	8b 15 88 f4 40 c0    	mov    0xc040f488,%edx
c040439f:	a1 84 f4 40 c0       	mov    0xc040f484,%eax
c04043a4:	39 c2                	cmp    %eax,%edx
c04043a6:	77 4f                	ja     c04043f7 <vmm_return_phys_pg+0xce>
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
                   "has overflowed!\n", CPU_ID);
c04043a8:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
c04043ad:	3c 01                	cmp    $0x1,%al
c04043af:	76 0c                	jbe    c04043bd <vmm_return_phys_pg+0x94>
                   "has overflowed!\n", CPU_ID);
c04043b1:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04043b6:	8b 00                	mov    (%eax),%eax
   if((unsigned int)addr < MEM_DMA_REGION_MARK)
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_low_ptr <= phys_pg_stack_low_limit)
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: low physical stack frame "
c04043b8:	c1 e8 18             	shr    $0x18,%eax
c04043bb:	eb 08                	jmp    c04043c5 <vmm_return_phys_pg+0x9c>
c04043bd:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04043c2:	0f b6 c0             	movzbl %al,%eax
c04043c5:	83 ec 08             	sub    $0x8,%esp
c04043c8:	50                   	push   %eax
c04043c9:	68 74 c6 40 c0       	push   $0xc040c674
c04043ce:	e8 af 7a 00 00       	call   c040be82 <debug_printf>
c04043d3:	83 c4 10             	add    $0x10,%esp
                   "has overflowed!\n", CPU_ID);
			debug_stacktrace();
c04043d6:	e8 98 73 00 00       	call   c040b773 <debug_stacktrace>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c04043db:	83 ec 08             	sub    $0x8,%esp
c04043de:	6a 01                	push   $0x1
c04043e0:	68 8c f4 40 c0       	push   $0xc040f48c
c04043e5:	e8 2d c2 ff ff       	call   c0400617 <unlock_gate>
c04043ea:	83 c4 10             	add    $0x10,%esp
         return e_phys_stk_overflow;
c04043ed:	b8 0d 00 00 00       	mov    $0xd,%eax
c04043f2:	e9 af 00 00 00       	jmp    c04044a6 <vmm_return_phys_pg+0x17d>
      }

      /* push stack frame onto lower stack */
      phys_pg_stack_low_ptr--;
c04043f7:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c04043fc:	83 e8 04             	sub    $0x4,%eax
c04043ff:	a3 88 f4 40 c0       	mov    %eax,0xc040f488
      *phys_pg_stack_low_ptr = (unsigned int)addr;
c0404404:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c0404409:	8b 54 24 10          	mov    0x10(%esp),%edx
c040440d:	89 10                	mov    %edx,(%eax)
c040440f:	eb 73                	jmp    c0404484 <vmm_return_phys_pg+0x15b>
   }
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
c0404411:	8b 15 80 f4 40 c0    	mov    0xc040f480,%edx
c0404417:	a1 9c f4 40 c0       	mov    0xc040f49c,%eax
c040441c:	39 c2                	cmp    %eax,%edx
c040441e:	77 4c                	ja     c040446c <vmm_return_phys_pg+0x143>
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
                     "has overflowed!\n", CPU_ID);
c0404420:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
c0404425:	3c 01                	cmp    $0x1,%al
c0404427:	76 0c                	jbe    c0404435 <vmm_return_phys_pg+0x10c>
                     "has overflowed!\n", CPU_ID);
c0404429:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040442e:	8b 00                	mov    (%eax),%eax
   else
   {
      /* check stack bounds before we go any further */
      if(phys_pg_stack_high_ptr <= phys_pg_stack_high_limit)
      {
         KOOPS_DEBUG("[vmm:%i] OMGWTF! vmm_return_phys_pg: high physical stack "
c0404430:	c1 e8 18             	shr    $0x18,%eax
c0404433:	eb 08                	jmp    c040443d <vmm_return_phys_pg+0x114>
c0404435:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040443a:	0f b6 c0             	movzbl %al,%eax
c040443d:	83 ec 08             	sub    $0x8,%esp
c0404440:	50                   	push   %eax
c0404441:	68 c4 c6 40 c0       	push   $0xc040c6c4
c0404446:	e8 37 7a 00 00       	call   c040be82 <debug_printf>
c040444b:	83 c4 10             	add    $0x10,%esp
                     "has overflowed!\n", CPU_ID);
			debug_stacktrace();
c040444e:	e8 20 73 00 00       	call   c040b773 <debug_stacktrace>
			unlock_gate(&(vmm_lock), LOCK_WRITE);
c0404453:	83 ec 08             	sub    $0x8,%esp
c0404456:	6a 01                	push   $0x1
c0404458:	68 8c f4 40 c0       	push   $0xc040f48c
c040445d:	e8 b5 c1 ff ff       	call   c0400617 <unlock_gate>
c0404462:	83 c4 10             	add    $0x10,%esp
         return e_phys_stk_overflow;
c0404465:	b8 0d 00 00 00       	mov    $0xd,%eax
c040446a:	eb 3a                	jmp    c04044a6 <vmm_return_phys_pg+0x17d>
      }

      /* push stack frame onto upper stack */
      phys_pg_stack_high_ptr--;
c040446c:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c0404471:	83 e8 04             	sub    $0x4,%eax
c0404474:	a3 80 f4 40 c0       	mov    %eax,0xc040f480
      *phys_pg_stack_high_ptr = (unsigned int)addr;
c0404479:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c040447e:	8b 54 24 10          	mov    0x10(%esp),%edx
c0404482:	89 10                	mov    %edx,(%eax)
   }

   phys_pg_reqed--; /* update accounting totals */
c0404484:	a1 f8 1c 41 c0       	mov    0xc0411cf8,%eax
c0404489:	48                   	dec    %eax
c040448a:	a3 f8 1c 41 c0       	mov    %eax,0xc0411cf8
	
	unlock_gate(&(vmm_lock), LOCK_WRITE);
c040448f:	83 ec 08             	sub    $0x8,%esp
c0404492:	6a 01                	push   $0x1
c0404494:	68 8c f4 40 c0       	push   $0xc040f48c
c0404499:	e8 79 c1 ff ff       	call   c0400617 <unlock_gate>
c040449e:	83 c4 10             	add    $0x10,%esp
	
   return success;
c04044a1:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04044a6:	83 c4 0c             	add    $0xc,%esp
c04044a9:	c3                   	ret    

c04044aa <vmm_enough_pgs>:
   of memory.
   => size = amount of memory to check for
   <= 0 for success (sufficient mem), or result code
*/
kresult vmm_enough_pgs(unsigned int size)
{
c04044aa:	83 ec 0c             	sub    $0xc,%esp
   if(!size) return success; /* there's always room for zero bytes ;) */
c04044ad:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c04044b2:	75 07                	jne    c04044bb <vmm_enough_pgs+0x11>
c04044b4:	b8 00 00 00 00       	mov    $0x0,%eax
c04044b9:	eb 5b                	jmp    c0404516 <vmm_enough_pgs+0x6c>

	lock_gate(&(vmm_lock), LOCK_READ);
c04044bb:	83 ec 08             	sub    $0x8,%esp
c04044be:	6a 00                	push   $0x0
c04044c0:	68 8c f4 40 c0       	push   $0xc040f48c
c04044c5:	e8 ce bf ff ff       	call   c0400498 <lock_gate>
c04044ca:	83 c4 10             	add    $0x10,%esp
	
   /* convert size into whole number of pages, rounding up */
   if((phys_pg_count - phys_pg_reqed) < ((size / MEM_PGSIZE) + 1))
c04044cd:	8b 15 f4 1c 41 c0    	mov    0xc0411cf4,%edx
c04044d3:	a1 f8 1c 41 c0       	mov    0xc0411cf8,%eax
c04044d8:	29 c2                	sub    %eax,%edx
c04044da:	8b 44 24 10          	mov    0x10(%esp),%eax
c04044de:	c1 e8 0c             	shr    $0xc,%eax
c04044e1:	40                   	inc    %eax
c04044e2:	39 c2                	cmp    %eax,%edx
c04044e4:	73 19                	jae    c04044ff <vmm_enough_pgs+0x55>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c04044e6:	83 ec 08             	sub    $0x8,%esp
c04044e9:	6a 00                	push   $0x0
c04044eb:	68 8c f4 40 c0       	push   $0xc040f48c
c04044f0:	e8 22 c1 ff ff       	call   c0400617 <unlock_gate>
c04044f5:	83 c4 10             	add    $0x10,%esp
      return e_not_enough_pgs;
c04044f8:	b8 09 00 00 00       	mov    $0x9,%eax
c04044fd:	eb 17                	jmp    c0404516 <vmm_enough_pgs+0x6c>
	}

	unlock_gate(&(vmm_lock), LOCK_READ);
c04044ff:	83 ec 08             	sub    $0x8,%esp
c0404502:	6a 00                	push   $0x0
c0404504:	68 8c f4 40 c0       	push   $0xc040f48c
c0404509:	e8 09 c1 ff ff       	call   c0400617 <unlock_gate>
c040450e:	83 c4 10             	add    $0x10,%esp
   return success;
c0404511:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404516:	83 c4 0c             	add    $0xc,%esp
c0404519:	c3                   	ret    

c040451a <vmm_ensure_pgs>:
   given area. Note: it will only check the selected type of mem.
   => size = number of bytes to check for
      type = 0 for DMA-able memory, 2 for non-DMA-able
*/
kresult vmm_ensure_pgs(unsigned int size, int type)
{
c040451a:	83 ec 1c             	sub    $0x1c,%esp
   unsigned int pg_loop;
	unsigned int *pg_ptr, *pg_base;
	
	lock_gate(&(vmm_lock), LOCK_READ);
c040451d:	83 ec 08             	sub    $0x8,%esp
c0404520:	6a 00                	push   $0x0
c0404522:	68 8c f4 40 c0       	push   $0xc040f48c
c0404527:	e8 6c bf ff ff       	call   c0400498 <lock_gate>
c040452c:	83 c4 10             	add    $0x10,%esp

   /* are we checking DMA-able physical memory? */
   if(type == MEM_LOW_PG)
c040452f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0404534:	75 14                	jne    c040454a <vmm_ensure_pgs+0x30>
   {
      pg_ptr = phys_pg_stack_low_ptr;
c0404536:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c040453b:	89 44 24 04          	mov    %eax,0x4(%esp)
      pg_base = phys_pg_stack_low_base;
c040453f:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c0404544:	89 44 24 08          	mov    %eax,0x8(%esp)
c0404548:	eb 12                	jmp    c040455c <vmm_ensure_pgs+0x42>
   }
   else /* or higher mem? */
   {
      pg_ptr = phys_pg_stack_high_ptr;
c040454a:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c040454f:	89 44 24 04          	mov    %eax,0x4(%esp)
      pg_base = phys_pg_stack_high_base;
c0404553:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c0404558:	89 44 24 08          	mov    %eax,0x8(%esp)
   }

   /* find number of pages fitting into size, rounding down for the benefit
      of the following checks. make sure physical pages are avaliable and
      that there's enough to bother checking before continuing. */
   pg_loop = (size / MEM_PGSIZE); 
c040455c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404560:	c1 e8 0c             	shr    $0xc,%eax
c0404563:	89 04 24             	mov    %eax,(%esp)
   
	if(pg_ptr > pg_base)
c0404566:	8b 44 24 04          	mov    0x4(%esp),%eax
c040456a:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040456e:	76 1c                	jbe    c040458c <vmm_ensure_pgs+0x72>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c0404570:	83 ec 08             	sub    $0x8,%esp
c0404573:	6a 00                	push   $0x0
c0404575:	68 8c f4 40 c0       	push   $0xc040f48c
c040457a:	e8 98 c0 ff ff       	call   c0400617 <unlock_gate>
c040457f:	83 c4 10             	add    $0x10,%esp
		return e_no_phys_pgs;
c0404582:	b8 04 00 00 00       	mov    $0x4,%eax
c0404587:	e9 8f 00 00 00       	jmp    c040461b <vmm_ensure_pgs+0x101>
	}
	
   if((pg_base - pg_ptr) < pg_loop)
c040458c:	8b 54 24 08          	mov    0x8(%esp),%edx
c0404590:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404594:	89 d1                	mov    %edx,%ecx
c0404596:	29 c1                	sub    %eax,%ecx
c0404598:	89 c8                	mov    %ecx,%eax
c040459a:	c1 f8 02             	sar    $0x2,%eax
c040459d:	3b 04 24             	cmp    (%esp),%eax
c04045a0:	73 5c                	jae    c04045fe <vmm_ensure_pgs+0xe4>
	{
		unlock_gate(&(vmm_lock), LOCK_READ);
c04045a2:	83 ec 08             	sub    $0x8,%esp
c04045a5:	6a 00                	push   $0x0
c04045a7:	68 8c f4 40 c0       	push   $0xc040f48c
c04045ac:	e8 66 c0 ff ff       	call   c0400617 <unlock_gate>
c04045b1:	83 c4 10             	add    $0x10,%esp
		return e_no_phys_pgs;
c04045b4:	b8 04 00 00 00       	mov    $0x4,%eax
c04045b9:	eb 60                	jmp    c040461b <vmm_ensure_pgs+0x101>

   /* we check to see if there is a run of contiguous stack frame pointers
      that descend in value as the loop moves up towards the stack base */
   while(pg_loop)
   {
      unsigned int *pg_next = pg_ptr;
c04045bb:	8b 44 24 04          	mov    0x4(%esp),%eax
c04045bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
		pg_next++;
c04045c3:	83 44 24 0c 04       	addl   $0x4,0xc(%esp)

      if(*pg_ptr != (*pg_next + MEM_PGSIZE))
c04045c8:	8b 44 24 04          	mov    0x4(%esp),%eax
c04045cc:	8b 10                	mov    (%eax),%edx
c04045ce:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04045d2:	8b 00                	mov    (%eax),%eax
c04045d4:	05 00 10 00 00       	add    $0x1000,%eax
c04045d9:	39 c2                	cmp    %eax,%edx
c04045db:	74 19                	je     c04045f6 <vmm_ensure_pgs+0xdc>
		{
			unlock_gate(&(vmm_lock), LOCK_READ);
c04045dd:	83 ec 08             	sub    $0x8,%esp
c04045e0:	6a 00                	push   $0x0
c04045e2:	68 8c f4 40 c0       	push   $0xc040f48c
c04045e7:	e8 2b c0 ff ff       	call   c0400617 <unlock_gate>
c04045ec:	83 c4 10             	add    $0x10,%esp
			return e_not_contiguous;
c04045ef:	b8 0a 00 00 00       	mov    $0xa,%eax
c04045f4:	eb 25                	jmp    c040461b <vmm_ensure_pgs+0x101>
		}
      pg_loop--;
c04045f6:	ff 0c 24             	decl   (%esp)
      pg_ptr++;
c04045f9:	83 44 24 04 04       	addl   $0x4,0x4(%esp)
		return e_no_phys_pgs;
	}

   /* we check to see if there is a run of contiguous stack frame pointers
      that descend in value as the loop moves up towards the stack base */
   while(pg_loop)
c04045fe:	83 3c 24 00          	cmpl   $0x0,(%esp)
c0404602:	75 b7                	jne    c04045bb <vmm_ensure_pgs+0xa1>
		}
      pg_loop--;
      pg_ptr++;
   }

	unlock_gate(&(vmm_lock), LOCK_READ);
c0404604:	83 ec 08             	sub    $0x8,%esp
c0404607:	6a 00                	push   $0x0
c0404609:	68 8c f4 40 c0       	push   $0xc040f48c
c040460e:	e8 04 c0 ff ff       	call   c0400617 <unlock_gate>
c0404613:	83 c4 10             	add    $0x10,%esp
   return success; /* managed to find run of pages */
c0404616:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040461b:	83 c4 1c             	add    $0x1c,%esp
c040461e:	c3                   	ret    

c040461f <vmm_initialise>:
   by the hardware-dependent code's start.s
   => mbd = ptr to multiboot data about the system around us
   <= 0 for success or error code
*/
kresult vmm_initialise(multiboot_info_t *mbd)
{
c040461f:	53                   	push   %ebx
c0404620:	83 ec 38             	sub    $0x38,%esp
   mb_memory_map_t *region;
   void *heap_init;
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
c0404623:	83 ec 04             	sub    $0x4,%esp
c0404626:	6a 10                	push   $0x10
c0404628:	6a 00                	push   $0x0
c040462a:	68 8c f4 40 c0       	push   $0xc040f48c
c040462f:	e8 f8 03 00 00       	call   c0404a2c <vmm_memset>
c0404634:	83 c4 10             	add    $0x10,%esp
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c0404637:	ba 38 1d 41 c0       	mov    $0xc0411d38,%edx
c040463c:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c0404641:	89 d1                	mov    %edx,%ecx
c0404643:	29 c1                	sub    %eax,%ecx
c0404645:	89 c8                	mov    %ecx,%eax
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
c0404647:	c1 f8 02             	sar    $0x2,%eax
c040464a:	89 c2                	mov    %eax,%edx
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c040464c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
c0404651:	3c 01                	cmp    $0x1,%al
c0404653:	76 0c                	jbe    c0404661 <vmm_initialise+0x42>
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
c0404655:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040465a:	8b 00                	mov    (%eax),%eax
   unsigned int pg_stack_size, *pg_stack_top;

	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
c040465c:	c1 e8 18             	shr    $0x18,%eax
c040465f:	eb 08                	jmp    c0404669 <vmm_initialise+0x4a>
c0404661:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0404666:	0f b6 c0             	movzbl %al,%eax
c0404669:	83 ec 0c             	sub    $0xc,%esp
c040466c:	52                   	push   %edx
c040466d:	68 38 1d 41 c0       	push   $0xc0411d38
c0404672:	68 00 00 40 c0       	push   $0xc0400000
c0404677:	50                   	push   %eax
c0404678:	68 10 c7 40 c0       	push   $0xc040c710
c040467d:	e8 00 78 00 00       	call   c040be82 <debug_printf>
c0404682:	83 c4 20             	add    $0x20,%esp
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   BOOT_DEBUG("[vmm:%i] kernel: physical start %x end %x aligned end %x\n",
              CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
				  KERNEL_PHYSICAL_END_ALIGNED);
c0404685:	ba 38 1d 41 c0       	mov    $0xc0411d38,%edx
c040468a:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c040468f:	89 d3                	mov    %edx,%ebx
c0404691:	29 c3                	sub    %eax,%ebx
c0404693:	89 d8                	mov    %ebx,%eax
c0404695:	c1 f8 02             	sar    $0x2,%eax
c0404698:	05 00 10 40 00       	add    $0x401000,%eax
c040469d:	25 00 f0 ff ff       	and    $0xfffff000,%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   BOOT_DEBUG("[vmm:%i] kernel: physical start %x end %x aligned end %x\n",
c04046a2:	89 c2                	mov    %eax,%edx
              CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c04046a4:	b9 38 1d 41 c0       	mov    $0xc0411d38,%ecx
c04046a9:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c04046ae:	89 cb                	mov    %ecx,%ebx
c04046b0:	29 c3                	sub    %eax,%ebx
c04046b2:	89 d8                	mov    %ebx,%eax
c04046b4:	c1 f8 02             	sar    $0x2,%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   BOOT_DEBUG("[vmm:%i] kernel: physical start %x end %x aligned end %x\n",
c04046b7:	8d 88 00 00 40 00    	lea    0x400000(%eax),%ecx
              CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c04046bd:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   BOOT_DEBUG("[vmm:%i] kernel: physical start %x end %x aligned end %x\n",
c04046c2:	3c 01                	cmp    $0x1,%al
c04046c4:	76 0c                	jbe    c04046d2 <vmm_initialise+0xb3>
              CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
c04046c6:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04046cb:	8b 00                	mov    (%eax),%eax
	/* initialise the smp lock */
	vmm_memset(&(vmm_lock), 0, sizeof(rw_gate));
	
   BOOT_DEBUG("[vmm:%i] kernel: logical start %x end %x size %i bytes\n",
              CPU_ID, KERNEL_START, KERNEL_END, KERNEL_SIZE);
   BOOT_DEBUG("[vmm:%i] kernel: physical start %x end %x aligned end %x\n",
c04046cd:	c1 e8 18             	shr    $0x18,%eax
c04046d0:	eb 08                	jmp    c04046da <vmm_initialise+0xbb>
c04046d2:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04046d7:	0f b6 c0             	movzbl %al,%eax
c04046da:	83 ec 0c             	sub    $0xc,%esp
c04046dd:	52                   	push   %edx
c04046de:	51                   	push   %ecx
c04046df:	68 00 00 40 00       	push   $0x400000
c04046e4:	50                   	push   %eax
c04046e5:	68 48 c7 40 c0       	push   $0xc040c748
c04046ea:	e8 93 77 00 00       	call   c040be82 <debug_printf>
c04046ef:	83 c4 20             	add    $0x20,%esp
              CPU_ID, KERNEL_PHYSICAL_BASE, KERNEL_PHYSICAL_END,
				  KERNEL_PHYSICAL_END_ALIGNED);

   /* check bit six to see if we can access mmap info */
   if(!(mbd->flags & (1<<6)))
c04046f2:	8b 44 24 40          	mov    0x40(%esp),%eax
c04046f6:	8b 00                	mov    (%eax),%eax
c04046f8:	83 e0 40             	and    $0x40,%eax
c04046fb:	85 c0                	test   %eax,%eax
c04046fd:	75 0a                	jne    c0404709 <vmm_initialise+0xea>
   {
      VMM_DEBUG("*** missing mem map data from multiboot. (%x)\n", mbd->flags);
      return e_missing_mb_data;
c04046ff:	b8 03 00 00 00       	mov    $0x3,%eax
c0404704:	e9 1e 03 00 00       	jmp    c0404a27 <vmm_initialise+0x408>
   }

   /* set up physical page frame stacks, initially empty.
      note: stack ptrs always point to the top available word. */
   phys_pg_stack_low_ptr    = phys_pg_stack_low_base;
c0404709:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c040470e:	a3 88 f4 40 c0       	mov    %eax,0xc040f488
   phys_pg_stack_low_limit  = phys_pg_stack_low_base;
c0404713:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c0404718:	a3 84 f4 40 c0       	mov    %eax,0xc040f484
   phys_pg_stack_high_ptr   = phys_pg_stack_high_base;
c040471d:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c0404722:	a3 80 f4 40 c0       	mov    %eax,0xc040f480
   phys_pg_stack_high_limit = phys_pg_stack_high_base;
c0404727:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c040472c:	a3 9c f4 40 c0       	mov    %eax,0xc040f49c
   /* do a quick count up of physical memory so we know how large our stacks
      need to be and thus, we can keep the physical page frames holding the
      stacks out of the stacks - we must make sure we do not hand out page
      frames holding the stacks and the kernel to the rest of the system to use
    */
   region = (mb_memory_map_t *)mbd->mmap_addr;
c0404731:	8b 44 24 40          	mov    0x40(%esp),%eax
c0404735:	8b 40 30             	mov    0x30(%eax),%eax
c0404738:	89 44 24 10          	mov    %eax,0x10(%esp)
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c040473c:	eb 39                	jmp    c0404777 <vmm_initialise+0x158>
   {
		if(region->type == 1) /* if region is present RAM */
c040473e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404742:	8b 40 14             	mov    0x14(%eax),%eax
c0404745:	83 f8 01             	cmp    $0x1,%eax
c0404748:	75 19                	jne    c0404763 <vmm_initialise+0x144>
			phys_pg_count += (region->length_low / MEM_PGSIZE);
c040474a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040474e:	8b 40 0c             	mov    0xc(%eax),%eax
c0404751:	89 c2                	mov    %eax,%edx
c0404753:	c1 ea 0c             	shr    $0xc,%edx
c0404756:	a1 f4 1c 41 c0       	mov    0xc0411cf4,%eax
c040475b:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040475e:	a3 f4 1c 41 c0       	mov    %eax,0xc0411cf4

      /* get next region */
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
c0404763:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404767:	8b 10                	mov    (%eax),%edx
c0404769:	8b 44 24 10          	mov    0x10(%esp),%eax
c040476d:	8d 04 02             	lea    (%edx,%eax,1),%eax
   {
		if(region->type == 1) /* if region is present RAM */
			phys_pg_count += (region->length_low / MEM_PGSIZE);

      /* get next region */
      region = (mb_memory_map_t *)((unsigned int)region +
c0404770:	83 c0 04             	add    $0x4,%eax
c0404773:	89 44 24 10          	mov    %eax,0x10(%esp)
      need to be and thus, we can keep the physical page frames holding the
      stacks out of the stacks - we must make sure we do not hand out page
      frames holding the stacks and the kernel to the rest of the system to use
    */
   region = (mb_memory_map_t *)mbd->mmap_addr;
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c0404777:	8b 54 24 10          	mov    0x10(%esp),%edx
c040477b:	8b 44 24 40          	mov    0x40(%esp),%eax
c040477f:	8b 48 30             	mov    0x30(%eax),%ecx
c0404782:	8b 44 24 40          	mov    0x40(%esp),%eax
c0404786:	8b 40 2c             	mov    0x2c(%eax),%eax
c0404789:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040478c:	39 c2                	cmp    %eax,%edx
c040478e:	72 ae                	jb     c040473e <vmm_initialise+0x11f>
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
                                   sizeof(unsigned int));
   }

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
c0404790:	a1 f4 1c 41 c0       	mov    0xc0411cf4,%eax
c0404795:	c1 e0 02             	shl    $0x2,%eax
c0404798:	89 44 24 14          	mov    %eax,0x14(%esp)
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
c040479c:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c04047a1:	2b 44 24 14          	sub    0x14(%esp),%eax
c04047a5:	89 44 24 18          	mov    %eax,0x18(%esp)
                                   pg_stack_size);

   BOOT_DEBUG("[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n",
              CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c04047a9:	a1 f4 1c 41 c0       	mov    0xc0411cf4,%eax
c04047ae:	c1 e0 0c             	shl    $0xc,%eax

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   BOOT_DEBUG("[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n",
c04047b1:	89 c1                	mov    %eax,%ecx
c04047b3:	c1 e9 14             	shr    $0x14,%ecx
c04047b6:	8b 15 f4 1c 41 c0    	mov    0xc0411cf4,%edx
              CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c04047bc:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   BOOT_DEBUG("[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n",
c04047c1:	3c 01                	cmp    $0x1,%al
c04047c3:	76 0c                	jbe    c04047d1 <vmm_initialise+0x1b2>
              CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
c04047c5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04047ca:	8b 00                	mov    (%eax),%eax

   pg_stack_size = phys_pg_count * sizeof(unsigned int);
   pg_stack_top = (unsigned int *)((unsigned int)phys_pg_stack_low_base -
                                   pg_stack_size);

   BOOT_DEBUG("[vmm:%i] found %i pages, %iMB total, phys stack size %i bytes\n",
c04047cc:	c1 e8 18             	shr    $0x18,%eax
c04047cf:	eb 08                	jmp    c04047d9 <vmm_initialise+0x1ba>
c04047d1:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04047d6:	0f b6 c0             	movzbl %al,%eax
c04047d9:	83 ec 0c             	sub    $0xc,%esp
c04047dc:	ff 74 24 20          	pushl  0x20(%esp)
c04047e0:	51                   	push   %ecx
c04047e1:	52                   	push   %edx
c04047e2:	50                   	push   %eax
c04047e3:	68 84 c7 40 c0       	push   $0xc040c784
c04047e8:	e8 95 76 00 00       	call   c040be82 <debug_printf>
c04047ed:	83 c4 20             	add    $0x20,%esp
              CPU_ID, phys_pg_count, (phys_pg_count * MEM_PGSIZE) / (1024 * 1024),
              pg_stack_size);
	
	/* check to make sure we have enough memory to function */
	if((phys_pg_count * MEM_PGSIZE) < (KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE))
c04047f0:	a1 f4 1c 41 c0       	mov    0xc0411cf4,%eax
c04047f5:	c1 e0 0c             	shl    $0xc,%eax
c04047f8:	3d ff ff 7f 00       	cmp    $0x7fffff,%eax
c04047fd:	77 1f                	ja     c040481e <vmm_initialise+0x1ff>
	{
		BOOT_DEBUG("*** Not enough memory present, must have at least %i bytes available.\n",
c04047ff:	83 ec 08             	sub    $0x8,%esp
c0404802:	68 00 00 80 00       	push   $0x800000
c0404807:	68 c4 c7 40 c0       	push   $0xc040c7c4
c040480c:	e8 71 76 00 00       	call   c040be82 <debug_printf>
c0404811:	83 c4 10             	add    $0x10,%esp
		   		  KERNEL_CRITICAL_END - KERNEL_CRITICAL_BASE);
		return e_failure;
c0404814:	b8 01 00 00 00       	mov    $0x1,%eax
c0404819:	e9 09 02 00 00       	jmp    c0404a27 <vmm_initialise+0x408>
			    pg_stack_top, MEM_PGALIGN(pg_stack_top)); 

   /* the stack may not end on a page boundary, so round down - this is so
	   that we can make sure the pages holding the stacks don't end up on
	   the list of available physical page frames */
   pg_stack_top = MEM_PGALIGN(pg_stack_top);
c040481e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404822:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0404827:	89 44 24 18          	mov    %eax,0x18(%esp)

   /* run through the memory areas found by the bootloader and build up
      physical page stacks */
   region = (mb_memory_map_t *)mbd->mmap_addr;
c040482b:	8b 44 24 40          	mov    0x40(%esp),%eax
c040482f:	8b 40 30             	mov    0x30(%eax),%eax
c0404832:	89 44 24 10          	mov    %eax,0x10(%esp)
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c0404836:	e9 72 01 00 00       	jmp    c04049ad <vmm_initialise+0x38e>
   {
      unsigned int pg_loop;
      unsigned int pg_count_lo = 0;
c040483b:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
c0404842:	00 
      unsigned int pg_count_hi = 0;
c0404843:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c040484a:	00 
      unsigned int pg_skip = 0;
c040484b:	c7 44 24 28 00 00 00 	movl   $0x0,0x28(%esp)
c0404852:	00 
      unsigned int max_addr = region->base_addr_low + region->length_low;
c0404853:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404857:	8b 50 04             	mov    0x4(%eax),%edx
c040485a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040485e:	8b 40 0c             	mov    0xc(%eax),%eax
c0404861:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0404864:	89 44 24 2c          	mov    %eax,0x2c(%esp)

      VMM_DEBUG("[vmm:%i] mem region: start %x length %i type %x\n",
               CPU_ID, region->base_addr_low, region->length_low, region->type);

		/* is this region present? */
		if(region->type == 1)
c0404868:	8b 44 24 10          	mov    0x10(%esp),%eax
c040486c:	8b 40 14             	mov    0x14(%eax),%eax
c040486f:	83 f8 01             	cmp    $0x1,%eax
c0404872:	0f 85 21 01 00 00    	jne    c0404999 <vmm_initialise+0x37a>
		{
			pg_loop = region->base_addr_low;
c0404878:	8b 44 24 10          	mov    0x10(%esp),%eax
c040487c:	8b 40 04             	mov    0x4(%eax),%eax
c040487f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			while((pg_loop + MEM_PGSIZE) <= max_addr)
c0404883:	e9 fd 00 00 00       	jmp    c0404985 <vmm_initialise+0x366>
			{
				/* skip over kernel in physical mem, otherwise things get messy */
				if((pg_loop >= (unsigned int)KERNEL_PHYSICAL_BASE) &&
c0404888:	81 7c 24 1c ff ff 3f 	cmpl   $0x3fffff,0x1c(%esp)
c040488f:	00 
c0404890:	76 34                	jbe    c04048c6 <vmm_initialise+0x2a7>
					(pg_loop < (unsigned int)KERNEL_PHYSICAL_END_ALIGNED))
c0404892:	ba 38 1d 41 c0       	mov    $0xc0411d38,%edx
c0404897:	b8 00 00 40 c0       	mov    $0xc0400000,%eax
c040489c:	89 d1                	mov    %edx,%ecx
c040489e:	29 c1                	sub    %eax,%ecx
c04048a0:	89 c8                	mov    %ecx,%eax
c04048a2:	c1 f8 02             	sar    $0x2,%eax
c04048a5:	05 00 10 40 00       	add    $0x401000,%eax
c04048aa:	25 00 f0 ff ff       	and    $0xfffff000,%eax
		{
			pg_loop = region->base_addr_low;
			while((pg_loop + MEM_PGSIZE) <= max_addr)
			{
				/* skip over kernel in physical mem, otherwise things get messy */
				if((pg_loop >= (unsigned int)KERNEL_PHYSICAL_BASE) &&
c04048af:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
c04048b3:	73 11                	jae    c04048c6 <vmm_initialise+0x2a7>
					(pg_loop < (unsigned int)KERNEL_PHYSICAL_END_ALIGNED))
				{
					pg_skip++;
c04048b5:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c04048b9:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c04048c0:	00 
					continue;
c04048c1:	e9 bf 00 00 00       	jmp    c0404985 <vmm_initialise+0x366>
				}

				/* skip over pages that will hold these page frame stacks */
				if((pg_loop < (unsigned int)phys_pg_stack_low_base) &&
c04048c6:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c04048cb:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c04048cf:	76 1b                	jbe    c04048ec <vmm_initialise+0x2cd>
					(pg_loop >= (unsigned int)pg_stack_top))
c04048d1:	8b 44 24 18          	mov    0x18(%esp),%eax
					pg_loop += MEM_PGSIZE;
					continue;
				}

				/* skip over pages that will hold these page frame stacks */
				if((pg_loop < (unsigned int)phys_pg_stack_low_base) &&
c04048d5:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c04048d9:	77 11                	ja     c04048ec <vmm_initialise+0x2cd>
					(pg_loop >= (unsigned int)pg_stack_top))
				{
					pg_skip++;
c04048db:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c04048df:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c04048e6:	00 
					continue;
c04048e7:	e9 99 00 00 00       	jmp    c0404985 <vmm_initialise+0x366>
				}

				/* skip over pages holding payload binaries XXX inefficient */
				if(payload_exist_here(pg_loop))
c04048ec:	83 ec 0c             	sub    $0xc,%esp
c04048ef:	ff 74 24 28          	pushl  0x28(%esp)
c04048f3:	e8 68 69 00 00       	call   c040b260 <payload_exist_here>
c04048f8:	83 c4 10             	add    $0x10,%esp
c04048fb:	85 c0                	test   %eax,%eax
c04048fd:	74 0e                	je     c040490d <vmm_initialise+0x2ee>
				{
					pg_skip++;
c04048ff:	ff 44 24 28          	incl   0x28(%esp)
					pg_loop += MEM_PGSIZE;
c0404903:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c040490a:	00 
					continue;
c040490b:	eb 78                	jmp    c0404985 <vmm_initialise+0x366>
				}

				/* decide which stack to place the page frame in */
				if(pg_loop < MEM_DMA_REGION_MARK)
c040490d:	81 7c 24 1c ff ff ff 	cmpl   $0xffffff,0x1c(%esp)
c0404914:	00 
c0404915:	77 1e                	ja     c0404935 <vmm_initialise+0x316>
				{
					*phys_pg_stack_low_ptr = pg_loop;
c0404917:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c040491c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0404920:	89 10                	mov    %edx,(%eax)
					phys_pg_stack_low_ptr--;
c0404922:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c0404927:	83 e8 04             	sub    $0x4,%eax
c040492a:	a3 88 f4 40 c0       	mov    %eax,0xc040f488
					pg_count_lo++;
c040492f:	ff 44 24 20          	incl   0x20(%esp)
c0404933:	eb 1c                	jmp    c0404951 <vmm_initialise+0x332>
				}
				else
				{
					*phys_pg_stack_high_ptr = pg_loop;
c0404935:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c040493a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c040493e:	89 10                	mov    %edx,(%eax)
					phys_pg_stack_high_ptr--;
c0404940:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c0404945:	83 e8 04             	sub    $0x4,%eax
c0404948:	a3 80 f4 40 c0       	mov    %eax,0xc040f480
					pg_count_hi++;
c040494d:	ff 44 24 24          	incl   0x24(%esp)
				}
				
				if(phys_pg_stack_low_ptr < phys_pg_stack_high_base)
c0404951:	8b 15 88 f4 40 c0    	mov    0xc040f488,%edx
c0404957:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c040495c:	39 c2                	cmp    %eax,%edx
c040495e:	73 1d                	jae    c040497d <vmm_initialise+0x35e>
				{
					KOOPS_DEBUG("*** lomem page stack crashed into himem stack!\n"
c0404960:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c0404965:	ff 74 24 1c          	pushl  0x1c(%esp)
c0404969:	ff 74 24 24          	pushl  0x24(%esp)
c040496d:	50                   	push   %eax
c040496e:	68 0c c8 40 c0       	push   $0xc040c80c
c0404973:	e8 0a 75 00 00       	call   c040be82 <debug_printf>
c0404978:	83 c4 10             	add    $0x10,%esp
					            "    ptr %p after %i pages (%x) - halting.\n",
							      phys_pg_stack_low_ptr, pg_count_lo, pg_loop);
					while(1);
c040497b:	eb fe                	jmp    c040497b <vmm_initialise+0x35c>
				}
				
				pg_loop += MEM_PGSIZE;
c040497d:	81 44 24 1c 00 10 00 	addl   $0x1000,0x1c(%esp)
c0404984:	00 

		/* is this region present? */
		if(region->type == 1)
		{
			pg_loop = region->base_addr_low;
			while((pg_loop + MEM_PGSIZE) <= max_addr)
c0404985:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0404989:	05 00 10 00 00       	add    $0x1000,%eax
c040498e:	3b 44 24 2c          	cmp    0x2c(%esp),%eax
c0404992:	0f 86 f0 fe ff ff    	jbe    c0404888 <vmm_initialise+0x269>
				}
				
				pg_loop += MEM_PGSIZE;
			}

			VMM_DEBUG("[vmm:%i] added phys pages: %i low, %i high (%i reserved)\n",
c0404998:	90                   	nop

		}
			
      /* get to the next memory region */
      region = (mb_memory_map_t *)((unsigned int)region +
                                   region->size +
c0404999:	8b 44 24 10          	mov    0x10(%esp),%eax
c040499d:	8b 10                	mov    (%eax),%edx
c040499f:	8b 44 24 10          	mov    0x10(%esp),%eax
c04049a3:	8d 04 02             	lea    (%edx,%eax,1),%eax
					  CPU_ID, pg_count_lo, pg_count_hi, pg_skip);

		}
			
      /* get to the next memory region */
      region = (mb_memory_map_t *)((unsigned int)region +
c04049a6:	83 c0 04             	add    $0x4,%eax
c04049a9:	89 44 24 10          	mov    %eax,0x10(%esp)
   pg_stack_top = MEM_PGALIGN(pg_stack_top);

   /* run through the memory areas found by the bootloader and build up
      physical page stacks */
   region = (mb_memory_map_t *)mbd->mmap_addr;
   while((unsigned int)region < mbd->mmap_addr + mbd->mmap_length)
c04049ad:	8b 54 24 10          	mov    0x10(%esp),%edx
c04049b1:	8b 44 24 40          	mov    0x40(%esp),%eax
c04049b5:	8b 48 30             	mov    0x30(%eax),%ecx
c04049b8:	8b 44 24 40          	mov    0x40(%esp),%eax
c04049bc:	8b 40 2c             	mov    0x2c(%eax),%eax
c04049bf:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04049c2:	39 c2                	cmp    %eax,%edx
c04049c4:	0f 82 71 fe ff ff    	jb     c040483b <vmm_initialise+0x21c>
                                   region->size +
                                   sizeof(unsigned int));
   }

   /* set stack limits so we know when we're out of memory */
   phys_pg_stack_low_ptr++; /* adjust ptr to top word */
c04049ca:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c04049cf:	83 c0 04             	add    $0x4,%eax
c04049d2:	a3 88 f4 40 c0       	mov    %eax,0xc040f488
   phys_pg_stack_high_ptr++; /* adjust ptr to top word */
c04049d7:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c04049dc:	83 c0 04             	add    $0x4,%eax
c04049df:	a3 80 f4 40 c0       	mov    %eax,0xc040f480
   phys_pg_stack_low_limit = phys_pg_stack_low_ptr;
c04049e4:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c04049e9:	a3 84 f4 40 c0       	mov    %eax,0xc040f484
   phys_pg_stack_high_limit = phys_pg_stack_high_ptr;
c04049ee:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c04049f3:	a3 9c f4 40 c0       	mov    %eax,0xc040f49c
		
   /* now we've got a grip on physical memory, map it all into our virtual
      space using pagination */
   pg_init(); /* non-portable code */
c04049f8:	e8 ad 34 00 00       	call   c0407eaa <pg_init>
	
   /* prime the kernel heap while we still have contiguous space */
   vmm_malloc(&heap_init, KHEAP_INITSIZE);
c04049fd:	83 ec 08             	sub    $0x8,%esp
c0404a00:	68 00 00 01 00       	push   $0x10000
c0404a05:	8d 44 24 18          	lea    0x18(%esp),%eax
c0404a09:	50                   	push   %eax
c0404a0a:	e8 d9 f0 ff ff       	call   c0403ae8 <vmm_malloc>
c0404a0f:	83 c4 10             	add    $0x10,%esp
   vmm_free(heap_init);
c0404a12:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404a16:	83 ec 0c             	sub    $0xc,%esp
c0404a19:	50                   	push   %eax
c0404a1a:	e8 f0 f4 ff ff       	call   c0403f0f <vmm_free>
c0404a1f:	83 c4 10             	add    $0x10,%esp

   return 0;
c0404a22:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0404a27:	83 c4 38             	add    $0x38,%esp
c0404a2a:	5b                   	pop    %ebx
c0404a2b:	c3                   	ret    

c0404a2c <vmm_memset>:
   => addr  = base address to start writing to
      value = byte-wide value to write into each byte
      count = number of bytes to write
*/
void vmm_memset(void *addr, unsigned char value, unsigned int count)
{
c0404a2c:	83 ec 14             	sub    $0x14,%esp
c0404a2f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0404a33:	88 04 24             	mov    %al,(%esp)
	unsigned char *ptr = (unsigned char *)addr;
c0404a36:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404a3a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int i;
	
	for(i = 0; i < count; i++)
c0404a3e:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0404a45:	00 
c0404a46:	eb 13                	jmp    c0404a5b <vmm_memset+0x2f>
		ptr[i] = value;
c0404a48:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404a4c:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0404a50:	01 c2                	add    %eax,%edx
c0404a52:	8a 04 24             	mov    (%esp),%al
c0404a55:	88 02                	mov    %al,(%edx)
void vmm_memset(void *addr, unsigned char value, unsigned int count)
{
	unsigned char *ptr = (unsigned char *)addr;
	unsigned int i;
	
	for(i = 0; i < count; i++)
c0404a57:	ff 44 24 10          	incl   0x10(%esp)
c0404a5b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404a5f:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0404a63:	72 e3                	jb     c0404a48 <vmm_memset+0x1c>
		ptr[i] = value;
}
c0404a65:	83 c4 14             	add    $0x14,%esp
c0404a68:	c3                   	ret    

c0404a69 <vmm_memcpy>:
   => target  = base address to write to
      source = base address to read from 
    	count = number of bytes to write
 */
void vmm_memcpy(void *target, void *source, unsigned int count)
{
c0404a69:	83 ec 10             	sub    $0x10,%esp
	unsigned char *ptr1 = (unsigned char *)target;
c0404a6c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404a70:	89 44 24 04          	mov    %eax,0x4(%esp)
	unsigned char *ptr2 = (unsigned char *)source;
c0404a74:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404a78:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int i;
	for(i = 0; i < count; i++)
c0404a7c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0404a83:	00 
c0404a84:	eb 1d                	jmp    c0404aa3 <vmm_memcpy+0x3a>
		ptr1[i] = ptr2[i];
c0404a86:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404a8a:	8b 54 24 04          	mov    0x4(%esp),%edx
c0404a8e:	01 c2                	add    %eax,%edx
c0404a90:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404a94:	8b 4c 24 08          	mov    0x8(%esp),%ecx
c0404a98:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0404a9b:	8a 00                	mov    (%eax),%al
c0404a9d:	88 02                	mov    %al,(%edx)
void vmm_memcpy(void *target, void *source, unsigned int count)
{
	unsigned char *ptr1 = (unsigned char *)target;
	unsigned char *ptr2 = (unsigned char *)source;
	unsigned int i;
	for(i = 0; i < count; i++)
c0404a9f:	ff 44 24 0c          	incl   0xc(%esp)
c0404aa3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404aa7:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
c0404aab:	72 d9                	jb     c0404a86 <vmm_memcpy+0x1d>
		ptr1[i] = ptr2[i];
}
c0404aad:	83 c4 10             	add    $0x10,%esp
c0404ab0:	c3                   	ret    

c0404ab1 <vmm_memcpyuser>:
	   sproc = source process structure (or NULL for kernel)
      count = number of bytes to write
*/
kresult vmm_memcpyuser(void *target, process *tproc,
						     void *source, process *sproc, unsigned int count)
{
c0404ab1:	83 ec 1c             	sub    $0x1c,%esp
	/* the goal is to resolve the addresses into kernel 
      virtual addresses */
	kresult err = e_failure;
c0404ab4:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
c0404abb:	00 
	unsigned int ktarget, ksource;
	
	if(((unsigned int)target + count) >= KERNEL_SPACE_BASE)
c0404abc:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404ac0:	03 44 24 30          	add    0x30(%esp),%eax
c0404ac4:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0404ac9:	76 15                	jbe    c0404ae0 <vmm_memcpyuser+0x2f>
	{
		/* copying into kernel, tproc must be NULL */
		if(tproc) goto vmm_memcpyuser_wtf;
c0404acb:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0404ad0:	0f 85 94 00 00 00    	jne    c0404b6a <vmm_memcpyuser+0xb9>
		ktarget = (unsigned int)target;
c0404ad6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404ada:	89 44 24 08          	mov    %eax,0x8(%esp)
c0404ade:	eb 24                	jmp    c0404b04 <vmm_memcpyuser+0x53>
	}
	else
	{
		err = pg_user2kernel(&ktarget, (unsigned int)target, tproc);
c0404ae0:	8b 44 24 20          	mov    0x20(%esp),%eax
c0404ae4:	83 ec 04             	sub    $0x4,%esp
c0404ae7:	ff 74 24 28          	pushl  0x28(%esp)
c0404aeb:	50                   	push   %eax
c0404aec:	8d 44 24 14          	lea    0x14(%esp),%eax
c0404af0:	50                   	push   %eax
c0404af1:	e8 96 30 00 00       	call   c0407b8c <pg_user2kernel>
c0404af6:	83 c4 10             	add    $0x10,%esp
c0404af9:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(err) goto vmm_memcpyuser_wtf;
c0404afd:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0404b02:	75 69                	jne    c0404b6d <vmm_memcpyuser+0xbc>
	}

	if(((unsigned int)source + count) >= KERNEL_SPACE_BASE)
c0404b04:	8b 44 24 28          	mov    0x28(%esp),%eax
c0404b08:	03 44 24 30          	add    0x30(%esp),%eax
c0404b0c:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0404b11:	76 11                	jbe    c0404b24 <vmm_memcpyuser+0x73>
	{
		/* copying from kernel, sproc must be NULL */
		if(sproc) goto vmm_memcpyuser_wtf;
c0404b13:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0404b18:	75 56                	jne    c0404b70 <vmm_memcpyuser+0xbf>
		ksource = (unsigned int)source;
c0404b1a:	8b 44 24 28          	mov    0x28(%esp),%eax
c0404b1e:	89 44 24 04          	mov    %eax,0x4(%esp)
c0404b22:	eb 24                	jmp    c0404b48 <vmm_memcpyuser+0x97>
	}
	else
	{
		err = pg_user2kernel(&ksource, (unsigned int)source, sproc);
c0404b24:	8b 44 24 28          	mov    0x28(%esp),%eax
c0404b28:	83 ec 04             	sub    $0x4,%esp
c0404b2b:	ff 74 24 30          	pushl  0x30(%esp)
c0404b2f:	50                   	push   %eax
c0404b30:	8d 44 24 10          	lea    0x10(%esp),%eax
c0404b34:	50                   	push   %eax
c0404b35:	e8 52 30 00 00       	call   c0407b8c <pg_user2kernel>
c0404b3a:	83 c4 10             	add    $0x10,%esp
c0404b3d:	89 44 24 0c          	mov    %eax,0xc(%esp)
		if(err) goto vmm_memcpyuser_wtf;
c0404b41:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0404b46:	75 2b                	jne    c0404b73 <vmm_memcpyuser+0xc2>
	}
	
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
c0404b48:	8b 44 24 04          	mov    0x4(%esp),%eax
c0404b4c:	89 c2                	mov    %eax,%edx
c0404b4e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404b52:	83 ec 04             	sub    $0x4,%esp
c0404b55:	ff 74 24 34          	pushl  0x34(%esp)
c0404b59:	52                   	push   %edx
c0404b5a:	50                   	push   %eax
c0404b5b:	e8 09 ff ff ff       	call   c0404a69 <vmm_memcpy>
c0404b60:	83 c4 10             	add    $0x10,%esp
	return success;
c0404b63:	b8 00 00 00 00       	mov    $0x0,%eax
c0404b68:	eb 55                	jmp    c0404bbf <vmm_memcpyuser+0x10e>
	unsigned int ktarget, ksource;
	
	if(((unsigned int)target + count) >= KERNEL_SPACE_BASE)
	{
		/* copying into kernel, tproc must be NULL */
		if(tproc) goto vmm_memcpyuser_wtf;
c0404b6a:	90                   	nop
c0404b6b:	eb 07                	jmp    c0404b74 <vmm_memcpyuser+0xc3>
		ktarget = (unsigned int)target;
	}
	else
	{
		err = pg_user2kernel(&ktarget, (unsigned int)target, tproc);
		if(err) goto vmm_memcpyuser_wtf;
c0404b6d:	90                   	nop
c0404b6e:	eb 04                	jmp    c0404b74 <vmm_memcpyuser+0xc3>
	}

	if(((unsigned int)source + count) >= KERNEL_SPACE_BASE)
	{
		/* copying from kernel, sproc must be NULL */
		if(sproc) goto vmm_memcpyuser_wtf;
c0404b70:	90                   	nop
c0404b71:	eb 01                	jmp    c0404b74 <vmm_memcpyuser+0xc3>
		ksource = (unsigned int)source;
	}
	else
	{
		err = pg_user2kernel(&ksource, (unsigned int)source, sproc);
		if(err) goto vmm_memcpyuser_wtf;
c0404b73:	90                   	nop
vmm_memcpyuser_wtf:
	KOOPS_DEBUG("[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n"
			      "                target = %p (proc %p)\n"
			      "                source = %p (proc %p)\n"
			      "                copying: %i bytes\n",
			      CPU_ID, target, tproc, source, sproc, count);
c0404b74:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
	return success;
	
vmm_memcpyuser_wtf:
	KOOPS_DEBUG("[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n"
c0404b79:	3c 01                	cmp    $0x1,%al
c0404b7b:	76 0c                	jbe    c0404b89 <vmm_memcpyuser+0xd8>
			      "                target = %p (proc %p)\n"
			      "                source = %p (proc %p)\n"
			      "                copying: %i bytes\n",
			      CPU_ID, target, tproc, source, sproc, count);
c0404b7d:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0404b82:	8b 00                	mov    (%eax),%eax
	/* perform the copy with sane virtual addresses */
	vmm_memcpy((void *)ktarget, (void *)ksource, count);
	return success;
	
vmm_memcpyuser_wtf:
	KOOPS_DEBUG("[vmm:%i] OMGWTF: vmm_memcpyuser has bad params!\n"
c0404b84:	c1 e8 18             	shr    $0x18,%eax
c0404b87:	eb 08                	jmp    c0404b91 <vmm_memcpyuser+0xe0>
c0404b89:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0404b8e:	0f b6 c0             	movzbl %al,%eax
c0404b91:	83 ec 04             	sub    $0x4,%esp
c0404b94:	ff 74 24 34          	pushl  0x34(%esp)
c0404b98:	ff 74 24 34          	pushl  0x34(%esp)
c0404b9c:	ff 74 24 34          	pushl  0x34(%esp)
c0404ba0:	ff 74 24 34          	pushl  0x34(%esp)
c0404ba4:	ff 74 24 34          	pushl  0x34(%esp)
c0404ba8:	50                   	push   %eax
c0404ba9:	68 68 c8 40 c0       	push   $0xc040c868
c0404bae:	e8 cf 72 00 00       	call   c040be82 <debug_printf>
c0404bb3:	83 c4 20             	add    $0x20,%esp
			      "                target = %p (proc %p)\n"
			      "                source = %p (proc %p)\n"
			      "                copying: %i bytes\n",
			      CPU_ID, target, tproc, source, sproc, count);
	debug_stacktrace();
c0404bb6:	e8 b8 6b 00 00       	call   c040b773 <debug_stacktrace>
	return err;
c0404bbb:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0404bbf:	83 c4 1c             	add    $0x1c,%esp
c0404bc2:	c3                   	ret    

c0404bc3 <sglib___vmm_tree_fix_left_insertion_discrepancy>:
 indicate it's greater than base+size of y */
#define vmm_cmp_vma(x, y) ( (x->area->base) < (y->area->base) ? -1 : ( (x->area->base) >= ((y->area->base) + (y->area->size)) ? 1 : 0 ) )

/* pointers to vmas are stored in a per-process balanced binary tree */
SGLIB_DEFINE_RBTREE_PROTOTYPES(vmm_tree, left, right, colour, vmm_cmp_vma);
SGLIB_DEFINE_RBTREE_FUNCTIONS(vmm_tree, left, right, colour, vmm_cmp_vma);
c0404bc3:	83 ec 30             	sub    $0x30,%esp
c0404bc6:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404bca:	8b 00                	mov    (%eax),%eax
c0404bcc:	89 44 24 08          	mov    %eax,0x8(%esp)
c0404bd0:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404bd4:	8b 40 04             	mov    0x4(%eax),%eax
c0404bd7:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0404bdb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404bdf:	8b 40 08             	mov    0x8(%eax),%eax
c0404be2:	85 c0                	test   %eax,%eax
c0404be4:	74 7a                	je     c0404c60 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x9d>
c0404be6:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404bea:	8b 40 08             	mov    0x8(%eax),%eax
c0404bed:	8a 40 0c             	mov    0xc(%eax),%al
c0404bf0:	3c 01                	cmp    $0x1,%al
c0404bf2:	75 6c                	jne    c0404c60 <sglib___vmm_tree_fix_left_insertion_discrepancy+0x9d>
c0404bf4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404bf8:	8a 40 0c             	mov    0xc(%eax),%al
c0404bfb:	3c 01                	cmp    $0x1,%al
c0404bfd:	0f 85 99 01 00 00    	jne    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404c03:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c07:	8b 40 04             	mov    0x4(%eax),%eax
c0404c0a:	85 c0                	test   %eax,%eax
c0404c0c:	74 0e                	je     c0404c1c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x59>
c0404c0e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c12:	8b 40 04             	mov    0x4(%eax),%eax
c0404c15:	8a 40 0c             	mov    0xc(%eax),%al
c0404c18:	3c 01                	cmp    $0x1,%al
c0404c1a:	74 21                	je     c0404c3d <sglib___vmm_tree_fix_left_insertion_discrepancy+0x7a>
c0404c1c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c20:	8b 40 08             	mov    0x8(%eax),%eax
c0404c23:	85 c0                	test   %eax,%eax
c0404c25:	0f 84 71 01 00 00    	je     c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404c2b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c2f:	8b 40 08             	mov    0x8(%eax),%eax
c0404c32:	8a 40 0c             	mov    0xc(%eax),%al
c0404c35:	3c 01                	cmp    $0x1,%al
c0404c37:	0f 85 5f 01 00 00    	jne    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404c3d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404c41:	8b 40 04             	mov    0x4(%eax),%eax
c0404c44:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404c48:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404c4c:	8b 40 08             	mov    0x8(%eax),%eax
c0404c4f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404c53:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404c57:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404c5b:	e9 3c 01 00 00       	jmp    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404c60:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c64:	8a 40 0c             	mov    0xc(%eax),%al
c0404c67:	3c 01                	cmp    $0x1,%al
c0404c69:	0f 85 2d 01 00 00    	jne    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404c6f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c73:	8b 40 04             	mov    0x4(%eax),%eax
c0404c76:	85 c0                	test   %eax,%eax
c0404c78:	74 74                	je     c0404cee <sglib___vmm_tree_fix_left_insertion_discrepancy+0x12b>
c0404c7a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c7e:	8b 40 04             	mov    0x4(%eax),%eax
c0404c81:	8a 40 0c             	mov    0xc(%eax),%al
c0404c84:	3c 01                	cmp    $0x1,%al
c0404c86:	75 66                	jne    c0404cee <sglib___vmm_tree_fix_left_insertion_discrepancy+0x12b>
c0404c88:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404c8c:	89 44 24 10          	mov    %eax,0x10(%esp)
c0404c90:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c94:	89 44 24 14          	mov    %eax,0x14(%esp)
c0404c98:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404c9c:	8b 40 04             	mov    0x4(%eax),%eax
c0404c9f:	89 44 24 18          	mov    %eax,0x18(%esp)
c0404ca3:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404ca7:	8b 40 08             	mov    0x8(%eax),%eax
c0404caa:	89 44 24 24          	mov    %eax,0x24(%esp)
c0404cae:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404cb2:	8b 54 24 24          	mov    0x24(%esp),%edx
c0404cb6:	89 50 04             	mov    %edx,0x4(%eax)
c0404cb9:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404cbd:	8b 54 24 18          	mov    0x18(%esp),%edx
c0404cc1:	89 50 04             	mov    %edx,0x4(%eax)
c0404cc4:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404cc8:	8b 54 24 10          	mov    0x10(%esp),%edx
c0404ccc:	89 50 08             	mov    %edx,0x8(%eax)
c0404ccf:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404cd3:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404cd7:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404cdb:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404cdf:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404ce3:	8b 54 24 14          	mov    0x14(%esp),%edx
c0404ce7:	89 10                	mov    %edx,(%eax)
c0404ce9:	e9 ae 00 00 00       	jmp    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404cee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404cf2:	8b 40 08             	mov    0x8(%eax),%eax
c0404cf5:	85 c0                	test   %eax,%eax
c0404cf7:	0f 84 9f 00 00 00    	je     c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404cfd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404d01:	8b 40 08             	mov    0x8(%eax),%eax
c0404d04:	8a 40 0c             	mov    0xc(%eax),%al
c0404d07:	3c 01                	cmp    $0x1,%al
c0404d09:	0f 85 8d 00 00 00    	jne    c0404d9c <sglib___vmm_tree_fix_left_insertion_discrepancy+0x1d9>
c0404d0f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404d13:	89 44 24 10          	mov    %eax,0x10(%esp)
c0404d17:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404d1b:	89 44 24 14          	mov    %eax,0x14(%esp)
c0404d1f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404d23:	8b 40 08             	mov    0x8(%eax),%eax
c0404d26:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0404d2a:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404d2e:	8b 40 04             	mov    0x4(%eax),%eax
c0404d31:	89 44 24 20          	mov    %eax,0x20(%esp)
c0404d35:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404d39:	8b 40 08             	mov    0x8(%eax),%eax
c0404d3c:	89 44 24 18          	mov    %eax,0x18(%esp)
c0404d40:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404d44:	8b 40 04             	mov    0x4(%eax),%eax
c0404d47:	89 44 24 28          	mov    %eax,0x28(%esp)
c0404d4b:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404d4f:	8b 40 08             	mov    0x8(%eax),%eax
c0404d52:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0404d56:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404d5a:	8b 54 24 28          	mov    0x28(%esp),%edx
c0404d5e:	89 50 08             	mov    %edx,0x8(%eax)
c0404d61:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404d65:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0404d69:	89 50 04             	mov    %edx,0x4(%eax)
c0404d6c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404d70:	8b 54 24 14          	mov    0x14(%esp),%edx
c0404d74:	89 50 04             	mov    %edx,0x4(%eax)
c0404d77:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404d7b:	8b 54 24 10          	mov    0x10(%esp),%edx
c0404d7f:	89 50 08             	mov    %edx,0x8(%eax)
c0404d82:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404d86:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404d8a:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404d8e:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404d92:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404d96:	8b 54 24 18          	mov    0x18(%esp),%edx
c0404d9a:	89 10                	mov    %edx,(%eax)
c0404d9c:	83 c4 30             	add    $0x30,%esp
c0404d9f:	c3                   	ret    

c0404da0 <sglib___vmm_tree_fix_right_insertion_discrepancy>:
c0404da0:	83 ec 30             	sub    $0x30,%esp
c0404da3:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404da7:	8b 00                	mov    (%eax),%eax
c0404da9:	89 44 24 08          	mov    %eax,0x8(%esp)
c0404dad:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404db1:	8b 40 08             	mov    0x8(%eax),%eax
c0404db4:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0404db8:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404dbc:	8b 40 04             	mov    0x4(%eax),%eax
c0404dbf:	85 c0                	test   %eax,%eax
c0404dc1:	74 7a                	je     c0404e3d <sglib___vmm_tree_fix_right_insertion_discrepancy+0x9d>
c0404dc3:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404dc7:	8b 40 04             	mov    0x4(%eax),%eax
c0404dca:	8a 40 0c             	mov    0xc(%eax),%al
c0404dcd:	3c 01                	cmp    $0x1,%al
c0404dcf:	75 6c                	jne    c0404e3d <sglib___vmm_tree_fix_right_insertion_discrepancy+0x9d>
c0404dd1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404dd5:	8a 40 0c             	mov    0xc(%eax),%al
c0404dd8:	3c 01                	cmp    $0x1,%al
c0404dda:	0f 85 99 01 00 00    	jne    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404de0:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404de4:	8b 40 08             	mov    0x8(%eax),%eax
c0404de7:	85 c0                	test   %eax,%eax
c0404de9:	74 0e                	je     c0404df9 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x59>
c0404deb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404def:	8b 40 08             	mov    0x8(%eax),%eax
c0404df2:	8a 40 0c             	mov    0xc(%eax),%al
c0404df5:	3c 01                	cmp    $0x1,%al
c0404df7:	74 21                	je     c0404e1a <sglib___vmm_tree_fix_right_insertion_discrepancy+0x7a>
c0404df9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404dfd:	8b 40 04             	mov    0x4(%eax),%eax
c0404e00:	85 c0                	test   %eax,%eax
c0404e02:	0f 84 71 01 00 00    	je     c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404e08:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e0c:	8b 40 04             	mov    0x4(%eax),%eax
c0404e0f:	8a 40 0c             	mov    0xc(%eax),%al
c0404e12:	3c 01                	cmp    $0x1,%al
c0404e14:	0f 85 5f 01 00 00    	jne    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404e1a:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404e1e:	8b 40 08             	mov    0x8(%eax),%eax
c0404e21:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404e25:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404e29:	8b 40 04             	mov    0x4(%eax),%eax
c0404e2c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404e30:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404e34:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404e38:	e9 3c 01 00 00       	jmp    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404e3d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e41:	8a 40 0c             	mov    0xc(%eax),%al
c0404e44:	3c 01                	cmp    $0x1,%al
c0404e46:	0f 85 2d 01 00 00    	jne    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404e4c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e50:	8b 40 08             	mov    0x8(%eax),%eax
c0404e53:	85 c0                	test   %eax,%eax
c0404e55:	74 74                	je     c0404ecb <sglib___vmm_tree_fix_right_insertion_discrepancy+0x12b>
c0404e57:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e5b:	8b 40 08             	mov    0x8(%eax),%eax
c0404e5e:	8a 40 0c             	mov    0xc(%eax),%al
c0404e61:	3c 01                	cmp    $0x1,%al
c0404e63:	75 66                	jne    c0404ecb <sglib___vmm_tree_fix_right_insertion_discrepancy+0x12b>
c0404e65:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404e69:	89 44 24 10          	mov    %eax,0x10(%esp)
c0404e6d:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e71:	89 44 24 14          	mov    %eax,0x14(%esp)
c0404e75:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404e79:	8b 40 08             	mov    0x8(%eax),%eax
c0404e7c:	89 44 24 18          	mov    %eax,0x18(%esp)
c0404e80:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404e84:	8b 40 04             	mov    0x4(%eax),%eax
c0404e87:	89 44 24 24          	mov    %eax,0x24(%esp)
c0404e8b:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404e8f:	8b 54 24 24          	mov    0x24(%esp),%edx
c0404e93:	89 50 08             	mov    %edx,0x8(%eax)
c0404e96:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404e9a:	8b 54 24 18          	mov    0x18(%esp),%edx
c0404e9e:	89 50 08             	mov    %edx,0x8(%eax)
c0404ea1:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404ea5:	8b 54 24 10          	mov    0x10(%esp),%edx
c0404ea9:	89 50 04             	mov    %edx,0x4(%eax)
c0404eac:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404eb0:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404eb4:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404eb8:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404ebc:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404ec0:	8b 54 24 14          	mov    0x14(%esp),%edx
c0404ec4:	89 10                	mov    %edx,(%eax)
c0404ec6:	e9 ae 00 00 00       	jmp    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404ecb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404ecf:	8b 40 04             	mov    0x4(%eax),%eax
c0404ed2:	85 c0                	test   %eax,%eax
c0404ed4:	0f 84 9f 00 00 00    	je     c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404eda:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404ede:	8b 40 04             	mov    0x4(%eax),%eax
c0404ee1:	8a 40 0c             	mov    0xc(%eax),%al
c0404ee4:	3c 01                	cmp    $0x1,%al
c0404ee6:	0f 85 8d 00 00 00    	jne    c0404f79 <sglib___vmm_tree_fix_right_insertion_discrepancy+0x1d9>
c0404eec:	8b 44 24 08          	mov    0x8(%esp),%eax
c0404ef0:	89 44 24 10          	mov    %eax,0x10(%esp)
c0404ef4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0404ef8:	89 44 24 14          	mov    %eax,0x14(%esp)
c0404efc:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404f00:	8b 40 04             	mov    0x4(%eax),%eax
c0404f03:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0404f07:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404f0b:	8b 40 08             	mov    0x8(%eax),%eax
c0404f0e:	89 44 24 20          	mov    %eax,0x20(%esp)
c0404f12:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404f16:	8b 40 04             	mov    0x4(%eax),%eax
c0404f19:	89 44 24 18          	mov    %eax,0x18(%esp)
c0404f1d:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404f21:	8b 40 08             	mov    0x8(%eax),%eax
c0404f24:	89 44 24 28          	mov    %eax,0x28(%esp)
c0404f28:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404f2c:	8b 40 04             	mov    0x4(%eax),%eax
c0404f2f:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0404f33:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404f37:	8b 54 24 28          	mov    0x28(%esp),%edx
c0404f3b:	89 50 04             	mov    %edx,0x4(%eax)
c0404f3e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404f42:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0404f46:	89 50 08             	mov    %edx,0x8(%eax)
c0404f49:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404f4d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0404f51:	89 50 08             	mov    %edx,0x8(%eax)
c0404f54:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404f58:	8b 54 24 10          	mov    0x10(%esp),%edx
c0404f5c:	89 50 04             	mov    %edx,0x4(%eax)
c0404f5f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0404f63:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0404f67:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404f6b:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0404f6f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0404f73:	8b 54 24 18          	mov    0x18(%esp),%edx
c0404f77:	89 10                	mov    %edx,(%eax)
c0404f79:	83 c4 30             	add    $0x30,%esp
c0404f7c:	c3                   	ret    

c0404f7d <sglib___vmm_tree_fix_left_deletion_discrepancy>:
c0404f7d:	83 ec 4c             	sub    $0x4c,%esp
c0404f80:	8b 44 24 50          	mov    0x50(%esp),%eax
c0404f84:	8b 00                	mov    (%eax),%eax
c0404f86:	89 44 24 14          	mov    %eax,0x14(%esp)
c0404f8a:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404f8e:	89 44 24 10          	mov    %eax,0x10(%esp)
c0404f92:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0404f97:	75 1c                	jne    c0404fb5 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x38>
c0404f99:	68 83 03 00 00       	push   $0x383
c0404f9e:	68 07 c9 40 c0       	push   $0xc040c907
c0404fa3:	68 07 c9 40 c0       	push   $0xc040c907
c0404fa8:	68 18 c9 40 c0       	push   $0xc040c918
c0404fad:	e8 b1 69 00 00       	call   c040b963 <debug_assert>
c0404fb2:	83 c4 10             	add    $0x10,%esp
c0404fb5:	8b 44 24 14          	mov    0x14(%esp),%eax
c0404fb9:	8b 40 04             	mov    0x4(%eax),%eax
c0404fbc:	89 44 24 24          	mov    %eax,0x24(%esp)
c0404fc0:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404fc4:	8b 40 08             	mov    0x8(%eax),%eax
c0404fc7:	89 44 24 18          	mov    %eax,0x18(%esp)
c0404fcb:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0404fd0:	75 3c                	jne    c040500e <sglib___vmm_tree_fix_left_deletion_discrepancy+0x91>
c0404fd2:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404fd6:	8a 40 0c             	mov    0xc(%eax),%al
c0404fd9:	3c 01                	cmp    $0x1,%al
c0404fdb:	74 1c                	je     c0404ff9 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x7c>
c0404fdd:	68 83 03 00 00       	push   $0x383
c0404fe2:	68 07 c9 40 c0       	push   $0xc040c907
c0404fe7:	68 07 c9 40 c0       	push   $0xc040c907
c0404fec:	68 20 c9 40 c0       	push   $0xc040c920
c0404ff1:	e8 6d 69 00 00       	call   c040b963 <debug_assert>
c0404ff6:	83 c4 10             	add    $0x10,%esp
c0404ff9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0404ffd:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405001:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405008:	00 
c0405009:	e9 41 05 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040500e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405012:	8b 40 08             	mov    0x8(%eax),%eax
c0405015:	89 44 24 28          	mov    %eax,0x28(%esp)
c0405019:	8b 44 24 18          	mov    0x18(%esp),%eax
c040501d:	8b 40 04             	mov    0x4(%eax),%eax
c0405020:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0405024:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405028:	8a 40 0c             	mov    0xc(%eax),%al
c040502b:	3c 01                	cmp    $0x1,%al
c040502d:	0f 85 ae 02 00 00    	jne    c04052e1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x364>
c0405033:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0405038:	75 35                	jne    c040506f <sglib___vmm_tree_fix_left_deletion_discrepancy+0xf2>
c040503a:	8b 44 24 50          	mov    0x50(%esp),%eax
c040503e:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405042:	89 10                	mov    %edx,(%eax)
c0405044:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405048:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c040504c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405050:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405054:	89 50 04             	mov    %edx,0x4(%eax)
c0405057:	8b 44 24 14          	mov    0x14(%esp),%eax
c040505b:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c040505f:	89 50 08             	mov    %edx,0x8(%eax)
c0405062:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405069:	00 
c040506a:	e9 e0 04 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040506f:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405073:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405077:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040507c:	74 0b                	je     c0405089 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x10c>
c040507e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405082:	8a 40 0c             	mov    0xc(%eax),%al
c0405085:	84 c0                	test   %al,%al
c0405087:	74 1c                	je     c04050a5 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x128>
c0405089:	68 83 03 00 00       	push   $0x383
c040508e:	68 07 c9 40 c0       	push   $0xc040c907
c0405093:	68 07 c9 40 c0       	push   $0xc040c907
c0405098:	68 40 c9 40 c0       	push   $0xc040c940
c040509d:	e8 c1 68 00 00       	call   c040b963 <debug_assert>
c04050a2:	83 c4 10             	add    $0x10,%esp
c04050a5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04050a9:	8b 40 08             	mov    0x8(%eax),%eax
c04050ac:	89 44 24 30          	mov    %eax,0x30(%esp)
c04050b0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04050b4:	8b 40 04             	mov    0x4(%eax),%eax
c04050b7:	89 44 24 34          	mov    %eax,0x34(%esp)
c04050bb:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04050c0:	74 0b                	je     c04050cd <sglib___vmm_tree_fix_left_deletion_discrepancy+0x150>
c04050c2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04050c6:	8a 40 0c             	mov    0xc(%eax),%al
c04050c9:	84 c0                	test   %al,%al
c04050cb:	75 4f                	jne    c040511c <sglib___vmm_tree_fix_left_deletion_discrepancy+0x19f>
c04050cd:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04050d2:	74 0b                	je     c04050df <sglib___vmm_tree_fix_left_deletion_discrepancy+0x162>
c04050d4:	8b 44 24 34          	mov    0x34(%esp),%eax
c04050d8:	8a 40 0c             	mov    0xc(%eax),%al
c04050db:	84 c0                	test   %al,%al
c04050dd:	75 3d                	jne    c040511c <sglib___vmm_tree_fix_left_deletion_discrepancy+0x19f>
c04050df:	8b 44 24 50          	mov    0x50(%esp),%eax
c04050e3:	8b 54 24 18          	mov    0x18(%esp),%edx
c04050e7:	89 10                	mov    %edx,(%eax)
c04050e9:	8b 44 24 18          	mov    0x18(%esp),%eax
c04050ed:	8b 54 24 14          	mov    0x14(%esp),%edx
c04050f1:	89 50 04             	mov    %edx,0x4(%eax)
c04050f4:	8b 44 24 18          	mov    0x18(%esp),%eax
c04050f8:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04050fc:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405100:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405104:	89 50 08             	mov    %edx,0x8(%eax)
c0405107:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040510b:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c040510f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405116:	00 
c0405117:	e9 33 04 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040511c:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0405121:	0f 84 e0 00 00 00    	je     c0405207 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x28a>
c0405127:	8b 44 24 30          	mov    0x30(%esp),%eax
c040512b:	8a 40 0c             	mov    0xc(%eax),%al
c040512e:	3c 01                	cmp    $0x1,%al
c0405130:	0f 85 d1 00 00 00    	jne    c0405207 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x28a>
c0405136:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c040513b:	74 74                	je     c04051b1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x234>
c040513d:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405141:	8a 40 0c             	mov    0xc(%eax),%al
c0405144:	3c 01                	cmp    $0x1,%al
c0405146:	75 69                	jne    c04051b1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x234>
c0405148:	8b 44 24 34          	mov    0x34(%esp),%eax
c040514c:	89 44 24 20          	mov    %eax,0x20(%esp)
c0405150:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405154:	8b 40 08             	mov    0x8(%eax),%eax
c0405157:	89 44 24 38          	mov    %eax,0x38(%esp)
c040515b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040515f:	8b 40 04             	mov    0x4(%eax),%eax
c0405162:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0405166:	8b 44 24 50          	mov    0x50(%esp),%eax
c040516a:	8b 54 24 20          	mov    0x20(%esp),%edx
c040516e:	89 10                	mov    %edx,(%eax)
c0405170:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405174:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405178:	8b 44 24 20          	mov    0x20(%esp),%eax
c040517c:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405180:	89 50 08             	mov    %edx,0x8(%eax)
c0405183:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405187:	8b 54 24 38          	mov    0x38(%esp),%edx
c040518b:	89 50 04             	mov    %edx,0x4(%eax)
c040518e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405192:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405196:	89 50 04             	mov    %edx,0x4(%eax)
c0405199:	8b 44 24 14          	mov    0x14(%esp),%eax
c040519d:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c04051a1:	89 50 08             	mov    %edx,0x8(%eax)
c04051a4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04051ab:	00 
c04051ac:	e9 9e 03 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04051b1:	8b 44 24 50          	mov    0x50(%esp),%eax
c04051b5:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04051b9:	89 10                	mov    %edx,(%eax)
c04051bb:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04051bf:	8b 54 24 18          	mov    0x18(%esp),%edx
c04051c3:	89 50 08             	mov    %edx,0x8(%eax)
c04051c6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04051ca:	8b 54 24 14          	mov    0x14(%esp),%edx
c04051ce:	89 50 04             	mov    %edx,0x4(%eax)
c04051d1:	8b 44 24 18          	mov    0x18(%esp),%eax
c04051d5:	8b 54 24 28          	mov    0x28(%esp),%edx
c04051d9:	89 50 08             	mov    %edx,0x8(%eax)
c04051dc:	8b 44 24 18          	mov    0x18(%esp),%eax
c04051e0:	8b 54 24 30          	mov    0x30(%esp),%edx
c04051e4:	89 50 04             	mov    %edx,0x4(%eax)
c04051e7:	8b 44 24 14          	mov    0x14(%esp),%eax
c04051eb:	8b 54 24 34          	mov    0x34(%esp),%edx
c04051ef:	89 50 08             	mov    %edx,0x8(%eax)
c04051f2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04051f6:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04051fa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405201:	00 
c0405202:	e9 48 03 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c0405207:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c040520c:	0f 84 a6 00 00 00    	je     c04052b8 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x33b>
c0405212:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405216:	8a 40 0c             	mov    0xc(%eax),%al
c0405219:	3c 01                	cmp    $0x1,%al
c040521b:	0f 85 97 00 00 00    	jne    c04052b8 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x33b>
c0405221:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0405226:	74 27                	je     c040524f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x2d2>
c0405228:	8b 44 24 30          	mov    0x30(%esp),%eax
c040522c:	8a 40 0c             	mov    0xc(%eax),%al
c040522f:	84 c0                	test   %al,%al
c0405231:	74 1c                	je     c040524f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x2d2>
c0405233:	68 83 03 00 00       	push   $0x383
c0405238:	68 07 c9 40 c0       	push   $0xc040c907
c040523d:	68 07 c9 40 c0       	push   $0xc040c907
c0405242:	68 6c c9 40 c0       	push   $0xc040c96c
c0405247:	e8 17 67 00 00       	call   c040b963 <debug_assert>
c040524c:	83 c4 10             	add    $0x10,%esp
c040524f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405253:	89 44 24 20          	mov    %eax,0x20(%esp)
c0405257:	8b 44 24 20          	mov    0x20(%esp),%eax
c040525b:	8b 40 08             	mov    0x8(%eax),%eax
c040525e:	89 44 24 38          	mov    %eax,0x38(%esp)
c0405262:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405266:	8b 40 04             	mov    0x4(%eax),%eax
c0405269:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c040526d:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405271:	8b 54 24 20          	mov    0x20(%esp),%edx
c0405275:	89 10                	mov    %edx,(%eax)
c0405277:	8b 44 24 20          	mov    0x20(%esp),%eax
c040527b:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c040527f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405283:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405287:	89 50 08             	mov    %edx,0x8(%eax)
c040528a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040528e:	8b 54 24 38          	mov    0x38(%esp),%edx
c0405292:	89 50 04             	mov    %edx,0x4(%eax)
c0405295:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405299:	8b 54 24 14          	mov    0x14(%esp),%edx
c040529d:	89 50 04             	mov    %edx,0x4(%eax)
c04052a0:	8b 44 24 14          	mov    0x14(%esp),%eax
c04052a4:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c04052a8:	89 50 08             	mov    %edx,0x8(%eax)
c04052ab:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04052b2:	00 
c04052b3:	e9 97 02 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04052b8:	68 83 03 00 00       	push   $0x383
c04052bd:	68 07 c9 40 c0       	push   $0xc040c907
c04052c2:	68 07 c9 40 c0       	push   $0xc040c907
c04052c7:	68 99 c9 40 c0       	push   $0xc040c999
c04052cc:	e8 92 66 00 00       	call   c040b963 <debug_assert>
c04052d1:	83 c4 10             	add    $0x10,%esp
c04052d4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04052db:	00 
c04052dc:	e9 6e 02 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04052e1:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04052e6:	74 0b                	je     c04052f3 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x376>
c04052e8:	8b 44 24 28          	mov    0x28(%esp),%eax
c04052ec:	8a 40 0c             	mov    0xc(%eax),%al
c04052ef:	84 c0                	test   %al,%al
c04052f1:	75 3a                	jne    c040532d <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3b0>
c04052f3:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04052f8:	74 0b                	je     c0405305 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x388>
c04052fa:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04052fe:	8a 40 0c             	mov    0xc(%eax),%al
c0405301:	84 c0                	test   %al,%al
c0405303:	75 28                	jne    c040532d <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3b0>
c0405305:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405309:	8a 40 0c             	mov    0xc(%eax),%al
c040530c:	84 c0                	test   %al,%al
c040530e:	0f 94 c0             	sete   %al
c0405311:	0f b6 c0             	movzbl %al,%eax
c0405314:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0405318:	8b 44 24 14          	mov    0x14(%esp),%eax
c040531c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405320:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405324:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0405328:	e9 22 02 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c040532d:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0405332:	0f 84 77 01 00 00    	je     c04054af <sglib___vmm_tree_fix_left_deletion_discrepancy+0x532>
c0405338:	8b 44 24 28          	mov    0x28(%esp),%eax
c040533c:	8a 40 0c             	mov    0xc(%eax),%al
c040533f:	3c 01                	cmp    $0x1,%al
c0405341:	0f 85 68 01 00 00    	jne    c04054af <sglib___vmm_tree_fix_left_deletion_discrepancy+0x532>
c0405347:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c040534c:	74 0b                	je     c0405359 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x3dc>
c040534e:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405352:	8a 40 0c             	mov    0xc(%eax),%al
c0405355:	84 c0                	test   %al,%al
c0405357:	75 4b                	jne    c04053a4 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x427>
c0405359:	8b 44 24 50          	mov    0x50(%esp),%eax
c040535d:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405361:	89 10                	mov    %edx,(%eax)
c0405363:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405367:	8a 50 0c             	mov    0xc(%eax),%dl
c040536a:	8b 44 24 18          	mov    0x18(%esp),%eax
c040536e:	88 50 0c             	mov    %dl,0xc(%eax)
c0405371:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405375:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405379:	8b 44 24 18          	mov    0x18(%esp),%eax
c040537d:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405381:	89 50 04             	mov    %edx,0x4(%eax)
c0405384:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405388:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c040538c:	89 50 08             	mov    %edx,0x8(%eax)
c040538f:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405393:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405397:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040539e:	00 
c040539f:	e9 ab 01 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04053a4:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04053a9:	75 1c                	jne    c04053c7 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x44a>
c04053ab:	68 83 03 00 00       	push   $0x383
c04053b0:	68 07 c9 40 c0       	push   $0xc040c907
c04053b5:	68 07 c9 40 c0       	push   $0xc040c907
c04053ba:	68 9b c9 40 c0       	push   $0xc040c99b
c04053bf:	e8 9f 65 00 00       	call   c040b963 <debug_assert>
c04053c4:	83 c4 10             	add    $0x10,%esp
c04053c7:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04053cc:	75 1c                	jne    c04053ea <sglib___vmm_tree_fix_left_deletion_discrepancy+0x46d>
c04053ce:	68 83 03 00 00       	push   $0x383
c04053d3:	68 07 c9 40 c0       	push   $0xc040c907
c04053d8:	68 07 c9 40 c0       	push   $0xc040c907
c04053dd:	68 a4 c9 40 c0       	push   $0xc040c9a4
c04053e2:	e8 7c 65 00 00       	call   c040b963 <debug_assert>
c04053e7:	83 c4 10             	add    $0x10,%esp
c04053ea:	8b 44 24 28          	mov    0x28(%esp),%eax
c04053ee:	8a 40 0c             	mov    0xc(%eax),%al
c04053f1:	3c 01                	cmp    $0x1,%al
c04053f3:	74 1c                	je     c0405411 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x494>
c04053f5:	68 83 03 00 00       	push   $0x383
c04053fa:	68 07 c9 40 c0       	push   $0xc040c907
c04053ff:	68 07 c9 40 c0       	push   $0xc040c907
c0405404:	68 b0 c9 40 c0       	push   $0xc040c9b0
c0405409:	e8 55 65 00 00       	call   c040b963 <debug_assert>
c040540e:	83 c4 10             	add    $0x10,%esp
c0405411:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405415:	8a 40 0c             	mov    0xc(%eax),%al
c0405418:	3c 01                	cmp    $0x1,%al
c040541a:	74 1c                	je     c0405438 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x4bb>
c040541c:	68 83 03 00 00       	push   $0x383
c0405421:	68 07 c9 40 c0       	push   $0xc040c907
c0405426:	68 07 c9 40 c0       	push   $0xc040c907
c040542b:	68 d4 c9 40 c0       	push   $0xc040c9d4
c0405430:	e8 2e 65 00 00       	call   c040b963 <debug_assert>
c0405435:	83 c4 10             	add    $0x10,%esp
c0405438:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040543c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405440:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405444:	8b 40 08             	mov    0x8(%eax),%eax
c0405447:	89 44 24 30          	mov    %eax,0x30(%esp)
c040544b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040544f:	8b 40 04             	mov    0x4(%eax),%eax
c0405452:	89 44 24 34          	mov    %eax,0x34(%esp)
c0405456:	8b 44 24 50          	mov    0x50(%esp),%eax
c040545a:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c040545e:	89 10                	mov    %edx,(%eax)
c0405460:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405464:	8a 50 0c             	mov    0xc(%eax),%dl
c0405467:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040546b:	88 50 0c             	mov    %dl,0xc(%eax)
c040546e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405472:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405476:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040547a:	8b 54 24 18          	mov    0x18(%esp),%edx
c040547e:	89 50 08             	mov    %edx,0x8(%eax)
c0405481:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405485:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405489:	89 50 04             	mov    %edx,0x4(%eax)
c040548c:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405490:	8b 54 24 30          	mov    0x30(%esp),%edx
c0405494:	89 50 04             	mov    %edx,0x4(%eax)
c0405497:	8b 44 24 14          	mov    0x14(%esp),%eax
c040549b:	8b 54 24 34          	mov    0x34(%esp),%edx
c040549f:	89 50 08             	mov    %edx,0x8(%eax)
c04054a2:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04054a9:	00 
c04054aa:	e9 a0 00 00 00       	jmp    c040554f <sglib___vmm_tree_fix_left_deletion_discrepancy+0x5d2>
c04054af:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04054b4:	74 0b                	je     c04054c1 <sglib___vmm_tree_fix_left_deletion_discrepancy+0x544>
c04054b6:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04054ba:	8a 40 0c             	mov    0xc(%eax),%al
c04054bd:	3c 01                	cmp    $0x1,%al
c04054bf:	74 1c                	je     c04054dd <sglib___vmm_tree_fix_left_deletion_discrepancy+0x560>
c04054c1:	68 83 03 00 00       	push   $0x383
c04054c6:	68 07 c9 40 c0       	push   $0xc040c907
c04054cb:	68 07 c9 40 c0       	push   $0xc040c907
c04054d0:	68 f8 c9 40 c0       	push   $0xc040c9f8
c04054d5:	e8 89 64 00 00       	call   c040b963 <debug_assert>
c04054da:	83 c4 10             	add    $0x10,%esp
c04054dd:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04054e1:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04054e5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04054e9:	8b 40 08             	mov    0x8(%eax),%eax
c04054ec:	89 44 24 30          	mov    %eax,0x30(%esp)
c04054f0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04054f4:	8b 40 04             	mov    0x4(%eax),%eax
c04054f7:	89 44 24 34          	mov    %eax,0x34(%esp)
c04054fb:	8b 44 24 50          	mov    0x50(%esp),%eax
c04054ff:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405503:	89 10                	mov    %edx,(%eax)
c0405505:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405509:	8a 50 0c             	mov    0xc(%eax),%dl
c040550c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405510:	88 50 0c             	mov    %dl,0xc(%eax)
c0405513:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405517:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c040551b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040551f:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405523:	89 50 08             	mov    %edx,0x8(%eax)
c0405526:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040552a:	8b 54 24 14          	mov    0x14(%esp),%edx
c040552e:	89 50 04             	mov    %edx,0x4(%eax)
c0405531:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405535:	8b 54 24 30          	mov    0x30(%esp),%edx
c0405539:	89 50 04             	mov    %edx,0x4(%eax)
c040553c:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405540:	8b 54 24 34          	mov    0x34(%esp),%edx
c0405544:	89 50 08             	mov    %edx,0x8(%eax)
c0405547:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040554e:	00 
c040554f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405553:	83 c4 4c             	add    $0x4c,%esp
c0405556:	c3                   	ret    

c0405557 <sglib___vmm_tree_fix_right_deletion_discrepancy>:
c0405557:	83 ec 4c             	sub    $0x4c,%esp
c040555a:	8b 44 24 50          	mov    0x50(%esp),%eax
c040555e:	8b 00                	mov    (%eax),%eax
c0405560:	89 44 24 14          	mov    %eax,0x14(%esp)
c0405564:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405568:	89 44 24 10          	mov    %eax,0x10(%esp)
c040556c:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0405571:	75 1c                	jne    c040558f <sglib___vmm_tree_fix_right_deletion_discrepancy+0x38>
c0405573:	68 83 03 00 00       	push   $0x383
c0405578:	68 07 c9 40 c0       	push   $0xc040c907
c040557d:	68 07 c9 40 c0       	push   $0xc040c907
c0405582:	68 18 c9 40 c0       	push   $0xc040c918
c0405587:	e8 d7 63 00 00       	call   c040b963 <debug_assert>
c040558c:	83 c4 10             	add    $0x10,%esp
c040558f:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405593:	8b 40 08             	mov    0x8(%eax),%eax
c0405596:	89 44 24 24          	mov    %eax,0x24(%esp)
c040559a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040559e:	8b 40 04             	mov    0x4(%eax),%eax
c04055a1:	89 44 24 18          	mov    %eax,0x18(%esp)
c04055a5:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c04055aa:	75 3c                	jne    c04055e8 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x91>
c04055ac:	8b 44 24 10          	mov    0x10(%esp),%eax
c04055b0:	8a 40 0c             	mov    0xc(%eax),%al
c04055b3:	3c 01                	cmp    $0x1,%al
c04055b5:	74 1c                	je     c04055d3 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x7c>
c04055b7:	68 83 03 00 00       	push   $0x383
c04055bc:	68 07 c9 40 c0       	push   $0xc040c907
c04055c1:	68 07 c9 40 c0       	push   $0xc040c907
c04055c6:	68 20 c9 40 c0       	push   $0xc040c920
c04055cb:	e8 93 63 00 00       	call   c040b963 <debug_assert>
c04055d0:	83 c4 10             	add    $0x10,%esp
c04055d3:	8b 44 24 10          	mov    0x10(%esp),%eax
c04055d7:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04055db:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04055e2:	00 
c04055e3:	e9 41 05 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04055e8:	8b 44 24 18          	mov    0x18(%esp),%eax
c04055ec:	8b 40 04             	mov    0x4(%eax),%eax
c04055ef:	89 44 24 28          	mov    %eax,0x28(%esp)
c04055f3:	8b 44 24 18          	mov    0x18(%esp),%eax
c04055f7:	8b 40 08             	mov    0x8(%eax),%eax
c04055fa:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c04055fe:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405602:	8a 40 0c             	mov    0xc(%eax),%al
c0405605:	3c 01                	cmp    $0x1,%al
c0405607:	0f 85 ae 02 00 00    	jne    c04058bb <sglib___vmm_tree_fix_right_deletion_discrepancy+0x364>
c040560d:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0405612:	75 35                	jne    c0405649 <sglib___vmm_tree_fix_right_deletion_discrepancy+0xf2>
c0405614:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405618:	8b 54 24 18          	mov    0x18(%esp),%edx
c040561c:	89 10                	mov    %edx,(%eax)
c040561e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405622:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405626:	8b 44 24 18          	mov    0x18(%esp),%eax
c040562a:	8b 54 24 14          	mov    0x14(%esp),%edx
c040562e:	89 50 08             	mov    %edx,0x8(%eax)
c0405631:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405635:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0405639:	89 50 04             	mov    %edx,0x4(%eax)
c040563c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405643:	00 
c0405644:	e9 e0 04 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0405649:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040564d:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405651:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405656:	74 0b                	je     c0405663 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x10c>
c0405658:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040565c:	8a 40 0c             	mov    0xc(%eax),%al
c040565f:	84 c0                	test   %al,%al
c0405661:	74 1c                	je     c040567f <sglib___vmm_tree_fix_right_deletion_discrepancy+0x128>
c0405663:	68 83 03 00 00       	push   $0x383
c0405668:	68 07 c9 40 c0       	push   $0xc040c907
c040566d:	68 07 c9 40 c0       	push   $0xc040c907
c0405672:	68 40 c9 40 c0       	push   $0xc040c940
c0405677:	e8 e7 62 00 00       	call   c040b963 <debug_assert>
c040567c:	83 c4 10             	add    $0x10,%esp
c040567f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405683:	8b 40 04             	mov    0x4(%eax),%eax
c0405686:	89 44 24 30          	mov    %eax,0x30(%esp)
c040568a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040568e:	8b 40 08             	mov    0x8(%eax),%eax
c0405691:	89 44 24 34          	mov    %eax,0x34(%esp)
c0405695:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040569a:	74 0b                	je     c04056a7 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x150>
c040569c:	8b 44 24 30          	mov    0x30(%esp),%eax
c04056a0:	8a 40 0c             	mov    0xc(%eax),%al
c04056a3:	84 c0                	test   %al,%al
c04056a5:	75 4f                	jne    c04056f6 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x19f>
c04056a7:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04056ac:	74 0b                	je     c04056b9 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x162>
c04056ae:	8b 44 24 34          	mov    0x34(%esp),%eax
c04056b2:	8a 40 0c             	mov    0xc(%eax),%al
c04056b5:	84 c0                	test   %al,%al
c04056b7:	75 3d                	jne    c04056f6 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x19f>
c04056b9:	8b 44 24 50          	mov    0x50(%esp),%eax
c04056bd:	8b 54 24 18          	mov    0x18(%esp),%edx
c04056c1:	89 10                	mov    %edx,(%eax)
c04056c3:	8b 44 24 18          	mov    0x18(%esp),%eax
c04056c7:	8b 54 24 14          	mov    0x14(%esp),%edx
c04056cb:	89 50 08             	mov    %edx,0x8(%eax)
c04056ce:	8b 44 24 18          	mov    0x18(%esp),%eax
c04056d2:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04056d6:	8b 44 24 14          	mov    0x14(%esp),%eax
c04056da:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04056de:	89 50 04             	mov    %edx,0x4(%eax)
c04056e1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04056e5:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c04056e9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04056f0:	00 
c04056f1:	e9 33 04 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04056f6:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c04056fb:	0f 84 e0 00 00 00    	je     c04057e1 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x28a>
c0405701:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405705:	8a 40 0c             	mov    0xc(%eax),%al
c0405708:	3c 01                	cmp    $0x1,%al
c040570a:	0f 85 d1 00 00 00    	jne    c04057e1 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x28a>
c0405710:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c0405715:	74 74                	je     c040578b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x234>
c0405717:	8b 44 24 34          	mov    0x34(%esp),%eax
c040571b:	8a 40 0c             	mov    0xc(%eax),%al
c040571e:	3c 01                	cmp    $0x1,%al
c0405720:	75 69                	jne    c040578b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x234>
c0405722:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405726:	89 44 24 20          	mov    %eax,0x20(%esp)
c040572a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040572e:	8b 40 04             	mov    0x4(%eax),%eax
c0405731:	89 44 24 38          	mov    %eax,0x38(%esp)
c0405735:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405739:	8b 40 08             	mov    0x8(%eax),%eax
c040573c:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0405740:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405744:	8b 54 24 20          	mov    0x20(%esp),%edx
c0405748:	89 10                	mov    %edx,(%eax)
c040574a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040574e:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405752:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405756:	8b 54 24 18          	mov    0x18(%esp),%edx
c040575a:	89 50 04             	mov    %edx,0x4(%eax)
c040575d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405761:	8b 54 24 38          	mov    0x38(%esp),%edx
c0405765:	89 50 08             	mov    %edx,0x8(%eax)
c0405768:	8b 44 24 20          	mov    0x20(%esp),%eax
c040576c:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405770:	89 50 08             	mov    %edx,0x8(%eax)
c0405773:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405777:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c040577b:	89 50 04             	mov    %edx,0x4(%eax)
c040577e:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405785:	00 
c0405786:	e9 9e 03 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c040578b:	8b 44 24 50          	mov    0x50(%esp),%eax
c040578f:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405793:	89 10                	mov    %edx,(%eax)
c0405795:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405799:	8b 54 24 18          	mov    0x18(%esp),%edx
c040579d:	89 50 04             	mov    %edx,0x4(%eax)
c04057a0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04057a4:	8b 54 24 14          	mov    0x14(%esp),%edx
c04057a8:	89 50 08             	mov    %edx,0x8(%eax)
c04057ab:	8b 44 24 18          	mov    0x18(%esp),%eax
c04057af:	8b 54 24 28          	mov    0x28(%esp),%edx
c04057b3:	89 50 04             	mov    %edx,0x4(%eax)
c04057b6:	8b 44 24 18          	mov    0x18(%esp),%eax
c04057ba:	8b 54 24 30          	mov    0x30(%esp),%edx
c04057be:	89 50 08             	mov    %edx,0x8(%eax)
c04057c1:	8b 44 24 14          	mov    0x14(%esp),%eax
c04057c5:	8b 54 24 34          	mov    0x34(%esp),%edx
c04057c9:	89 50 04             	mov    %edx,0x4(%eax)
c04057cc:	8b 44 24 30          	mov    0x30(%esp),%eax
c04057d0:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04057d4:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04057db:	00 
c04057dc:	e9 48 03 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04057e1:	83 7c 24 34 00       	cmpl   $0x0,0x34(%esp)
c04057e6:	0f 84 a6 00 00 00    	je     c0405892 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x33b>
c04057ec:	8b 44 24 34          	mov    0x34(%esp),%eax
c04057f0:	8a 40 0c             	mov    0xc(%eax),%al
c04057f3:	3c 01                	cmp    $0x1,%al
c04057f5:	0f 85 97 00 00 00    	jne    c0405892 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x33b>
c04057fb:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0405800:	74 27                	je     c0405829 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x2d2>
c0405802:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405806:	8a 40 0c             	mov    0xc(%eax),%al
c0405809:	84 c0                	test   %al,%al
c040580b:	74 1c                	je     c0405829 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x2d2>
c040580d:	68 83 03 00 00       	push   $0x383
c0405812:	68 07 c9 40 c0       	push   $0xc040c907
c0405817:	68 07 c9 40 c0       	push   $0xc040c907
c040581c:	68 6c c9 40 c0       	push   $0xc040c96c
c0405821:	e8 3d 61 00 00       	call   c040b963 <debug_assert>
c0405826:	83 c4 10             	add    $0x10,%esp
c0405829:	8b 44 24 34          	mov    0x34(%esp),%eax
c040582d:	89 44 24 20          	mov    %eax,0x20(%esp)
c0405831:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405835:	8b 40 04             	mov    0x4(%eax),%eax
c0405838:	89 44 24 38          	mov    %eax,0x38(%esp)
c040583c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405840:	8b 40 08             	mov    0x8(%eax),%eax
c0405843:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c0405847:	8b 44 24 50          	mov    0x50(%esp),%eax
c040584b:	8b 54 24 20          	mov    0x20(%esp),%edx
c040584f:	89 10                	mov    %edx,(%eax)
c0405851:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405855:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405859:	8b 44 24 20          	mov    0x20(%esp),%eax
c040585d:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405861:	89 50 04             	mov    %edx,0x4(%eax)
c0405864:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405868:	8b 54 24 38          	mov    0x38(%esp),%edx
c040586c:	89 50 08             	mov    %edx,0x8(%eax)
c040586f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405873:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405877:	89 50 08             	mov    %edx,0x8(%eax)
c040587a:	8b 44 24 14          	mov    0x14(%esp),%eax
c040587e:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0405882:	89 50 04             	mov    %edx,0x4(%eax)
c0405885:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040588c:	00 
c040588d:	e9 97 02 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0405892:	68 83 03 00 00       	push   $0x383
c0405897:	68 07 c9 40 c0       	push   $0xc040c907
c040589c:	68 07 c9 40 c0       	push   $0xc040c907
c04058a1:	68 99 c9 40 c0       	push   $0xc040c999
c04058a6:	e8 b8 60 00 00       	call   c040b963 <debug_assert>
c04058ab:	83 c4 10             	add    $0x10,%esp
c04058ae:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04058b5:	00 
c04058b6:	e9 6e 02 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c04058bb:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04058c0:	74 0b                	je     c04058cd <sglib___vmm_tree_fix_right_deletion_discrepancy+0x376>
c04058c2:	8b 44 24 28          	mov    0x28(%esp),%eax
c04058c6:	8a 40 0c             	mov    0xc(%eax),%al
c04058c9:	84 c0                	test   %al,%al
c04058cb:	75 3a                	jne    c0405907 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3b0>
c04058cd:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04058d2:	74 0b                	je     c04058df <sglib___vmm_tree_fix_right_deletion_discrepancy+0x388>
c04058d4:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04058d8:	8a 40 0c             	mov    0xc(%eax),%al
c04058db:	84 c0                	test   %al,%al
c04058dd:	75 28                	jne    c0405907 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3b0>
c04058df:	8b 44 24 14          	mov    0x14(%esp),%eax
c04058e3:	8a 40 0c             	mov    0xc(%eax),%al
c04058e6:	84 c0                	test   %al,%al
c04058e8:	0f 94 c0             	sete   %al
c04058eb:	0f b6 c0             	movzbl %al,%eax
c04058ee:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04058f2:	8b 44 24 14          	mov    0x14(%esp),%eax
c04058f6:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c04058fa:	8b 44 24 18          	mov    0x18(%esp),%eax
c04058fe:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0405902:	e9 22 02 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0405907:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c040590c:	0f 84 77 01 00 00    	je     c0405a89 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x532>
c0405912:	8b 44 24 28          	mov    0x28(%esp),%eax
c0405916:	8a 40 0c             	mov    0xc(%eax),%al
c0405919:	3c 01                	cmp    $0x1,%al
c040591b:	0f 85 68 01 00 00    	jne    c0405a89 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x532>
c0405921:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0405926:	74 0b                	je     c0405933 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x3dc>
c0405928:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040592c:	8a 40 0c             	mov    0xc(%eax),%al
c040592f:	84 c0                	test   %al,%al
c0405931:	75 4b                	jne    c040597e <sglib___vmm_tree_fix_right_deletion_discrepancy+0x427>
c0405933:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405937:	8b 54 24 18          	mov    0x18(%esp),%edx
c040593b:	89 10                	mov    %edx,(%eax)
c040593d:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405941:	8a 50 0c             	mov    0xc(%eax),%dl
c0405944:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405948:	88 50 0c             	mov    %dl,0xc(%eax)
c040594b:	8b 44 24 14          	mov    0x14(%esp),%eax
c040594f:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405953:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405957:	8b 54 24 14          	mov    0x14(%esp),%edx
c040595b:	89 50 08             	mov    %edx,0x8(%eax)
c040595e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405962:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c0405966:	89 50 04             	mov    %edx,0x4(%eax)
c0405969:	8b 44 24 28          	mov    0x28(%esp),%eax
c040596d:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405971:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405978:	00 
c0405979:	e9 ab 01 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c040597e:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c0405983:	75 1c                	jne    c04059a1 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x44a>
c0405985:	68 83 03 00 00       	push   $0x383
c040598a:	68 07 c9 40 c0       	push   $0xc040c907
c040598f:	68 07 c9 40 c0       	push   $0xc040c907
c0405994:	68 9b c9 40 c0       	push   $0xc040c99b
c0405999:	e8 c5 5f 00 00       	call   c040b963 <debug_assert>
c040599e:	83 c4 10             	add    $0x10,%esp
c04059a1:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04059a6:	75 1c                	jne    c04059c4 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x46d>
c04059a8:	68 83 03 00 00       	push   $0x383
c04059ad:	68 07 c9 40 c0       	push   $0xc040c907
c04059b2:	68 07 c9 40 c0       	push   $0xc040c907
c04059b7:	68 a4 c9 40 c0       	push   $0xc040c9a4
c04059bc:	e8 a2 5f 00 00       	call   c040b963 <debug_assert>
c04059c1:	83 c4 10             	add    $0x10,%esp
c04059c4:	8b 44 24 28          	mov    0x28(%esp),%eax
c04059c8:	8a 40 0c             	mov    0xc(%eax),%al
c04059cb:	3c 01                	cmp    $0x1,%al
c04059cd:	74 1c                	je     c04059eb <sglib___vmm_tree_fix_right_deletion_discrepancy+0x494>
c04059cf:	68 83 03 00 00       	push   $0x383
c04059d4:	68 07 c9 40 c0       	push   $0xc040c907
c04059d9:	68 07 c9 40 c0       	push   $0xc040c907
c04059de:	68 b0 c9 40 c0       	push   $0xc040c9b0
c04059e3:	e8 7b 5f 00 00       	call   c040b963 <debug_assert>
c04059e8:	83 c4 10             	add    $0x10,%esp
c04059eb:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04059ef:	8a 40 0c             	mov    0xc(%eax),%al
c04059f2:	3c 01                	cmp    $0x1,%al
c04059f4:	74 1c                	je     c0405a12 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x4bb>
c04059f6:	68 83 03 00 00       	push   $0x383
c04059fb:	68 07 c9 40 c0       	push   $0xc040c907
c0405a00:	68 07 c9 40 c0       	push   $0xc040c907
c0405a05:	68 d4 c9 40 c0       	push   $0xc040c9d4
c0405a0a:	e8 54 5f 00 00       	call   c040b963 <debug_assert>
c0405a0f:	83 c4 10             	add    $0x10,%esp
c0405a12:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405a16:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405a1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405a1e:	8b 40 04             	mov    0x4(%eax),%eax
c0405a21:	89 44 24 30          	mov    %eax,0x30(%esp)
c0405a25:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405a29:	8b 40 08             	mov    0x8(%eax),%eax
c0405a2c:	89 44 24 34          	mov    %eax,0x34(%esp)
c0405a30:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405a34:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405a38:	89 10                	mov    %edx,(%eax)
c0405a3a:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405a3e:	8a 50 0c             	mov    0xc(%eax),%dl
c0405a41:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405a45:	88 50 0c             	mov    %dl,0xc(%eax)
c0405a48:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405a4c:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405a50:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405a54:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405a58:	89 50 04             	mov    %edx,0x4(%eax)
c0405a5b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405a5f:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405a63:	89 50 08             	mov    %edx,0x8(%eax)
c0405a66:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405a6a:	8b 54 24 30          	mov    0x30(%esp),%edx
c0405a6e:	89 50 08             	mov    %edx,0x8(%eax)
c0405a71:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405a75:	8b 54 24 34          	mov    0x34(%esp),%edx
c0405a79:	89 50 04             	mov    %edx,0x4(%eax)
c0405a7c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405a83:	00 
c0405a84:	e9 a0 00 00 00       	jmp    c0405b29 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x5d2>
c0405a89:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c0405a8e:	74 0b                	je     c0405a9b <sglib___vmm_tree_fix_right_deletion_discrepancy+0x544>
c0405a90:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405a94:	8a 40 0c             	mov    0xc(%eax),%al
c0405a97:	3c 01                	cmp    $0x1,%al
c0405a99:	74 1c                	je     c0405ab7 <sglib___vmm_tree_fix_right_deletion_discrepancy+0x560>
c0405a9b:	68 83 03 00 00       	push   $0x383
c0405aa0:	68 07 c9 40 c0       	push   $0xc040c907
c0405aa5:	68 07 c9 40 c0       	push   $0xc040c907
c0405aaa:	68 f8 c9 40 c0       	push   $0xc040c9f8
c0405aaf:	e8 af 5e 00 00       	call   c040b963 <debug_assert>
c0405ab4:	83 c4 10             	add    $0x10,%esp
c0405ab7:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0405abb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405abf:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405ac3:	8b 40 04             	mov    0x4(%eax),%eax
c0405ac6:	89 44 24 30          	mov    %eax,0x30(%esp)
c0405aca:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405ace:	8b 40 08             	mov    0x8(%eax),%eax
c0405ad1:	89 44 24 34          	mov    %eax,0x34(%esp)
c0405ad5:	8b 44 24 50          	mov    0x50(%esp),%eax
c0405ad9:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0405add:	89 10                	mov    %edx,(%eax)
c0405adf:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405ae3:	8a 50 0c             	mov    0xc(%eax),%dl
c0405ae6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405aea:	88 50 0c             	mov    %dl,0xc(%eax)
c0405aed:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405af1:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405af5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405af9:	8b 54 24 18          	mov    0x18(%esp),%edx
c0405afd:	89 50 04             	mov    %edx,0x4(%eax)
c0405b00:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0405b04:	8b 54 24 14          	mov    0x14(%esp),%edx
c0405b08:	89 50 08             	mov    %edx,0x8(%eax)
c0405b0b:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405b0f:	8b 54 24 30          	mov    0x30(%esp),%edx
c0405b13:	89 50 08             	mov    %edx,0x8(%eax)
c0405b16:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405b1a:	8b 54 24 34          	mov    0x34(%esp),%edx
c0405b1e:	89 50 04             	mov    %edx,0x4(%eax)
c0405b21:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0405b28:	00 
c0405b29:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405b2d:	83 c4 4c             	add    $0x4c,%esp
c0405b30:	c3                   	ret    

c0405b31 <sglib___vmm_tree_add_recursive>:
c0405b31:	83 ec 1c             	sub    $0x1c,%esp
c0405b34:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b38:	8b 00                	mov    (%eax),%eax
c0405b3a:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0405b3e:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0405b43:	75 17                	jne    c0405b5c <sglib___vmm_tree_add_recursive+0x2b>
c0405b45:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405b49:	c6 40 0c 01          	movb   $0x1,0xc(%eax)
c0405b4d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405b51:	8b 54 24 24          	mov    0x24(%esp),%edx
c0405b55:	89 10                	mov    %edx,(%eax)
c0405b57:	e9 c3 00 00 00       	jmp    c0405c1f <sglib___vmm_tree_add_recursive+0xee>
c0405b5c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405b60:	8b 00                	mov    (%eax),%eax
c0405b62:	8b 50 08             	mov    0x8(%eax),%edx
c0405b65:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405b69:	8b 00                	mov    (%eax),%eax
c0405b6b:	8b 40 08             	mov    0x8(%eax),%eax
c0405b6e:	39 c2                	cmp    %eax,%edx
c0405b70:	72 28                	jb     c0405b9a <sglib___vmm_tree_add_recursive+0x69>
c0405b72:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405b76:	8b 00                	mov    (%eax),%eax
c0405b78:	8b 50 08             	mov    0x8(%eax),%edx
c0405b7b:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405b7f:	8b 00                	mov    (%eax),%eax
c0405b81:	8b 48 08             	mov    0x8(%eax),%ecx
c0405b84:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405b88:	8b 00                	mov    (%eax),%eax
c0405b8a:	8b 40 0c             	mov    0xc(%eax),%eax
c0405b8d:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0405b90:	39 c2                	cmp    %eax,%edx
c0405b92:	0f 93 c0             	setae  %al
c0405b95:	0f b6 c0             	movzbl %al,%eax
c0405b98:	eb 05                	jmp    c0405b9f <sglib___vmm_tree_add_recursive+0x6e>
c0405b9a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0405b9f:	89 44 24 08          	mov    %eax,0x8(%esp)
c0405ba3:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0405ba8:	78 11                	js     c0405bbb <sglib___vmm_tree_add_recursive+0x8a>
c0405baa:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0405baf:	75 3d                	jne    c0405bee <sglib___vmm_tree_add_recursive+0xbd>
c0405bb1:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405bb5:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0405bb9:	73 33                	jae    c0405bee <sglib___vmm_tree_add_recursive+0xbd>
c0405bbb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405bbf:	83 c0 04             	add    $0x4,%eax
c0405bc2:	83 ec 08             	sub    $0x8,%esp
c0405bc5:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405bc9:	50                   	push   %eax
c0405bca:	e8 62 ff ff ff       	call   c0405b31 <sglib___vmm_tree_add_recursive>
c0405bcf:	83 c4 10             	add    $0x10,%esp
c0405bd2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405bd6:	8a 40 0c             	mov    0xc(%eax),%al
c0405bd9:	84 c0                	test   %al,%al
c0405bdb:	75 42                	jne    c0405c1f <sglib___vmm_tree_add_recursive+0xee>
c0405bdd:	83 ec 0c             	sub    $0xc,%esp
c0405be0:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405be4:	e8 da ef ff ff       	call   c0404bc3 <sglib___vmm_tree_fix_left_insertion_discrepancy>
c0405be9:	83 c4 10             	add    $0x10,%esp
c0405bec:	eb 31                	jmp    c0405c1f <sglib___vmm_tree_add_recursive+0xee>
c0405bee:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405bf2:	83 c0 08             	add    $0x8,%eax
c0405bf5:	83 ec 08             	sub    $0x8,%esp
c0405bf8:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405bfc:	50                   	push   %eax
c0405bfd:	e8 2f ff ff ff       	call   c0405b31 <sglib___vmm_tree_add_recursive>
c0405c02:	83 c4 10             	add    $0x10,%esp
c0405c05:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405c09:	8a 40 0c             	mov    0xc(%eax),%al
c0405c0c:	84 c0                	test   %al,%al
c0405c0e:	75 0f                	jne    c0405c1f <sglib___vmm_tree_add_recursive+0xee>
c0405c10:	83 ec 0c             	sub    $0xc,%esp
c0405c13:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405c17:	e8 84 f1 ff ff       	call   c0404da0 <sglib___vmm_tree_fix_right_insertion_discrepancy>
c0405c1c:	83 c4 10             	add    $0x10,%esp
c0405c1f:	83 c4 1c             	add    $0x1c,%esp
c0405c22:	c3                   	ret    

c0405c23 <sglib___vmm_tree_delete_rightmost_leaf>:
c0405c23:	83 ec 1c             	sub    $0x1c,%esp
c0405c26:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405c2a:	8b 00                	mov    (%eax),%eax
c0405c2c:	89 44 24 04          	mov    %eax,0x4(%esp)
c0405c30:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0405c37:	00 
c0405c38:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0405c3d:	75 1c                	jne    c0405c5b <sglib___vmm_tree_delete_rightmost_leaf+0x38>
c0405c3f:	68 83 03 00 00       	push   $0x383
c0405c44:	68 07 c9 40 c0       	push   $0xc040c907
c0405c49:	68 07 c9 40 c0       	push   $0xc040c907
c0405c4e:	68 18 c9 40 c0       	push   $0xc040c918
c0405c53:	e8 0b 5d 00 00       	call   c040b963 <debug_assert>
c0405c58:	83 c4 10             	add    $0x10,%esp
c0405c5b:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405c5f:	8b 40 08             	mov    0x8(%eax),%eax
c0405c62:	85 c0                	test   %eax,%eax
c0405c64:	75 6f                	jne    c0405cd5 <sglib___vmm_tree_delete_rightmost_leaf+0xb2>
c0405c66:	8b 44 24 24          	mov    0x24(%esp),%eax
c0405c6a:	8b 54 24 04          	mov    0x4(%esp),%edx
c0405c6e:	89 10                	mov    %edx,(%eax)
c0405c70:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405c74:	8b 40 04             	mov    0x4(%eax),%eax
c0405c77:	85 c0                	test   %eax,%eax
c0405c79:	74 3b                	je     c0405cb6 <sglib___vmm_tree_delete_rightmost_leaf+0x93>
c0405c7b:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405c7f:	8a 40 0c             	mov    0xc(%eax),%al
c0405c82:	84 c0                	test   %al,%al
c0405c84:	75 16                	jne    c0405c9c <sglib___vmm_tree_delete_rightmost_leaf+0x79>
c0405c86:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405c8a:	8b 40 04             	mov    0x4(%eax),%eax
c0405c8d:	8a 40 0c             	mov    0xc(%eax),%al
c0405c90:	84 c0                	test   %al,%al
c0405c92:	75 08                	jne    c0405c9c <sglib___vmm_tree_delete_rightmost_leaf+0x79>
c0405c94:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c0405c9b:	00 
c0405c9c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405ca0:	8b 40 04             	mov    0x4(%eax),%eax
c0405ca3:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405ca7:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405cab:	8b 50 04             	mov    0x4(%eax),%edx
c0405cae:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405cb2:	89 10                	mov    %edx,(%eax)
c0405cb4:	eb 54                	jmp    c0405d0a <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0405cb6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0405cba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0405cc0:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405cc4:	8a 40 0c             	mov    0xc(%eax),%al
c0405cc7:	84 c0                	test   %al,%al
c0405cc9:	0f 94 c0             	sete   %al
c0405ccc:	0f b6 c0             	movzbl %al,%eax
c0405ccf:	89 44 24 08          	mov    %eax,0x8(%esp)
c0405cd3:	eb 35                	jmp    c0405d0a <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0405cd5:	8b 44 24 04          	mov    0x4(%esp),%eax
c0405cd9:	83 c0 08             	add    $0x8,%eax
c0405cdc:	83 ec 08             	sub    $0x8,%esp
c0405cdf:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405ce3:	50                   	push   %eax
c0405ce4:	e8 3a ff ff ff       	call   c0405c23 <sglib___vmm_tree_delete_rightmost_leaf>
c0405ce9:	83 c4 10             	add    $0x10,%esp
c0405cec:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0405cf0:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0405cf5:	74 13                	je     c0405d0a <sglib___vmm_tree_delete_rightmost_leaf+0xe7>
c0405cf7:	83 ec 0c             	sub    $0xc,%esp
c0405cfa:	ff 74 24 2c          	pushl  0x2c(%esp)
c0405cfe:	e8 54 f8 ff ff       	call   c0405557 <sglib___vmm_tree_fix_right_deletion_discrepancy>
c0405d03:	83 c4 10             	add    $0x10,%esp
c0405d06:	89 44 24 08          	mov    %eax,0x8(%esp)
c0405d0a:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405d0e:	83 c4 1c             	add    $0x1c,%esp
c0405d11:	c3                   	ret    

c0405d12 <sglib___vmm_tree_delete_recursive>:
c0405d12:	83 ec 2c             	sub    $0x2c,%esp
c0405d15:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405d19:	8b 00                	mov    (%eax),%eax
c0405d1b:	89 44 24 10          	mov    %eax,0x10(%esp)
c0405d1f:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0405d26:	00 
c0405d27:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0405d2c:	75 21                	jne    c0405d4f <sglib___vmm_tree_delete_recursive+0x3d>
c0405d2e:	68 83 03 00 00       	push   $0x383
c0405d33:	68 07 c9 40 c0       	push   $0xc040c907
c0405d38:	68 07 c9 40 c0       	push   $0xc040c907
c0405d3d:	68 28 ca 40 c0       	push   $0xc040ca28
c0405d42:	e8 1c 5c 00 00       	call   c040b963 <debug_assert>
c0405d47:	83 c4 10             	add    $0x10,%esp
c0405d4a:	e9 f6 01 00 00       	jmp    c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405d4f:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405d53:	8b 00                	mov    (%eax),%eax
c0405d55:	8b 50 08             	mov    0x8(%eax),%edx
c0405d58:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405d5c:	8b 00                	mov    (%eax),%eax
c0405d5e:	8b 40 08             	mov    0x8(%eax),%eax
c0405d61:	39 c2                	cmp    %eax,%edx
c0405d63:	72 28                	jb     c0405d8d <sglib___vmm_tree_delete_recursive+0x7b>
c0405d65:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405d69:	8b 00                	mov    (%eax),%eax
c0405d6b:	8b 50 08             	mov    0x8(%eax),%edx
c0405d6e:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405d72:	8b 00                	mov    (%eax),%eax
c0405d74:	8b 48 08             	mov    0x8(%eax),%ecx
c0405d77:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405d7b:	8b 00                	mov    (%eax),%eax
c0405d7d:	8b 40 0c             	mov    0xc(%eax),%eax
c0405d80:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0405d83:	39 c2                	cmp    %eax,%edx
c0405d85:	0f 93 c0             	setae  %al
c0405d88:	0f b6 c0             	movzbl %al,%eax
c0405d8b:	eb 05                	jmp    c0405d92 <sglib___vmm_tree_delete_recursive+0x80>
c0405d8d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0405d92:	89 44 24 14          	mov    %eax,0x14(%esp)
c0405d96:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0405d9b:	78 11                	js     c0405dae <sglib___vmm_tree_delete_recursive+0x9c>
c0405d9d:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0405da2:	75 48                	jne    c0405dec <sglib___vmm_tree_delete_recursive+0xda>
c0405da4:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405da8:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0405dac:	73 3e                	jae    c0405dec <sglib___vmm_tree_delete_recursive+0xda>
c0405dae:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405db2:	83 c0 04             	add    $0x4,%eax
c0405db5:	83 ec 08             	sub    $0x8,%esp
c0405db8:	ff 74 24 3c          	pushl  0x3c(%esp)
c0405dbc:	50                   	push   %eax
c0405dbd:	e8 50 ff ff ff       	call   c0405d12 <sglib___vmm_tree_delete_recursive>
c0405dc2:	83 c4 10             	add    $0x10,%esp
c0405dc5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405dc9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405dce:	0f 84 71 01 00 00    	je     c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405dd4:	83 ec 0c             	sub    $0xc,%esp
c0405dd7:	ff 74 24 3c          	pushl  0x3c(%esp)
c0405ddb:	e8 9d f1 ff ff       	call   c0404f7d <sglib___vmm_tree_fix_left_deletion_discrepancy>
c0405de0:	83 c4 10             	add    $0x10,%esp
c0405de3:	89 44 24 18          	mov    %eax,0x18(%esp)
c0405de7:	e9 59 01 00 00       	jmp    c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405dec:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0405df1:	7f 11                	jg     c0405e04 <sglib___vmm_tree_delete_recursive+0xf2>
c0405df3:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0405df8:	75 48                	jne    c0405e42 <sglib___vmm_tree_delete_recursive+0x130>
c0405dfa:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405dfe:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0405e02:	76 3e                	jbe    c0405e42 <sglib___vmm_tree_delete_recursive+0x130>
c0405e04:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405e08:	83 c0 08             	add    $0x8,%eax
c0405e0b:	83 ec 08             	sub    $0x8,%esp
c0405e0e:	ff 74 24 3c          	pushl  0x3c(%esp)
c0405e12:	50                   	push   %eax
c0405e13:	e8 fa fe ff ff       	call   c0405d12 <sglib___vmm_tree_delete_recursive>
c0405e18:	83 c4 10             	add    $0x10,%esp
c0405e1b:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405e1f:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405e24:	0f 84 1b 01 00 00    	je     c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405e2a:	83 ec 0c             	sub    $0xc,%esp
c0405e2d:	ff 74 24 3c          	pushl  0x3c(%esp)
c0405e31:	e8 21 f7 ff ff       	call   c0405557 <sglib___vmm_tree_fix_right_deletion_discrepancy>
c0405e36:	83 c4 10             	add    $0x10,%esp
c0405e39:	89 44 24 18          	mov    %eax,0x18(%esp)
c0405e3d:	e9 03 01 00 00       	jmp    c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405e42:	8b 44 24 34          	mov    0x34(%esp),%eax
c0405e46:	3b 44 24 10          	cmp    0x10(%esp),%eax
c0405e4a:	74 1c                	je     c0405e68 <sglib___vmm_tree_delete_recursive+0x156>
c0405e4c:	68 83 03 00 00       	push   $0x383
c0405e51:	68 07 c9 40 c0       	push   $0xc040c907
c0405e56:	68 07 c9 40 c0       	push   $0xc040c907
c0405e5b:	68 7c ca 40 c0       	push   $0xc040ca7c
c0405e60:	e8 fe 5a 00 00       	call   c040b963 <debug_assert>
c0405e65:	83 c4 10             	add    $0x10,%esp
c0405e68:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405e6c:	8b 40 04             	mov    0x4(%eax),%eax
c0405e6f:	85 c0                	test   %eax,%eax
c0405e71:	75 68                	jne    c0405edb <sglib___vmm_tree_delete_recursive+0x1c9>
c0405e73:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405e77:	8b 40 08             	mov    0x8(%eax),%eax
c0405e7a:	85 c0                	test   %eax,%eax
c0405e7c:	75 22                	jne    c0405ea0 <sglib___vmm_tree_delete_recursive+0x18e>
c0405e7e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405e82:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c0405e88:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405e8c:	8a 40 0c             	mov    0xc(%eax),%al
c0405e8f:	84 c0                	test   %al,%al
c0405e91:	0f 94 c0             	sete   %al
c0405e94:	0f b6 c0             	movzbl %al,%eax
c0405e97:	89 44 24 18          	mov    %eax,0x18(%esp)
c0405e9b:	e9 a5 00 00 00       	jmp    c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405ea0:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405ea4:	8a 40 0c             	mov    0xc(%eax),%al
c0405ea7:	84 c0                	test   %al,%al
c0405ea9:	75 16                	jne    c0405ec1 <sglib___vmm_tree_delete_recursive+0x1af>
c0405eab:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405eaf:	8b 40 08             	mov    0x8(%eax),%eax
c0405eb2:	8a 40 0c             	mov    0xc(%eax),%al
c0405eb5:	84 c0                	test   %al,%al
c0405eb7:	75 08                	jne    c0405ec1 <sglib___vmm_tree_delete_recursive+0x1af>
c0405eb9:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c0405ec0:	00 
c0405ec1:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405ec5:	8b 40 08             	mov    0x8(%eax),%eax
c0405ec8:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405ecc:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405ed0:	8b 50 08             	mov    0x8(%eax),%edx
c0405ed3:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405ed7:	89 10                	mov    %edx,(%eax)
c0405ed9:	eb 6a                	jmp    c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405edb:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405edf:	8d 50 04             	lea    0x4(%eax),%edx
c0405ee2:	83 ec 08             	sub    $0x8,%esp
c0405ee5:	8d 44 24 14          	lea    0x14(%esp),%eax
c0405ee9:	50                   	push   %eax
c0405eea:	52                   	push   %edx
c0405eeb:	e8 33 fd ff ff       	call   c0405c23 <sglib___vmm_tree_delete_rightmost_leaf>
c0405ef0:	83 c4 10             	add    $0x10,%esp
c0405ef3:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0405ef7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405efb:	8b 54 24 10          	mov    0x10(%esp),%edx
c0405eff:	8b 52 04             	mov    0x4(%edx),%edx
c0405f02:	89 50 04             	mov    %edx,0x4(%eax)
c0405f05:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405f09:	8b 54 24 10          	mov    0x10(%esp),%edx
c0405f0d:	8b 52 08             	mov    0x8(%edx),%edx
c0405f10:	89 50 08             	mov    %edx,0x8(%eax)
c0405f13:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0405f17:	8b 54 24 10          	mov    0x10(%esp),%edx
c0405f1b:	8a 52 0c             	mov    0xc(%edx),%dl
c0405f1e:	88 50 0c             	mov    %dl,0xc(%eax)
c0405f21:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0405f25:	8b 44 24 30          	mov    0x30(%esp),%eax
c0405f29:	89 10                	mov    %edx,(%eax)
c0405f2b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0405f30:	74 13                	je     c0405f45 <sglib___vmm_tree_delete_recursive+0x233>
c0405f32:	83 ec 0c             	sub    $0xc,%esp
c0405f35:	ff 74 24 3c          	pushl  0x3c(%esp)
c0405f39:	e8 3f f0 ff ff       	call   c0404f7d <sglib___vmm_tree_fix_left_deletion_discrepancy>
c0405f3e:	83 c4 10             	add    $0x10,%esp
c0405f41:	89 44 24 18          	mov    %eax,0x18(%esp)
c0405f45:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405f49:	83 c4 2c             	add    $0x2c,%esp
c0405f4c:	c3                   	ret    

c0405f4d <sglib_vmm_tree_add>:
c0405f4d:	83 ec 0c             	sub    $0xc,%esp
c0405f50:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405f54:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
c0405f5b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405f5f:	8b 50 08             	mov    0x8(%eax),%edx
c0405f62:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405f66:	89 50 04             	mov    %edx,0x4(%eax)
c0405f69:	83 ec 08             	sub    $0x8,%esp
c0405f6c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0405f70:	ff 74 24 1c          	pushl  0x1c(%esp)
c0405f74:	e8 b8 fb ff ff       	call   c0405b31 <sglib___vmm_tree_add_recursive>
c0405f79:	83 c4 10             	add    $0x10,%esp
c0405f7c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405f80:	8b 00                	mov    (%eax),%eax
c0405f82:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405f86:	83 c4 0c             	add    $0xc,%esp
c0405f89:	c3                   	ret    

c0405f8a <sglib_vmm_tree_delete>:
c0405f8a:	83 ec 0c             	sub    $0xc,%esp
c0405f8d:	83 ec 08             	sub    $0x8,%esp
c0405f90:	ff 74 24 1c          	pushl  0x1c(%esp)
c0405f94:	ff 74 24 1c          	pushl  0x1c(%esp)
c0405f98:	e8 75 fd ff ff       	call   c0405d12 <sglib___vmm_tree_delete_recursive>
c0405f9d:	83 c4 10             	add    $0x10,%esp
c0405fa0:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405fa4:	8b 00                	mov    (%eax),%eax
c0405fa6:	85 c0                	test   %eax,%eax
c0405fa8:	74 0a                	je     c0405fb4 <sglib_vmm_tree_delete+0x2a>
c0405faa:	8b 44 24 10          	mov    0x10(%esp),%eax
c0405fae:	8b 00                	mov    (%eax),%eax
c0405fb0:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
c0405fb4:	83 c4 0c             	add    $0xc,%esp
c0405fb7:	c3                   	ret    

c0405fb8 <sglib_vmm_tree_find_member>:
c0405fb8:	83 ec 10             	sub    $0x10,%esp
c0405fbb:	8b 44 24 14          	mov    0x14(%esp),%eax
c0405fbf:	89 44 24 08          	mov    %eax,0x8(%esp)
c0405fc3:	eb 6d                	jmp    c0406032 <sglib_vmm_tree_find_member+0x7a>
c0405fc5:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405fc9:	8b 00                	mov    (%eax),%eax
c0405fcb:	8b 50 08             	mov    0x8(%eax),%edx
c0405fce:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405fd2:	8b 00                	mov    (%eax),%eax
c0405fd4:	8b 40 08             	mov    0x8(%eax),%eax
c0405fd7:	39 c2                	cmp    %eax,%edx
c0405fd9:	72 28                	jb     c0406003 <sglib_vmm_tree_find_member+0x4b>
c0405fdb:	8b 44 24 18          	mov    0x18(%esp),%eax
c0405fdf:	8b 00                	mov    (%eax),%eax
c0405fe1:	8b 50 08             	mov    0x8(%eax),%edx
c0405fe4:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405fe8:	8b 00                	mov    (%eax),%eax
c0405fea:	8b 48 08             	mov    0x8(%eax),%ecx
c0405fed:	8b 44 24 08          	mov    0x8(%esp),%eax
c0405ff1:	8b 00                	mov    (%eax),%eax
c0405ff3:	8b 40 0c             	mov    0xc(%eax),%eax
c0405ff6:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0405ff9:	39 c2                	cmp    %eax,%edx
c0405ffb:	0f 93 c0             	setae  %al
c0405ffe:	0f b6 c0             	movzbl %al,%eax
c0406001:	eb 05                	jmp    c0406008 <sglib_vmm_tree_find_member+0x50>
c0406003:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0406008:	89 44 24 0c          	mov    %eax,0xc(%esp)
c040600c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0406011:	79 0d                	jns    c0406020 <sglib_vmm_tree_find_member+0x68>
c0406013:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406017:	8b 40 04             	mov    0x4(%eax),%eax
c040601a:	89 44 24 08          	mov    %eax,0x8(%esp)
c040601e:	eb 12                	jmp    c0406032 <sglib_vmm_tree_find_member+0x7a>
c0406020:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0406025:	7e 12                	jle    c0406039 <sglib_vmm_tree_find_member+0x81>
c0406027:	8b 44 24 08          	mov    0x8(%esp),%eax
c040602b:	8b 40 08             	mov    0x8(%eax),%eax
c040602e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0406032:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0406037:	75 8c                	jne    c0405fc5 <sglib_vmm_tree_find_member+0xd>
c0406039:	8b 44 24 08          	mov    0x8(%esp),%eax
c040603d:	89 44 24 04          	mov    %eax,0x4(%esp)
c0406041:	8b 44 24 04          	mov    0x4(%esp),%eax
c0406045:	83 c4 10             	add    $0x10,%esp
c0406048:	c3                   	ret    

c0406049 <sglib_vmm_tree_is_member>:
c0406049:	83 ec 1c             	sub    $0x1c,%esp
c040604c:	e9 be 00 00 00       	jmp    c040610f <sglib_vmm_tree_is_member+0xc6>
c0406051:	8b 44 24 24          	mov    0x24(%esp),%eax
c0406055:	8b 00                	mov    (%eax),%eax
c0406057:	8b 50 08             	mov    0x8(%eax),%edx
c040605a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040605e:	8b 00                	mov    (%eax),%eax
c0406060:	8b 40 08             	mov    0x8(%eax),%eax
c0406063:	39 c2                	cmp    %eax,%edx
c0406065:	72 28                	jb     c040608f <sglib_vmm_tree_is_member+0x46>
c0406067:	8b 44 24 24          	mov    0x24(%esp),%eax
c040606b:	8b 00                	mov    (%eax),%eax
c040606d:	8b 50 08             	mov    0x8(%eax),%edx
c0406070:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406074:	8b 00                	mov    (%eax),%eax
c0406076:	8b 48 08             	mov    0x8(%eax),%ecx
c0406079:	8b 44 24 20          	mov    0x20(%esp),%eax
c040607d:	8b 00                	mov    (%eax),%eax
c040607f:	8b 40 0c             	mov    0xc(%eax),%eax
c0406082:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0406085:	39 c2                	cmp    %eax,%edx
c0406087:	0f 93 c0             	setae  %al
c040608a:	0f b6 c0             	movzbl %al,%eax
c040608d:	eb 05                	jmp    c0406094 <sglib_vmm_tree_is_member+0x4b>
c040608f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0406094:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0406098:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040609d:	78 11                	js     c04060b0 <sglib_vmm_tree_is_member+0x67>
c040609f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04060a4:	75 17                	jne    c04060bd <sglib_vmm_tree_is_member+0x74>
c04060a6:	8b 44 24 24          	mov    0x24(%esp),%eax
c04060aa:	3b 44 24 20          	cmp    0x20(%esp),%eax
c04060ae:	73 0d                	jae    c04060bd <sglib_vmm_tree_is_member+0x74>
c04060b0:	8b 44 24 20          	mov    0x20(%esp),%eax
c04060b4:	8b 40 04             	mov    0x4(%eax),%eax
c04060b7:	89 44 24 20          	mov    %eax,0x20(%esp)
c04060bb:	eb 52                	jmp    c040610f <sglib_vmm_tree_is_member+0xc6>
c04060bd:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04060c2:	7f 11                	jg     c04060d5 <sglib_vmm_tree_is_member+0x8c>
c04060c4:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04060c9:	75 17                	jne    c04060e2 <sglib_vmm_tree_is_member+0x99>
c04060cb:	8b 44 24 24          	mov    0x24(%esp),%eax
c04060cf:	3b 44 24 20          	cmp    0x20(%esp),%eax
c04060d3:	76 0d                	jbe    c04060e2 <sglib_vmm_tree_is_member+0x99>
c04060d5:	8b 44 24 20          	mov    0x20(%esp),%eax
c04060d9:	8b 40 08             	mov    0x8(%eax),%eax
c04060dc:	89 44 24 20          	mov    %eax,0x20(%esp)
c04060e0:	eb 2d                	jmp    c040610f <sglib_vmm_tree_is_member+0xc6>
c04060e2:	8b 44 24 20          	mov    0x20(%esp),%eax
c04060e6:	3b 44 24 24          	cmp    0x24(%esp),%eax
c04060ea:	74 1c                	je     c0406108 <sglib_vmm_tree_is_member+0xbf>
c04060ec:	68 83 03 00 00       	push   $0x383
c04060f1:	68 07 c9 40 c0       	push   $0xc040c907
c04060f6:	68 07 c9 40 c0       	push   $0xc040c907
c04060fb:	68 db ca 40 c0       	push   $0xc040cadb
c0406100:	e8 5e 58 00 00       	call   c040b963 <debug_assert>
c0406105:	83 c4 10             	add    $0x10,%esp
c0406108:	b8 01 00 00 00       	mov    $0x1,%eax
c040610d:	eb 10                	jmp    c040611f <sglib_vmm_tree_is_member+0xd6>
c040610f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0406114:	0f 85 37 ff ff ff    	jne    c0406051 <sglib_vmm_tree_is_member+0x8>
c040611a:	b8 00 00 00 00       	mov    $0x0,%eax
c040611f:	83 c4 1c             	add    $0x1c,%esp
c0406122:	c3                   	ret    

c0406123 <sglib_vmm_tree_delete_if_member>:
c0406123:	83 ec 0c             	sub    $0xc,%esp
c0406126:	8b 44 24 10          	mov    0x10(%esp),%eax
c040612a:	8b 00                	mov    (%eax),%eax
c040612c:	ff 74 24 14          	pushl  0x14(%esp)
c0406130:	50                   	push   %eax
c0406131:	e8 82 fe ff ff       	call   c0405fb8 <sglib_vmm_tree_find_member>
c0406136:	83 c4 08             	add    $0x8,%esp
c0406139:	8b 54 24 18          	mov    0x18(%esp),%edx
c040613d:	89 02                	mov    %eax,(%edx)
c040613f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406143:	8b 00                	mov    (%eax),%eax
c0406145:	85 c0                	test   %eax,%eax
c0406147:	74 1d                	je     c0406166 <sglib_vmm_tree_delete_if_member+0x43>
c0406149:	8b 44 24 18          	mov    0x18(%esp),%eax
c040614d:	8b 00                	mov    (%eax),%eax
c040614f:	83 ec 08             	sub    $0x8,%esp
c0406152:	50                   	push   %eax
c0406153:	ff 74 24 1c          	pushl  0x1c(%esp)
c0406157:	e8 2e fe ff ff       	call   c0405f8a <sglib_vmm_tree_delete>
c040615c:	83 c4 10             	add    $0x10,%esp
c040615f:	b8 01 00 00 00       	mov    $0x1,%eax
c0406164:	eb 05                	jmp    c040616b <sglib_vmm_tree_delete_if_member+0x48>
c0406166:	b8 00 00 00 00       	mov    $0x0,%eax
c040616b:	83 c4 0c             	add    $0xc,%esp
c040616e:	c3                   	ret    

c040616f <sglib_vmm_tree_add_if_not_member>:
c040616f:	83 ec 0c             	sub    $0xc,%esp
c0406172:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406176:	8b 00                	mov    (%eax),%eax
c0406178:	ff 74 24 14          	pushl  0x14(%esp)
c040617c:	50                   	push   %eax
c040617d:	e8 36 fe ff ff       	call   c0405fb8 <sglib_vmm_tree_find_member>
c0406182:	83 c4 08             	add    $0x8,%esp
c0406185:	8b 54 24 18          	mov    0x18(%esp),%edx
c0406189:	89 02                	mov    %eax,(%edx)
c040618b:	8b 44 24 18          	mov    0x18(%esp),%eax
c040618f:	8b 00                	mov    (%eax),%eax
c0406191:	85 c0                	test   %eax,%eax
c0406193:	75 1a                	jne    c04061af <sglib_vmm_tree_add_if_not_member+0x40>
c0406195:	83 ec 08             	sub    $0x8,%esp
c0406198:	ff 74 24 1c          	pushl  0x1c(%esp)
c040619c:	ff 74 24 1c          	pushl  0x1c(%esp)
c04061a0:	e8 a8 fd ff ff       	call   c0405f4d <sglib_vmm_tree_add>
c04061a5:	83 c4 10             	add    $0x10,%esp
c04061a8:	b8 01 00 00 00       	mov    $0x1,%eax
c04061ad:	eb 05                	jmp    c04061b4 <sglib_vmm_tree_add_if_not_member+0x45>
c04061af:	b8 00 00 00 00       	mov    $0x0,%eax
c04061b4:	83 c4 0c             	add    $0xc,%esp
c04061b7:	c3                   	ret    

c04061b8 <sglib_vmm_tree_len>:
c04061b8:	81 ec ac 04 00 00    	sub    $0x4ac,%esp
c04061be:	c7 84 24 8c 04 00 00 	movl   $0x0,0x48c(%esp)
c04061c5:	00 00 00 00 
c04061c9:	8b 84 24 b0 04 00 00 	mov    0x4b0(%esp),%eax
c04061d0:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c04061d7:	c7 84 24 98 04 00 00 	movl   $0x0,0x498(%esp)
c04061de:	00 00 00 00 
c04061e2:	e9 11 01 00 00       	jmp    c04062f8 <sglib_vmm_tree_len+0x140>
c04061e7:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04061ee:	8b 94 24 94 04 00 00 	mov    0x494(%esp),%edx
c04061f5:	89 94 84 0c 02 00 00 	mov    %edx,0x20c(%esp,%eax,4)
c04061fc:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0406203:	8b 94 24 94 04 00 00 	mov    0x494(%esp),%edx
c040620a:	8b 52 08             	mov    0x8(%edx),%edx
c040620d:	89 54 84 0c          	mov    %edx,0xc(%esp,%eax,4)
c0406211:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c0406218:	c6 84 04 0c 04 00 00 	movb   $0x0,0x40c(%esp,%eax,1)
c040621f:	00 
c0406220:	8b 84 24 94 04 00 00 	mov    0x494(%esp),%eax
c0406227:	8b 40 04             	mov    0x4(%eax),%eax
c040622a:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c0406231:	ff 84 24 98 04 00 00 	incl   0x498(%esp)
c0406238:	83 bc 24 98 04 00 00 	cmpl   $0x7f,0x498(%esp)
c040623f:	7f 
c0406240:	7e 1c                	jle    c040625e <sglib_vmm_tree_len+0xa6>
c0406242:	68 83 03 00 00       	push   $0x383
c0406247:	68 07 c9 40 c0       	push   $0xc040c907
c040624c:	68 07 c9 40 c0       	push   $0xc040c907
c0406251:	68 e8 ca 40 c0       	push   $0xc040cae8
c0406256:	e8 08 57 00 00       	call   c040b963 <debug_assert>
c040625b:	83 c4 10             	add    $0x10,%esp
c040625e:	83 bc 24 94 04 00 00 	cmpl   $0x0,0x494(%esp)
c0406265:	00 
c0406266:	0f 85 7b ff ff ff    	jne    c04061e7 <sglib_vmm_tree_len+0x2f>
c040626c:	ff 8c 24 98 04 00 00 	decl   0x498(%esp)
c0406273:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c040627a:	8a 84 04 0c 04 00 00 	mov    0x40c(%esp,%eax,1),%al
c0406281:	84 c0                	test   %al,%al
c0406283:	75 1c                	jne    c04062a1 <sglib_vmm_tree_len+0xe9>
c0406285:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c040628c:	8b 84 84 0c 02 00 00 	mov    0x20c(%esp,%eax,4),%eax
c0406293:	89 84 24 9c 04 00 00 	mov    %eax,0x49c(%esp)
c040629a:	ff 84 24 8c 04 00 00 	incl   0x48c(%esp)
c04062a1:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04062a8:	8a 94 04 0c 04 00 00 	mov    0x40c(%esp,%eax,1),%dl
c04062af:	42                   	inc    %edx
c04062b0:	88 94 04 0c 04 00 00 	mov    %dl,0x40c(%esp,%eax,1)
c04062b7:	83 bc 24 98 04 00 00 	cmpl   $0x0,0x498(%esp)
c04062be:	00 
c04062bf:	7e 0f                	jle    c04062d0 <sglib_vmm_tree_len+0x118>
c04062c1:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04062c8:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
c04062cc:	85 c0                	test   %eax,%eax
c04062ce:	74 9c                	je     c040626c <sglib_vmm_tree_len+0xb4>
c04062d0:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04062d7:	8b 44 84 0c          	mov    0xc(%esp,%eax,4),%eax
c04062db:	89 84 24 94 04 00 00 	mov    %eax,0x494(%esp)
c04062e2:	8b 84 24 98 04 00 00 	mov    0x498(%esp),%eax
c04062e9:	c7 44 84 0c 00 00 00 	movl   $0x0,0xc(%esp,%eax,4)
c04062f0:	00 
c04062f1:	ff 84 24 98 04 00 00 	incl   0x498(%esp)
c04062f8:	83 bc 24 94 04 00 00 	cmpl   $0x0,0x494(%esp)
c04062ff:	00 
c0406300:	0f 85 58 ff ff ff    	jne    c040625e <sglib_vmm_tree_len+0xa6>
c0406306:	8b 84 24 8c 04 00 00 	mov    0x48c(%esp),%eax
c040630d:	81 c4 ac 04 00 00    	add    $0x4ac,%esp
c0406313:	c3                   	ret    

c0406314 <sglib__vmm_tree_it_compute_current_elem>:
c0406314:	83 ec 3c             	sub    $0x3c,%esp
c0406317:	8b 44 24 40          	mov    0x40(%esp),%eax
c040631b:	8b 80 88 02 00 00    	mov    0x288(%eax),%eax
c0406321:	89 44 24 18          	mov    %eax,0x18(%esp)
c0406325:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406329:	8b 80 8c 02 00 00    	mov    0x28c(%eax),%eax
c040632f:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0406333:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406337:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c040633d:	e9 2c 02 00 00       	jmp    c040656e <sglib__vmm_tree_it_compute_current_elem+0x25a>
c0406342:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406346:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c040634c:	98                   	cwtl   
c040634d:	48                   	dec    %eax
c040634e:	89 44 24 08          	mov    %eax,0x8(%esp)
c0406352:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0406357:	0f 88 bb 01 00 00    	js     c0406518 <sglib__vmm_tree_it_compute_current_elem+0x204>
c040635d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406361:	8b 54 24 40          	mov    0x40(%esp),%edx
c0406365:	8a 44 02 04          	mov    0x4(%edx,%eax,1),%al
c0406369:	3c 01                	cmp    $0x1,%al
c040636b:	7e 1b                	jle    c0406388 <sglib__vmm_tree_it_compute_current_elem+0x74>
c040636d:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406371:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0406377:	48                   	dec    %eax
c0406378:	8b 54 24 40          	mov    0x40(%esp),%edx
c040637c:	66 89 82 84 02 00 00 	mov    %ax,0x284(%edx)
c0406383:	e9 90 01 00 00       	jmp    c0406518 <sglib__vmm_tree_it_compute_current_elem+0x204>
c0406388:	8b 44 24 08          	mov    0x8(%esp),%eax
c040638c:	8b 54 24 40          	mov    0x40(%esp),%edx
c0406390:	8a 44 02 04          	mov    0x4(%edx,%eax,1),%al
c0406394:	84 c0                	test   %al,%al
c0406396:	75 18                	jne    c04063b0 <sglib__vmm_tree_it_compute_current_elem+0x9c>
c0406398:	8b 54 24 08          	mov    0x8(%esp),%edx
c040639c:	8b 44 24 40          	mov    0x40(%esp),%eax
c04063a0:	83 c2 20             	add    $0x20,%edx
c04063a3:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c04063a7:	8b 40 04             	mov    0x4(%eax),%eax
c04063aa:	89 44 24 14          	mov    %eax,0x14(%esp)
c04063ae:	eb 16                	jmp    c04063c6 <sglib__vmm_tree_it_compute_current_elem+0xb2>
c04063b0:	8b 54 24 08          	mov    0x8(%esp),%edx
c04063b4:	8b 44 24 40          	mov    0x40(%esp),%eax
c04063b8:	83 c2 20             	add    $0x20,%edx
c04063bb:	8b 44 90 04          	mov    0x4(%eax,%edx,4),%eax
c04063bf:	8b 40 08             	mov    0x8(%eax),%eax
c04063c2:	89 44 24 14          	mov    %eax,0x14(%esp)
c04063c6:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c04063cb:	0f 84 ea 00 00 00    	je     c04064bb <sglib__vmm_tree_it_compute_current_elem+0x1a7>
c04063d1:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04063d6:	0f 85 88 00 00 00    	jne    c0406464 <sglib__vmm_tree_it_compute_current_elem+0x150>
c04063dc:	8b 44 24 14          	mov    0x14(%esp),%eax
c04063e0:	89 44 24 20          	mov    %eax,0x20(%esp)
c04063e4:	eb 6d                	jmp    c0406453 <sglib__vmm_tree_it_compute_current_elem+0x13f>
c04063e6:	8b 44 24 18          	mov    0x18(%esp),%eax
c04063ea:	8b 00                	mov    (%eax),%eax
c04063ec:	8b 50 08             	mov    0x8(%eax),%edx
c04063ef:	8b 44 24 20          	mov    0x20(%esp),%eax
c04063f3:	8b 00                	mov    (%eax),%eax
c04063f5:	8b 40 08             	mov    0x8(%eax),%eax
c04063f8:	39 c2                	cmp    %eax,%edx
c04063fa:	72 28                	jb     c0406424 <sglib__vmm_tree_it_compute_current_elem+0x110>
c04063fc:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406400:	8b 00                	mov    (%eax),%eax
c0406402:	8b 50 08             	mov    0x8(%eax),%edx
c0406405:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406409:	8b 00                	mov    (%eax),%eax
c040640b:	8b 48 08             	mov    0x8(%eax),%ecx
c040640e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406412:	8b 00                	mov    (%eax),%eax
c0406414:	8b 40 0c             	mov    0xc(%eax),%eax
c0406417:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040641a:	39 c2                	cmp    %eax,%edx
c040641c:	0f 93 c0             	setae  %al
c040641f:	0f b6 c0             	movzbl %al,%eax
c0406422:	eb 05                	jmp    c0406429 <sglib__vmm_tree_it_compute_current_elem+0x115>
c0406424:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0406429:	89 44 24 24          	mov    %eax,0x24(%esp)
c040642d:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0406432:	79 0d                	jns    c0406441 <sglib__vmm_tree_it_compute_current_elem+0x12d>
c0406434:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406438:	8b 40 04             	mov    0x4(%eax),%eax
c040643b:	89 44 24 20          	mov    %eax,0x20(%esp)
c040643f:	eb 12                	jmp    c0406453 <sglib__vmm_tree_it_compute_current_elem+0x13f>
c0406441:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0406446:	7e 12                	jle    c040645a <sglib__vmm_tree_it_compute_current_elem+0x146>
c0406448:	8b 44 24 20          	mov    0x20(%esp),%eax
c040644c:	8b 40 08             	mov    0x8(%eax),%eax
c040644f:	89 44 24 20          	mov    %eax,0x20(%esp)
c0406453:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0406458:	75 8c                	jne    c04063e6 <sglib__vmm_tree_it_compute_current_elem+0xd2>
c040645a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040645e:	89 44 24 14          	mov    %eax,0x14(%esp)
c0406462:	eb 57                	jmp    c04064bb <sglib__vmm_tree_it_compute_current_elem+0x1a7>
c0406464:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406468:	89 44 24 28          	mov    %eax,0x28(%esp)
c040646c:	eb 3e                	jmp    c04064ac <sglib__vmm_tree_it_compute_current_elem+0x198>
c040646e:	83 ec 08             	sub    $0x8,%esp
c0406471:	ff 74 24 30          	pushl  0x30(%esp)
c0406475:	ff 74 24 24          	pushl  0x24(%esp)
c0406479:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040647d:	ff d0                	call   *%eax
c040647f:	83 c4 10             	add    $0x10,%esp
c0406482:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c0406486:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c040648b:	79 0d                	jns    c040649a <sglib__vmm_tree_it_compute_current_elem+0x186>
c040648d:	8b 44 24 28          	mov    0x28(%esp),%eax
c0406491:	8b 40 04             	mov    0x4(%eax),%eax
c0406494:	89 44 24 28          	mov    %eax,0x28(%esp)
c0406498:	eb 12                	jmp    c04064ac <sglib__vmm_tree_it_compute_current_elem+0x198>
c040649a:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c040649f:	7e 12                	jle    c04064b3 <sglib__vmm_tree_it_compute_current_elem+0x19f>
c04064a1:	8b 44 24 28          	mov    0x28(%esp),%eax
c04064a5:	8b 40 08             	mov    0x8(%eax),%eax
c04064a8:	89 44 24 28          	mov    %eax,0x28(%esp)
c04064ac:	83 7c 24 28 00       	cmpl   $0x0,0x28(%esp)
c04064b1:	75 bb                	jne    c040646e <sglib__vmm_tree_it_compute_current_elem+0x15a>
c04064b3:	8b 44 24 28          	mov    0x28(%esp),%eax
c04064b7:	89 44 24 14          	mov    %eax,0x14(%esp)
c04064bb:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c04064c0:	74 3f                	je     c0406501 <sglib__vmm_tree_it_compute_current_elem+0x1ed>
c04064c2:	8b 44 24 08          	mov    0x8(%esp),%eax
c04064c6:	40                   	inc    %eax
c04064c7:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04064cb:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04064cf:	8b 44 24 40          	mov    0x40(%esp),%eax
c04064d3:	8d 4a 20             	lea    0x20(%edx),%ecx
c04064d6:	8b 54 24 14          	mov    0x14(%esp),%edx
c04064da:	89 54 88 04          	mov    %edx,0x4(%eax,%ecx,4)
c04064de:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04064e2:	8b 54 24 40          	mov    0x40(%esp),%edx
c04064e6:	c6 44 02 04 00       	movb   $0x0,0x4(%edx,%eax,1)
c04064eb:	8b 44 24 40          	mov    0x40(%esp),%eax
c04064ef:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c04064f5:	40                   	inc    %eax
c04064f6:	8b 54 24 40          	mov    0x40(%esp),%edx
c04064fa:	66 89 82 84 02 00 00 	mov    %ax,0x284(%edx)
c0406501:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406505:	8b 54 24 40          	mov    0x40(%esp),%edx
c0406509:	8a 54 02 04          	mov    0x4(%edx,%eax,1),%dl
c040650d:	8d 4a 01             	lea    0x1(%edx),%ecx
c0406510:	8b 54 24 40          	mov    0x40(%esp),%edx
c0406514:	88 4c 02 04          	mov    %cl,0x4(%edx,%eax,1)
c0406518:	8b 44 24 40          	mov    0x40(%esp),%eax
c040651c:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0406522:	66 85 c0             	test   %ax,%ax
c0406525:	7e 47                	jle    c040656e <sglib__vmm_tree_it_compute_current_elem+0x25a>
c0406527:	8b 44 24 40          	mov    0x40(%esp),%eax
c040652b:	66 8b 90 86 02 00 00 	mov    0x286(%eax),%dx
c0406532:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406536:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c040653c:	98                   	cwtl   
c040653d:	8d 48 ff             	lea    -0x1(%eax),%ecx
c0406540:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406544:	8a 44 08 04          	mov    0x4(%eax,%ecx,1),%al
c0406548:	66 98                	cbtw   
c040654a:	66 39 c2             	cmp    %ax,%dx
c040654d:	75 1f                	jne    c040656e <sglib__vmm_tree_it_compute_current_elem+0x25a>
c040654f:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406553:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0406559:	98                   	cwtl   
c040655a:	8d 50 ff             	lea    -0x1(%eax),%edx
c040655d:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406561:	83 c2 20             	add    $0x20,%edx
c0406564:	8b 54 90 04          	mov    0x4(%eax,%edx,4),%edx
c0406568:	8b 44 24 40          	mov    0x40(%esp),%eax
c040656c:	89 10                	mov    %edx,(%eax)
c040656e:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406572:	8b 80 84 02 00 00    	mov    0x284(%eax),%eax
c0406578:	66 85 c0             	test   %ax,%ax
c040657b:	7e 0e                	jle    c040658b <sglib__vmm_tree_it_compute_current_elem+0x277>
c040657d:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406581:	8b 00                	mov    (%eax),%eax
c0406583:	85 c0                	test   %eax,%eax
c0406585:	0f 84 b7 fd ff ff    	je     c0406342 <sglib__vmm_tree_it_compute_current_elem+0x2e>
c040658b:	83 c4 3c             	add    $0x3c,%esp
c040658e:	c3                   	ret    

c040658f <sglib__vmm_tree_it_init>:
c040658f:	83 ec 2c             	sub    $0x2c,%esp
c0406592:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0406597:	75 1c                	jne    c04065b5 <sglib__vmm_tree_it_init+0x26>
c0406599:	68 83 03 00 00       	push   $0x383
c040659e:	68 07 c9 40 c0       	push   $0xc040c907
c04065a3:	68 07 c9 40 c0       	push   $0xc040c907
c04065a8:	68 0b cb 40 c0       	push   $0xc040cb0b
c04065ad:	e8 b1 53 00 00       	call   c040b963 <debug_assert>
c04065b2:	83 c4 10             	add    $0x10,%esp
c04065b5:	8b 44 24 38          	mov    0x38(%esp),%eax
c04065b9:	8b 54 24 30          	mov    0x30(%esp),%edx
c04065bd:	66 89 82 86 02 00 00 	mov    %ax,0x286(%edx)
c04065c4:	8b 44 24 30          	mov    0x30(%esp),%eax
c04065c8:	8b 54 24 40          	mov    0x40(%esp),%edx
c04065cc:	89 90 88 02 00 00    	mov    %edx,0x288(%eax)
c04065d2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04065d6:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c04065da:	89 90 8c 02 00 00    	mov    %edx,0x28c(%eax)
c04065e0:	83 7c 24 40 00       	cmpl   $0x0,0x40(%esp)
c04065e5:	75 0d                	jne    c04065f4 <sglib__vmm_tree_it_init+0x65>
c04065e7:	8b 44 24 34          	mov    0x34(%esp),%eax
c04065eb:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04065ef:	e9 ea 00 00 00       	jmp    c04066de <sglib__vmm_tree_it_init+0x14f>
c04065f4:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
c04065f9:	0f 85 88 00 00 00    	jne    c0406687 <sglib__vmm_tree_it_init+0xf8>
c04065ff:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406603:	89 44 24 10          	mov    %eax,0x10(%esp)
c0406607:	eb 6d                	jmp    c0406676 <sglib__vmm_tree_it_init+0xe7>
c0406609:	8b 44 24 40          	mov    0x40(%esp),%eax
c040660d:	8b 00                	mov    (%eax),%eax
c040660f:	8b 50 08             	mov    0x8(%eax),%edx
c0406612:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406616:	8b 00                	mov    (%eax),%eax
c0406618:	8b 40 08             	mov    0x8(%eax),%eax
c040661b:	39 c2                	cmp    %eax,%edx
c040661d:	72 28                	jb     c0406647 <sglib__vmm_tree_it_init+0xb8>
c040661f:	8b 44 24 40          	mov    0x40(%esp),%eax
c0406623:	8b 00                	mov    (%eax),%eax
c0406625:	8b 50 08             	mov    0x8(%eax),%edx
c0406628:	8b 44 24 10          	mov    0x10(%esp),%eax
c040662c:	8b 00                	mov    (%eax),%eax
c040662e:	8b 48 08             	mov    0x8(%eax),%ecx
c0406631:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406635:	8b 00                	mov    (%eax),%eax
c0406637:	8b 40 0c             	mov    0xc(%eax),%eax
c040663a:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c040663d:	39 c2                	cmp    %eax,%edx
c040663f:	0f 93 c0             	setae  %al
c0406642:	0f b6 c0             	movzbl %al,%eax
c0406645:	eb 05                	jmp    c040664c <sglib__vmm_tree_it_init+0xbd>
c0406647:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c040664c:	89 44 24 14          	mov    %eax,0x14(%esp)
c0406650:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0406655:	79 0d                	jns    c0406664 <sglib__vmm_tree_it_init+0xd5>
c0406657:	8b 44 24 10          	mov    0x10(%esp),%eax
c040665b:	8b 40 04             	mov    0x4(%eax),%eax
c040665e:	89 44 24 10          	mov    %eax,0x10(%esp)
c0406662:	eb 12                	jmp    c0406676 <sglib__vmm_tree_it_init+0xe7>
c0406664:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0406669:	7e 12                	jle    c040667d <sglib__vmm_tree_it_init+0xee>
c040666b:	8b 44 24 10          	mov    0x10(%esp),%eax
c040666f:	8b 40 08             	mov    0x8(%eax),%eax
c0406672:	89 44 24 10          	mov    %eax,0x10(%esp)
c0406676:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040667b:	75 8c                	jne    c0406609 <sglib__vmm_tree_it_init+0x7a>
c040667d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406681:	89 44 24 0c          	mov    %eax,0xc(%esp)
c0406685:	eb 57                	jmp    c04066de <sglib__vmm_tree_it_init+0x14f>
c0406687:	8b 44 24 34          	mov    0x34(%esp),%eax
c040668b:	89 44 24 18          	mov    %eax,0x18(%esp)
c040668f:	eb 3e                	jmp    c04066cf <sglib__vmm_tree_it_init+0x140>
c0406691:	83 ec 08             	sub    $0x8,%esp
c0406694:	ff 74 24 20          	pushl  0x20(%esp)
c0406698:	ff 74 24 4c          	pushl  0x4c(%esp)
c040669c:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c04066a0:	ff d0                	call   *%eax
c04066a2:	83 c4 10             	add    $0x10,%esp
c04066a5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c04066a9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04066ae:	79 0d                	jns    c04066bd <sglib__vmm_tree_it_init+0x12e>
c04066b0:	8b 44 24 18          	mov    0x18(%esp),%eax
c04066b4:	8b 40 04             	mov    0x4(%eax),%eax
c04066b7:	89 44 24 18          	mov    %eax,0x18(%esp)
c04066bb:	eb 12                	jmp    c04066cf <sglib__vmm_tree_it_init+0x140>
c04066bd:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04066c2:	7e 12                	jle    c04066d6 <sglib__vmm_tree_it_init+0x147>
c04066c4:	8b 44 24 18          	mov    0x18(%esp),%eax
c04066c8:	8b 40 08             	mov    0x8(%eax),%eax
c04066cb:	89 44 24 18          	mov    %eax,0x18(%esp)
c04066cf:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c04066d4:	75 bb                	jne    c0406691 <sglib__vmm_tree_it_init+0x102>
c04066d6:	8b 44 24 18          	mov    0x18(%esp),%eax
c04066da:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04066de:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04066e3:	75 19                	jne    c04066fe <sglib__vmm_tree_it_init+0x16f>
c04066e5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04066e9:	66 c7 80 84 02 00 00 	movw   $0x0,0x284(%eax)
c04066f0:	00 00 
c04066f2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04066f6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
c04066fc:	eb 45                	jmp    c0406743 <sglib__vmm_tree_it_init+0x1b4>
c04066fe:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406702:	66 c7 80 84 02 00 00 	movw   $0x1,0x284(%eax)
c0406709:	01 00 
c040670b:	8b 44 24 30          	mov    0x30(%esp),%eax
c040670f:	c6 40 04 00          	movb   $0x0,0x4(%eax)
c0406713:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406717:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040671b:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
c0406721:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c0406726:	75 0c                	jne    c0406734 <sglib__vmm_tree_it_init+0x1a5>
c0406728:	8b 44 24 30          	mov    0x30(%esp),%eax
c040672c:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0406730:	89 10                	mov    %edx,(%eax)
c0406732:	eb 0f                	jmp    c0406743 <sglib__vmm_tree_it_init+0x1b4>
c0406734:	83 ec 0c             	sub    $0xc,%esp
c0406737:	ff 74 24 3c          	pushl  0x3c(%esp)
c040673b:	e8 d4 fb ff ff       	call   c0406314 <sglib__vmm_tree_it_compute_current_elem>
c0406740:	83 c4 10             	add    $0x10,%esp
c0406743:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406747:	8b 00                	mov    (%eax),%eax
c0406749:	83 c4 2c             	add    $0x2c,%esp
c040674c:	c3                   	ret    

c040674d <sglib_vmm_tree_it_init>:
c040674d:	83 ec 0c             	sub    $0xc,%esp
c0406750:	83 ec 0c             	sub    $0xc,%esp
c0406753:	6a 00                	push   $0x0
c0406755:	6a 00                	push   $0x0
c0406757:	6a 02                	push   $0x2
c0406759:	ff 74 24 2c          	pushl  0x2c(%esp)
c040675d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0406761:	e8 29 fe ff ff       	call   c040658f <sglib__vmm_tree_it_init>
c0406766:	83 c4 20             	add    $0x20,%esp
c0406769:	83 c4 0c             	add    $0xc,%esp
c040676c:	c3                   	ret    

c040676d <sglib_vmm_tree_it_init_preorder>:
c040676d:	83 ec 0c             	sub    $0xc,%esp
c0406770:	83 ec 0c             	sub    $0xc,%esp
c0406773:	6a 00                	push   $0x0
c0406775:	6a 00                	push   $0x0
c0406777:	6a 00                	push   $0x0
c0406779:	ff 74 24 2c          	pushl  0x2c(%esp)
c040677d:	ff 74 24 2c          	pushl  0x2c(%esp)
c0406781:	e8 09 fe ff ff       	call   c040658f <sglib__vmm_tree_it_init>
c0406786:	83 c4 20             	add    $0x20,%esp
c0406789:	83 c4 0c             	add    $0xc,%esp
c040678c:	c3                   	ret    

c040678d <sglib_vmm_tree_it_init_inorder>:
c040678d:	83 ec 0c             	sub    $0xc,%esp
c0406790:	83 ec 0c             	sub    $0xc,%esp
c0406793:	6a 00                	push   $0x0
c0406795:	6a 00                	push   $0x0
c0406797:	6a 01                	push   $0x1
c0406799:	ff 74 24 2c          	pushl  0x2c(%esp)
c040679d:	ff 74 24 2c          	pushl  0x2c(%esp)
c04067a1:	e8 e9 fd ff ff       	call   c040658f <sglib__vmm_tree_it_init>
c04067a6:	83 c4 20             	add    $0x20,%esp
c04067a9:	83 c4 0c             	add    $0xc,%esp
c04067ac:	c3                   	ret    

c04067ad <sglib_vmm_tree_it_init_postorder>:
c04067ad:	83 ec 0c             	sub    $0xc,%esp
c04067b0:	83 ec 0c             	sub    $0xc,%esp
c04067b3:	6a 00                	push   $0x0
c04067b5:	6a 00                	push   $0x0
c04067b7:	6a 02                	push   $0x2
c04067b9:	ff 74 24 2c          	pushl  0x2c(%esp)
c04067bd:	ff 74 24 2c          	pushl  0x2c(%esp)
c04067c1:	e8 c9 fd ff ff       	call   c040658f <sglib__vmm_tree_it_init>
c04067c6:	83 c4 20             	add    $0x20,%esp
c04067c9:	83 c4 0c             	add    $0xc,%esp
c04067cc:	c3                   	ret    

c04067cd <sglib_vmm_tree_it_init_on_equal>:
c04067cd:	83 ec 0c             	sub    $0xc,%esp
c04067d0:	83 ec 0c             	sub    $0xc,%esp
c04067d3:	ff 74 24 28          	pushl  0x28(%esp)
c04067d7:	ff 74 24 28          	pushl  0x28(%esp)
c04067db:	6a 01                	push   $0x1
c04067dd:	ff 74 24 2c          	pushl  0x2c(%esp)
c04067e1:	ff 74 24 2c          	pushl  0x2c(%esp)
c04067e5:	e8 a5 fd ff ff       	call   c040658f <sglib__vmm_tree_it_init>
c04067ea:	83 c4 20             	add    $0x20,%esp
c04067ed:	83 c4 0c             	add    $0xc,%esp
c04067f0:	c3                   	ret    

c04067f1 <sglib_vmm_tree_it_current>:
c04067f1:	8b 44 24 04          	mov    0x4(%esp),%eax
c04067f5:	8b 00                	mov    (%eax),%eax
c04067f7:	c3                   	ret    

c04067f8 <sglib_vmm_tree_it_next>:
c04067f8:	83 ec 0c             	sub    $0xc,%esp
c04067fb:	83 ec 0c             	sub    $0xc,%esp
c04067fe:	ff 74 24 1c          	pushl  0x1c(%esp)
c0406802:	e8 0d fb ff ff       	call   c0406314 <sglib__vmm_tree_it_compute_current_elem>
c0406807:	83 c4 10             	add    $0x10,%esp
c040680a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040680e:	8b 00                	mov    (%eax),%eax
c0406810:	83 c4 0c             	add    $0xc,%esp
c0406813:	c3                   	ret    

c0406814 <sglib___vmm_tree_consistency_check_recursive>:
c0406814:	83 ec 0c             	sub    $0xc,%esp
c0406817:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c040681c:	75 4a                	jne    c0406868 <sglib___vmm_tree_consistency_check_recursive+0x54>
c040681e:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406822:	8b 00                	mov    (%eax),%eax
c0406824:	85 c0                	test   %eax,%eax
c0406826:	79 0f                	jns    c0406837 <sglib___vmm_tree_consistency_check_recursive+0x23>
c0406828:	8b 44 24 14          	mov    0x14(%esp),%eax
c040682c:	8b 54 24 18          	mov    0x18(%esp),%edx
c0406830:	89 10                	mov    %edx,(%eax)
c0406832:	e9 ed 01 00 00       	jmp    c0406a24 <sglib___vmm_tree_consistency_check_recursive+0x210>
c0406837:	8b 44 24 14          	mov    0x14(%esp),%eax
c040683b:	8b 00                	mov    (%eax),%eax
c040683d:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0406841:	0f 84 dd 01 00 00    	je     c0406a24 <sglib___vmm_tree_consistency_check_recursive+0x210>
c0406847:	68 83 03 00 00       	push   $0x383
c040684c:	68 07 c9 40 c0       	push   $0xc040c907
c0406851:	68 07 c9 40 c0       	push   $0xc040c907
c0406856:	68 14 cb 40 c0       	push   $0xc040cb14
c040685b:	e8 03 51 00 00       	call   c040b963 <debug_assert>
c0406860:	83 c4 10             	add    $0x10,%esp
c0406863:	e9 bc 01 00 00       	jmp    c0406a24 <sglib___vmm_tree_consistency_check_recursive+0x210>
c0406868:	8b 44 24 10          	mov    0x10(%esp),%eax
c040686c:	8b 40 04             	mov    0x4(%eax),%eax
c040686f:	85 c0                	test   %eax,%eax
c0406871:	74 5a                	je     c04068cd <sglib___vmm_tree_consistency_check_recursive+0xb9>
c0406873:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406877:	8b 40 04             	mov    0x4(%eax),%eax
c040687a:	8b 00                	mov    (%eax),%eax
c040687c:	8b 50 08             	mov    0x8(%eax),%edx
c040687f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406883:	8b 00                	mov    (%eax),%eax
c0406885:	8b 40 08             	mov    0x8(%eax),%eax
c0406888:	39 c2                	cmp    %eax,%edx
c040688a:	72 41                	jb     c04068cd <sglib___vmm_tree_consistency_check_recursive+0xb9>
c040688c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406890:	8b 40 04             	mov    0x4(%eax),%eax
c0406893:	8b 00                	mov    (%eax),%eax
c0406895:	8b 50 08             	mov    0x8(%eax),%edx
c0406898:	8b 44 24 10          	mov    0x10(%esp),%eax
c040689c:	8b 00                	mov    (%eax),%eax
c040689e:	8b 48 08             	mov    0x8(%eax),%ecx
c04068a1:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068a5:	8b 00                	mov    (%eax),%eax
c04068a7:	8b 40 0c             	mov    0xc(%eax),%eax
c04068aa:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c04068ad:	39 c2                	cmp    %eax,%edx
c04068af:	72 1c                	jb     c04068cd <sglib___vmm_tree_consistency_check_recursive+0xb9>
c04068b1:	68 83 03 00 00       	push   $0x383
c04068b6:	68 07 c9 40 c0       	push   $0xc040c907
c04068bb:	68 07 c9 40 c0       	push   $0xc040c907
c04068c0:	68 27 cb 40 c0       	push   $0xc040cb27
c04068c5:	e8 99 50 00 00       	call   c040b963 <debug_assert>
c04068ca:	83 c4 10             	add    $0x10,%esp
c04068cd:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068d1:	8b 40 08             	mov    0x8(%eax),%eax
c04068d4:	85 c0                	test   %eax,%eax
c04068d6:	74 5d                	je     c0406935 <sglib___vmm_tree_consistency_check_recursive+0x121>
c04068d8:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068dc:	8b 00                	mov    (%eax),%eax
c04068de:	8b 50 08             	mov    0x8(%eax),%edx
c04068e1:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068e5:	8b 40 08             	mov    0x8(%eax),%eax
c04068e8:	8b 00                	mov    (%eax),%eax
c04068ea:	8b 40 08             	mov    0x8(%eax),%eax
c04068ed:	39 c2                	cmp    %eax,%edx
c04068ef:	72 44                	jb     c0406935 <sglib___vmm_tree_consistency_check_recursive+0x121>
c04068f1:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068f5:	8b 00                	mov    (%eax),%eax
c04068f7:	8b 50 08             	mov    0x8(%eax),%edx
c04068fa:	8b 44 24 10          	mov    0x10(%esp),%eax
c04068fe:	8b 40 08             	mov    0x8(%eax),%eax
c0406901:	8b 00                	mov    (%eax),%eax
c0406903:	8b 48 08             	mov    0x8(%eax),%ecx
c0406906:	8b 44 24 10          	mov    0x10(%esp),%eax
c040690a:	8b 40 08             	mov    0x8(%eax),%eax
c040690d:	8b 00                	mov    (%eax),%eax
c040690f:	8b 40 0c             	mov    0xc(%eax),%eax
c0406912:	8d 04 01             	lea    (%ecx,%eax,1),%eax
c0406915:	39 c2                	cmp    %eax,%edx
c0406917:	72 1c                	jb     c0406935 <sglib___vmm_tree_consistency_check_recursive+0x121>
c0406919:	68 83 03 00 00       	push   $0x383
c040691e:	68 07 c9 40 c0       	push   $0xc040c907
c0406923:	68 07 c9 40 c0       	push   $0xc040c907
c0406928:	68 44 cb 40 c0       	push   $0xc040cb44
c040692d:	e8 31 50 00 00       	call   c040b963 <debug_assert>
c0406932:	83 c4 10             	add    $0x10,%esp
c0406935:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406939:	8a 40 0c             	mov    0xc(%eax),%al
c040693c:	3c 01                	cmp    $0x1,%al
c040693e:	0f 85 a2 00 00 00    	jne    c04069e6 <sglib___vmm_tree_consistency_check_recursive+0x1d2>
c0406944:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406948:	8b 40 04             	mov    0x4(%eax),%eax
c040694b:	85 c0                	test   %eax,%eax
c040694d:	74 2a                	je     c0406979 <sglib___vmm_tree_consistency_check_recursive+0x165>
c040694f:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406953:	8b 40 04             	mov    0x4(%eax),%eax
c0406956:	8a 40 0c             	mov    0xc(%eax),%al
c0406959:	84 c0                	test   %al,%al
c040695b:	74 1c                	je     c0406979 <sglib___vmm_tree_consistency_check_recursive+0x165>
c040695d:	68 83 03 00 00       	push   $0x383
c0406962:	68 07 c9 40 c0       	push   $0xc040c907
c0406967:	68 07 c9 40 c0       	push   $0xc040c907
c040696c:	68 64 cb 40 c0       	push   $0xc040cb64
c0406971:	e8 ed 4f 00 00       	call   c040b963 <debug_assert>
c0406976:	83 c4 10             	add    $0x10,%esp
c0406979:	8b 44 24 10          	mov    0x10(%esp),%eax
c040697d:	8b 40 08             	mov    0x8(%eax),%eax
c0406980:	85 c0                	test   %eax,%eax
c0406982:	74 2a                	je     c04069ae <sglib___vmm_tree_consistency_check_recursive+0x19a>
c0406984:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406988:	8b 40 08             	mov    0x8(%eax),%eax
c040698b:	8a 40 0c             	mov    0xc(%eax),%al
c040698e:	84 c0                	test   %al,%al
c0406990:	74 1c                	je     c04069ae <sglib___vmm_tree_consistency_check_recursive+0x19a>
c0406992:	68 83 03 00 00       	push   $0x383
c0406997:	68 07 c9 40 c0       	push   $0xc040c907
c040699c:	68 07 c9 40 c0       	push   $0xc040c907
c04069a1:	68 a0 cb 40 c0       	push   $0xc040cba0
c04069a6:	e8 b8 4f 00 00       	call   c040b963 <debug_assert>
c04069ab:	83 c4 10             	add    $0x10,%esp
c04069ae:	8b 44 24 10          	mov    0x10(%esp),%eax
c04069b2:	8b 40 04             	mov    0x4(%eax),%eax
c04069b5:	83 ec 04             	sub    $0x4,%esp
c04069b8:	ff 74 24 1c          	pushl  0x1c(%esp)
c04069bc:	ff 74 24 1c          	pushl  0x1c(%esp)
c04069c0:	50                   	push   %eax
c04069c1:	e8 4e fe ff ff       	call   c0406814 <sglib___vmm_tree_consistency_check_recursive>
c04069c6:	83 c4 10             	add    $0x10,%esp
c04069c9:	8b 44 24 10          	mov    0x10(%esp),%eax
c04069cd:	8b 40 08             	mov    0x8(%eax),%eax
c04069d0:	83 ec 04             	sub    $0x4,%esp
c04069d3:	ff 74 24 1c          	pushl  0x1c(%esp)
c04069d7:	ff 74 24 1c          	pushl  0x1c(%esp)
c04069db:	50                   	push   %eax
c04069dc:	e8 33 fe ff ff       	call   c0406814 <sglib___vmm_tree_consistency_check_recursive>
c04069e1:	83 c4 10             	add    $0x10,%esp
c04069e4:	eb 3e                	jmp    c0406a24 <sglib___vmm_tree_consistency_check_recursive+0x210>
c04069e6:	8b 44 24 18          	mov    0x18(%esp),%eax
c04069ea:	8d 50 01             	lea    0x1(%eax),%edx
c04069ed:	8b 44 24 10          	mov    0x10(%esp),%eax
c04069f1:	8b 40 04             	mov    0x4(%eax),%eax
c04069f4:	83 ec 04             	sub    $0x4,%esp
c04069f7:	52                   	push   %edx
c04069f8:	ff 74 24 1c          	pushl  0x1c(%esp)
c04069fc:	50                   	push   %eax
c04069fd:	e8 12 fe ff ff       	call   c0406814 <sglib___vmm_tree_consistency_check_recursive>
c0406a02:	83 c4 10             	add    $0x10,%esp
c0406a05:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406a09:	8d 50 01             	lea    0x1(%eax),%edx
c0406a0c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406a10:	8b 40 08             	mov    0x8(%eax),%eax
c0406a13:	83 ec 04             	sub    $0x4,%esp
c0406a16:	52                   	push   %edx
c0406a17:	ff 74 24 1c          	pushl  0x1c(%esp)
c0406a1b:	50                   	push   %eax
c0406a1c:	e8 f3 fd ff ff       	call   c0406814 <sglib___vmm_tree_consistency_check_recursive>
c0406a21:	83 c4 10             	add    $0x10,%esp
c0406a24:	83 c4 0c             	add    $0xc,%esp
c0406a27:	c3                   	ret    

c0406a28 <sglib___vmm_tree_consistency_check>:
c0406a28:	83 ec 1c             	sub    $0x1c,%esp
c0406a2b:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0406a30:	74 27                	je     c0406a59 <sglib___vmm_tree_consistency_check+0x31>
c0406a32:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406a36:	8a 40 0c             	mov    0xc(%eax),%al
c0406a39:	84 c0                	test   %al,%al
c0406a3b:	74 1c                	je     c0406a59 <sglib___vmm_tree_consistency_check+0x31>
c0406a3d:	68 83 03 00 00       	push   $0x383
c0406a42:	68 07 c9 40 c0       	push   $0xc040c907
c0406a47:	68 07 c9 40 c0       	push   $0xc040c907
c0406a4c:	68 dc cb 40 c0       	push   $0xc040cbdc
c0406a51:	e8 0d 4f 00 00       	call   c040b963 <debug_assert>
c0406a56:	83 c4 10             	add    $0x10,%esp
c0406a59:	c7 44 24 0c ff ff ff 	movl   $0xffffffff,0xc(%esp)
c0406a60:	ff 
c0406a61:	83 ec 04             	sub    $0x4,%esp
c0406a64:	6a 00                	push   $0x0
c0406a66:	8d 44 24 14          	lea    0x14(%esp),%eax
c0406a6a:	50                   	push   %eax
c0406a6b:	ff 74 24 2c          	pushl  0x2c(%esp)
c0406a6f:	e8 a0 fd ff ff       	call   c0406814 <sglib___vmm_tree_consistency_check_recursive>
c0406a74:	83 c4 10             	add    $0x10,%esp
c0406a77:	83 c4 1c             	add    $0x1c,%esp
c0406a7a:	c3                   	ret    

c0406a7b <vmm_link_vma>:
   => proc = process to link the vma with
      vma = the vma to link
   <= success or a failure code
*/
kresult vmm_link_vma(process *proc, vmm_area *vma)
{
c0406a7b:	83 ec 2c             	sub    $0x2c,%esp
	kresult err;
	vmm_tree *new, *existing;
	unsigned int loop;
	
	/* allocate and zero memory for the new tree node */
	err = vmm_malloc((void **)&new, sizeof(vmm_tree));
c0406a7e:	8d 44 24 10          	lea    0x10(%esp),%eax
c0406a82:	83 ec 08             	sub    $0x8,%esp
c0406a85:	6a 10                	push   $0x10
c0406a87:	50                   	push   %eax
c0406a88:	e8 5b d0 ff ff       	call   c0403ae8 <vmm_malloc>
c0406a8d:	83 c4 10             	add    $0x10,%esp
c0406a90:	89 44 24 14          	mov    %eax,0x14(%esp)
	if(err) return err;
c0406a94:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0406a99:	74 09                	je     c0406aa4 <vmm_link_vma+0x29>
c0406a9b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0406a9f:	e9 0f 02 00 00       	jmp    c0406cb3 <vmm_link_vma+0x238>
	vmm_memset(new, 0, sizeof(vmm_tree));
c0406aa4:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406aa8:	83 ec 04             	sub    $0x4,%esp
c0406aab:	6a 10                	push   $0x10
c0406aad:	6a 00                	push   $0x0
c0406aaf:	50                   	push   %eax
c0406ab0:	e8 77 df ff ff       	call   c0404a2c <vmm_memset>
c0406ab5:	83 c4 10             	add    $0x10,%esp
	
	/* set the area pointer */
	new->area = vma;
c0406ab8:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406abc:	8b 54 24 34          	mov    0x34(%esp),%edx
c0406ac0:	89 10                	mov    %edx,(%eax)
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c0406ac2:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406ac6:	83 c0 10             	add    $0x10,%eax
c0406ac9:	83 ec 08             	sub    $0x8,%esp
c0406acc:	6a 01                	push   $0x1
c0406ace:	50                   	push   %eax
c0406acf:	e8 c4 99 ff ff       	call   c0400498 <lock_gate>
c0406ad4:	83 c4 10             	add    $0x10,%esp
	
	/* and try to add to the tree */
	if(sglib_vmm_tree_add_if_not_member(&(proc->mem), new, &existing))
c0406ad7:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406adb:	8b 54 24 30          	mov    0x30(%esp),%edx
c0406adf:	8d 4a 48             	lea    0x48(%edx),%ecx
c0406ae2:	83 ec 04             	sub    $0x4,%esp
c0406ae5:	8d 54 24 10          	lea    0x10(%esp),%edx
c0406ae9:	52                   	push   %edx
c0406aea:	50                   	push   %eax
c0406aeb:	51                   	push   %ecx
c0406aec:	e8 7e f6 ff ff       	call   c040616f <sglib_vmm_tree_add_if_not_member>
c0406af1:	83 c4 10             	add    $0x10,%esp
c0406af4:	85 c0                	test   %eax,%eax
c0406af6:	0f 84 85 01 00 00    	je     c0406c81 <vmm_link_vma+0x206>
	{
		lock_gate(&(vma->lock), LOCK_WRITE);
c0406afc:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b00:	83 c0 14             	add    $0x14,%eax
c0406b03:	83 ec 08             	sub    $0x8,%esp
c0406b06:	6a 01                	push   $0x1
c0406b08:	50                   	push   %eax
c0406b09:	e8 8a 99 ff ff       	call   c0400498 <lock_gate>
c0406b0e:	83 c4 10             	add    $0x10,%esp
		
		/* non-zero return for success, so incremement the refcount */
		vma->refcount++;
c0406b11:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b15:	8b 40 04             	mov    0x4(%eax),%eax
c0406b18:	8d 50 01             	lea    0x1(%eax),%edx
c0406b1b:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b1f:	89 50 04             	mov    %edx,0x4(%eax)
		err = success;
c0406b22:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0406b29:	00 
		
		VMM_DEBUG("[vmm:%i] linked vma %p to process %i (%p) via tree node %p\n",
				  CPU_ID, vma, proc->pid, proc, new);
		
		/* add the vma to the list of users */
		if(vma->refcount > vma->users_max)
c0406b2a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b2e:	8b 50 04             	mov    0x4(%eax),%edx
c0406b31:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b35:	8b 40 24             	mov    0x24(%eax),%eax
c0406b38:	39 c2                	cmp    %eax,%edx
c0406b3a:	0f 86 e0 00 00 00    	jbe    c0406c20 <vmm_link_vma+0x1a5>
		{
			process **new_list;
			
			/* we need to grow the list size */
			unsigned int new_size = vma->users_max * 2;
c0406b40:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b44:	8b 40 24             	mov    0x24(%eax),%eax
c0406b47:	d1 e0                	shl    %eax
c0406b49:	89 44 24 1c          	mov    %eax,0x1c(%esp)
			
			if(vmm_malloc((void **)&new_list, new_size * sizeof(process *)))
c0406b4d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406b51:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0406b58:	8d 44 24 08          	lea    0x8(%esp),%eax
c0406b5c:	83 ec 08             	sub    $0x8,%esp
c0406b5f:	52                   	push   %edx
c0406b60:	50                   	push   %eax
c0406b61:	e8 82 cf ff ff       	call   c0403ae8 <vmm_malloc>
c0406b66:	83 c4 10             	add    $0x10,%esp
c0406b69:	85 c0                	test   %eax,%eax
c0406b6b:	74 4d                	je     c0406bba <vmm_link_vma+0x13f>
			{
				vmm_free(vma);
c0406b6d:	83 ec 0c             	sub    $0xc,%esp
c0406b70:	ff 74 24 40          	pushl  0x40(%esp)
c0406b74:	e8 96 d3 ff ff       	call   c0403f0f <vmm_free>
c0406b79:	83 c4 10             	add    $0x10,%esp
				new->area = NULL; /* FIXME: and unlink from the tree ?? */
c0406b7c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406b80:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
				unlock_gate(&(vma->lock), LOCK_WRITE);
c0406b86:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406b8a:	83 c0 14             	add    $0x14,%eax
c0406b8d:	83 ec 08             	sub    $0x8,%esp
c0406b90:	6a 01                	push   $0x1
c0406b92:	50                   	push   %eax
c0406b93:	e8 7f 9a ff ff       	call   c0400617 <unlock_gate>
c0406b98:	83 c4 10             	add    $0x10,%esp
				unlock_gate(&(proc->lock), LOCK_WRITE);
c0406b9b:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406b9f:	83 c0 10             	add    $0x10,%eax
c0406ba2:	83 ec 08             	sub    $0x8,%esp
c0406ba5:	6a 01                	push   $0x1
c0406ba7:	50                   	push   %eax
c0406ba8:	e8 6a 9a ff ff       	call   c0400617 <unlock_gate>
c0406bad:	83 c4 10             	add    $0x10,%esp
				return e_failure; /* bail out if the malloc failed! */
c0406bb0:	b8 01 00 00 00       	mov    $0x1,%eax
c0406bb5:	e9 f9 00 00 00       	jmp    c0406cb3 <vmm_link_vma+0x238>
			}
			
			vmm_memset(new_list, 0, new_size); /* clean the new list */
c0406bba:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406bbe:	83 ec 04             	sub    $0x4,%esp
c0406bc1:	ff 74 24 20          	pushl  0x20(%esp)
c0406bc5:	6a 00                	push   $0x0
c0406bc7:	50                   	push   %eax
c0406bc8:	e8 5f de ff ff       	call   c0404a2c <vmm_memset>
c0406bcd:	83 c4 10             	add    $0x10,%esp
			
			/* copy over the previous list */
			vmm_memcpy(new_list, vma->users, vma->users_max * sizeof(process *));
c0406bd0:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406bd4:	8b 40 24             	mov    0x24(%eax),%eax
c0406bd7:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c0406bde:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406be2:	8b 50 2c             	mov    0x2c(%eax),%edx
c0406be5:	8b 44 24 08          	mov    0x8(%esp),%eax
c0406be9:	83 ec 04             	sub    $0x4,%esp
c0406bec:	51                   	push   %ecx
c0406bed:	52                   	push   %edx
c0406bee:	50                   	push   %eax
c0406bef:	e8 75 de ff ff       	call   c0404a69 <vmm_memcpy>
c0406bf4:	83 c4 10             	add    $0x10,%esp
			vmm_free(vma->users); /* free the old list */
c0406bf7:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406bfb:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406bfe:	83 ec 0c             	sub    $0xc,%esp
c0406c01:	50                   	push   %eax
c0406c02:	e8 08 d3 ff ff       	call   c0403f0f <vmm_free>
c0406c07:	83 c4 10             	add    $0x10,%esp
			
			/* update the list's accounting */
			vma->users = new_list;
c0406c0a:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406c0e:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c12:	89 50 2c             	mov    %edx,0x2c(%eax)
			vma->users_max = new_size;
c0406c15:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c19:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0406c1d:	89 50 24             	mov    %edx,0x24(%eax)
		}
		
		/* find an empty slot and insert the new user's pointer */
		for(loop = 0; loop < vma->users_max; loop++)
c0406c20:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0406c27:	00 
c0406c28:	eb 33                	jmp    c0406c5d <vmm_link_vma+0x1e2>
			if((vma->users[loop]) == NULL)
c0406c2a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c2e:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406c31:	8b 54 24 18          	mov    0x18(%esp),%edx
c0406c35:	c1 e2 02             	shl    $0x2,%edx
c0406c38:	01 d0                	add    %edx,%eax
c0406c3a:	8b 00                	mov    (%eax),%eax
c0406c3c:	85 c0                	test   %eax,%eax
c0406c3e:	75 19                	jne    c0406c59 <vmm_link_vma+0x1de>
			{
				/* found a free slot */
				vma->users[loop] = proc;
c0406c40:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c44:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406c47:	8b 54 24 18          	mov    0x18(%esp),%edx
c0406c4b:	c1 e2 02             	shl    $0x2,%edx
c0406c4e:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0406c51:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406c55:	89 02                	mov    %eax,(%edx)
				break;
c0406c57:	eb 11                	jmp    c0406c6a <vmm_link_vma+0x1ef>
			vma->users = new_list;
			vma->users_max = new_size;
		}
		
		/* find an empty slot and insert the new user's pointer */
		for(loop = 0; loop < vma->users_max; loop++)
c0406c59:	ff 44 24 18          	incl   0x18(%esp)
c0406c5d:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c61:	8b 40 24             	mov    0x24(%eax),%eax
c0406c64:	3b 44 24 18          	cmp    0x18(%esp),%eax
c0406c68:	77 c0                	ja     c0406c2a <vmm_link_vma+0x1af>
				/* found a free slot */
				vma->users[loop] = proc;
				break;
			}
		
		unlock_gate(&(vma->lock), LOCK_WRITE);
c0406c6a:	8b 44 24 34          	mov    0x34(%esp),%eax
c0406c6e:	83 c0 14             	add    $0x14,%eax
c0406c71:	83 ec 08             	sub    $0x8,%esp
c0406c74:	6a 01                	push   $0x1
c0406c76:	50                   	push   %eax
c0406c77:	e8 9b 99 ff ff       	call   c0400617 <unlock_gate>
c0406c7c:	83 c4 10             	add    $0x10,%esp
c0406c7f:	eb 19                	jmp    c0406c9a <vmm_link_vma+0x21f>
	}
	else
	{
		/* the vma already exists or collides with an area */
		err = e_vma_exists;
c0406c81:	c7 44 24 14 16 00 00 	movl   $0x16,0x14(%esp)
c0406c88:	00 
		vmm_free(new);
c0406c89:	8b 44 24 10          	mov    0x10(%esp),%eax
c0406c8d:	83 ec 0c             	sub    $0xc,%esp
c0406c90:	50                   	push   %eax
c0406c91:	e8 79 d2 ff ff       	call   c0403f0f <vmm_free>
c0406c96:	83 c4 10             	add    $0x10,%esp
		
		VMM_DEBUG("[vmm:%i] couldn't link vma %p to process %i (%p) - collision with vma %p\n", 
c0406c99:	90                   	nop
				  CPU_ID, vma, proc->pid, proc, existing->area);
	}
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0406c9a:	8b 44 24 30          	mov    0x30(%esp),%eax
c0406c9e:	83 c0 10             	add    $0x10,%eax
c0406ca1:	83 ec 08             	sub    $0x8,%esp
c0406ca4:	6a 01                	push   $0x1
c0406ca6:	50                   	push   %eax
c0406ca7:	e8 6b 99 ff ff       	call   c0400617 <unlock_gate>
c0406cac:	83 c4 10             	add    $0x10,%esp
	
	return err;
c0406caf:	8b 44 24 14          	mov    0x14(%esp),%eax
}
c0406cb3:	83 c4 2c             	add    $0x2c,%esp
c0406cb6:	c3                   	ret    

c0406cb7 <vmm_unlink_vma>:
   => owner = process to unlink the vma from
      victim = the vma to unlink
   <= success or a failure code
 */
kresult vmm_unlink_vma(process *owner, vmm_tree *victim)
{
c0406cb7:	83 ec 1c             	sub    $0x1c,%esp
	lock_gate(&(owner->lock), LOCK_WRITE);
c0406cba:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406cbe:	83 c0 10             	add    $0x10,%eax
c0406cc1:	83 ec 08             	sub    $0x8,%esp
c0406cc4:	6a 01                	push   $0x1
c0406cc6:	50                   	push   %eax
c0406cc7:	e8 cc 97 ff ff       	call   c0400498 <lock_gate>
c0406ccc:	83 c4 10             	add    $0x10,%esp
	
	unsigned int loop;
	vmm_area *vma = victim->area;
c0406ccf:	8b 44 24 24          	mov    0x24(%esp),%eax
c0406cd3:	8b 00                	mov    (%eax),%eax
c0406cd5:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	lock_gate(&(vma->lock), LOCK_WRITE);
c0406cd9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406cdd:	83 c0 14             	add    $0x14,%eax
c0406ce0:	83 ec 08             	sub    $0x8,%esp
c0406ce3:	6a 01                	push   $0x1
c0406ce5:	50                   	push   %eax
c0406ce6:	e8 ad 97 ff ff       	call   c0400498 <lock_gate>
c0406ceb:	83 c4 10             	add    $0x10,%esp
	
	/* try to remove from the tree */
	sglib_vmm_tree_delete(&(owner->mem), victim);
c0406cee:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406cf2:	83 c0 48             	add    $0x48,%eax
c0406cf5:	83 ec 08             	sub    $0x8,%esp
c0406cf8:	ff 74 24 2c          	pushl  0x2c(%esp)
c0406cfc:	50                   	push   %eax
c0406cfd:	e8 88 f2 ff ff       	call   c0405f8a <sglib_vmm_tree_delete>
c0406d02:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(owner->lock), LOCK_WRITE);
c0406d05:	8b 44 24 20          	mov    0x20(%esp),%eax
c0406d09:	83 c0 10             	add    $0x10,%eax
c0406d0c:	83 ec 08             	sub    $0x8,%esp
c0406d0f:	6a 01                	push   $0x1
c0406d11:	50                   	push   %eax
c0406d12:	e8 00 99 ff ff       	call   c0400617 <unlock_gate>
c0406d17:	83 c4 10             	add    $0x10,%esp
	
	/* delete from the vma's users list */
	for(loop = 0; loop < vma->refcount; loop++)
c0406d1a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0406d21:	00 
c0406d22:	eb 3f                	jmp    c0406d63 <vmm_unlink_vma+0xac>
	{
		if(vma->users[loop] == owner)
c0406d24:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d28:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406d2b:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406d2f:	c1 e2 02             	shl    $0x2,%edx
c0406d32:	01 d0                	add    %edx,%eax
c0406d34:	8b 00                	mov    (%eax),%eax
c0406d36:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0406d3a:	75 23                	jne    c0406d5f <vmm_unlink_vma+0xa8>
		{
			vma->users[loop] = NULL;
c0406d3c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d40:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406d43:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406d47:	c1 e2 02             	shl    $0x2,%edx
c0406d4a:	01 d0                	add    %edx,%eax
c0406d4c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			vma->users_ptr = loop; /* next free slot is this one */
c0406d52:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d56:	8b 54 24 08          	mov    0x8(%esp),%edx
c0406d5a:	89 50 28             	mov    %edx,0x28(%eax)
			break;
c0406d5d:	eb 11                	jmp    c0406d70 <vmm_unlink_vma+0xb9>
	/* try to remove from the tree */
	sglib_vmm_tree_delete(&(owner->mem), victim);
	unlock_gate(&(owner->lock), LOCK_WRITE);
	
	/* delete from the vma's users list */
	for(loop = 0; loop < vma->refcount; loop++)
c0406d5f:	ff 44 24 08          	incl   0x8(%esp)
c0406d63:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d67:	8b 40 04             	mov    0x4(%eax),%eax
c0406d6a:	3b 44 24 08          	cmp    0x8(%esp),%eax
c0406d6e:	77 b4                	ja     c0406d24 <vmm_unlink_vma+0x6d>
			break;
		}
	}
	
	/* reduce the refcount and free if zero */
	vma->refcount--;
c0406d70:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d74:	8b 40 04             	mov    0x4(%eax),%eax
c0406d77:	8d 50 ff             	lea    -0x1(%eax),%edx
c0406d7a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d7e:	89 50 04             	mov    %edx,0x4(%eax)
	if(!(vma->refcount))
c0406d81:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d85:	8b 40 04             	mov    0x4(%eax),%eax
c0406d88:	85 c0                	test   %eax,%eax
c0406d8a:	75 26                	jne    c0406db2 <vmm_unlink_vma+0xfb>
	{
		unlock_gate(&(vma->lock), LOCK_WRITE | LOCK_SELFDESTRUCT);
c0406d8c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406d90:	83 c0 14             	add    $0x14,%eax
c0406d93:	83 ec 08             	sub    $0x8,%esp
c0406d96:	6a 03                	push   $0x3
c0406d98:	50                   	push   %eax
c0406d99:	e8 79 98 ff ff       	call   c0400617 <unlock_gate>
c0406d9e:	83 c4 10             	add    $0x10,%esp
		vmm_free(vma);
c0406da1:	83 ec 0c             	sub    $0xc,%esp
c0406da4:	ff 74 24 18          	pushl  0x18(%esp)
c0406da8:	e8 62 d1 ff ff       	call   c0403f0f <vmm_free>
c0406dad:	83 c4 10             	add    $0x10,%esp
c0406db0:	eb 15                	jmp    c0406dc7 <vmm_unlink_vma+0x110>
	}
	else
		unlock_gate(&(vma->lock), LOCK_WRITE);
c0406db2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0406db6:	83 c0 14             	add    $0x14,%eax
c0406db9:	83 ec 08             	sub    $0x8,%esp
c0406dbc:	6a 01                	push   $0x1
c0406dbe:	50                   	push   %eax
c0406dbf:	e8 53 98 ff ff       	call   c0400617 <unlock_gate>
c0406dc4:	83 c4 10             	add    $0x10,%esp
		
	VMM_DEBUG("[vmm:%i] unlinked vma %p from tree node %p in process %i (%p)\n",
			  CPU_ID, vma, victim, owner->pid, owner);
	
	return vmm_free(victim);
c0406dc7:	83 ec 0c             	sub    $0xc,%esp
c0406dca:	ff 74 24 30          	pushl  0x30(%esp)
c0406dce:	e8 3c d1 ff ff       	call   c0403f0f <vmm_free>
c0406dd3:	83 c4 10             	add    $0x10,%esp
}
c0406dd6:	83 c4 1c             	add    $0x1c,%esp
c0406dd9:	c3                   	ret    

c0406dda <vmm_add_vma>:
      cookie = a private reference set by the userspace page manager
   <= success or a failure code
*/
kresult vmm_add_vma(process *proc, unsigned int base, unsigned int size,
						  unsigned char flags, unsigned int cookie)
{
c0406dda:	83 ec 2c             	sub    $0x2c,%esp
c0406ddd:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c0406de1:	88 44 24 0c          	mov    %al,0xc(%esp)
	vmm_area *new;
	kresult err = vmm_malloc((void **)&new, sizeof(vmm_area));
c0406de5:	8d 44 24 18          	lea    0x18(%esp),%eax
c0406de9:	83 ec 08             	sub    $0x8,%esp
c0406dec:	6a 30                	push   $0x30
c0406dee:	50                   	push   %eax
c0406def:	e8 f4 cc ff ff       	call   c0403ae8 <vmm_malloc>
c0406df4:	83 c4 10             	add    $0x10,%esp
c0406df7:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err) return err;
c0406dfb:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0406e00:	74 09                	je     c0406e0b <vmm_add_vma+0x31>
c0406e02:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406e06:	e9 e1 00 00 00       	jmp    c0406eec <vmm_add_vma+0x112>
	vmm_memset(new, 0, sizeof(vmm_area)); /* zero the area */
c0406e0b:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e0f:	83 ec 04             	sub    $0x4,%esp
c0406e12:	6a 30                	push   $0x30
c0406e14:	6a 00                	push   $0x0
c0406e16:	50                   	push   %eax
c0406e17:	e8 10 dc ff ff       	call   c0404a2c <vmm_memset>
c0406e1c:	83 c4 10             	add    $0x10,%esp
	
	/* fill in the details - ref_count will be updated by the link_vma() call */
	new->flags    = flags;
c0406e1f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e23:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c0406e28:	89 10                	mov    %edx,(%eax)
	new->refcount = 0;
c0406e2a:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e2e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
	new->base     = base;
c0406e35:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e39:	8b 54 24 34          	mov    0x34(%esp),%edx
c0406e3d:	89 50 08             	mov    %edx,0x8(%eax)
	new->size     = size;
c0406e40:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e44:	8b 54 24 38          	mov    0x38(%esp),%edx
c0406e48:	89 50 0c             	mov    %edx,0xc(%eax)
	new->token    = cookie;
c0406e4b:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e4f:	8b 54 24 40          	mov    0x40(%esp),%edx
c0406e53:	89 50 10             	mov    %edx,0x10(%eax)
	
	/* set up an empty amortised list of vma users */
	new->users_max = 4;
c0406e56:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e5a:	c7 40 24 04 00 00 00 	movl   $0x4,0x24(%eax)
	err = vmm_malloc((void **)&(new->users), sizeof(process *) * new->users_max);
c0406e61:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e65:	8b 40 24             	mov    0x24(%eax),%eax
c0406e68:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0406e6f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e73:	83 c0 2c             	add    $0x2c,%eax
c0406e76:	83 ec 08             	sub    $0x8,%esp
c0406e79:	52                   	push   %edx
c0406e7a:	50                   	push   %eax
c0406e7b:	e8 68 cc ff ff       	call   c0403ae8 <vmm_malloc>
c0406e80:	83 c4 10             	add    $0x10,%esp
c0406e83:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c0406e87:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0406e8c:	74 16                	je     c0406ea4 <vmm_add_vma+0xca>
	{
		vmm_free(new);
c0406e8e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406e92:	83 ec 0c             	sub    $0xc,%esp
c0406e95:	50                   	push   %eax
c0406e96:	e8 74 d0 ff ff       	call   c0403f0f <vmm_free>
c0406e9b:	83 c4 10             	add    $0x10,%esp
		return err;
c0406e9e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0406ea2:	eb 48                	jmp    c0406eec <vmm_add_vma+0x112>
	}
	vmm_memset(new->users, 0, sizeof(process *) * new->users_max); /* zero the list */
c0406ea4:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406ea8:	8b 40 24             	mov    0x24(%eax),%eax
c0406eab:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0406eb2:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406eb6:	8b 40 2c             	mov    0x2c(%eax),%eax
c0406eb9:	83 ec 04             	sub    $0x4,%esp
c0406ebc:	52                   	push   %edx
c0406ebd:	6a 00                	push   $0x0
c0406ebf:	50                   	push   %eax
c0406ec0:	e8 67 db ff ff       	call   c0404a2c <vmm_memset>
c0406ec5:	83 c4 10             	add    $0x10,%esp
	
	VMM_DEBUG("[vmm:%i] created vma %p for proc %i (%p): base %x size %i flags %x cookie %x\n",
			  CPU_ID, new, proc->pid, proc, base, size, flags, cookie);
	
	if(vmm_link_vma(proc, new))
c0406ec8:	8b 44 24 18          	mov    0x18(%esp),%eax
c0406ecc:	83 ec 08             	sub    $0x8,%esp
c0406ecf:	50                   	push   %eax
c0406ed0:	ff 74 24 3c          	pushl  0x3c(%esp)
c0406ed4:	e8 a2 fb ff ff       	call   c0406a7b <vmm_link_vma>
c0406ed9:	83 c4 10             	add    $0x10,%esp
c0406edc:	85 c0                	test   %eax,%eax
c0406ede:	74 07                	je     c0406ee7 <vmm_add_vma+0x10d>
		return e_failure;
c0406ee0:	b8 01 00 00 00       	mov    $0x1,%eax
c0406ee5:	eb 05                	jmp    c0406eec <vmm_add_vma+0x112>
	else
		return success;
c0406ee7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0406eec:	83 c4 2c             	add    $0x2c,%esp
c0406eef:	c3                   	ret    

c0406ef0 <vmm_duplicate_vmas>:
   => new = child process
      source = parent process to clone from
   <= success or a failure code
*/
kresult vmm_duplicate_vmas(process *new, process *source)
{
c0406ef0:	81 ec ac 02 00 00    	sub    $0x2ac,%esp
	kresult err;
	struct vmm_tree *node;
	struct sglib_vmm_tree_iterator state;
	
	if(!source) return e_failure;
c0406ef6:	83 bc 24 b4 02 00 00 	cmpl   $0x0,0x2b4(%esp)
c0406efd:	00 
c0406efe:	75 0a                	jne    c0406f0a <vmm_duplicate_vmas+0x1a>
c0406f00:	b8 01 00 00 00       	mov    $0x1,%eax
c0406f05:	e9 ac 00 00 00       	jmp    c0406fb6 <vmm_duplicate_vmas+0xc6>

	VMM_DEBUG("[vmm:%i] duplicating process map for proc %i (%p) from %i (%p)\n",
			  CPU_ID, new->pid, new, source->pid, source);
	
	lock_gate(&(source->lock), LOCK_READ);
c0406f0a:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c0406f11:	83 c0 10             	add    $0x10,%eax
c0406f14:	83 ec 08             	sub    $0x8,%esp
c0406f17:	6a 00                	push   $0x0
c0406f19:	50                   	push   %eax
c0406f1a:	e8 79 95 ff ff       	call   c0400498 <lock_gate>
c0406f1f:	83 c4 10             	add    $0x10,%esp
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
c0406f22:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c0406f29:	8b 40 48             	mov    0x48(%eax),%eax
c0406f2c:	83 ec 08             	sub    $0x8,%esp
c0406f2f:	50                   	push   %eax
c0406f30:	8d 44 24 14          	lea    0x14(%esp),%eax
c0406f34:	50                   	push   %eax
c0406f35:	e8 13 f8 ff ff       	call   c040674d <sglib_vmm_tree_it_init>
c0406f3a:	83 c4 10             	add    $0x10,%esp
c0406f3d:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
c0406f44:	eb 44                	jmp    c0406f8a <vmm_duplicate_vmas+0x9a>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_link_vma(new, node->area);
c0406f46:	8b 84 24 9c 02 00 00 	mov    0x29c(%esp),%eax
c0406f4d:	8b 00                	mov    (%eax),%eax
c0406f4f:	83 ec 08             	sub    $0x8,%esp
c0406f52:	50                   	push   %eax
c0406f53:	ff b4 24 bc 02 00 00 	pushl  0x2bc(%esp)
c0406f5a:	e8 1c fb ff ff       	call   c0406a7b <vmm_link_vma>
c0406f5f:	83 c4 10             	add    $0x10,%esp
c0406f62:	89 84 24 98 02 00 00 	mov    %eax,0x298(%esp)
		if(err != success) break;
c0406f69:	83 bc 24 98 02 00 00 	cmpl   $0x0,0x298(%esp)
c0406f70:	00 
c0406f71:	75 23                	jne    c0406f96 <vmm_duplicate_vmas+0xa6>
	lock_gate(&(source->lock), LOCK_READ);
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
c0406f73:	83 ec 0c             	sub    $0xc,%esp
c0406f76:	8d 44 24 14          	lea    0x14(%esp),%eax
c0406f7a:	50                   	push   %eax
c0406f7b:	e8 78 f8 ff ff       	call   c04067f8 <sglib_vmm_tree_it_next>
c0406f80:	83 c4 10             	add    $0x10,%esp
c0406f83:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
			  CPU_ID, new->pid, new, source->pid, source);
	
	lock_gate(&(source->lock), LOCK_READ);
	
	/* walk the parent's tree and copy it */
	for(node = sglib_vmm_tree_it_init(&state, source->mem);
c0406f8a:	83 bc 24 9c 02 00 00 	cmpl   $0x0,0x29c(%esp)
c0406f91:	00 
c0406f92:	75 b2                	jne    c0406f46 <vmm_duplicate_vmas+0x56>
c0406f94:	eb 01                	jmp    c0406f97 <vmm_duplicate_vmas+0xa7>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_link_vma(new, node->area);
		if(err != success) break;
c0406f96:	90                   	nop
	}
	
	unlock_gate(&(source->lock), LOCK_READ);
c0406f97:	8b 84 24 b4 02 00 00 	mov    0x2b4(%esp),%eax
c0406f9e:	83 c0 10             	add    $0x10,%eax
c0406fa1:	83 ec 08             	sub    $0x8,%esp
c0406fa4:	6a 00                	push   $0x0
c0406fa6:	50                   	push   %eax
c0406fa7:	e8 6b 96 ff ff       	call   c0400617 <unlock_gate>
c0406fac:	83 c4 10             	add    $0x10,%esp
	
	return err;
c0406faf:	8b 84 24 98 02 00 00 	mov    0x298(%esp),%eax
}
c0406fb6:	81 c4 ac 02 00 00    	add    $0x2ac,%esp
c0406fbc:	c3                   	ret    

c0406fbd <vmm_destroy_vmas>:

/* vmm_destroy_vmas
	Tear down the given process's memory tree
   <= success or a failure code */
kresult vmm_destroy_vmas(process *victim)
{
c0406fbd:	81 ec ac 02 00 00    	sub    $0x2ac,%esp
	kresult err;
	struct vmm_tree *node;
	struct sglib_vmm_tree_iterator state;	
	
	lock_gate(&(victim->lock), LOCK_WRITE);
c0406fc3:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c0406fca:	83 c0 10             	add    $0x10,%eax
c0406fcd:	83 ec 08             	sub    $0x8,%esp
c0406fd0:	6a 01                	push   $0x1
c0406fd2:	50                   	push   %eax
c0406fd3:	e8 c0 94 ff ff       	call   c0400498 <lock_gate>
c0406fd8:	83 c4 10             	add    $0x10,%esp
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
c0406fdb:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c0406fe2:	8b 40 48             	mov    0x48(%eax),%eax
c0406fe5:	83 ec 08             	sub    $0x8,%esp
c0406fe8:	50                   	push   %eax
c0406fe9:	8d 44 24 14          	lea    0x14(%esp),%eax
c0406fed:	50                   	push   %eax
c0406fee:	e8 5a f7 ff ff       	call   c040674d <sglib_vmm_tree_it_init>
c0406ff3:	83 c4 10             	add    $0x10,%esp
c0406ff6:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
c0406ffd:	eb 41                	jmp    c0407040 <vmm_destroy_vmas+0x83>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_unlink_vma(victim, node);
c0406fff:	83 ec 08             	sub    $0x8,%esp
c0407002:	ff b4 24 a4 02 00 00 	pushl  0x2a4(%esp)
c0407009:	ff b4 24 bc 02 00 00 	pushl  0x2bc(%esp)
c0407010:	e8 a2 fc ff ff       	call   c0406cb7 <vmm_unlink_vma>
c0407015:	83 c4 10             	add    $0x10,%esp
c0407018:	89 84 24 98 02 00 00 	mov    %eax,0x298(%esp)
		if(err != success) break;
c040701f:	83 bc 24 98 02 00 00 	cmpl   $0x0,0x298(%esp)
c0407026:	00 
c0407027:	75 23                	jne    c040704c <vmm_destroy_vmas+0x8f>
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
c0407029:	83 ec 0c             	sub    $0xc,%esp
c040702c:	8d 44 24 14          	lea    0x14(%esp),%eax
c0407030:	50                   	push   %eax
c0407031:	e8 c2 f7 ff ff       	call   c04067f8 <sglib_vmm_tree_it_next>
c0407036:	83 c4 10             	add    $0x10,%esp
c0407039:	89 84 24 9c 02 00 00 	mov    %eax,0x29c(%esp)
	struct sglib_vmm_tree_iterator state;	
	
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	/* walk the victim's tree, unlink and free the nodes */
	for(node = sglib_vmm_tree_it_init(&state, victim->mem);
c0407040:	83 bc 24 9c 02 00 00 	cmpl   $0x0,0x29c(%esp)
c0407047:	00 
c0407048:	75 b5                	jne    c0406fff <vmm_destroy_vmas+0x42>
c040704a:	eb 01                	jmp    c040704d <vmm_destroy_vmas+0x90>
		 node != NULL;
		 node = sglib_vmm_tree_it_next(&state))
	{
		err = vmm_unlink_vma(victim, node);
		if(err != success) break;
c040704c:	90                   	nop
	}
	
	victim->mem = NULL;
c040704d:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c0407054:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
	
	unlock_gate(&(victim->lock), LOCK_WRITE);
c040705b:	8b 84 24 b0 02 00 00 	mov    0x2b0(%esp),%eax
c0407062:	83 c0 10             	add    $0x10,%eax
c0407065:	83 ec 08             	sub    $0x8,%esp
c0407068:	6a 01                	push   $0x1
c040706a:	50                   	push   %eax
c040706b:	e8 a7 95 ff ff       	call   c0400617 <unlock_gate>
c0407070:	83 c4 10             	add    $0x10,%esp
	return err;
c0407073:	8b 84 24 98 02 00 00 	mov    0x298(%esp),%eax
}
c040707a:	81 c4 ac 02 00 00    	add    $0x2ac,%esp
c0407080:	c3                   	ret    

c0407081 <vmm_find_vma>:
/* vmm_find_vma
	Locate a vma tree node using the given address in the given proc
   <= pointer to tree node or NULL for not found
*/
vmm_tree *vmm_find_vma(process *proc, unsigned int addr)
{
c0407081:	83 ec 5c             	sub    $0x5c,%esp
	vmm_tree node;
	vmm_area area;
	vmm_tree *result;
	
	/* give up now if we're given rubbish pointers */
	if(!proc) return NULL;
c0407084:	83 7c 24 60 00       	cmpl   $0x0,0x60(%esp)
c0407089:	75 07                	jne    c0407092 <vmm_find_vma+0x11>
c040708b:	b8 00 00 00 00       	mov    $0x0,%eax
c0407090:	eb 62                	jmp    c04070f4 <vmm_find_vma+0x73>

	/* mock up a vma and node to search for */
	area.base = addr;
c0407092:	8b 44 24 64          	mov    0x64(%esp),%eax
c0407096:	89 44 24 14          	mov    %eax,0x14(%esp)
	area.size = 1;
c040709a:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
c04070a1:	00 
	node.area = &area;
c04070a2:	8d 44 24 0c          	lea    0xc(%esp),%eax
c04070a6:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	
	lock_gate(&(proc->lock), LOCK_READ);
c04070aa:	8b 44 24 60          	mov    0x60(%esp),%eax
c04070ae:	83 c0 10             	add    $0x10,%eax
c04070b1:	83 ec 08             	sub    $0x8,%esp
c04070b4:	6a 00                	push   $0x0
c04070b6:	50                   	push   %eax
c04070b7:	e8 dc 93 ff ff       	call   c0400498 <lock_gate>
c04070bc:	83 c4 10             	add    $0x10,%esp
	result = sglib_vmm_tree_find_member(proc->mem, &node);
c04070bf:	8b 44 24 60          	mov    0x60(%esp),%eax
c04070c3:	8b 40 48             	mov    0x48(%eax),%eax
c04070c6:	83 ec 08             	sub    $0x8,%esp
c04070c9:	8d 54 24 44          	lea    0x44(%esp),%edx
c04070cd:	52                   	push   %edx
c04070ce:	50                   	push   %eax
c04070cf:	e8 e4 ee ff ff       	call   c0405fb8 <sglib_vmm_tree_find_member>
c04070d4:	83 c4 10             	add    $0x10,%esp
c04070d7:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	unlock_gate(&(proc->lock), LOCK_READ);
c04070db:	8b 44 24 60          	mov    0x60(%esp),%eax
c04070df:	83 c0 10             	add    $0x10,%eax
c04070e2:	83 ec 08             	sub    $0x8,%esp
c04070e5:	6a 00                	push   $0x0
c04070e7:	50                   	push   %eax
c04070e8:	e8 2a 95 ff ff       	call   c0400617 <unlock_gate>
c04070ed:	83 c4 10             	add    $0x10,%esp
	
	return result;
c04070f0:	8b 44 24 4c          	mov    0x4c(%esp),%eax
}
c04070f4:	83 c4 5c             	add    $0x5c,%esp
c04070f7:	c3                   	ret    

c04070f8 <vmm_fault>:
      addr = virtual address where fault occurred
      flags = type of access attempted using the vma_area flags 
   <= decision code
*/
vmm_decision vmm_fault(process *proc, unsigned int addr, unsigned char flags)
{
c04070f8:	83 ec 3c             	sub    $0x3c,%esp
c04070fb:	8b 44 24 48          	mov    0x48(%esp),%eax
c04070ff:	88 44 24 0c          	mov    %al,0xc(%esp)
	lock_gate(&(proc->lock), LOCK_READ);
c0407103:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407107:	83 c0 10             	add    $0x10,%eax
c040710a:	83 ec 08             	sub    $0x8,%esp
c040710d:	6a 00                	push   $0x0
c040710f:	50                   	push   %eax
c0407110:	e8 83 93 ff ff       	call   c0400498 <lock_gate>
c0407115:	83 c4 10             	add    $0x10,%esp
	
	vmm_area *vma;
	vmm_tree *found = vmm_find_vma(proc, addr);
c0407118:	83 ec 08             	sub    $0x8,%esp
c040711b:	ff 74 24 4c          	pushl  0x4c(%esp)
c040711f:	ff 74 24 4c          	pushl  0x4c(%esp)
c0407123:	e8 59 ff ff ff       	call   c0407081 <vmm_find_vma>
c0407128:	83 c4 10             	add    $0x10,%esp
c040712b:	89 44 24 20          	mov    %eax,0x20(%esp)

	if(!found) return badaccess; /* no vma means no possible access */
c040712f:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0407134:	75 0a                	jne    c0407140 <vmm_fault+0x48>
c0407136:	b8 04 00 00 00       	mov    $0x4,%eax
c040713b:	e9 53 02 00 00       	jmp    c0407393 <vmm_fault+0x29b>
	
	vma = found->area;
c0407140:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407144:	8b 00                	mov    (%eax),%eax
c0407146:	89 44 24 1c          	mov    %eax,0x1c(%esp)

	lock_gate(&(vma->lock), LOCK_READ);
c040714a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040714e:	83 c0 14             	add    $0x14,%eax
c0407151:	83 ec 08             	sub    $0x8,%esp
c0407154:	6a 00                	push   $0x0
c0407156:	50                   	push   %eax
c0407157:	e8 3c 93 ff ff       	call   c0400498 <lock_gate>
c040715c:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(proc->lock), LOCK_READ);
c040715f:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407163:	83 c0 10             	add    $0x10,%eax
c0407166:	83 ec 08             	sub    $0x8,%esp
c0407169:	6a 00                	push   $0x0
c040716b:	50                   	push   %eax
c040716c:	e8 a6 94 ff ff       	call   c0400617 <unlock_gate>
c0407171:	83 c4 10             	add    $0x10,%esp
	
	VMM_DEBUG("[vmm:%i] fault at %x lies within vma %p (base %x size %i) in process %i\n",
			  CPU_ID, addr, vma, vma->base, vma->size, proc->pid);
	
	/* fail this access if it's a write to a non-writeable area */
	if((flags & VMA_WRITEABLE) && !(vma->flags & VMA_WRITEABLE))
c0407174:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c0407179:	83 e0 01             	and    $0x1,%eax
c040717c:	84 c0                	test   %al,%al
c040717e:	74 2c                	je     c04071ac <vmm_fault+0xb4>
c0407180:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407184:	8b 00                	mov    (%eax),%eax
c0407186:	83 e0 01             	and    $0x1,%eax
c0407189:	85 c0                	test   %eax,%eax
c040718b:	75 1f                	jne    c04071ac <vmm_fault+0xb4>
	{
		unlock_gate(&(vma->lock), LOCK_READ);
c040718d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407191:	83 c0 14             	add    $0x14,%eax
c0407194:	83 ec 08             	sub    $0x8,%esp
c0407197:	6a 00                	push   $0x0
c0407199:	50                   	push   %eax
c040719a:	e8 78 94 ff ff       	call   c0400617 <unlock_gate>
c040719f:	83 c4 10             	add    $0x10,%esp
		return badaccess;
c04071a2:	b8 04 00 00 00       	mov    $0x4,%eax
c04071a7:	e9 e7 01 00 00       	jmp    c0407393 <vmm_fault+0x29b>
	}

	/* defer to the userspace page manager if it is managing this vma */
	if(!(vma->flags & VMA_MEMSOURCE))
c04071ac:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04071b0:	8b 00                	mov    (%eax),%eax
c04071b2:	83 e0 02             	and    $0x2,%eax
c04071b5:	85 c0                	test   %eax,%eax
c04071b7:	75 1f                	jne    c04071d8 <vmm_fault+0xe0>
	{
		unlock_gate(&(vma->lock), LOCK_READ);
c04071b9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04071bd:	83 c0 14             	add    $0x14,%eax
c04071c0:	83 ec 08             	sub    $0x8,%esp
c04071c3:	6a 00                	push   $0x0
c04071c5:	50                   	push   %eax
c04071c6:	e8 4c 94 ff ff       	call   c0400617 <unlock_gate>
c04071cb:	83 c4 10             	add    $0x10,%esp
		return external;
c04071ce:	b8 03 00 00 00       	mov    $0x3,%eax
c04071d3:	e9 bb 01 00 00       	jmp    c0407393 <vmm_fault+0x29b>
	}
	
	/* if it's a linked vma then now's time to copy the page so this
	   process can have its own private copy */
	if(vma->refcount > 1)
c04071d8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04071dc:	8b 40 04             	mov    0x4(%eax),%eax
c04071df:	83 f8 01             	cmp    $0x1,%eax
c04071e2:	0f 86 45 01 00 00    	jbe    c040732d <vmm_fault+0x235>
	{
		unsigned int loop, loopmax, thisphys, phys;
		process *search;
		
		/* if there's nothing to copy, then have a new private blank page */
		if(!(flags & VMA_HASPHYS))
c04071e8:	8a 44 24 0c          	mov    0xc(%esp),%al
c04071ec:	84 c0                	test   %al,%al
c04071ee:	78 1f                	js     c040720f <vmm_fault+0x117>
		{
			unlock_gate(&(vma->lock), LOCK_READ);
c04071f0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04071f4:	83 c0 14             	add    $0x14,%eax
c04071f7:	83 ec 08             	sub    $0x8,%esp
c04071fa:	6a 00                	push   $0x0
c04071fc:	50                   	push   %eax
c04071fd:	e8 15 94 ff ff       	call   c0400617 <unlock_gate>
c0407202:	83 c4 10             	add    $0x10,%esp
			return newpage;
c0407205:	b8 02 00 00 00       	mov    $0x2,%eax
c040720a:	e9 84 01 00 00       	jmp    c0407393 <vmm_fault+0x29b>
		}
		
		/* to avoid leaking a page of phys mem, only clone if there are two
		   or more processes (including this one) sharing one physical page */
		if(pg_user2phys(&thisphys, proc->pgdir, addr))
c040720f:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407213:	8b 40 20             	mov    0x20(%eax),%eax
c0407216:	83 ec 04             	sub    $0x4,%esp
c0407219:	ff 74 24 48          	pushl  0x48(%esp)
c040721d:	50                   	push   %eax
c040721e:	8d 44 24 24          	lea    0x24(%esp),%eax
c0407222:	50                   	push   %eax
c0407223:	e8 bd 08 00 00       	call   c0407ae5 <pg_user2phys>
c0407228:	83 c4 10             	add    $0x10,%esp
c040722b:	85 c0                	test   %eax,%eax
c040722d:	74 4d                	je     c040727c <vmm_fault+0x184>
		{
			KOOPS_DEBUG("[vmm:%i] OMGWTF page claimed to have physical memory - but doesn't\n", CPU_ID);
c040722f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0407234:	3c 01                	cmp    $0x1,%al
c0407236:	76 0c                	jbe    c0407244 <vmm_fault+0x14c>
c0407238:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040723d:	8b 00                	mov    (%eax),%eax
c040723f:	c1 e8 18             	shr    $0x18,%eax
c0407242:	eb 08                	jmp    c040724c <vmm_fault+0x154>
c0407244:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0407249:	0f b6 c0             	movzbl %al,%eax
c040724c:	83 ec 08             	sub    $0x8,%esp
c040724f:	50                   	push   %eax
c0407250:	68 0c cc 40 c0       	push   $0xc040cc0c
c0407255:	e8 28 4c 00 00       	call   c040be82 <debug_printf>
c040725a:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(vma->lock), LOCK_READ);
c040725d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407261:	83 c0 14             	add    $0x14,%eax
c0407264:	83 ec 08             	sub    $0x8,%esp
c0407267:	6a 00                	push   $0x0
c0407269:	50                   	push   %eax
c040726a:	e8 a8 93 ff ff       	call   c0400617 <unlock_gate>
c040726f:	83 c4 10             	add    $0x10,%esp
			return badaccess;
c0407272:	b8 04 00 00 00       	mov    $0x4,%eax
c0407277:	e9 17 01 00 00       	jmp    c0407393 <vmm_fault+0x29b>
		}
		
		loopmax = vma->refcount;
c040727c:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407280:	8b 40 04             	mov    0x4(%eax),%eax
c0407283:	89 44 24 28          	mov    %eax,0x28(%esp)
		for(loop = 0; loop < loopmax; loop++)
c0407287:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c040728e:	00 
c040728f:	eb 76                	jmp    c0407307 <vmm_fault+0x20f>
		{
			search = vma->users[loop];
c0407291:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407295:	8b 40 2c             	mov    0x2c(%eax),%eax
c0407298:	8b 54 24 24          	mov    0x24(%esp),%edx
c040729c:	c1 e2 02             	shl    $0x2,%edx
c040729f:	01 d0                	add    %edx,%eax
c04072a1:	8b 00                	mov    (%eax),%eax
c04072a3:	89 44 24 2c          	mov    %eax,0x2c(%esp)
			if(search)
c04072a7:	83 7c 24 2c 00       	cmpl   $0x0,0x2c(%esp)
c04072ac:	74 55                	je     c0407303 <vmm_fault+0x20b>
				/* this process doesn't count in the search */
				if(search != proc)
c04072ae:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04072b2:	3b 44 24 40          	cmp    0x40(%esp),%eax
c04072b6:	74 4b                	je     c0407303 <vmm_fault+0x20b>
					if(pg_user2phys(&phys, search->pgdir, addr) == success)
c04072b8:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c04072bc:	8b 40 20             	mov    0x20(%eax),%eax
c04072bf:	83 ec 04             	sub    $0x4,%esp
c04072c2:	ff 74 24 48          	pushl  0x48(%esp)
c04072c6:	50                   	push   %eax
c04072c7:	8d 44 24 20          	lea    0x20(%esp),%eax
c04072cb:	50                   	push   %eax
c04072cc:	e8 14 08 00 00       	call   c0407ae5 <pg_user2phys>
c04072d1:	83 c4 10             	add    $0x10,%esp
c04072d4:	85 c0                	test   %eax,%eax
c04072d6:	75 2b                	jne    c0407303 <vmm_fault+0x20b>
						if(phys == thisphys)
c04072d8:	8b 54 24 14          	mov    0x14(%esp),%edx
c04072dc:	8b 44 24 18          	mov    0x18(%esp),%eax
c04072e0:	39 c2                	cmp    %eax,%edx
c04072e2:	75 1f                	jne    c0407303 <vmm_fault+0x20b>
						{
							unlock_gate(&(vma->lock), LOCK_READ);
c04072e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04072e8:	83 c0 14             	add    $0x14,%eax
c04072eb:	83 ec 08             	sub    $0x8,%esp
c04072ee:	6a 00                	push   $0x0
c04072f0:	50                   	push   %eax
c04072f1:	e8 21 93 ff ff       	call   c0400617 <unlock_gate>
c04072f6:	83 c4 10             	add    $0x10,%esp
							return clonepage;
c04072f9:	b8 00 00 00 00       	mov    $0x0,%eax
c04072fe:	e9 90 00 00 00       	jmp    c0407393 <vmm_fault+0x29b>
			unlock_gate(&(vma->lock), LOCK_READ);
			return badaccess;
		}
		
		loopmax = vma->refcount;
		for(loop = 0; loop < loopmax; loop++)
c0407303:	ff 44 24 24          	incl   0x24(%esp)
c0407307:	8b 44 24 24          	mov    0x24(%esp),%eax
c040730b:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040730f:	72 80                	jb     c0407291 <vmm_fault+0x199>
							return clonepage;
						}
		}
		
		/* it's writeable, it's present, we're the only ones using it.. */
		unlock_gate(&(vma->lock), LOCK_READ);
c0407311:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407315:	83 c0 14             	add    $0x14,%eax
c0407318:	83 ec 08             	sub    $0x8,%esp
c040731b:	6a 00                	push   $0x0
c040731d:	50                   	push   %eax
c040731e:	e8 f4 92 ff ff       	call   c0400617 <unlock_gate>
c0407323:	83 c4 10             	add    $0x10,%esp
		return makewriteable;
c0407326:	b8 01 00 00 00       	mov    $0x1,%eax
c040732b:	eb 66                	jmp    c0407393 <vmm_fault+0x29b>
	}

	/* if it's single-linked and has its own physical memory and writes are
	   allowed then it's a page left over from a copy-on-write, so just
	   mark it writeable */
	if(vma->refcount == 1)
c040732d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407331:	8b 40 04             	mov    0x4(%eax),%eax
c0407334:	83 f8 01             	cmp    $0x1,%eax
c0407337:	75 40                	jne    c0407379 <vmm_fault+0x281>
	{	
		/* but only if there's physical memory to write onto */
		if(flags & VMA_HASPHYS)
c0407339:	8a 44 24 0c          	mov    0xc(%esp),%al
c040733d:	84 c0                	test   %al,%al
c040733f:	79 1c                	jns    c040735d <vmm_fault+0x265>
		{
			unlock_gate(&(vma->lock), LOCK_READ);
c0407341:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407345:	83 c0 14             	add    $0x14,%eax
c0407348:	83 ec 08             	sub    $0x8,%esp
c040734b:	6a 00                	push   $0x0
c040734d:	50                   	push   %eax
c040734e:	e8 c4 92 ff ff       	call   c0400617 <unlock_gate>
c0407353:	83 c4 10             	add    $0x10,%esp
			return makewriteable;
c0407356:	b8 01 00 00 00       	mov    $0x1,%eax
c040735b:	eb 36                	jmp    c0407393 <vmm_fault+0x29b>
		}
	
		/* but if there's no physical memory and it's single-linked and
		   writes are allowed then allocate some memory for this page */
		unlock_gate(&(vma->lock), LOCK_READ);
c040735d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407361:	83 c0 14             	add    $0x14,%eax
c0407364:	83 ec 08             	sub    $0x8,%esp
c0407367:	6a 00                	push   $0x0
c0407369:	50                   	push   %eax
c040736a:	e8 a8 92 ff ff       	call   c0400617 <unlock_gate>
c040736f:	83 c4 10             	add    $0x10,%esp
		return newpage;
c0407372:	b8 02 00 00 00       	mov    $0x2,%eax
c0407377:	eb 1a                	jmp    c0407393 <vmm_fault+0x29b>
	}

	/* if this access satisfies no other cases then give up and fail it */
	unlock_gate(&(vma->lock), LOCK_READ);
c0407379:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040737d:	83 c0 14             	add    $0x14,%eax
c0407380:	83 ec 08             	sub    $0x8,%esp
c0407383:	6a 00                	push   $0x0
c0407385:	50                   	push   %eax
c0407386:	e8 8c 92 ff ff       	call   c0400617 <unlock_gate>
c040738b:	83 c4 10             	add    $0x10,%esp
	return badaccess;
c040738e:	b8 04 00 00 00       	mov    $0x4,%eax
}
c0407393:	83 c4 3c             	add    $0x3c,%esp
c0407396:	c3                   	ret    
	...

c0407398 <pg_fault>:
   Handle an incoming page fault
   => regs = faulting thread's state
   <= success if the fault was handled or a failure code if it couldn't be
*/
kresult pg_fault(int_registers_block *regs)
{
c0407398:	83 ec 3c             	sub    $0x3c,%esp
	unsigned int *pgtable, pgentry, faultaddr = x86_read_cr2();
c040739b:	e8 4c 94 ff ff       	call   c04007ec <x86_read_cr2>
c04073a0:	89 44 24 14          	mov    %eax,0x14(%esp)
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
c04073a4:	8b 44 24 14          	mov    0x14(%esp),%eax
c04073a8:	c1 e8 16             	shr    $0x16,%eax
c04073ab:	89 44 24 18          	mov    %eax,0x18(%esp)
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
c04073af:	8b 44 24 14          	mov    0x14(%esp),%eax
c04073b3:	c1 e8 0c             	shr    $0xc,%eax
c04073b6:	25 ff 03 00 00       	and    $0x3ff,%eax
c04073bb:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	unsigned char errflags;
	
	/* give up if we're in early system initialisation */
	if(!cpu_table) goto pf_fault_bad;
c04073bf:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c04073c4:	85 c0                	test   %eax,%eax
c04073c6:	0f 84 96 02 00 00    	je     c0407662 <pg_fault+0x2ca>
	if(!(cpu_table[CPU_ID].current)) goto pf_fault_bad;
c04073cc:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c04073d2:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04073d7:	3c 01                	cmp    $0x1,%al
c04073d9:	76 0f                	jbe    c04073ea <pg_fault+0x52>
c04073db:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04073e0:	8b 00                	mov    (%eax),%eax
c04073e2:	c1 e8 18             	shr    $0x18,%eax
c04073e5:	c1 e0 06             	shl    $0x6,%eax
c04073e8:	eb 0b                	jmp    c04073f5 <pg_fault+0x5d>
c04073ea:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04073ef:	0f b6 c0             	movzbl %al,%eax
c04073f2:	c1 e0 06             	shl    $0x6,%eax
c04073f5:	8d 04 02             	lea    (%edx,%eax,1),%eax
c04073f8:	8b 40 04             	mov    0x4(%eax),%eax
c04073fb:	85 c0                	test   %eax,%eax
c04073fd:	0f 84 62 02 00 00    	je     c0407665 <pg_fault+0x2cd>
	
	process *proc = cpu_table[CPU_ID].current->proc;
c0407403:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c0407409:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040740e:	3c 01                	cmp    $0x1,%al
c0407410:	76 0f                	jbe    c0407421 <pg_fault+0x89>
c0407412:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0407417:	8b 00                	mov    (%eax),%eax
c0407419:	c1 e8 18             	shr    $0x18,%eax
c040741c:	c1 e0 06             	shl    $0x6,%eax
c040741f:	eb 0b                	jmp    c040742c <pg_fault+0x94>
c0407421:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0407426:	0f b6 c0             	movzbl %al,%eax
c0407429:	c1 e0 06             	shl    $0x6,%eax
c040742c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040742f:	8b 40 04             	mov    0x4(%eax),%eax
c0407432:	8b 00                	mov    (%eax),%eax
c0407434:	89 44 24 24          	mov    %eax,0x24(%esp)
	
	/* give up if the user process has tried to access kernel memory */
	if((faultaddr >= KERNEL_SPACE_BASE) && (regs->errcode & PG_FAULT_U))
c0407438:	81 7c 24 14 ff ff ff 	cmpl   $0xbfffffff,0x14(%esp)
c040743f:	bf 
c0407440:	76 12                	jbe    c0407454 <pg_fault+0xbc>
c0407442:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407446:	8b 40 28             	mov    0x28(%eax),%eax
c0407449:	83 e0 04             	and    $0x4,%eax
c040744c:	85 c0                	test   %eax,%eax
c040744e:	0f 85 14 02 00 00    	jne    c0407668 <pg_fault+0x2d0>
		goto pf_fault_bad;

	/* look up the entry for this faulting address in the user page tables */
	pgtable = (unsigned int *)((unsigned int)proc->pgdir[pgdir_index] & PG_4K_MASK);
c0407454:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407458:	8b 40 20             	mov    0x20(%eax),%eax
c040745b:	8b 54 24 18          	mov    0x18(%esp),%edx
c040745f:	c1 e2 02             	shl    $0x2,%edx
c0407462:	01 d0                	add    %edx,%eax
c0407464:	8b 00                	mov    (%eax),%eax
c0407466:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c040746b:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(pgtable)
c040746f:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407474:	74 20                	je     c0407496 <pg_fault+0xfe>
	{
		pgtable = KERNEL_PHYS2LOG(pgtable);
c0407476:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040747a:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040747f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		pgentry = pgtable[pgtable_index];
c0407483:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407487:	c1 e0 02             	shl    $0x2,%eax
c040748a:	03 44 24 0c          	add    0xc(%esp),%eax
c040748e:	8b 00                	mov    (%eax),%eax
c0407490:	89 44 24 10          	mov    %eax,0x10(%esp)
c0407494:	eb 08                	jmp    c040749e <pg_fault+0x106>
	}
	else
		pgentry = 0;
c0407496:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c040749d:	00 

	/* inspect the page table flags */
	if(pgentry & PG_EXTERNAL)
c040749e:	8b 44 24 10          	mov    0x10(%esp),%eax
c04074a2:	25 00 02 00 00       	and    $0x200,%eax
c04074a7:	85 c0                	test   %eax,%eax
c04074a9:	0f 85 a8 01 00 00    	jne    c0407657 <pg_fault+0x2bf>
		goto pg_fault_external;
	
	/* convert x86 page fault flags into generic vmm flags */
	if(regs->errcode & PG_FAULT_W)
c04074af:	8b 44 24 40          	mov    0x40(%esp),%eax
c04074b3:	8b 40 28             	mov    0x28(%eax),%eax
c04074b6:	83 e0 02             	and    $0x2,%eax
c04074b9:	85 c0                	test   %eax,%eax
c04074bb:	74 07                	je     c04074c4 <pg_fault+0x12c>
		errflags = VMA_WRITEABLE;
c04074bd:	c6 44 24 23 01       	movb   $0x1,0x23(%esp)
c04074c2:	eb 05                	jmp    c04074c9 <pg_fault+0x131>
	else
		errflags = VMA_READABLE;
c04074c4:	c6 44 24 23 00       	movb   $0x0,0x23(%esp)
	
	/* hint to the vmm that the page already has physical memory */
	if(pgentry & PG_PRESENT)
c04074c9:	8b 44 24 10          	mov    0x10(%esp),%eax
c04074cd:	83 e0 01             	and    $0x1,%eax
c04074d0:	84 c0                	test   %al,%al
c04074d2:	74 05                	je     c04074d9 <pg_fault+0x141>
		errflags |= VMA_HASPHYS;
c04074d4:	80 4c 24 23 80       	orb    $0x80,0x23(%esp)
	
	/* ask the vmm for a decision */
	switch(vmm_fault(proc, faultaddr, errflags))
c04074d9:	0f b6 44 24 23       	movzbl 0x23(%esp),%eax
c04074de:	83 ec 04             	sub    $0x4,%esp
c04074e1:	50                   	push   %eax
c04074e2:	ff 74 24 1c          	pushl  0x1c(%esp)
c04074e6:	ff 74 24 30          	pushl  0x30(%esp)
c04074ea:	e8 09 fc ff ff       	call   c04070f8 <vmm_fault>
c04074ef:	83 c4 10             	add    $0x10,%esp
c04074f2:	83 f8 04             	cmp    $0x4,%eax
c04074f5:	0f 87 70 01 00 00    	ja     c040766b <pg_fault+0x2d3>
c04074fb:	8b 04 85 50 cc 40 c0 	mov    -0x3fbf33b0(,%eax,4),%eax
c0407502:	ff e0                	jmp    *%eax
		case newpage:
			{ 
				unsigned int new_phys;
				
				/* grab a new (blank) physical page */
				if(vmm_req_phys_pg((void **)&new_phys, 1))
c0407504:	8d 44 24 08          	lea    0x8(%esp),%eax
c0407508:	83 ec 08             	sub    $0x8,%esp
c040750b:	6a 01                	push   $0x1
c040750d:	50                   	push   %eax
c040750e:	e8 28 cd ff ff       	call   c040423b <vmm_req_phys_pg>
c0407513:	83 c4 10             	add    $0x10,%esp
c0407516:	85 c0                	test   %eax,%eax
c0407518:	74 0a                	je     c0407524 <pg_fault+0x18c>
					return e_failure; /* bail out if we can't get a phys page */
c040751a:	b8 01 00 00 00       	mov    $0x1,%eax
c040751f:	e9 95 01 00 00       	jmp    c04076b9 <pg_fault+0x321>
				
				/* map this new physical page in, remembering to set write access */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c0407524:	8b 54 24 08          	mov    0x8(%esp),%edx
c0407528:	8b 44 24 14          	mov    0x14(%esp),%eax
c040752c:	89 c1                	mov    %eax,%ecx
c040752e:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0407534:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407538:	8b 40 20             	mov    0x20(%eax),%eax
c040753b:	6a 07                	push   $0x7
c040753d:	52                   	push   %edx
c040753e:	51                   	push   %ecx
c040753f:	50                   	push   %eax
c0407540:	e8 97 06 00 00       	call   c0407bdc <pg_add_4K_mapping>
c0407545:	83 c4 10             	add    $0x10,%esp
										new_phys, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c0407548:	8b 44 24 24          	mov    0x24(%esp),%eax
c040754c:	8b 40 20             	mov    0x20(%eax),%eax
c040754f:	05 00 00 00 40       	add    $0x40000000,%eax
c0407554:	83 ec 0c             	sub    $0xc,%esp
c0407557:	50                   	push   %eax
c0407558:	e8 87 92 ff ff       	call   c04007e4 <x86_load_cr3>
c040755d:	83 c4 10             	add    $0x10,%esp
				
				PAGE_DEBUG("[page:%i] mapped new page for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, new_phys);
			}
			return success;			
c0407560:	b8 00 00 00 00       	mov    $0x0,%eax
c0407565:	e9 4f 01 00 00       	jmp    c04076b9 <pg_fault+0x321>
		case clonepage:
			{
				unsigned int new_phys, new_virt, source_virt;
				
				/* grab a new (blank) physical page */
				if(vmm_req_phys_pg((void **)&new_phys, 1))
c040756a:	8d 44 24 04          	lea    0x4(%esp),%eax
c040756e:	83 ec 08             	sub    $0x8,%esp
c0407571:	6a 01                	push   $0x1
c0407573:	50                   	push   %eax
c0407574:	e8 c2 cc ff ff       	call   c040423b <vmm_req_phys_pg>
c0407579:	83 c4 10             	add    $0x10,%esp
c040757c:	85 c0                	test   %eax,%eax
c040757e:	74 0a                	je     c040758a <pg_fault+0x1f2>
					return e_failure; /* bail out if we can't get a phys page */
c0407580:	b8 01 00 00 00       	mov    $0x1,%eax
c0407585:	e9 2f 01 00 00       	jmp    c04076b9 <pg_fault+0x321>
				
				/* copy physical page to another via kernel virtual addresses */
				new_virt = (unsigned int)KERNEL_PHYS2LOG(new_phys);
c040758a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040758e:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407593:	89 44 24 28          	mov    %eax,0x28(%esp)
				source_virt = (unsigned int)KERNEL_PHYS2LOG(pgentry & PG_4K_MASK);
c0407597:	8b 44 24 10          	mov    0x10(%esp),%eax
c040759b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c04075a0:	2d 00 00 00 40       	sub    $0x40000000,%eax
c04075a5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
				vmm_memcpy((unsigned int *)new_virt, (unsigned int *)source_virt, MEM_PGSIZE);
c04075a9:	8b 54 24 2c          	mov    0x2c(%esp),%edx
c04075ad:	8b 44 24 28          	mov    0x28(%esp),%eax
c04075b1:	83 ec 04             	sub    $0x4,%esp
c04075b4:	68 00 10 00 00       	push   $0x1000
c04075b9:	52                   	push   %edx
c04075ba:	50                   	push   %eax
c04075bb:	e8 a9 d4 ff ff       	call   c0404a69 <vmm_memcpy>
c04075c0:	83 c4 10             	add    $0x10,%esp
				
				/* map this new physical page in, remembering to set write access */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c04075c3:	8b 54 24 04          	mov    0x4(%esp),%edx
c04075c7:	8b 44 24 14          	mov    0x14(%esp),%eax
c04075cb:	89 c1                	mov    %eax,%ecx
c04075cd:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c04075d3:	8b 44 24 24          	mov    0x24(%esp),%eax
c04075d7:	8b 40 20             	mov    0x20(%eax),%eax
c04075da:	6a 07                	push   $0x7
c04075dc:	52                   	push   %edx
c04075dd:	51                   	push   %ecx
c04075de:	50                   	push   %eax
c04075df:	e8 f8 05 00 00       	call   c0407bdc <pg_add_4K_mapping>
c04075e4:	83 c4 10             	add    $0x10,%esp
										new_phys, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c04075e7:	8b 44 24 24          	mov    0x24(%esp),%eax
c04075eb:	8b 40 20             	mov    0x20(%eax),%eax
c04075ee:	05 00 00 00 40       	add    $0x40000000,%eax
c04075f3:	83 ec 0c             	sub    $0xc,%esp
c04075f6:	50                   	push   %eax
c04075f7:	e8 e8 91 ff ff       	call   c04007e4 <x86_load_cr3>
c04075fc:	83 c4 10             	add    $0x10,%esp
				
				PAGE_DEBUG("[page:%i] cloned page for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, new_phys);
			}
			return success;
c04075ff:	b8 00 00 00 00       	mov    $0x0,%eax
c0407604:	e9 b0 00 00 00       	jmp    c04076b9 <pg_fault+0x321>
			
		case makewriteable:
			{				
				/* it's safe to just set write access on this page */
				pg_add_4K_mapping(proc->pgdir, faultaddr & PG_4K_MASK,
c0407609:	8b 44 24 10          	mov    0x10(%esp),%eax
c040760d:	89 c1                	mov    %eax,%ecx
c040760f:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
c0407615:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407619:	89 c2                	mov    %eax,%edx
c040761b:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0407621:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407625:	8b 40 20             	mov    0x20(%eax),%eax
c0407628:	6a 07                	push   $0x7
c040762a:	51                   	push   %ecx
c040762b:	52                   	push   %edx
c040762c:	50                   	push   %eax
c040762d:	e8 aa 05 00 00       	call   c0407bdc <pg_add_4K_mapping>
c0407632:	83 c4 10             	add    $0x10,%esp
										pgentry & PG_4K_MASK, PG_PRESENT | PG_RW | PG_PRIVLVL);
				
				/* tell the processor to reload the page tables */
				x86_load_cr3(KERNEL_LOG2PHYS(proc->pgdir));
c0407635:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407639:	8b 40 20             	mov    0x20(%eax),%eax
c040763c:	05 00 00 00 40       	add    $0x40000000,%eax
c0407641:	83 ec 0c             	sub    $0xc,%esp
c0407644:	50                   	push   %eax
c0407645:	e8 9a 91 ff ff       	call   c04007e4 <x86_load_cr3>
c040764a:	83 c4 10             	add    $0x10,%esp
				
				PAGE_DEBUG("[page:%i] made page writeable for process %i: virtual %x -> physical %x\n",
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, pgentry & PG_4K_MASK);
			}
			return success;
c040764d:	b8 00 00 00 00       	mov    $0x0,%eax
c0407652:	eb 65                	jmp    c04076b9 <pg_fault+0x321>

		case external:
			goto pg_fault_external;
			
		case badaccess:
			PAGE_DEBUG("[page:%i] can't handle fault at %x for process %i\n",
c0407654:	90                   	nop
					  CPU_ID, faultaddr, proc->pid);
			
		default:
			goto pf_fault_bad;
c0407655:	eb 15                	jmp    c040766c <pg_fault+0x2d4>
	else
		pgentry = 0;

	/* inspect the page table flags */
	if(pgentry & PG_EXTERNAL)
		goto pg_fault_external;
c0407657:	90                   	nop
c0407658:	eb 01                	jmp    c040765b <pg_fault+0x2c3>
						  CPU_ID, proc->pid, faultaddr & PG_4K_MASK, pgentry & PG_4K_MASK);
			}
			return success;

		case external:
			goto pg_fault_external;
c040765a:	90                   	nop
	}
	
pg_fault_external:
	PAGE_DEBUG("[page:%i] delegating fault at %x for process %i to userspace page manager\n",
			  CPU_ID, faultaddr, proc->pid);
	return e_failure;
c040765b:	b8 01 00 00 00       	mov    $0x1,%eax
c0407660:	eb 57                	jmp    c04076b9 <pg_fault+0x321>
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned char errflags;
	
	/* give up if we're in early system initialisation */
	if(!cpu_table) goto pf_fault_bad;
c0407662:	90                   	nop
c0407663:	eb 07                	jmp    c040766c <pg_fault+0x2d4>
	if(!(cpu_table[CPU_ID].current)) goto pf_fault_bad;
c0407665:	90                   	nop
c0407666:	eb 04                	jmp    c040766c <pg_fault+0x2d4>
	
	process *proc = cpu_table[CPU_ID].current->proc;
	
	/* give up if the user process has tried to access kernel memory */
	if((faultaddr >= KERNEL_SPACE_BASE) && (regs->errcode & PG_FAULT_U))
		goto pf_fault_bad;
c0407668:	90                   	nop
c0407669:	eb 01                	jmp    c040766c <pg_fault+0x2d4>
		case badaccess:
			PAGE_DEBUG("[page:%i] can't handle fault at %x for process %i\n",
					  CPU_ID, faultaddr, proc->pid);
			
		default:
			goto pf_fault_bad;
c040766b:	90                   	nop
			  CPU_ID, faultaddr, proc->pid);
	return e_failure;
	
pf_fault_bad:
	/* give up if the kernel's faulting */
	if(regs->eip > KERNEL_SPACE_BASE)
c040766c:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407670:	8b 40 2c             	mov    0x2c(%eax),%eax
c0407673:	3d 00 00 00 c0       	cmp    $0xc0000000,%eax
c0407678:	76 3a                	jbe    c04076b4 <pg_fault+0x31c>
	{
		/* dump details about the fault */
		if(!page_fatal_flag)
c040767a:	a0 08 1d 41 c0       	mov    0xc0411d08,%al
c040767f:	84 c0                	test   %al,%al
c0407681:	75 2e                	jne    c04076b1 <pg_fault+0x319>
		{
			page_fatal_flag = 1;
c0407683:	c6 05 08 1d 41 c0 01 	movb   $0x1,0xc0411d08
			pg_postmortem(regs);
c040768a:	83 ec 0c             	sub    $0xc,%esp
c040768d:	ff 74 24 4c          	pushl  0x4c(%esp)
c0407691:	e8 44 09 00 00       	call   c0407fda <pg_postmortem>
c0407696:	83 c4 10             	add    $0x10,%esp
			pg_dump_pagedir((unsigned int *)(proc->pgdir));
c0407699:	8b 44 24 24          	mov    0x24(%esp),%eax
c040769d:	8b 40 20             	mov    0x20(%eax),%eax
c04076a0:	83 ec 0c             	sub    $0xc,%esp
c04076a3:	50                   	push   %eax
c04076a4:	e8 03 09 00 00       	call   c0407fac <pg_dump_pagedir>
c04076a9:	83 c4 10             	add    $0x10,%esp
			debug_stacktrace();
c04076ac:	e8 c2 40 00 00       	call   c040b773 <debug_stacktrace>
		}
		PAGE_DEBUG("\n*** panic: unhandled serious fault in the kernel. halting.\n");
c04076b1:	90                   	nop
		while(1);
c04076b2:	eb fe                	jmp    c04076b2 <pg_fault+0x31a>
	}	
	
	/* or signal that the process has made a run-time error */
	return e_failure;
c04076b4:	b8 01 00 00 00       	mov    $0x1,%eax
}
c04076b9:	83 c4 3c             	add    $0x3c,%esp
c04076bc:	c3                   	ret    

c04076bd <pg_clone_pgdir>:
   maintaining links to read-only data and 
   => source = pointer to page directory array for the pgdir we want to clone
   <= returns pointer to new page directory array, or NULL for failure
 */
unsigned int **pg_clone_pgdir(unsigned int **source)
{
c04076bd:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int loop;
	unsigned int **new = NULL;
c04076c0:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c04076c7:	00 

	/* ask the vmm for a physical page */
	if(vmm_req_phys_pg((void **)&new, 1))
c04076c8:	8d 44 24 0c          	lea    0xc(%esp),%eax
c04076cc:	83 ec 08             	sub    $0x8,%esp
c04076cf:	6a 01                	push   $0x1
c04076d1:	50                   	push   %eax
c04076d2:	e8 64 cb ff ff       	call   c040423b <vmm_req_phys_pg>
c04076d7:	83 c4 10             	add    $0x10,%esp
c04076da:	85 c0                	test   %eax,%eax
c04076dc:	74 0a                	je     c04076e8 <pg_clone_pgdir+0x2b>
		return NULL; /* bail out if we can't get a phys page */
c04076de:	b8 00 00 00 00       	mov    $0x0,%eax
c04076e3:	e9 8a 01 00 00       	jmp    c0407872 <pg_clone_pgdir+0x1b5>
	
	new = (unsigned int **)KERNEL_PHYS2LOG(new);
c04076e8:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04076ec:	2d 00 00 00 40       	sub    $0x40000000,%eax
c04076f1:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* link the kernelspace mappings */
	for(loop = (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop < 1024; loop++)
c04076f5:	c7 44 24 10 00 03 00 	movl   $0x300,0x10(%esp)
c04076fc:	00 
c04076fd:	eb 21                	jmp    c0407720 <pg_clone_pgdir+0x63>
		new[loop] = source[loop];
c04076ff:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407703:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407707:	c1 e2 02             	shl    $0x2,%edx
c040770a:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040770d:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407711:	c1 e0 02             	shl    $0x2,%eax
c0407714:	03 44 24 30          	add    0x30(%esp),%eax
c0407718:	8b 00                	mov    (%eax),%eax
c040771a:	89 02                	mov    %eax,(%edx)
		return NULL; /* bail out if we can't get a phys page */
	
	new = (unsigned int **)KERNEL_PHYS2LOG(new);
	
	/* link the kernelspace mappings */
	for(loop = (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop < 1024; loop++)
c040771c:	ff 44 24 10          	incl   0x10(%esp)
c0407720:	81 7c 24 10 ff 03 00 	cmpl   $0x3ff,0x10(%esp)
c0407727:	00 
c0407728:	76 d5                	jbe    c04076ff <pg_clone_pgdir+0x42>
	
	/* link read-only user areas, link r/w user areas but mark them
	    to copy-on-write and disable the write bit - we'll fault on
	    write and then the fault handler can demand copy the pages.
	    also, it's assumed all userspace pages are handled as 4K entries */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c040772a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c0407731:	00 
c0407732:	e9 29 01 00 00       	jmp    c0407860 <pg_clone_pgdir+0x1a3>
	{
		if(source[loop])
c0407737:	8b 44 24 10          	mov    0x10(%esp),%eax
c040773b:	c1 e0 02             	shl    $0x2,%eax
c040773e:	03 44 24 30          	add    0x30(%esp),%eax
c0407742:	8b 00                	mov    (%eax),%eax
c0407744:	85 c0                	test   %eax,%eax
c0407746:	0f 84 fd 00 00 00    	je     c0407849 <pg_clone_pgdir+0x18c>
		{
			unsigned *pgtable_phys, *pgtable, *src_table = source[loop];
c040774c:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407750:	c1 e0 02             	shl    $0x2,%eax
c0407753:	03 44 24 30          	add    0x30(%esp),%eax
c0407757:	8b 00                	mov    (%eax),%eax
c0407759:	89 44 24 18          	mov    %eax,0x18(%esp)
			unsigned int page;
			
			/* make a new copy of the page table */
			if(vmm_req_phys_pg((void **)&pgtable_phys, 1))
c040775d:	8d 44 24 08          	lea    0x8(%esp),%eax
c0407761:	83 ec 08             	sub    $0x8,%esp
c0407764:	6a 01                	push   $0x1
c0407766:	50                   	push   %eax
c0407767:	e8 cf ca ff ff       	call   c040423b <vmm_req_phys_pg>
c040776c:	83 c4 10             	add    $0x10,%esp
c040776f:	85 c0                	test   %eax,%eax
c0407771:	74 0a                	je     c040777d <pg_clone_pgdir+0xc0>
				return NULL; /*bail out if we can't get a phys page */
c0407773:	b8 00 00 00 00       	mov    $0x0,%eax
c0407778:	e9 f5 00 00 00       	jmp    c0407872 <pg_clone_pgdir+0x1b5>
		
			/* calc the logical addresses, strip flags and start modifying the new table */
			pgtable = (unsigned int *)(KERNEL_PHYS2LOG(pgtable_phys));
c040777d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407781:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407786:	89 44 24 14          	mov    %eax,0x14(%esp)
			src_table = (unsigned int *)((unsigned int)KERNEL_PHYS2LOG(src_table) & PG_4K_MASK);
c040778a:	8b 44 24 18          	mov    0x18(%esp),%eax
c040778e:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407793:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0407798:	89 44 24 18          	mov    %eax,0x18(%esp)
			
			for(page = 0; page < 1024; page++)
c040779c:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c04077a3:	00 
c04077a4:	eb 6c                	jmp    c0407812 <pg_clone_pgdir+0x155>
			{
				pgtable[page] = src_table[page];
c04077a6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077aa:	c1 e0 02             	shl    $0x2,%eax
c04077ad:	03 44 24 14          	add    0x14(%esp),%eax
c04077b1:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04077b5:	c1 e2 02             	shl    $0x2,%edx
c04077b8:	03 54 24 18          	add    0x18(%esp),%edx
c04077bc:	8b 12                	mov    (%edx),%edx
c04077be:	89 10                	mov    %edx,(%eax)
				
				/* if page is writeable, then disable writing so we can later fault and
				   perform the copy-on-write */
				if(pgtable[page] & PG_RW)
c04077c0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077c4:	c1 e0 02             	shl    $0x2,%eax
c04077c7:	03 44 24 14          	add    0x14(%esp),%eax
c04077cb:	8b 00                	mov    (%eax),%eax
c04077cd:	83 e0 02             	and    $0x2,%eax
c04077d0:	85 c0                	test   %eax,%eax
c04077d2:	74 3a                	je     c040780e <pg_clone_pgdir+0x151>
				{
					/* in the child */
					pgtable[page] = pgtable[page] & (~PG_RW); /* clear R/W */
c04077d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077d8:	c1 e0 02             	shl    $0x2,%eax
c04077db:	03 44 24 14          	add    0x14(%esp),%eax
c04077df:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c04077e3:	c1 e2 02             	shl    $0x2,%edx
c04077e6:	03 54 24 14          	add    0x14(%esp),%edx
c04077ea:	8b 12                	mov    (%edx),%edx
c04077ec:	83 e2 fd             	and    $0xfffffffd,%edx
c04077ef:	89 10                	mov    %edx,(%eax)
					
					/* in the parent */
					src_table[page] = src_table[page] & (~PG_RW); /* clear R/W */
c04077f1:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c04077f5:	c1 e0 02             	shl    $0x2,%eax
c04077f8:	03 44 24 18          	add    0x18(%esp),%eax
c04077fc:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0407800:	c1 e2 02             	shl    $0x2,%edx
c0407803:	03 54 24 18          	add    0x18(%esp),%edx
c0407807:	8b 12                	mov    (%edx),%edx
c0407809:	83 e2 fd             	and    $0xfffffffd,%edx
c040780c:	89 10                	mov    %edx,(%eax)
		
			/* calc the logical addresses, strip flags and start modifying the new table */
			pgtable = (unsigned int *)(KERNEL_PHYS2LOG(pgtable_phys));
			src_table = (unsigned int *)((unsigned int)KERNEL_PHYS2LOG(src_table) & PG_4K_MASK);
			
			for(page = 0; page < 1024; page++)
c040780e:	ff 44 24 1c          	incl   0x1c(%esp)
c0407812:	81 7c 24 1c ff 03 00 	cmpl   $0x3ff,0x1c(%esp)
c0407819:	00 
c040781a:	76 8a                	jbe    c04077a6 <pg_clone_pgdir+0xe9>
					src_table[page] = src_table[page] & (~PG_RW); /* clear R/W */
				}
			}
			
			/* save the phys address into the directory with suitable flags */
			new[loop] = (unsigned int *)((unsigned int)pgtable_phys | ((unsigned int)(source[loop]) & ~PG_4K_MASK));
c040781c:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407820:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407824:	c1 e2 02             	shl    $0x2,%edx
c0407827:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040782a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040782e:	c1 e0 02             	shl    $0x2,%eax
c0407831:	03 44 24 30          	add    0x30(%esp),%eax
c0407835:	8b 00                	mov    (%eax),%eax
c0407837:	89 c1                	mov    %eax,%ecx
c0407839:	81 e1 ff 0f 00 00    	and    $0xfff,%ecx
c040783f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407843:	09 c8                	or     %ecx,%eax
c0407845:	89 02                	mov    %eax,(%edx)
c0407847:	eb 13                	jmp    c040785c <pg_clone_pgdir+0x19f>
		}
		else
			new[loop] = NULL;
c0407849:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040784d:	8b 54 24 10          	mov    0x10(%esp),%edx
c0407851:	c1 e2 02             	shl    $0x2,%edx
c0407854:	01 d0                	add    %edx,%eax
c0407856:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	
	/* link read-only user areas, link r/w user areas but mark them
	    to copy-on-write and disable the write bit - we'll fault on
	    write and then the fault handler can demand copy the pages.
	    also, it's assumed all userspace pages are handled as 4K entries */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c040785c:	ff 44 24 10          	incl   0x10(%esp)
c0407860:	81 7c 24 10 ff 02 00 	cmpl   $0x2ff,0x10(%esp)
c0407867:	00 
c0407868:	0f 86 c9 fe ff ff    	jbe    c0407737 <pg_clone_pgdir+0x7a>
		}
		else
			new[loop] = NULL;
	}
	
	return new;
c040786e:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0407872:	83 c4 2c             	add    $0x2c,%esp
c0407875:	c3                   	ret    

c0407876 <pg_new_process>:
 => new = pointer to process structure
 current = pointer or NULL for initial system processes
 <= 0 for success or an error code
 */
kresult pg_new_process(process *new, process *current)
{
c0407876:	53                   	push   %ebx
c0407877:	83 ec 18             	sub    $0x18,%esp
	unsigned int **pgdir;

	lock_gate(&(new->lock), LOCK_WRITE);
c040787a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040787e:	83 c0 10             	add    $0x10,%eax
c0407881:	83 ec 08             	sub    $0x8,%esp
c0407884:	6a 01                	push   $0x1
c0407886:	50                   	push   %eax
c0407887:	e8 0c 8c ff ff       	call   c0400498 <lock_gate>
c040788c:	83 c4 10             	add    $0x10,%esp
	
	/* pick the right page directory */
	if(current)
c040788f:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0407894:	74 22                	je     c04078b8 <pg_new_process+0x42>
	{
		lock_gate(&(current->lock), LOCK_READ);
c0407896:	8b 44 24 24          	mov    0x24(%esp),%eax
c040789a:	83 c0 10             	add    $0x10,%eax
c040789d:	83 ec 08             	sub    $0x8,%esp
c04078a0:	6a 00                	push   $0x0
c04078a2:	50                   	push   %eax
c04078a3:	e8 f0 8b ff ff       	call   c0400498 <lock_gate>
c04078a8:	83 c4 10             	add    $0x10,%esp
		pgdir = current->pgdir;
c04078ab:	8b 44 24 24          	mov    0x24(%esp),%eax
c04078af:	8b 40 20             	mov    0x20(%eax),%eax
c04078b2:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04078b6:	eb 08                	jmp    c04078c0 <pg_new_process+0x4a>
	}
	else
		pgdir = (unsigned int **)&KernelPageDirectory;
c04078b8:	c7 44 24 0c 00 e0 40 	movl   $0xc040e000,0xc(%esp)
c04078bf:	c0 
	/* grab a copy of the parent page directory or
	 bail out if there's a failure. if there is no
	 parent, we're create new processes from scratch
	 and the kernel's page directory should be empty
	 for userspace... */
	new->pgdir = pg_clone_pgdir(pgdir);
c04078c0:	83 ec 0c             	sub    $0xc,%esp
c04078c3:	ff 74 24 18          	pushl  0x18(%esp)
c04078c7:	e8 f1 fd ff ff       	call   c04076bd <pg_clone_pgdir>
c04078cc:	83 c4 10             	add    $0x10,%esp
c04078cf:	8b 54 24 20          	mov    0x20(%esp),%edx
c04078d3:	89 42 20             	mov    %eax,0x20(%edx)
	if(new->pgdir == NULL)
c04078d6:	8b 44 24 20          	mov    0x20(%esp),%eax
c04078da:	8b 40 20             	mov    0x20(%eax),%eax
c04078dd:	85 c0                	test   %eax,%eax
c04078df:	75 3b                	jne    c040791c <pg_new_process+0xa6>
	{
		unlock_gate(&(new->lock), LOCK_WRITE);
c04078e1:	8b 44 24 20          	mov    0x20(%esp),%eax
c04078e5:	83 c0 10             	add    $0x10,%eax
c04078e8:	83 ec 08             	sub    $0x8,%esp
c04078eb:	6a 01                	push   $0x1
c04078ed:	50                   	push   %eax
c04078ee:	e8 24 8d ff ff       	call   c0400617 <unlock_gate>
c04078f3:	83 c4 10             	add    $0x10,%esp
		if(current) unlock_gate(&(current->lock), LOCK_READ);
c04078f6:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04078fb:	74 15                	je     c0407912 <pg_new_process+0x9c>
c04078fd:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407901:	83 c0 10             	add    $0x10,%eax
c0407904:	83 ec 08             	sub    $0x8,%esp
c0407907:	6a 00                	push   $0x0
c0407909:	50                   	push   %eax
c040790a:	e8 08 8d ff ff       	call   c0400617 <unlock_gate>
c040790f:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0407912:	b8 01 00 00 00       	mov    $0x1,%eax
c0407917:	e9 a5 00 00 00       	jmp    c04079c1 <pg_new_process+0x14b>
	}

	if(current) unlock_gate(&(current->lock), LOCK_READ);
c040791c:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0407921:	74 15                	je     c0407938 <pg_new_process+0xc2>
c0407923:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407927:	83 c0 10             	add    $0x10,%eax
c040792a:	83 ec 08             	sub    $0x8,%esp
c040792d:	6a 00                	push   $0x0
c040792f:	50                   	push   %eax
c0407930:	e8 e2 8c ff ff       	call   c0400617 <unlock_gate>
c0407935:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(new->lock), LOCK_WRITE);
c0407938:	8b 44 24 20          	mov    0x20(%esp),%eax
c040793c:	83 c0 10             	add    $0x10,%eax
c040793f:	83 ec 08             	sub    $0x8,%esp
c0407942:	6a 01                	push   $0x1
c0407944:	50                   	push   %eax
c0407945:	e8 cd 8c ff ff       	call   c0400617 <unlock_gate>
c040794a:	83 c4 10             	add    $0x10,%esp
	
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
c040794d:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
c0407952:	85 c0                	test   %eax,%eax
c0407954:	74 66                	je     c04079bc <pg_new_process+0x146>
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
c0407956:	8b 44 24 20          	mov    0x20(%esp),%eax
c040795a:	8b 10                	mov    (%eax),%edx
c040795c:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
c0407961:	83 ec 04             	sub    $0x4,%esp
c0407964:	52                   	push   %edx
c0407965:	6a 21                	push   $0x21
c0407967:	50                   	push   %eax
c0407968:	e8 cf a8 ff ff       	call   c040223c <msg_send_signal>
c040796d:	83 c4 10             	add    $0x10,%esp
c0407970:	85 c0                	test   %eax,%eax
c0407972:	74 48                	je     c04079bc <pg_new_process+0x146>
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407974:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407978:	8b 18                	mov    (%eax),%ebx
c040797a:	8b 0d 04 1d 41 c0    	mov    0xc0411d04,%ecx
					      "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407980:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407985:	8b 10                	mov    (%eax),%edx
					      "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407987:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c040798c:	3c 01                	cmp    $0x1,%al
c040798e:	76 0c                	jbe    c040799c <pg_new_process+0x126>
					      "          tried talking to proc %i (%p) while cloning %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407990:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0407995:	8b 00                	mov    (%eax),%eax
	/* notify the userspace page manager that a process is starting up */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCCLONED, new->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407997:	c1 e8 18             	shr    $0x18,%eax
c040799a:	eb 08                	jmp    c04079a4 <pg_new_process+0x12e>
c040799c:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04079a1:	0f b6 c0             	movzbl %al,%eax
c04079a4:	83 ec 08             	sub    $0x8,%esp
c04079a7:	ff 74 24 28          	pushl  0x28(%esp)
c04079ab:	53                   	push   %ebx
c04079ac:	51                   	push   %ecx
c04079ad:	52                   	push   %edx
c04079ae:	50                   	push   %eax
c04079af:	68 64 cc 40 c0       	push   $0xc040cc64
c04079b4:	e8 c9 44 00 00       	call   c040be82 <debug_printf>
c04079b9:	83 c4 20             	add    $0x20,%esp
	}	
	
	PAGE_DEBUG("[page:%i] created new pgdir %p for new process %i\n", 
			  CPU_ID, new->pgdir, new->pid);
	
	return success;
c04079bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c04079c1:	83 c4 18             	add    $0x18,%esp
c04079c4:	5b                   	pop    %ebx
c04079c5:	c3                   	ret    

c04079c6 <pg_destroy_process>:
   effectively reversing the operation of clonedir()
   => victim = process to tear down
   <= success or e_failure if something went wrong
*/
kresult pg_destroy_process(process *victim)
{
c04079c6:	53                   	push   %ebx
c04079c7:	83 ec 18             	sub    $0x18,%esp
	unsigned int loop;
	unsigned int **pgdir;
	
	lock_gate(&(victim->lock), LOCK_WRITE);
c04079ca:	8b 44 24 20          	mov    0x20(%esp),%eax
c04079ce:	83 c0 10             	add    $0x10,%eax
c04079d1:	83 ec 08             	sub    $0x8,%esp
c04079d4:	6a 01                	push   $0x1
c04079d6:	50                   	push   %eax
c04079d7:	e8 bc 8a ff ff       	call   c0400498 <lock_gate>
c04079dc:	83 c4 10             	add    $0x10,%esp
	
	pgdir = victim->pgdir;
c04079df:	8b 44 24 20          	mov    0x20(%esp),%eax
c04079e3:	8b 40 20             	mov    0x20(%eax),%eax
c04079e6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	/* run through the userspace of the page directory */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c04079ea:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c04079f1:	00 
c04079f2:	eb 36                	jmp    c0407a2a <pg_destroy_process+0x64>
	{
		if((unsigned int)(pgdir[loop]) & PG_PRESENT)
c04079f4:	8b 44 24 08          	mov    0x8(%esp),%eax
c04079f8:	c1 e0 02             	shl    $0x2,%eax
c04079fb:	03 44 24 0c          	add    0xc(%esp),%eax
c04079ff:	8b 00                	mov    (%eax),%eax
c0407a01:	83 e0 01             	and    $0x1,%eax
c0407a04:	84 c0                	test   %al,%al
c0407a06:	74 1e                	je     c0407a26 <pg_destroy_process+0x60>
			/* return the page holding the table */
			vmm_return_phys_pg((unsigned int *)((unsigned int)(pgdir[loop]) & PG_4K_MASK));
c0407a08:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407a0c:	c1 e0 02             	shl    $0x2,%eax
c0407a0f:	03 44 24 0c          	add    0xc(%esp),%eax
c0407a13:	8b 00                	mov    (%eax),%eax
c0407a15:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0407a1a:	83 ec 0c             	sub    $0xc,%esp
c0407a1d:	50                   	push   %eax
c0407a1e:	e8 06 c9 ff ff       	call   c0404329 <vmm_return_phys_pg>
c0407a23:	83 c4 10             	add    $0x10,%esp
	lock_gate(&(victim->lock), LOCK_WRITE);
	
	pgdir = victim->pgdir;
	
	/* run through the userspace of the page directory */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0407a26:	ff 44 24 08          	incl   0x8(%esp)
c0407a2a:	81 7c 24 08 ff 02 00 	cmpl   $0x2ff,0x8(%esp)
c0407a31:	00 
c0407a32:	76 c0                	jbe    c04079f4 <pg_destroy_process+0x2e>
			/* return the page holding the table */
			vmm_return_phys_pg((unsigned int *)((unsigned int)(pgdir[loop]) & PG_4K_MASK));
	}
	
	/* return the page dir's page */
	vmm_return_phys_pg(KERNEL_LOG2PHYS(victim->pgdir));
c0407a34:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a38:	8b 40 20             	mov    0x20(%eax),%eax
c0407a3b:	05 00 00 00 40       	add    $0x40000000,%eax
c0407a40:	83 ec 0c             	sub    $0xc,%esp
c0407a43:	50                   	push   %eax
c0407a44:	e8 e0 c8 ff ff       	call   c0404329 <vmm_return_phys_pg>
c0407a49:	83 c4 10             	add    $0x10,%esp
	victim->pgdir = NULL;
c0407a4c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a50:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
	
	/* bump the userspace page manager */
	if(userspace_page_handler)
c0407a57:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
c0407a5c:	85 c0                	test   %eax,%eax
c0407a5e:	74 66                	je     c0407ac6 <pg_destroy_process+0x100>
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
c0407a60:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a64:	8b 10                	mov    (%eax),%edx
c0407a66:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
c0407a6b:	83 ec 04             	sub    $0x4,%esp
c0407a6e:	52                   	push   %edx
c0407a6f:	6a 20                	push   $0x20
c0407a71:	50                   	push   %eax
c0407a72:	e8 c5 a7 ff ff       	call   c040223c <msg_send_signal>
c0407a77:	83 c4 10             	add    $0x10,%esp
c0407a7a:	85 c0                	test   %eax,%eax
c0407a7c:	74 48                	je     c0407ac6 <pg_destroy_process+0x100>
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407a7e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407a82:	8b 18                	mov    (%eax),%ebx
c0407a84:	8b 0d 04 1d 41 c0    	mov    0xc0411d04,%ecx
					      "       tried signalling proc %i (%p) while tearing down %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407a8a:	a1 04 1d 41 c0       	mov    0xc0411d04,%eax
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407a8f:	8b 10                	mov    (%eax),%edx
					      "       tried signalling proc %i (%p) while tearing down %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407a91:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407a96:	3c 01                	cmp    $0x1,%al
c0407a98:	76 0c                	jbe    c0407aa6 <pg_destroy_process+0xe0>
					      "       tried signalling proc %i (%p) while tearing down %i (%p)\n",
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
c0407a9a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0407a9f:	8b 00                	mov    (%eax),%eax
	/* bump the userspace page manager */
	if(userspace_page_handler)
	{
		if(msg_send_signal(userspace_page_handler, SIGXPROCKILLED, victim->pid))
		{
			KOOPS_DEBUG("[page:%i] OMGWTF userspace page manager has gone AWOL\n"
c0407aa1:	c1 e8 18             	shr    $0x18,%eax
c0407aa4:	eb 08                	jmp    c0407aae <pg_destroy_process+0xe8>
c0407aa6:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0407aab:	0f b6 c0             	movzbl %al,%eax
c0407aae:	83 ec 08             	sub    $0x8,%esp
c0407ab1:	ff 74 24 28          	pushl  0x28(%esp)
c0407ab5:	53                   	push   %ebx
c0407ab6:	51                   	push   %ecx
c0407ab7:	52                   	push   %edx
c0407ab8:	50                   	push   %eax
c0407ab9:	68 dc cc 40 c0       	push   $0xc040ccdc
c0407abe:	e8 bf 43 00 00       	call   c040be82 <debug_printf>
c0407ac3:	83 c4 20             	add    $0x20,%esp
					      CPU_ID, userspace_page_handler->pid, userspace_page_handler,
					      victim->pid, victim);
		}
	}
	
	unlock_gate(&(victim->lock), LOCK_WRITE);
c0407ac6:	8b 44 24 20          	mov    0x20(%esp),%eax
c0407aca:	83 c0 10             	add    $0x10,%eax
c0407acd:	83 ec 08             	sub    $0x8,%esp
c0407ad0:	6a 01                	push   $0x1
c0407ad2:	50                   	push   %eax
c0407ad3:	e8 3f 8b ff ff       	call   c0400617 <unlock_gate>
c0407ad8:	83 c4 10             	add    $0x10,%esp
							
	return success;
c0407adb:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0407ae0:	83 c4 18             	add    $0x18,%esp
c0407ae3:	5b                   	pop    %ebx
c0407ae4:	c3                   	ret    

c0407ae5 <pg_user2phys>:
      pgdir = pgdir belonging to a process
      virtual = virtual address to translate
   <= success or failure code
*/
kresult pg_user2phys(unsigned int *paddr, unsigned int **pgdir, unsigned int virtual)
{
c0407ae5:	83 ec 10             	sub    $0x10,%esp
	unsigned int pgdir_index = (virtual >> PG_DIR_BASE) & PG_INDEX_MASK;
c0407ae8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407aec:	c1 e8 16             	shr    $0x16,%eax
c0407aef:	89 44 24 04          	mov    %eax,0x4(%esp)
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
c0407af3:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407af7:	c1 e8 0c             	shr    $0xc,%eax
c0407afa:	25 ff 03 00 00       	and    $0x3ff,%eax
c0407aff:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int *pgtbl;
	
	if((!pgdir) || (!paddr)) return e_failure;
c0407b03:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0407b08:	74 07                	je     c0407b11 <pg_user2phys+0x2c>
c0407b0a:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c0407b0f:	75 07                	jne    c0407b18 <pg_user2phys+0x33>
c0407b11:	b8 01 00 00 00       	mov    $0x1,%eax
c0407b16:	eb 70                	jmp    c0407b88 <pg_user2phys+0xa3>
	
	pgtbl = (unsigned int *)((unsigned int)pgdir[pgdir_index] & PG_4K_MASK);
c0407b18:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407b1c:	c1 e0 02             	shl    $0x2,%eax
c0407b1f:	03 44 24 18          	add    0x18(%esp),%eax
c0407b23:	8b 00                	mov    (%eax),%eax
c0407b25:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0407b2a:	89 44 24 0c          	mov    %eax,0xc(%esp)
	pgtbl = KERNEL_PHYS2LOG(pgtbl);
c0407b2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407b32:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407b37:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(pgtbl)
c0407b3b:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407b40:	74 41                	je     c0407b83 <pg_user2phys+0x9e>
		if(pgtbl[pgtable_index] & PG_PRESENT)
c0407b42:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407b46:	c1 e0 02             	shl    $0x2,%eax
c0407b49:	03 44 24 0c          	add    0xc(%esp),%eax
c0407b4d:	8b 00                	mov    (%eax),%eax
c0407b4f:	83 e0 01             	and    $0x1,%eax
c0407b52:	84 c0                	test   %al,%al
c0407b54:	74 2d                	je     c0407b83 <pg_user2phys+0x9e>
		{
			*(paddr) = (pgtbl[pgtable_index] & PG_4K_MASK) + (virtual & ~PG_4K_MASK);
c0407b56:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407b5a:	c1 e0 02             	shl    $0x2,%eax
c0407b5d:	03 44 24 0c          	add    0xc(%esp),%eax
c0407b61:	8b 00                	mov    (%eax),%eax
c0407b63:	89 c2                	mov    %eax,%edx
c0407b65:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
c0407b6b:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407b6f:	25 ff 0f 00 00       	and    $0xfff,%eax
c0407b74:	01 c2                	add    %eax,%edx
c0407b76:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407b7a:	89 10                	mov    %edx,(%eax)
			return success;
c0407b7c:	b8 00 00 00 00       	mov    $0x0,%eax
c0407b81:	eb 05                	jmp    c0407b88 <pg_user2phys+0xa3>
		}

	return e_not_found;
c0407b83:	b8 02 00 00 00       	mov    $0x2,%eax
}
c0407b88:	83 c4 10             	add    $0x10,%esp
c0407b8b:	c3                   	ret    

c0407b8c <pg_user2kernel>:
      proc  = process owning the userspace to interrogate
   <= 0 for success or an error code
*/
kresult pg_user2kernel(unsigned int *kaddr, unsigned int uaddr, process *proc)
{
	if((!proc) || (!kaddr)) return e_failure;
c0407b8c:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407b91:	74 07                	je     c0407b9a <pg_user2kernel+0xe>
c0407b93:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0407b98:	75 07                	jne    c0407ba1 <pg_user2kernel+0x15>
c0407b9a:	b8 01 00 00 00       	mov    $0x1,%eax
c0407b9f:	eb 3a                	jmp    c0407bdb <pg_user2kernel+0x4f>
	
	if(pg_user2phys(kaddr, proc->pgdir, uaddr))
c0407ba1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407ba5:	8b 40 20             	mov    0x20(%eax),%eax
c0407ba8:	ff 74 24 08          	pushl  0x8(%esp)
c0407bac:	50                   	push   %eax
c0407bad:	ff 74 24 0c          	pushl  0xc(%esp)
c0407bb1:	e8 2f ff ff ff       	call   c0407ae5 <pg_user2phys>
c0407bb6:	83 c4 0c             	add    $0xc,%esp
c0407bb9:	85 c0                	test   %eax,%eax
c0407bbb:	74 07                	je     c0407bc4 <pg_user2kernel+0x38>
		return e_failure;
c0407bbd:	b8 01 00 00 00       	mov    $0x1,%eax
c0407bc2:	eb 17                	jmp    c0407bdb <pg_user2kernel+0x4f>

	/* got a physical addr, turn it into a kernel virtual address */
	*(kaddr) = (unsigned int)KERNEL_PHYS2LOG((unsigned int *)(*(kaddr)));
c0407bc4:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407bc8:	8b 00                	mov    (%eax),%eax
c0407bca:	8d 90 00 00 00 c0    	lea    -0x40000000(%eax),%edx
c0407bd0:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407bd4:	89 10                	mov    %edx,(%eax)
	
	return success;
c0407bd6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0407bdb:	c3                   	ret    

c0407bdc <pg_add_4K_mapping>:
		flags = flag bits to be ORd with the phys addr
   <= 0 for success, anything else is a fail
*/
kresult pg_add_4K_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, 
								  unsigned int flags)
{
c0407bdc:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int pgdir_index = (virtual >> PG_DIR_BASE) & PG_INDEX_MASK;
c0407bdf:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407be3:	c1 e8 16             	shr    $0x16,%eax
c0407be6:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
c0407bea:	8b 44 24 34          	mov    0x34(%esp),%eax
c0407bee:	c1 e8 0c             	shr    $0xc,%eax
c0407bf1:	25 ff 03 00 00       	and    $0x3ff,%eax
c0407bf6:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
c0407bfa:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c0407bff:	74 0b                	je     c0407c0c <pg_add_4K_mapping+0x30>
c0407c01:	8b 44 24 30          	mov    0x30(%esp),%eax
c0407c05:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0407c0a:	77 52                	ja     c0407c5e <pg_add_4K_mapping+0x82>
	{
		KOOPS_DEBUG("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
				      "              pgdir %p virtual %x physical %x flags %i\n"
				      "              pgdir_index %i pgtable_index %i\n",
				      CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
c0407c0c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
	{
		KOOPS_DEBUG("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
c0407c11:	3c 01                	cmp    $0x1,%al
c0407c13:	76 0c                	jbe    c0407c21 <pg_add_4K_mapping+0x45>
				      "              pgdir %p virtual %x physical %x flags %i\n"
				      "              pgdir_index %i pgtable_index %i\n",
				      CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
c0407c15:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0407c1a:	8b 00                	mov    (%eax),%eax
	unsigned int pgtable_index = (virtual >> PG_TBL_BASE) & PG_INDEX_MASK;
	unsigned int *pgtbl;

	if(!pgdir || ((unsigned int)pgdir < KERNEL_SPACE_BASE))
	{
		KOOPS_DEBUG("[page:%i] OMGWTF bad page directory pointer to pg_add_4K_mapping!\n"
c0407c1c:	c1 e8 18             	shr    $0x18,%eax
c0407c1f:	eb 08                	jmp    c0407c29 <pg_add_4K_mapping+0x4d>
c0407c21:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0407c26:	0f b6 c0             	movzbl %al,%eax
c0407c29:	ff 74 24 0c          	pushl  0xc(%esp)
c0407c2d:	ff 74 24 0c          	pushl  0xc(%esp)
c0407c31:	ff 74 24 44          	pushl  0x44(%esp)
c0407c35:	ff 74 24 44          	pushl  0x44(%esp)
c0407c39:	ff 74 24 44          	pushl  0x44(%esp)
c0407c3d:	ff 74 24 44          	pushl  0x44(%esp)
c0407c41:	50                   	push   %eax
c0407c42:	68 54 cd 40 c0       	push   $0xc040cd54
c0407c47:	e8 36 42 00 00       	call   c040be82 <debug_printf>
c0407c4c:	83 c4 20             	add    $0x20,%esp
				      "              pgdir %p virtual %x physical %x flags %i\n"
				      "              pgdir_index %i pgtable_index %i\n",
				      CPU_ID, pgdir, virtual, physical, flags, pgdir_index, pgtable_index);
		debug_stacktrace();
c0407c4f:	e8 1f 3b 00 00       	call   c040b773 <debug_stacktrace>
		return e_failure; /* bail out now if we get a bad pointer */
c0407c54:	b8 01 00 00 00       	mov    $0x1,%eax
c0407c59:	e9 ec 00 00 00       	jmp    c0407d4a <pg_add_4K_mapping+0x16e>
	}
	
	/* if a 4M mapping already exists for this virtual address then bail out */
	if((unsigned int)(pgdir[pgdir_index]) & PG_SIZE)
c0407c5e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407c62:	c1 e0 02             	shl    $0x2,%eax
c0407c65:	03 44 24 30          	add    0x30(%esp),%eax
c0407c69:	8b 00                	mov    (%eax),%eax
c0407c6b:	25 80 00 00 00       	and    $0x80,%eax
c0407c70:	85 c0                	test   %eax,%eax
c0407c72:	74 0a                	je     c0407c7e <pg_add_4K_mapping+0xa2>
		return success;
c0407c74:	b8 00 00 00 00       	mov    $0x0,%eax
c0407c79:	e9 cc 00 00 00       	jmp    c0407d4a <pg_add_4K_mapping+0x16e>

	/* find the entry in the page directory for the page table for this 4K page and
		allocate a page table if it doesn't exist */
	if(!(pgdir[pgdir_index]))
c0407c7e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407c82:	c1 e0 02             	shl    $0x2,%eax
c0407c85:	03 44 24 30          	add    0x30(%esp),%eax
c0407c89:	8b 00                	mov    (%eax),%eax
c0407c8b:	85 c0                	test   %eax,%eax
c0407c8d:	75 74                	jne    c0407d03 <pg_add_4K_mapping+0x127>
	{
		unsigned int loop;
		unsigned int *newtable, *cleantable;
		
		kresult err = vmm_req_phys_pg((void **)&newtable, 1);
c0407c8f:	8d 44 24 04          	lea    0x4(%esp),%eax
c0407c93:	83 ec 08             	sub    $0x8,%esp
c0407c96:	6a 01                	push   $0x1
c0407c98:	50                   	push   %eax
c0407c99:	e8 9d c5 ff ff       	call   c040423b <vmm_req_phys_pg>
c0407c9e:	83 c4 10             	add    $0x10,%esp
c0407ca1:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if(err) return err; /* failed */
c0407ca5:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0407caa:	74 09                	je     c0407cb5 <pg_add_4K_mapping+0xd9>
c0407cac:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0407cb0:	e9 95 00 00 00       	jmp    c0407d4a <pg_add_4K_mapping+0x16e>

		/* PLEASE PLEASE don't forget that all kernel addresses are
		   logical! So you must convert phys to log before accessing
		   the referenced memory */
		/* zero the new page table */
		cleantable = (unsigned int *)KERNEL_PHYS2LOG(newtable);
c0407cb5:	8b 44 24 04          	mov    0x4(%esp),%eax
c0407cb9:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407cbe:	89 44 24 18          	mov    %eax,0x18(%esp)
		for(loop = 0; loop < 1024; loop++)
c0407cc2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0407cc9:	00 
c0407cca:	eb 15                	jmp    c0407ce1 <pg_add_4K_mapping+0x105>
			cleantable[loop] = 0;
c0407ccc:	8b 44 24 14          	mov    0x14(%esp),%eax
c0407cd0:	c1 e0 02             	shl    $0x2,%eax
c0407cd3:	03 44 24 18          	add    0x18(%esp),%eax
c0407cd7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
		/* PLEASE PLEASE don't forget that all kernel addresses are
		   logical! So you must convert phys to log before accessing
		   the referenced memory */
		/* zero the new page table */
		cleantable = (unsigned int *)KERNEL_PHYS2LOG(newtable);
		for(loop = 0; loop < 1024; loop++)
c0407cdd:	ff 44 24 14          	incl   0x14(%esp)
c0407ce1:	81 7c 24 14 ff 03 00 	cmpl   $0x3ff,0x14(%esp)
c0407ce8:	00 
c0407ce9:	76 e1                	jbe    c0407ccc <pg_add_4K_mapping+0xf0>
			cleantable[loop] = 0;
		
		/* write into the page directory entry the new tbl addr and flags */
		/* force the r/w bit high so that if a particular page is marked read-only
			the whole directory entry isn't */
		pgdir[pgdir_index] = (unsigned int *)((unsigned int)newtable | PG_RW | flags);
c0407ceb:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407cef:	c1 e0 02             	shl    $0x2,%eax
c0407cf2:	03 44 24 30          	add    0x30(%esp),%eax
c0407cf6:	8b 54 24 04          	mov    0x4(%esp),%edx
c0407cfa:	0b 54 24 3c          	or     0x3c(%esp),%edx
c0407cfe:	83 ca 02             	or     $0x2,%edx
c0407d01:	89 10                	mov    %edx,(%eax)
	}
	
	/* align address and clean lower bits */
	physical = physical & PG_4K_MASK;
c0407d03:	81 64 24 38 00 f0 ff 	andl   $0xfffff000,0x38(%esp)
c0407d0a:	ff 
	
	PAGE_DEBUG("[page:%i] mapping 4K: %x -> %x (%x) dir index %x table index %x table base %p (%x)\n", 
			  CPU_ID, virtual, physical, flags, pgdir_index, pgtable_index,
			  pgdir[pgdir_index], KERNEL_PHYS2LOG(pgdir[pgdir_index]));
	
	pgtbl = (unsigned int *)KERNEL_PHYS2LOG(pgdir[pgdir_index]);
c0407d0b:	8b 44 24 08          	mov    0x8(%esp),%eax
c0407d0f:	c1 e0 02             	shl    $0x2,%eax
c0407d12:	03 44 24 30          	add    0x30(%esp),%eax
c0407d16:	8b 00                	mov    (%eax),%eax
c0407d18:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407d1d:	89 44 24 10          	mov    %eax,0x10(%esp)
	pgtbl = (unsigned int *)((unsigned int)pgtbl & PG_TBL_MASK); /* clean out lower bits */
c0407d21:	8b 44 24 10          	mov    0x10(%esp),%eax
c0407d25:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0407d2a:	89 44 24 10          	mov    %eax,0x10(%esp)
	
	pgtbl[pgtable_index] = physical | flags;
c0407d2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407d32:	c1 e0 02             	shl    $0x2,%eax
c0407d35:	03 44 24 10          	add    0x10(%esp),%eax
c0407d39:	8b 54 24 3c          	mov    0x3c(%esp),%edx
c0407d3d:	8b 4c 24 38          	mov    0x38(%esp),%ecx
c0407d41:	09 ca                	or     %ecx,%edx
c0407d43:	89 10                	mov    %edx,(%eax)
	
	return 0;
c0407d45:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0407d4a:	83 c4 2c             	add    $0x2c,%esp
c0407d4d:	c3                   	ret    

c0407d4e <pg_add_4M_mapping>:
    flags = flag bits to be ORd with the phys addr
 <= 0 for success, anything else is a fail
 */
kresult pg_add_4M_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, 
								  unsigned int flags)
{	
c0407d4e:	83 ec 10             	sub    $0x10,%esp
	PAGE_DEBUG("[page:%i] mapping 4M: %x -> %x (%x) dir index %x\n", 
			  CPU_ID, virtual, physical, flags, virtual >> PG_DIR_BASE);
	
	virtual = virtual & PG_4M_MASK;
c0407d51:	81 64 24 18 00 00 c0 	andl   $0xffc00000,0x18(%esp)
c0407d58:	ff 
	physical = physical & PG_4M_MASK;
c0407d59:	81 64 24 1c 00 00 c0 	andl   $0xffc00000,0x1c(%esp)
c0407d60:	ff 
	
	/* create 4MB entry, read+write for kernel-only */
	if((virtual >> PG_DIR_BASE) < 1024)
c0407d61:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407d65:	c1 e8 16             	shr    $0x16,%eax
c0407d68:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0407d6d:	77 53                	ja     c0407dc2 <pg_add_4M_mapping+0x74>
	{
		unsigned int entry = (unsigned int)(pgdir[(virtual >> PG_DIR_BASE)]);
c0407d6f:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407d73:	c1 e8 16             	shr    $0x16,%eax
c0407d76:	c1 e0 02             	shl    $0x2,%eax
c0407d79:	03 44 24 14          	add    0x14(%esp),%eax
c0407d7d:	8b 00                	mov    (%eax),%eax
c0407d7f:	89 44 24 0c          	mov    %eax,0xc(%esp)
		
		/* give up if this entry is taken by a 4K mapping entry */
		if(entry != 0)
c0407d83:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0407d88:	74 14                	je     c0407d9e <pg_add_4M_mapping+0x50>
			if((entry & PG_SIZE) == 0)
c0407d8a:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407d8e:	25 80 00 00 00       	and    $0x80,%eax
c0407d93:	85 c0                	test   %eax,%eax
c0407d95:	75 07                	jne    c0407d9e <pg_add_4M_mapping+0x50>
				return e_failure;
c0407d97:	b8 01 00 00 00       	mov    $0x1,%eax
c0407d9c:	eb 29                	jmp    c0407dc7 <pg_add_4M_mapping+0x79>
		
		pgdir[(virtual >> PG_DIR_BASE)] = (unsigned int *)(physical | PG_SIZE | flags);
c0407d9e:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407da2:	c1 e8 16             	shr    $0x16,%eax
c0407da5:	c1 e0 02             	shl    $0x2,%eax
c0407da8:	03 44 24 14          	add    0x14(%esp),%eax
c0407dac:	8b 54 24 20          	mov    0x20(%esp),%edx
c0407db0:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
c0407db4:	09 ca                	or     %ecx,%edx
c0407db6:	80 ca 80             	or     $0x80,%dl
c0407db9:	89 10                	mov    %edx,(%eax)
		return success;
c0407dbb:	b8 00 00 00 00       	mov    $0x0,%eax
c0407dc0:	eb 05                	jmp    c0407dc7 <pg_add_4M_mapping+0x79>
	}
	
	/* fall through to failure */
	return e_failure;
c0407dc2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0407dc7:	83 c4 10             	add    $0x10,%esp
c0407dca:	c3                   	ret    

c0407dcb <pg_map_phys_to_kernel_space>:
   => base = base of descending stack
      top = last entry in stack
      granularity = 0 to add 4KB page entries, 1 to add 4M page entries
*/
void pg_map_phys_to_kernel_space(unsigned int *base, unsigned int *top, unsigned char granularity)
{
c0407dcb:	83 ec 3c             	sub    $0x3c,%esp
c0407dce:	8b 44 24 48          	mov    0x48(%esp),%eax
c0407dd2:	88 44 24 0c          	mov    %al,0xc(%esp)
   unsigned int **pg_dir = (unsigned int **)&KernelPageDirectory; /* from start.s */
c0407dd6:	c7 44 24 1c 00 e0 40 	movl   $0xc040e000,0x1c(%esp)
c0407ddd:	c0 

   /* we must assume the physical page stacks are full - ie: no one has
      popped any stack frames off them. and we have to assume for now that
      the frames are in ascending order. scan through the stacks and map
      frames into the kernel's virtual space. */
   while(base >= top)
c0407dde:	e9 b5 00 00 00       	jmp    c0407e98 <pg_map_phys_to_kernel_space+0xcd>
   {
		unsigned int addr, logical_addr;
		unsigned char this_granularity = granularity;
c0407de3:	8a 44 24 0c          	mov    0xc(%esp),%al
c0407de7:	88 44 24 2f          	mov    %al,0x2f(%esp)
		
		if(this_granularity == 1)
c0407deb:	80 7c 24 2f 01       	cmpb   $0x1,0x2f(%esp)
c0407df0:	75 11                	jne    c0407e03 <pg_map_phys_to_kernel_space+0x38>
			addr = *base & PG_4M_MASK;
c0407df2:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407df6:	8b 00                	mov    (%eax),%eax
c0407df8:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c0407dfd:	89 44 24 24          	mov    %eax,0x24(%esp)
c0407e01:	eb 0f                	jmp    c0407e12 <pg_map_phys_to_kernel_space+0x47>
		else
			addr = *base & PG_4K_MASK; 
c0407e03:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407e07:	8b 00                	mov    (%eax),%eax
c0407e09:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0407e0e:	89 44 24 24          	mov    %eax,0x24(%esp)

		/* perform the page table scribbling */
		if(this_granularity == 1)
c0407e12:	80 7c 24 2f 01       	cmpb   $0x1,0x2f(%esp)
c0407e17:	75 47                	jne    c0407e60 <pg_map_phys_to_kernel_space+0x95>
		{
			logical_addr = (unsigned int)KERNEL_PHYS2LOG((unsigned int)addr);
c0407e19:	8b 44 24 24          	mov    0x24(%esp),%eax
c0407e1d:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407e22:	89 44 24 28          	mov    %eax,0x28(%esp)
			
			PAGE_DEBUG("[page:%i] mapped to kernel 4M, page dir[%i] = %x (%x) (%x)\n",
					  CPU_ID, (logical_addr >> PG_DIR_BASE), addr, logical_addr, pg_dir);
			
			/* create 4MB entry, read+write for kernel-only */
			pg_add_4M_mapping(pg_dir, logical_addr, addr, PG_PRESENT | PG_RW);
c0407e26:	6a 03                	push   $0x3
c0407e28:	ff 74 24 28          	pushl  0x28(%esp)
c0407e2c:	ff 74 24 30          	pushl  0x30(%esp)
c0407e30:	ff 74 24 28          	pushl  0x28(%esp)
c0407e34:	e8 15 ff ff ff       	call   c0407d4e <pg_add_4M_mapping>
c0407e39:	83 c4 10             	add    $0x10,%esp
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
c0407e3c:	eb 16                	jmp    c0407e54 <pg_map_phys_to_kernel_space+0x89>
			{
				base--;
c0407e3e:	83 6c 24 40 04       	subl   $0x4,0x40(%esp)
				if((*base & PG_4M_MASK) != addr) break;
c0407e43:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407e47:	8b 00                	mov    (%eax),%eax
c0407e49:	25 00 00 c0 ff       	and    $0xffc00000,%eax
c0407e4e:	3b 44 24 24          	cmp    0x24(%esp),%eax
c0407e52:	75 43                	jne    c0407e97 <pg_map_phys_to_kernel_space+0xcc>
			
			/* create 4MB entry, read+write for kernel-only */
			pg_add_4M_mapping(pg_dir, logical_addr, addr, PG_PRESENT | PG_RW);
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
c0407e54:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407e58:	3b 44 24 44          	cmp    0x44(%esp),%eax
c0407e5c:	73 e0                	jae    c0407e3e <pg_map_phys_to_kernel_space+0x73>
c0407e5e:	eb 38                	jmp    c0407e98 <pg_map_phys_to_kernel_space+0xcd>

			PAGE_DEBUG("[page:%i] mapped to kernel 4K, phys %x log %x (%x)\n",
					  CPU_ID, *base, KERNEL_PHYS2LOG(*base), pg_dir);
							
			/* create a 4KB entry, read+write for kernel-only */
			err = pg_add_4K_mapping((unsigned int **)pg_dir, (unsigned int)KERNEL_PHYS2LOG(*base),
c0407e60:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407e64:	8b 00                	mov    (%eax),%eax
c0407e66:	8b 54 24 40          	mov    0x40(%esp),%edx
c0407e6a:	8b 12                	mov    (%edx),%edx
c0407e6c:	81 ea 00 00 00 40    	sub    $0x40000000,%edx
c0407e72:	6a 03                	push   $0x3
c0407e74:	50                   	push   %eax
c0407e75:	52                   	push   %edx
c0407e76:	ff 74 24 28          	pushl  0x28(%esp)
c0407e7a:	e8 5d fd ff ff       	call   c0407bdc <pg_add_4K_mapping>
c0407e7f:	83 c4 10             	add    $0x10,%esp
c0407e82:	89 44 24 20          	mov    %eax,0x20(%esp)
											*base, PG_PRESENT | PG_RW);
			 if(err)
c0407e86:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0407e8b:	74 03                	je     c0407e90 <pg_map_phys_to_kernel_space+0xc5>
			 {
				 PAGE_DEBUG("*** failed to map virtual %x to physical %x into kernel! halting.",
c0407e8d:	90                   	nop
							(unsigned int)KERNEL_PHYS2LOG(*base), *base);
				 while(1);
c0407e8e:	eb fe                	jmp    c0407e8e <pg_map_phys_to_kernel_space+0xc3>
			 }

			base--;
c0407e90:	83 6c 24 40 04       	subl   $0x4,0x40(%esp)
c0407e95:	eb 01                	jmp    c0407e98 <pg_map_phys_to_kernel_space+0xcd>
			
			/* skip to next 4M boundary aka next */
			while(base >= top)
			{
				base--;
				if((*base & PG_4M_MASK) != addr) break;
c0407e97:	90                   	nop

   /* we must assume the physical page stacks are full - ie: no one has
      popped any stack frames off them. and we have to assume for now that
      the frames are in ascending order. scan through the stacks and map
      frames into the kernel's virtual space. */
   while(base >= top)
c0407e98:	8b 44 24 40          	mov    0x40(%esp),%eax
c0407e9c:	3b 44 24 44          	cmp    0x44(%esp),%eax
c0407ea0:	0f 83 3d ff ff ff    	jae    c0407de3 <pg_map_phys_to_kernel_space+0x18>
			 }

			base--;
		}
   }
}
c0407ea6:	83 c4 3c             	add    $0x3c,%esp
c0407ea9:	c3                   	ret    

c0407eaa <pg_init>:
/* pg_init
   Start up the underlying pagination system for the vmm. This includes
   mapping as much physical ram into the kernel's virtual space as possible.
*/
void pg_init(void)
{
c0407eaa:	83 ec 2c             	sub    $0x2c,%esp
	/* grab a copy of the physical page stack limits because calls to
	   pg_map_phys_to_kernel_space() will modify these global variables */
	unsigned int *low_base = phys_pg_stack_low_base;
c0407ead:	a1 48 f0 40 c0       	mov    0xc040f048,%eax
c0407eb2:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int *low_ptr = phys_pg_stack_low_ptr;
c0407eb6:	a1 88 f4 40 c0       	mov    0xc040f488,%eax
c0407ebb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	unsigned int *high_base = phys_pg_stack_high_base;
c0407ebf:	a1 4c f0 40 c0       	mov    0xc040f04c,%eax
c0407ec4:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int *high_ptr = phys_pg_stack_high_ptr;
c0407ec8:	a1 80 f4 40 c0       	mov    0xc040f480,%eax
c0407ecd:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	unsigned int loop;
	unsigned int **kernel_dir = (unsigned int **)&KernelPageDirectory;
c0407ed1:	c7 44 24 1c 00 e0 40 	movl   $0xc040e000,0x1c(%esp)
c0407ed8:	c0 
	
   PAGE_DEBUG("[page:%i] initialising.. kernel page dir %x\n", CPU_ID, &KernelPageDirectory);

	/* clear out all non-kernelspace entries to start again */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0407ed9:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
c0407ee0:	00 
c0407ee1:	eb 15                	jmp    c0407ef8 <pg_init+0x4e>
		kernel_dir[loop] = NULL;
c0407ee3:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407ee7:	c1 e0 02             	shl    $0x2,%eax
c0407eea:	03 44 24 1c          	add    0x1c(%esp),%eax
c0407eee:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	unsigned int **kernel_dir = (unsigned int **)&KernelPageDirectory;
	
   PAGE_DEBUG("[page:%i] initialising.. kernel page dir %x\n", CPU_ID, &KernelPageDirectory);

	/* clear out all non-kernelspace entries to start again */
	for(loop = 0; loop < (KERNEL_SPACE_BASE >> PG_DIR_BASE); loop++)
c0407ef4:	ff 44 24 18          	incl   0x18(%esp)
c0407ef8:	81 7c 24 18 ff 02 00 	cmpl   $0x2ff,0x18(%esp)
c0407eff:	00 
c0407f00:	76 e1                	jbe    c0407ee3 <pg_init+0x39>
	    will have to be found and written in. The physical pages holding these
	    tables are unlikely to be mapped in unless we process the upper
	    memory first, which are mapped in as 4M pages requiring no separate
	    tables */
	/* map most of memory into 4M pages */
   pg_map_phys_to_kernel_space(high_base, high_ptr, 1);
c0407f02:	83 ec 04             	sub    $0x4,%esp
c0407f05:	6a 01                	push   $0x1
c0407f07:	ff 74 24 1c          	pushl  0x1c(%esp)
c0407f0b:	ff 74 24 1c          	pushl  0x1c(%esp)
c0407f0f:	e8 b7 fe ff ff       	call   c0407dcb <pg_map_phys_to_kernel_space>
c0407f14:	83 c4 10             	add    $0x10,%esp
	
	/* ensure the kernel critical area is mapped in - we use 4M pages to 
	   maximise TLB performance */
	for(loop = KERNEL_CRITICAL_BASE; loop < KERNEL_CRITICAL_END; loop += MEM_4M_PGSIZE)
c0407f17:	c7 44 24 18 00 00 40 	movl   $0x400000,0x18(%esp)
c0407f1e:	00 
c0407f1f:	eb 24                	jmp    c0407f45 <pg_init+0x9b>
		pg_add_4M_mapping(kernel_dir, (unsigned int)KERNEL_PHYS2LOG(loop), loop, PG_PRESENT | PG_RW);
c0407f21:	8b 44 24 18          	mov    0x18(%esp),%eax
c0407f25:	2d 00 00 00 40       	sub    $0x40000000,%eax
c0407f2a:	6a 03                	push   $0x3
c0407f2c:	ff 74 24 1c          	pushl  0x1c(%esp)
c0407f30:	50                   	push   %eax
c0407f31:	ff 74 24 28          	pushl  0x28(%esp)
c0407f35:	e8 14 fe ff ff       	call   c0407d4e <pg_add_4M_mapping>
c0407f3a:	83 c4 10             	add    $0x10,%esp
	/* map most of memory into 4M pages */
   pg_map_phys_to_kernel_space(high_base, high_ptr, 1);
	
	/* ensure the kernel critical area is mapped in - we use 4M pages to 
	   maximise TLB performance */
	for(loop = KERNEL_CRITICAL_BASE; loop < KERNEL_CRITICAL_END; loop += MEM_4M_PGSIZE)
c0407f3d:	81 44 24 18 00 00 40 	addl   $0x400000,0x18(%esp)
c0407f44:	00 
c0407f45:	81 7c 24 18 ff ff bf 	cmpl   $0xbfffff,0x18(%esp)
c0407f4c:	00 
c0407f4d:	76 d2                	jbe    c0407f21 <pg_init+0x77>
		pg_add_4M_mapping(kernel_dir, (unsigned int)KERNEL_PHYS2LOG(loop), loop, PG_PRESENT | PG_RW);
	
	/* map the rest of the lowest 16M in 4K pages */
   pg_map_phys_to_kernel_space(low_base, low_ptr, 0);
c0407f4f:	83 ec 04             	sub    $0x4,%esp
c0407f52:	6a 00                	push   $0x0
c0407f54:	ff 74 24 14          	pushl  0x14(%esp)
c0407f58:	ff 74 24 14          	pushl  0x14(%esp)
c0407f5c:	e8 6a fe ff ff       	call   c0407dcb <pg_map_phys_to_kernel_space>
c0407f61:	83 c4 10             	add    $0x10,%esp
	
	/* notify cpu of change in kernel directory */
   x86_load_cr3(KERNEL_LOG2PHYS(&KernelPageDirectory));
c0407f64:	b8 00 e0 40 c0       	mov    $0xc040e000,%eax
c0407f69:	05 00 00 00 40       	add    $0x40000000,%eax
c0407f6e:	83 ec 0c             	sub    $0xc,%esp
c0407f71:	50                   	push   %eax
c0407f72:	e8 6d 88 ff ff       	call   c04007e4 <x86_load_cr3>
c0407f77:	83 c4 10             	add    $0x10,%esp
   BOOT_DEBUG("[page:%i] vmm initialised\n", CPU_ID);
c0407f7a:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0407f7f:	3c 01                	cmp    $0x1,%al
c0407f81:	76 0c                	jbe    c0407f8f <pg_init+0xe5>
c0407f83:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0407f88:	8b 00                	mov    (%eax),%eax
c0407f8a:	c1 e8 18             	shr    $0x18,%eax
c0407f8d:	eb 08                	jmp    c0407f97 <pg_init+0xed>
c0407f8f:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0407f94:	0f b6 c0             	movzbl %al,%eax
c0407f97:	83 ec 08             	sub    $0x8,%esp
c0407f9a:	50                   	push   %eax
c0407f9b:	68 fc cd 40 c0       	push   $0xc040cdfc
c0407fa0:	e8 dd 3e 00 00       	call   c040be82 <debug_printf>
c0407fa5:	83 c4 10             	add    $0x10,%esp
}
c0407fa8:	83 c4 2c             	add    $0x2c,%esp
c0407fab:	c3                   	ret    

c0407fac <pg_dump_pagedir>:


/* pg_dump_pagedir
   For debug purposes, dump a copy of the current page directory */
void pg_dump_pagedir(unsigned int *pgdir)
{
c0407fac:	83 ec 10             	sub    $0x10,%esp
	unsigned int i;
	
	PAGE_DEBUG("[page:%i] contents of pgdir at %p (%x)\n", 
			  CPU_ID, pgdir, KERNEL_LOG2PHYS(pgdir));
	
	for(i = 0; i < 1024; i++)
c0407faf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0407fb6:	00 
c0407fb7:	eb 13                	jmp    c0407fcc <pg_dump_pagedir+0x20>
		if(pgdir[i])
c0407fb9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0407fbd:	c1 e0 02             	shl    $0x2,%eax
c0407fc0:	03 44 24 14          	add    0x14(%esp),%eax
c0407fc4:	8b 00                	mov    (%eax),%eax
c0407fc6:	85 c0                	test   %eax,%eax
	unsigned int i;
	
	PAGE_DEBUG("[page:%i] contents of pgdir at %p (%x)\n", 
			  CPU_ID, pgdir, KERNEL_LOG2PHYS(pgdir));
	
	for(i = 0; i < 1024; i++)
c0407fc8:	ff 44 24 0c          	incl   0xc(%esp)
c0407fcc:	81 7c 24 0c ff 03 00 	cmpl   $0x3ff,0xc(%esp)
c0407fd3:	00 
c0407fd4:	76 e3                	jbe    c0407fb9 <pg_dump_pagedir+0xd>
		if(pgdir[i])
		{
			PAGE_DEBUG("       kernel_dir[%i] = %x\n", i, pgdir[i]);
		}
}
c0407fd6:	83 c4 10             	add    $0x10,%esp
c0407fd9:	c3                   	ret    

c0407fda <pg_postmortem>:

/* pg_postmortem
 Perform a diagnostic dump if a page fault can't be handled */
void pg_postmortem(int_registers_block *regs)
{
c0407fda:	55                   	push   %ebp
c0407fdb:	57                   	push   %edi
c0407fdc:	56                   	push   %esi
c0407fdd:	53                   	push   %ebx
c0407fde:	83 ec 6c             	sub    $0x6c,%esp
	unsigned int faultaddr = x86_read_cr2();
c0407fe1:	e8 06 88 ff ff       	call   c04007ec <x86_read_cr2>
c0407fe6:	89 44 24 48          	mov    %eax,0x48(%esp)
	unsigned int pgdir_index = (faultaddr >> PG_DIR_BASE) & PG_INDEX_MASK;
c0407fea:	8b 44 24 48          	mov    0x48(%esp),%eax
c0407fee:	c1 e8 16             	shr    $0x16,%eax
c0407ff1:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	unsigned int pgtable_index = (faultaddr >> PG_TBL_BASE) & PG_INDEX_MASK;
c0407ff5:	8b 44 24 48          	mov    0x48(%esp),%eax
c0407ff9:	c1 e8 0c             	shr    $0xc,%eax
c0407ffc:	25 ff 03 00 00       	and    $0x3ff,%eax
c0408001:	89 44 24 50          	mov    %eax,0x50(%esp)
	unsigned int *pgtable; 
	thread *running = cpu_table[CPU_ID].current;
c0408005:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040800b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0408010:	3c 01                	cmp    $0x1,%al
c0408012:	76 0f                	jbe    c0408023 <pg_postmortem+0x49>
c0408014:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0408019:	8b 00                	mov    (%eax),%eax
c040801b:	c1 e8 18             	shr    $0x18,%eax
c040801e:	c1 e0 06             	shl    $0x6,%eax
c0408021:	eb 0b                	jmp    c040802e <pg_postmortem+0x54>
c0408023:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0408028:	0f b6 c0             	movzbl %al,%eax
c040802b:	c1 e0 06             	shl    $0x6,%eax
c040802e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c0408031:	8b 40 04             	mov    0x4(%eax),%eax
c0408034:	89 44 24 58          	mov    %eax,0x58(%esp)
	process *proc;
	char func[32];
	unsigned int sym_base = 0;
c0408038:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
c040803f:	00 

	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
c0408040:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408047:	8b 40 2c             	mov    0x2c(%eax),%eax
c040804a:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c040804f:	76 4f                	jbe    c04080a0 <pg_postmortem+0xc6>
c0408051:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408058:	8b 40 2c             	mov    0x2c(%eax),%eax
c040805b:	b9 38 1d 41 c0       	mov    $0xc0411d38,%ecx
c0408060:	ba 00 00 40 c0       	mov    $0xc0400000,%edx
c0408065:	89 cb                	mov    %ecx,%ebx
c0408067:	29 d3                	sub    %edx,%ebx
c0408069:	89 da                	mov    %ebx,%edx
c040806b:	c1 fa 02             	sar    $0x2,%edx
c040806e:	81 ea 00 00 c0 3f    	sub    $0x3fc00000,%edx
c0408074:	39 d0                	cmp    %edx,%eax
c0408076:	73 28                	jae    c04080a0 <pg_postmortem+0xc6>
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
c0408078:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040807f:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408082:	8d 54 24 24          	lea    0x24(%esp),%edx
c0408086:	52                   	push   %edx
c0408087:	6a 20                	push   $0x20
c0408089:	8d 54 24 30          	lea    0x30(%esp),%edx
c040808d:	52                   	push   %edx
c040808e:	50                   	push   %eax
c040808f:	e8 a2 40 00 00       	call   c040c136 <debug_lookup_symbol>
c0408094:	83 c4 10             	add    $0x10,%esp
c0408097:	85 c0                	test   %eax,%eax
c0408099:	74 05                	je     c04080a0 <pg_postmortem+0xc6>
			func[0] = NULL; /* or not.. */
c040809b:	c6 44 24 28 00       	movb   $0x0,0x28(%esp)
	
	KOOPS_DEBUG("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c04080a0:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080a7:	8b 70 3c             	mov    0x3c(%eax),%esi
c04080aa:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080b1:	8b 68 38             	mov    0x38(%eax),%ebp
c04080b4:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080bb:	8b 40 34             	mov    0x34(%eax),%eax
c04080be:	89 44 24 04          	mov    %eax,0x4(%esp)
c04080c2:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080c9:	8b 40 30             	mov    0x30(%eax),%eax
c04080cc:	89 44 24 08          	mov    %eax,0x8(%esp)
c04080d0:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080d7:	8b 40 20             	mov    0x20(%eax),%eax
c04080da:	89 44 24 0c          	mov    %eax,0xc(%esp)
c04080de:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080e5:	8b 40 10             	mov    0x10(%eax),%eax
c04080e8:	89 44 24 10          	mov    %eax,0x10(%esp)
c04080ec:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04080f3:	8b 40 0c             	mov    0xc(%eax),%eax
c04080f6:	89 44 24 14          	mov    %eax,0x14(%esp)
c04080fa:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408101:	8b 40 04             	mov    0x4(%eax),%eax
c0408104:	89 44 24 18          	mov    %eax,0x18(%esp)
c0408108:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040810f:	8b 00                	mov    (%eax),%eax
c0408111:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c0408115:	8b 7c 24 24          	mov    0x24(%esp),%edi
c0408119:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408120:	8b 58 2c             	mov    0x2c(%eax),%ebx
c0408123:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040812a:	8b 48 28             	mov    0x28(%eax),%ecx
					"      ds %x edi %x ebp %x esp %x\n"
				   "      eax %x cs %x eflags %x useresp %x ss %x\n",
				   CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
c040812d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
			func[0] = NULL; /* or not.. */
	
	KOOPS_DEBUG("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c0408132:	3c 01                	cmp    $0x1,%al
c0408134:	76 0e                	jbe    c0408144 <pg_postmortem+0x16a>
					"      ds %x edi %x ebp %x esp %x\n"
				   "      eax %x cs %x eflags %x useresp %x ss %x\n",
				   CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
c0408136:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040813b:	8b 00                	mov    (%eax),%eax
	/* get the function name of faulting instruction */
	if((regs->eip >= KERNEL_VIRTUAL_BASE) && (regs->eip < KERNEL_VIRTUAL_END))
		if(debug_lookup_symbol(regs->eip, func, 32, &sym_base) != success)
			func[0] = NULL; /* or not.. */
	
	KOOPS_DEBUG("[page:%i] fault: code %i eip %x (%x:%s) fault at %x\n"
c040813d:	89 c2                	mov    %eax,%edx
c040813f:	c1 ea 18             	shr    $0x18,%edx
c0408142:	eb 08                	jmp    c040814c <pg_postmortem+0x172>
c0408144:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0408149:	0f b6 d0             	movzbl %al,%edx
c040814c:	56                   	push   %esi
c040814d:	55                   	push   %ebp
c040814e:	ff 74 24 0c          	pushl  0xc(%esp)
c0408152:	ff 74 24 14          	pushl  0x14(%esp)
c0408156:	ff 74 24 1c          	pushl  0x1c(%esp)
c040815a:	ff 74 24 24          	pushl  0x24(%esp)
c040815e:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408162:	ff 74 24 34          	pushl  0x34(%esp)
c0408166:	ff 74 24 3c          	pushl  0x3c(%esp)
c040816a:	ff 74 24 6c          	pushl  0x6c(%esp)
c040816e:	8d 44 24 50          	lea    0x50(%esp),%eax
c0408172:	50                   	push   %eax
c0408173:	57                   	push   %edi
c0408174:	53                   	push   %ebx
c0408175:	51                   	push   %ecx
c0408176:	52                   	push   %edx
c0408177:	68 18 ce 40 c0       	push   $0xc040ce18
c040817c:	e8 01 3d 00 00       	call   c040be82 <debug_printf>
c0408181:	83 c4 40             	add    $0x40,%esp
				   "      eax %x cs %x eflags %x useresp %x ss %x\n",
				   CPU_ID, regs->errcode, regs->eip, sym_base, func, faultaddr,
				   regs->ds, regs->edi, regs->ebp, regs->esp,
				   regs->eax, regs->cs, regs->eflags, regs->useresp, regs->ss);
	
	KOOPS_DEBUG("      Reason: ");
c0408184:	83 ec 0c             	sub    $0xc,%esp
c0408187:	68 9c ce 40 c0       	push   $0xc040ce9c
c040818c:	e8 f1 3c 00 00       	call   c040be82 <debug_printf>
c0408191:	83 c4 10             	add    $0x10,%esp
	if(regs->errcode & PG_FAULT_P)
c0408194:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c040819b:	8b 40 28             	mov    0x28(%eax),%eax
c040819e:	83 e0 01             	and    $0x1,%eax
c04081a1:	84 c0                	test   %al,%al
c04081a3:	74 12                	je     c04081b7 <pg_postmortem+0x1dd>
	{
		KOOPS_DEBUG("AccessViolation ");
c04081a5:	83 ec 0c             	sub    $0xc,%esp
c04081a8:	68 ab ce 40 c0       	push   $0xc040ceab
c04081ad:	e8 d0 3c 00 00       	call   c040be82 <debug_printf>
c04081b2:	83 c4 10             	add    $0x10,%esp
c04081b5:	eb 10                	jmp    c04081c7 <pg_postmortem+0x1ed>
	}
	else
	{
		KOOPS_DEBUG("NotPresent ");
c04081b7:	83 ec 0c             	sub    $0xc,%esp
c04081ba:	68 bc ce 40 c0       	push   $0xc040cebc
c04081bf:	e8 be 3c 00 00       	call   c040be82 <debug_printf>
c04081c4:	83 c4 10             	add    $0x10,%esp
	}
	
	if(regs->errcode & PG_FAULT_W)
c04081c7:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c04081ce:	8b 40 28             	mov    0x28(%eax),%eax
c04081d1:	83 e0 02             	and    $0x2,%eax
c04081d4:	85 c0                	test   %eax,%eax
c04081d6:	74 12                	je     c04081ea <pg_postmortem+0x210>
	{
		KOOPS_DEBUG("Write ");
c04081d8:	83 ec 0c             	sub    $0xc,%esp
c04081db:	68 c8 ce 40 c0       	push   $0xc040cec8
c04081e0:	e8 9d 3c 00 00       	call   c040be82 <debug_printf>
c04081e5:	83 c4 10             	add    $0x10,%esp
c04081e8:	eb 10                	jmp    c04081fa <pg_postmortem+0x220>
	}
	else
	{
		KOOPS_DEBUG("Read ");
c04081ea:	83 ec 0c             	sub    $0xc,%esp
c04081ed:	68 cf ce 40 c0       	push   $0xc040cecf
c04081f2:	e8 8b 3c 00 00       	call   c040be82 <debug_printf>
c04081f7:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_U)
c04081fa:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408201:	8b 40 28             	mov    0x28(%eax),%eax
c0408204:	83 e0 04             	and    $0x4,%eax
c0408207:	85 c0                	test   %eax,%eax
c0408209:	74 12                	je     c040821d <pg_postmortem+0x243>
	{
		KOOPS_DEBUG("User ");
c040820b:	83 ec 0c             	sub    $0xc,%esp
c040820e:	68 d5 ce 40 c0       	push   $0xc040ced5
c0408213:	e8 6a 3c 00 00       	call   c040be82 <debug_printf>
c0408218:	83 c4 10             	add    $0x10,%esp
c040821b:	eb 10                	jmp    c040822d <pg_postmortem+0x253>
	}
	else
	{
		KOOPS_DEBUG("Kernel ");
c040821d:	83 ec 0c             	sub    $0xc,%esp
c0408220:	68 db ce 40 c0       	push   $0xc040cedb
c0408225:	e8 58 3c 00 00       	call   c040be82 <debug_printf>
c040822a:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_R)
c040822d:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408234:	8b 40 28             	mov    0x28(%eax),%eax
c0408237:	83 e0 08             	and    $0x8,%eax
c040823a:	85 c0                	test   %eax,%eax
c040823c:	74 10                	je     c040824e <pg_postmortem+0x274>
	{
		KOOPS_DEBUG("Reserved ");
c040823e:	83 ec 0c             	sub    $0xc,%esp
c0408241:	68 e3 ce 40 c0       	push   $0xc040cee3
c0408246:	e8 37 3c 00 00       	call   c040be82 <debug_printf>
c040824b:	83 c4 10             	add    $0x10,%esp
	}
	if(regs->errcode & PG_FAULT_I)
c040824e:	8b 84 24 80 00 00 00 	mov    0x80(%esp),%eax
c0408255:	8b 40 28             	mov    0x28(%eax),%eax
c0408258:	83 e0 10             	and    $0x10,%eax
c040825b:	85 c0                	test   %eax,%eax
c040825d:	74 10                	je     c040826f <pg_postmortem+0x295>
	{
		KOOPS_DEBUG("NoExecute ");
c040825f:	83 ec 0c             	sub    $0xc,%esp
c0408262:	68 ed ce 40 c0       	push   $0xc040ceed
c0408267:	e8 16 3c 00 00       	call   c040be82 <debug_printf>
c040826c:	83 c4 10             	add    $0x10,%esp
	}
	KOOPS_DEBUG("\n");
c040826f:	83 ec 0c             	sub    $0xc,%esp
c0408272:	68 f8 ce 40 c0       	push   $0xc040cef8
c0408277:	e8 06 3c 00 00       	call   c040be82 <debug_printf>
c040827c:	83 c4 10             	add    $0x10,%esp
	
	if(running)
c040827f:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
c0408284:	0f 84 bb 00 00 00    	je     c0408345 <pg_postmortem+0x36b>
	{
		proc = running->proc;
c040828a:	8b 44 24 58          	mov    0x58(%esp),%eax
c040828e:	8b 00                	mov    (%eax),%eax
c0408290:	89 44 24 5c          	mov    %eax,0x5c(%esp)
		
		KOOPS_DEBUG("      Faulting thread: %i (%p) in process %i (%p) with pg dir %p\n",
c0408294:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c0408298:	8b 48 20             	mov    0x20(%eax),%ecx
c040829b:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c040829f:	8b 10                	mov    (%eax),%edx
c04082a1:	8b 44 24 58          	mov    0x58(%esp),%eax
c04082a5:	8b 40 04             	mov    0x4(%eax),%eax
c04082a8:	83 ec 08             	sub    $0x8,%esp
c04082ab:	51                   	push   %ecx
c04082ac:	ff 74 24 68          	pushl  0x68(%esp)
c04082b0:	52                   	push   %edx
c04082b1:	ff 74 24 6c          	pushl  0x6c(%esp)
c04082b5:	50                   	push   %eax
c04082b6:	68 fc ce 40 c0       	push   $0xc040cefc
c04082bb:	e8 c2 3b 00 00       	call   c040be82 <debug_printf>
c04082c0:	83 c4 20             	add    $0x20,%esp
				  running->tid, running, proc->pid, proc, proc->pgdir);
		
		KOOPS_DEBUG("      Page directory entry %x = %x\n", pgdir_index, proc->pgdir[pgdir_index]);
c04082c3:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c04082c7:	8b 40 20             	mov    0x20(%eax),%eax
c04082ca:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c04082ce:	c1 e2 02             	shl    $0x2,%edx
c04082d1:	01 d0                	add    %edx,%eax
c04082d3:	8b 00                	mov    (%eax),%eax
c04082d5:	83 ec 04             	sub    $0x4,%esp
c04082d8:	50                   	push   %eax
c04082d9:	ff 74 24 54          	pushl  0x54(%esp)
c04082dd:	68 40 cf 40 c0       	push   $0xc040cf40
c04082e2:	e8 9b 3b 00 00       	call   c040be82 <debug_printf>
c04082e7:	83 c4 10             	add    $0x10,%esp
		pgtable = (unsigned int *)((unsigned int)proc->pgdir[pgdir_index] & PG_4K_MASK);
c04082ea:	8b 44 24 5c          	mov    0x5c(%esp),%eax
c04082ee:	8b 40 20             	mov    0x20(%eax),%eax
c04082f1:	8b 54 24 4c          	mov    0x4c(%esp),%edx
c04082f5:	c1 e2 02             	shl    $0x2,%edx
c04082f8:	01 d0                	add    %edx,%eax
c04082fa:	8b 00                	mov    (%eax),%eax
c04082fc:	25 00 f0 ff ff       	and    $0xfffff000,%eax
c0408301:	89 44 24 54          	mov    %eax,0x54(%esp)
		pgtable = KERNEL_PHYS2LOG(pgtable);
c0408305:	8b 44 24 54          	mov    0x54(%esp),%eax
c0408309:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040830e:	89 44 24 54          	mov    %eax,0x54(%esp)
		if(pgtable && (faultaddr < KERNEL_SPACE_BASE))
c0408312:	83 7c 24 54 00       	cmpl   $0x0,0x54(%esp)
c0408317:	74 2c                	je     c0408345 <pg_postmortem+0x36b>
c0408319:	81 7c 24 48 ff ff ff 	cmpl   $0xbfffffff,0x48(%esp)
c0408320:	bf 
c0408321:	77 22                	ja     c0408345 <pg_postmortem+0x36b>
		{
			KOOPS_DEBUG("      Page table entry %x = %x\n", pgtable_index, pgtable[pgtable_index]);
c0408323:	8b 44 24 50          	mov    0x50(%esp),%eax
c0408327:	c1 e0 02             	shl    $0x2,%eax
c040832a:	03 44 24 54          	add    0x54(%esp),%eax
c040832e:	8b 00                	mov    (%eax),%eax
c0408330:	83 ec 04             	sub    $0x4,%esp
c0408333:	50                   	push   %eax
c0408334:	ff 74 24 58          	pushl  0x58(%esp)
c0408338:	68 64 cf 40 c0       	push   $0xc040cf64
c040833d:	e8 40 3b 00 00       	call   c040be82 <debug_printf>
c0408342:	83 c4 10             	add    $0x10,%esp
		}
	}
}
c0408345:	83 c4 6c             	add    $0x6c,%esp
c0408348:	5b                   	pop    %ebx
c0408349:	5e                   	pop    %esi
c040834a:	5f                   	pop    %edi
c040834b:	5d                   	pop    %ebp
c040834c:	c3                   	ret    
c040834d:	00 00                	add    %al,(%eax)
	...

c0408350 <thread_find_thread>:

/* thread_find_thread
	<= return a pointer to a thread that matches the given tid owned by the
      given process, or NULL for failure */
thread *thread_find_thread(process *proc, unsigned int tid)
{
c0408350:	83 ec 1c             	sub    $0x1c,%esp
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;
c0408353:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408357:	83 e0 3f             	and    $0x3f,%eax
c040835a:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!tid || !proc)
c040835e:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0408363:	74 07                	je     c040836c <thread_find_thread+0x1c>
c0408365:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c040836a:	75 3d                	jne    c04083a9 <thread_find_thread+0x59>
	{
		KOOPS_DEBUG("[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n"
				      "            process %p tid %i\n", CPU_ID, proc, tid);
c040836c:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;

	if(!tid || !proc)
	{
		KOOPS_DEBUG("[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n"
c0408371:	3c 01                	cmp    $0x1,%al
c0408373:	76 0c                	jbe    c0408381 <thread_find_thread+0x31>
				      "            process %p tid %i\n", CPU_ID, proc, tid);
c0408375:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040837a:	8b 00                	mov    (%eax),%eax
	thread *search, **table;
	unsigned int hash = tid % THREAD_HASH_BUCKETS;

	if(!tid || !proc)
	{
		KOOPS_DEBUG("[thread:%i] OMGWTF thread_find_thread failed on sanity check.\n"
c040837c:	c1 e8 18             	shr    $0x18,%eax
c040837f:	eb 08                	jmp    c0408389 <thread_find_thread+0x39>
c0408381:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0408386:	0f b6 c0             	movzbl %al,%eax
c0408389:	ff 74 24 24          	pushl  0x24(%esp)
c040838d:	ff 74 24 24          	pushl  0x24(%esp)
c0408391:	50                   	push   %eax
c0408392:	68 84 cf 40 c0       	push   $0xc040cf84
c0408397:	e8 e6 3a 00 00       	call   c040be82 <debug_printf>
c040839c:	83 c4 10             	add    $0x10,%esp
				      "            process %p tid %i\n", CPU_ID, proc, tid);
		return NULL;
c040839f:	b8 00 00 00 00       	mov    $0x0,%eax
c04083a4:	e9 95 00 00 00       	jmp    c040843e <thread_find_thread+0xee>
	}

	if(lock_gate(&(proc->lock), LOCK_READ))
c04083a9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04083ad:	83 c0 10             	add    $0x10,%eax
c04083b0:	83 ec 08             	sub    $0x8,%esp
c04083b3:	6a 00                	push   $0x0
c04083b5:	50                   	push   %eax
c04083b6:	e8 dd 80 ff ff       	call   c0400498 <lock_gate>
c04083bb:	83 c4 10             	add    $0x10,%esp
c04083be:	85 c0                	test   %eax,%eax
c04083c0:	74 07                	je     c04083c9 <thread_find_thread+0x79>
		return NULL;
c04083c2:	b8 00 00 00 00       	mov    $0x0,%eax
c04083c7:	eb 75                	jmp    c040843e <thread_find_thread+0xee>
	
	table = proc->threads;
c04083c9:	8b 44 24 20          	mov    0x20(%esp),%eax
c04083cd:	8b 40 38             	mov    0x38(%eax),%eax
c04083d0:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	search = table[hash];
c04083d4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04083d8:	c1 e0 02             	shl    $0x2,%eax
c04083db:	03 44 24 08          	add    0x8(%esp),%eax
c04083df:	8b 00                	mov    (%eax),%eax
c04083e1:	89 44 24 04          	mov    %eax,0x4(%esp)
	while(search)
c04083e5:	eb 36                	jmp    c040841d <thread_find_thread+0xcd>
	{
		if(search->tid == tid)
c04083e7:	8b 44 24 04          	mov    0x4(%esp),%eax
c04083eb:	8b 40 04             	mov    0x4(%eax),%eax
c04083ee:	3b 44 24 24          	cmp    0x24(%esp),%eax
c04083f2:	75 1b                	jne    c040840f <thread_find_thread+0xbf>
		{
			unlock_gate(&(proc->lock), LOCK_READ);
c04083f4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04083f8:	83 c0 10             	add    $0x10,%eax
c04083fb:	83 ec 08             	sub    $0x8,%esp
c04083fe:	6a 00                	push   $0x0
c0408400:	50                   	push   %eax
c0408401:	e8 11 82 ff ff       	call   c0400617 <unlock_gate>
c0408406:	83 c4 10             	add    $0x10,%esp
			return search; /* foundya */
c0408409:	8b 44 24 04          	mov    0x4(%esp),%eax
c040840d:	eb 2f                	jmp    c040843e <thread_find_thread+0xee>
		}
		
		search = search->hash_next;
c040840f:	8b 44 24 04          	mov    0x4(%esp),%eax
c0408413:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0408419:	89 44 24 04          	mov    %eax,0x4(%esp)
		return NULL;
	
	table = proc->threads;
	
	search = table[hash];
	while(search)
c040841d:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0408422:	75 c3                	jne    c04083e7 <thread_find_thread+0x97>
		}
		
		search = search->hash_next;
	}
	
	unlock_gate(&(proc->lock), LOCK_READ);
c0408424:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408428:	83 c0 10             	add    $0x10,%eax
c040842b:	83 ec 08             	sub    $0x8,%esp
c040842e:	6a 00                	push   $0x0
c0408430:	50                   	push   %eax
c0408431:	e8 e1 81 ff ff       	call   c0400617 <unlock_gate>
c0408436:	83 c4 10             	add    $0x10,%esp
	return NULL; /* not found! */
c0408439:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040843e:	83 c4 1c             	add    $0x1c,%esp
c0408441:	c3                   	ret    

c0408442 <thread_duplicate>:
   => proc = process to create new thread for
      source = original thread to clone
   <= returns pointer to new thread or NULL for failure
*/
thread *thread_duplicate(process *proc, thread *source)
{
c0408442:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int kstack, hash;
	thread *new, **threads;
	
	if(lock_gate(&(proc->lock), LOCK_WRITE))
c0408445:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408449:	83 c0 10             	add    $0x10,%eax
c040844c:	83 ec 08             	sub    $0x8,%esp
c040844f:	6a 01                	push   $0x1
c0408451:	50                   	push   %eax
c0408452:	e8 41 80 ff ff       	call   c0400498 <lock_gate>
c0408457:	83 c4 10             	add    $0x10,%esp
c040845a:	85 c0                	test   %eax,%eax
c040845c:	74 0a                	je     c0408468 <thread_duplicate+0x26>
		return NULL;
c040845e:	b8 00 00 00 00       	mov    $0x0,%eax
c0408463:	e9 e9 02 00 00       	jmp    c0408751 <thread_duplicate+0x30f>
	if(lock_gate(&(source->lock), LOCK_READ))
c0408468:	8b 44 24 34          	mov    0x34(%esp),%eax
c040846c:	83 c0 1c             	add    $0x1c,%eax
c040846f:	83 ec 08             	sub    $0x8,%esp
c0408472:	6a 00                	push   $0x0
c0408474:	50                   	push   %eax
c0408475:	e8 1e 80 ff ff       	call   c0400498 <lock_gate>
c040847a:	83 c4 10             	add    $0x10,%esp
c040847d:	85 c0                	test   %eax,%eax
c040847f:	74 1f                	je     c04084a0 <thread_duplicate+0x5e>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c0408481:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408485:	83 c0 10             	add    $0x10,%eax
c0408488:	83 ec 08             	sub    $0x8,%esp
c040848b:	6a 01                	push   $0x1
c040848d:	50                   	push   %eax
c040848e:	e8 84 81 ff ff       	call   c0400617 <unlock_gate>
c0408493:	83 c4 10             	add    $0x10,%esp
		return NULL;
c0408496:	b8 00 00 00 00       	mov    $0x0,%eax
c040849b:	e9 b1 02 00 00       	jmp    c0408751 <thread_duplicate+0x30f>
	}
	
	/* grab memory and zero it now to store details of new thread */
	kresult err = vmm_malloc((void **)&new, sizeof(thread));
c04084a0:	8d 44 24 0c          	lea    0xc(%esp),%eax
c04084a4:	83 ec 08             	sub    $0x8,%esp
c04084a7:	68 f0 00 00 00       	push   $0xf0
c04084ac:	50                   	push   %eax
c04084ad:	e8 36 b6 ff ff       	call   c0403ae8 <vmm_malloc>
c04084b2:	83 c4 10             	add    $0x10,%esp
c04084b5:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c04084b9:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04084be:	74 34                	je     c04084f4 <thread_duplicate+0xb2>
	{
		unlock_gate(&(source->lock), LOCK_READ);
c04084c0:	8b 44 24 34          	mov    0x34(%esp),%eax
c04084c4:	83 c0 1c             	add    $0x1c,%eax
c04084c7:	83 ec 08             	sub    $0x8,%esp
c04084ca:	6a 00                	push   $0x0
c04084cc:	50                   	push   %eax
c04084cd:	e8 45 81 ff ff       	call   c0400617 <unlock_gate>
c04084d2:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c04084d5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04084d9:	83 c0 10             	add    $0x10,%eax
c04084dc:	83 ec 08             	sub    $0x8,%esp
c04084df:	6a 01                	push   $0x1
c04084e1:	50                   	push   %eax
c04084e2:	e8 30 81 ff ff       	call   c0400617 <unlock_gate>
c04084e7:	83 c4 10             	add    $0x10,%esp
		return NULL; /* fail if we can't alloc a new thread */
c04084ea:	b8 00 00 00 00       	mov    $0x0,%eax
c04084ef:	e9 5d 02 00 00       	jmp    c0408751 <thread_duplicate+0x30f>
	}
	vmm_memset(new, 0, sizeof(thread));
c04084f4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04084f8:	83 ec 04             	sub    $0x4,%esp
c04084fb:	68 f0 00 00 00       	push   $0xf0
c0408500:	6a 00                	push   $0x0
c0408502:	50                   	push   %eax
c0408503:	e8 24 c5 ff ff       	call   c0404a2c <vmm_memset>
c0408508:	83 c4 10             	add    $0x10,%esp
	
	/* initialise thread hash table if required */
	if(!(proc->threads))
c040850b:	8b 44 24 30          	mov    0x30(%esp),%eax
c040850f:	8b 40 38             	mov    0x38(%eax),%eax
c0408512:	85 c0                	test   %eax,%eax
c0408514:	75 5e                	jne    c0408574 <thread_duplicate+0x132>
	{
		thread_new_hash(proc);
c0408516:	83 ec 0c             	sub    $0xc,%esp
c0408519:	ff 74 24 3c          	pushl  0x3c(%esp)
c040851d:	e8 33 02 00 00       	call   c0408755 <thread_new_hash>
c0408522:	83 c4 10             	add    $0x10,%esp
		if(!(proc->threads))
c0408525:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408529:	8b 40 38             	mov    0x38(%eax),%eax
c040852c:	85 c0                	test   %eax,%eax
c040852e:	75 44                	jne    c0408574 <thread_duplicate+0x132>
		{
			vmm_free(new);
c0408530:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408534:	83 ec 0c             	sub    $0xc,%esp
c0408537:	50                   	push   %eax
c0408538:	e8 d2 b9 ff ff       	call   c0403f0f <vmm_free>
c040853d:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(source->lock), LOCK_READ);
c0408540:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408544:	83 c0 1c             	add    $0x1c,%eax
c0408547:	83 ec 08             	sub    $0x8,%esp
c040854a:	6a 00                	push   $0x0
c040854c:	50                   	push   %eax
c040854d:	e8 c5 80 ff ff       	call   c0400617 <unlock_gate>
c0408552:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(proc->lock), LOCK_WRITE);
c0408555:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408559:	83 c0 10             	add    $0x10,%eax
c040855c:	83 ec 08             	sub    $0x8,%esp
c040855f:	6a 01                	push   $0x1
c0408561:	50                   	push   %eax
c0408562:	e8 b0 80 ff ff       	call   c0400617 <unlock_gate>
c0408567:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040856a:	b8 00 00 00 00       	mov    $0x0,%eax
c040856f:	e9 dd 01 00 00       	jmp    c0408751 <thread_duplicate+0x30f>
		}
	}
	threads = proc->threads;
c0408574:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408578:	8b 40 38             	mov    0x38(%eax),%eax
c040857b:	89 44 24 18          	mov    %eax,0x18(%esp)
	
	new->proc          = proc;
c040857f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408583:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408587:	89 10                	mov    %edx,(%eax)
	new->tid           = source->tid;
c0408589:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040858d:	8b 54 24 34          	mov    0x34(%esp),%edx
c0408591:	8b 52 04             	mov    0x4(%edx),%edx
c0408594:	89 50 04             	mov    %edx,0x4(%eax)
	new->flags         = source->flags;
c0408597:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040859b:	8b 54 24 34          	mov    0x34(%esp),%edx
c040859f:	8a 52 0c             	mov    0xc(%edx),%dl
c04085a2:	88 50 0c             	mov    %dl,0xc(%eax)
	new->timeslice     = source->timeslice;
c04085a5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085a9:	8b 54 24 34          	mov    0x34(%esp),%edx
c04085ad:	8a 52 0d             	mov    0xd(%edx),%dl
c04085b0:	88 50 0d             	mov    %dl,0xd(%eax)
	new->priority      = source->priority;
c04085b3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085b7:	8b 54 24 34          	mov    0x34(%esp),%edx
c04085bb:	8a 52 0e             	mov    0xe(%edx),%dl
c04085be:	88 50 0e             	mov    %dl,0xe(%eax)
	new->prev_priority = source->prev_priority;
c04085c1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085c5:	8b 54 24 34          	mov    0x34(%esp),%edx
c04085c9:	8a 52 0f             	mov    0xf(%edx),%dl
c04085cc:	88 50 0f             	mov    %dl,0xf(%eax)
	new->stackbase		 = source->stackbase;
c04085cf:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085d3:	8b 54 24 34          	mov    0x34(%esp),%edx
c04085d7:	8b 52 2c             	mov    0x2c(%edx),%edx
c04085da:	89 50 2c             	mov    %edx,0x2c(%eax)

	/* the new thread is asleep and due to be scheduled */
	new->state = sleeping;
c04085dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085e1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
	
	/* clone the source thread's tss FIXME not very portable? :( */
	vmm_memcpy(&(new->tss), &(source->tss), sizeof(tss_descr));
c04085e8:	8b 44 24 34          	mov    0x34(%esp),%eax
c04085ec:	8d 50 38             	lea    0x38(%eax),%edx
c04085ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04085f3:	83 c0 38             	add    $0x38,%eax
c04085f6:	83 ec 04             	sub    $0x4,%esp
c04085f9:	6a 68                	push   $0x68
c04085fb:	52                   	push   %edx
c04085fc:	50                   	push   %eax
c04085fd:	e8 67 c4 ff ff       	call   c0404a69 <vmm_memcpy>
c0408602:	83 c4 10             	add    $0x10,%esp
	
	/* clone the source thread's kernel stack for this new thread */
	err = vmm_malloc((void **)&kstack, MEM_PGSIZE);
c0408605:	8d 44 24 10          	lea    0x10(%esp),%eax
c0408609:	83 ec 08             	sub    $0x8,%esp
c040860c:	68 00 10 00 00       	push   $0x1000
c0408611:	50                   	push   %eax
c0408612:	e8 d1 b4 ff ff       	call   c0403ae8 <vmm_malloc>
c0408617:	83 c4 10             	add    $0x10,%esp
c040861a:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	if(err)
c040861e:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c0408623:	74 44                	je     c0408669 <thread_duplicate+0x227>
	{
		unlock_gate(&(source->lock), LOCK_READ);
c0408625:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408629:	83 c0 1c             	add    $0x1c,%eax
c040862c:	83 ec 08             	sub    $0x8,%esp
c040862f:	6a 00                	push   $0x0
c0408631:	50                   	push   %eax
c0408632:	e8 e0 7f ff ff       	call   c0400617 <unlock_gate>
c0408637:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040863a:	8b 44 24 30          	mov    0x30(%esp),%eax
c040863e:	83 c0 10             	add    $0x10,%eax
c0408641:	83 ec 08             	sub    $0x8,%esp
c0408644:	6a 01                	push   $0x1
c0408646:	50                   	push   %eax
c0408647:	e8 cb 7f ff ff       	call   c0400617 <unlock_gate>
c040864c:	83 c4 10             	add    $0x10,%esp
		vmm_free(new);
c040864f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408653:	83 ec 0c             	sub    $0xc,%esp
c0408656:	50                   	push   %eax
c0408657:	e8 b3 b8 ff ff       	call   c0403f0f <vmm_free>
c040865c:	83 c4 10             	add    $0x10,%esp
		return NULL; /* something went wrong */
c040865f:	b8 00 00 00 00       	mov    $0x0,%eax
c0408664:	e9 e8 00 00 00       	jmp    c0408751 <thread_duplicate+0x30f>
	}
	
	/* stacks grow down, hence pushing base up */
	new->kstackblk = kstack;
c0408669:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040866d:	8b 54 24 10          	mov    0x10(%esp),%edx
c0408671:	89 50 34             	mov    %edx,0x34(%eax)
	new->kstackbase = kstack + MEM_PGSIZE;
c0408674:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408678:	8b 54 24 10          	mov    0x10(%esp),%edx
c040867c:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0408682:	89 50 30             	mov    %edx,0x30(%eax)
	
	/* copy thread state FIXME not very portable :( */
	vmm_memcpy(&(new->regs), &(source->regs), sizeof(int_registers_block));
c0408685:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408689:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c040868f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408693:	05 a0 00 00 00       	add    $0xa0,%eax
c0408698:	83 ec 04             	sub    $0x4,%esp
c040869b:	6a 40                	push   $0x40
c040869d:	52                   	push   %edx
c040869e:	50                   	push   %eax
c040869f:	e8 c5 c3 ff ff       	call   c0404a69 <vmm_memcpy>
c04086a4:	83 c4 10             	add    $0x10,%esp
	
	hash = new->tid % THREAD_HASH_BUCKETS;
c04086a7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04086ab:	8b 40 04             	mov    0x4(%eax),%eax
c04086ae:	83 e0 3f             	and    $0x3f,%eax
c04086b1:	89 44 24 14          	mov    %eax,0x14(%esp)
	if(threads[hash])
c04086b5:	8b 44 24 14          	mov    0x14(%esp),%eax
c04086b9:	c1 e0 02             	shl    $0x2,%eax
c04086bc:	03 44 24 18          	add    0x18(%esp),%eax
c04086c0:	8b 00                	mov    (%eax),%eax
c04086c2:	85 c0                	test   %eax,%eax
c04086c4:	74 30                	je     c04086f6 <thread_duplicate+0x2b4>
	{ 
		threads[hash]->hash_prev = new;
c04086c6:	8b 44 24 14          	mov    0x14(%esp),%eax
c04086ca:	c1 e0 02             	shl    $0x2,%eax
c04086cd:	03 44 24 18          	add    0x18(%esp),%eax
c04086d1:	8b 00                	mov    (%eax),%eax
c04086d3:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04086d7:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
		new->hash_next = threads[hash];
c04086dd:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04086e1:	8b 54 24 14          	mov    0x14(%esp),%edx
c04086e5:	c1 e2 02             	shl    $0x2,%edx
c04086e8:	03 54 24 18          	add    0x18(%esp),%edx
c04086ec:	8b 12                	mov    (%edx),%edx
c04086ee:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c04086f4:	eb 0e                	jmp    c0408704 <thread_duplicate+0x2c2>
	}
	else
	{
		new->hash_next = NULL;
c04086f6:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04086fa:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
c0408701:	00 00 00 
	}
	threads[hash] = new;
c0408704:	8b 44 24 14          	mov    0x14(%esp),%eax
c0408708:	c1 e0 02             	shl    $0x2,%eax
c040870b:	03 44 24 18          	add    0x18(%esp),%eax
c040870f:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408713:	89 10                	mov    %edx,(%eax)
	new->hash_prev = NULL;	
c0408715:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408719:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
c0408720:	00 00 00 
	
	unlock_gate(&(source->lock), LOCK_READ);
c0408723:	8b 44 24 34          	mov    0x34(%esp),%eax
c0408727:	83 c0 1c             	add    $0x1c,%eax
c040872a:	83 ec 08             	sub    $0x8,%esp
c040872d:	6a 00                	push   $0x0
c040872f:	50                   	push   %eax
c0408730:	e8 e2 7e ff ff       	call   c0400617 <unlock_gate>
c0408735:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(proc->lock), LOCK_WRITE);
c0408738:	8b 44 24 30          	mov    0x30(%esp),%eax
c040873c:	83 c0 10             	add    $0x10,%eax
c040873f:	83 ec 08             	sub    $0x8,%esp
c0408742:	6a 01                	push   $0x1
c0408744:	50                   	push   %eax
c0408745:	e8 cd 7e ff ff       	call   c0400617 <unlock_gate>
c040874a:	83 c4 10             	add    $0x10,%esp
	
	THREAD_DEBUG("[thread:%i] cloned thread %i of process %i for process %i (%p) (kstack %p)\n",
			  CPU_ID, source->tid, source->proc->pid, proc->pid, new, new->kstackbase);
	
	return new;
c040874d:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0408751:	83 c4 2c             	add    $0x2c,%esp
c0408754:	c3                   	ret    

c0408755 <thread_new_hash>:
/* thread_new_hash
	Create a new hash table for threads in the given process
   <= returns 0 for success, anything else is failure
*/
kresult thread_new_hash(process *proc)
{
c0408755:	83 ec 1c             	sub    $0x1c,%esp
	kresult err;
	thread **threads;
	
	if(lock_gate(&(proc->lock), LOCK_WRITE))
c0408758:	8b 44 24 20          	mov    0x20(%esp),%eax
c040875c:	83 c0 10             	add    $0x10,%eax
c040875f:	83 ec 08             	sub    $0x8,%esp
c0408762:	6a 01                	push   $0x1
c0408764:	50                   	push   %eax
c0408765:	e8 2e 7d ff ff       	call   c0400498 <lock_gate>
c040876a:	83 c4 10             	add    $0x10,%esp
c040876d:	85 c0                	test   %eax,%eax
c040876f:	74 0a                	je     c040877b <thread_new_hash+0x26>
		return e_failure;
c0408771:	b8 01 00 00 00       	mov    $0x1,%eax
c0408776:	e9 9e 00 00 00       	jmp    c0408819 <thread_new_hash+0xc4>
	
	if(proc->threads)
c040877b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040877f:	8b 40 38             	mov    0x38(%eax),%eax
c0408782:	85 c0                	test   %eax,%eax
c0408784:	74 1c                	je     c04087a2 <thread_new_hash+0x4d>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c0408786:	8b 44 24 20          	mov    0x20(%esp),%eax
c040878a:	83 c0 10             	add    $0x10,%eax
c040878d:	83 ec 08             	sub    $0x8,%esp
c0408790:	6a 01                	push   $0x1
c0408792:	50                   	push   %eax
c0408793:	e8 7f 7e ff ff       	call   c0400617 <unlock_gate>
c0408798:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040879b:	b8 01 00 00 00       	mov    $0x1,%eax
c04087a0:	eb 77                	jmp    c0408819 <thread_new_hash+0xc4>
	}
	
	err = vmm_malloc((void **)&threads, sizeof(thread *) * THREAD_HASH_BUCKETS);
c04087a2:	8d 44 24 08          	lea    0x8(%esp),%eax
c04087a6:	83 ec 08             	sub    $0x8,%esp
c04087a9:	68 00 01 00 00       	push   $0x100
c04087ae:	50                   	push   %eax
c04087af:	e8 34 b3 ff ff       	call   c0403ae8 <vmm_malloc>
c04087b4:	83 c4 10             	add    $0x10,%esp
c04087b7:	89 44 24 0c          	mov    %eax,0xc(%esp)
	if(err)
c04087bb:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c04087c0:	74 1b                	je     c04087dd <thread_new_hash+0x88>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c04087c2:	8b 44 24 20          	mov    0x20(%esp),%eax
c04087c6:	83 c0 10             	add    $0x10,%eax
c04087c9:	83 ec 08             	sub    $0x8,%esp
c04087cc:	6a 01                	push   $0x1
c04087ce:	50                   	push   %eax
c04087cf:	e8 43 7e ff ff       	call   c0400617 <unlock_gate>
c04087d4:	83 c4 10             	add    $0x10,%esp
		return err;
c04087d7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04087db:	eb 3c                	jmp    c0408819 <thread_new_hash+0xc4>
	}
	
	vmm_memset(threads, 0, sizeof(thread *) * THREAD_HASH_BUCKETS);
c04087dd:	8b 44 24 08          	mov    0x8(%esp),%eax
c04087e1:	83 ec 04             	sub    $0x4,%esp
c04087e4:	68 00 01 00 00       	push   $0x100
c04087e9:	6a 00                	push   $0x0
c04087eb:	50                   	push   %eax
c04087ec:	e8 3b c2 ff ff       	call   c0404a2c <vmm_memset>
c04087f1:	83 c4 10             	add    $0x10,%esp
	proc->threads = threads;
c04087f4:	8b 54 24 08          	mov    0x8(%esp),%edx
c04087f8:	8b 44 24 20          	mov    0x20(%esp),%eax
c04087fc:	89 50 38             	mov    %edx,0x38(%eax)
	
	unlock_gate(&(proc->lock), LOCK_WRITE);
c04087ff:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408803:	83 c0 10             	add    $0x10,%eax
c0408806:	83 ec 08             	sub    $0x8,%esp
c0408809:	6a 01                	push   $0x1
c040880b:	50                   	push   %eax
c040880c:	e8 06 7e ff ff       	call   c0400617 <unlock_gate>
c0408811:	83 c4 10             	add    $0x10,%esp
	
	THREAD_DEBUG("[thread:%i] created thread hash table %p for process %i\n",
			  CPU_ID, threads, proc->pid);

	return success;
c0408814:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0408819:	83 c4 1c             	add    $0x1c,%esp
c040881c:	c3                   	ret    

c040881d <thread_new>:
	Create a new thread inside a process
   => proc = pointer to process owning the thread
 <= pointer to new thread structure, or NULL for failure
*/
thread *thread_new(process *proc)
{
c040881d:	83 ec 2c             	sub    $0x2c,%esp
	kresult err;
	unsigned int tid_free = 0, hash, stackbase;
c0408820:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0408827:	00 
	thread *new;
	unsigned int kstack;
	
	if(!proc) return NULL; /* give up now if we get a bad pointer */
c0408828:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040882d:	75 0a                	jne    c0408839 <thread_new+0x1c>
c040882f:	b8 00 00 00 00       	mov    $0x0,%eax
c0408834:	e9 1f 03 00 00       	jmp    c0408b58 <thread_new+0x33b>
	
	lock_gate(&(proc->lock), LOCK_WRITE);
c0408839:	8b 44 24 30          	mov    0x30(%esp),%eax
c040883d:	83 c0 10             	add    $0x10,%eax
c0408840:	83 ec 08             	sub    $0x8,%esp
c0408843:	6a 01                	push   $0x1
c0408845:	50                   	push   %eax
c0408846:	e8 4d 7c ff ff       	call   c0400498 <lock_gate>
c040884b:	83 c4 10             	add    $0x10,%esp
	
	/* give up now if we have too many threads */
	if(proc->thread_count > THREAD_MAX_NR)
c040884e:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408852:	8b 40 3c             	mov    0x3c(%eax),%eax
c0408855:	3d 00 04 00 00       	cmp    $0x400,%eax
c040885a:	76 1f                	jbe    c040887b <thread_new+0x5e>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040885c:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408860:	83 c0 10             	add    $0x10,%eax
c0408863:	83 ec 08             	sub    $0x8,%esp
c0408866:	6a 01                	push   $0x1
c0408868:	50                   	push   %eax
c0408869:	e8 a9 7d ff ff       	call   c0400617 <unlock_gate>
c040886e:	83 c4 10             	add    $0x10,%esp
		return NULL;
c0408871:	b8 00 00 00 00       	mov    $0x0,%eax
c0408876:	e9 dd 02 00 00       	jmp    c0408b58 <thread_new+0x33b>
	}

	/* grab memory now to store details of new thread */
	err = vmm_malloc((void **)&new, sizeof(thread));
c040887b:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040887f:	83 ec 08             	sub    $0x8,%esp
c0408882:	68 f0 00 00 00       	push   $0xf0
c0408887:	50                   	push   %eax
c0408888:	e8 5b b2 ff ff       	call   c0403ae8 <vmm_malloc>
c040888d:	83 c4 10             	add    $0x10,%esp
c0408890:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(err)
c0408894:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c0408899:	74 1f                	je     c04088ba <thread_new+0x9d>
	{
		unlock_gate(&(proc->lock), LOCK_WRITE);
c040889b:	8b 44 24 30          	mov    0x30(%esp),%eax
c040889f:	83 c0 10             	add    $0x10,%eax
c04088a2:	83 ec 08             	sub    $0x8,%esp
c04088a5:	6a 01                	push   $0x1
c04088a7:	50                   	push   %eax
c04088a8:	e8 6a 7d ff ff       	call   c0400617 <unlock_gate>
c04088ad:	83 c4 10             	add    $0x10,%esp
		return NULL; /* fail if we can't alloc a new thread */
c04088b0:	b8 00 00 00 00       	mov    $0x0,%eax
c04088b5:	e9 9e 02 00 00       	jmp    c0408b58 <thread_new+0x33b>
	}
	vmm_memset(new, 0, sizeof(thread));
c04088ba:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04088be:	83 ec 04             	sub    $0x4,%esp
c04088c1:	68 f0 00 00 00       	push   $0xf0
c04088c6:	6a 00                	push   $0x0
c04088c8:	50                   	push   %eax
c04088c9:	e8 5e c1 ff ff       	call   c0404a2c <vmm_memset>
c04088ce:	83 c4 10             	add    $0x10,%esp
	
	/* kernel stack initialisation - just 4K per thread for now */
	err = vmm_malloc((void **)&kstack, MEM_PGSIZE);
c04088d1:	8d 44 24 08          	lea    0x8(%esp),%eax
c04088d5:	83 ec 08             	sub    $0x8,%esp
c04088d8:	68 00 10 00 00       	push   $0x1000
c04088dd:	50                   	push   %eax
c04088de:	e8 05 b2 ff ff       	call   c0403ae8 <vmm_malloc>
c04088e3:	83 c4 10             	add    $0x10,%esp
c04088e6:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(err)
c04088ea:	83 7c 24 10 00       	cmpl   $0x0,0x10(%esp)
c04088ef:	74 2f                	je     c0408920 <thread_new+0x103>
	{
		vmm_free(new);
c04088f1:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04088f5:	83 ec 0c             	sub    $0xc,%esp
c04088f8:	50                   	push   %eax
c04088f9:	e8 11 b6 ff ff       	call   c0403f0f <vmm_free>
c04088fe:	83 c4 10             	add    $0x10,%esp
		unlock_gate(&(proc->lock), LOCK_WRITE);
c0408901:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408905:	83 c0 10             	add    $0x10,%eax
c0408908:	83 ec 08             	sub    $0x8,%esp
c040890b:	6a 01                	push   $0x1
c040890d:	50                   	push   %eax
c040890e:	e8 04 7d ff ff       	call   c0400617 <unlock_gate>
c0408913:	83 c4 10             	add    $0x10,%esp
		return NULL; /* FIXME should really do some clean up if this fails */
c0408916:	b8 00 00 00 00       	mov    $0x0,%eax
c040891b:	e9 38 02 00 00       	jmp    c0408b58 <thread_new+0x33b>
	}
	vmm_memset((void *)kstack, 0, MEM_PGSIZE);
c0408920:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408924:	83 ec 04             	sub    $0x4,%esp
c0408927:	68 00 10 00 00       	push   $0x1000
c040892c:	6a 00                	push   $0x0
c040892e:	50                   	push   %eax
c040892f:	e8 f8 c0 ff ff       	call   c0404a2c <vmm_memset>
c0408934:	83 c4 10             	add    $0x10,%esp
	
	/* initialise thread hash table if required */
	if(!(proc->threads))
c0408937:	8b 44 24 30          	mov    0x30(%esp),%eax
c040893b:	8b 40 38             	mov    0x38(%eax),%eax
c040893e:	85 c0                	test   %eax,%eax
c0408940:	0f 85 ac 00 00 00    	jne    c04089f2 <thread_new+0x1d5>
	{
		thread_new_hash(proc);
c0408946:	83 ec 0c             	sub    $0xc,%esp
c0408949:	ff 74 24 3c          	pushl  0x3c(%esp)
c040894d:	e8 03 fe ff ff       	call   c0408755 <thread_new_hash>
c0408952:	83 c4 10             	add    $0x10,%esp
		if(!(proc->threads))
c0408955:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408959:	8b 40 38             	mov    0x38(%eax),%eax
c040895c:	85 c0                	test   %eax,%eax
c040895e:	0f 85 8e 00 00 00    	jne    c04089f2 <thread_new+0x1d5>
		{
			vmm_free((void *)kstack);
c0408964:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408968:	83 ec 0c             	sub    $0xc,%esp
c040896b:	50                   	push   %eax
c040896c:	e8 9e b5 ff ff       	call   c0403f0f <vmm_free>
c0408971:	83 c4 10             	add    $0x10,%esp
			vmm_free(new);
c0408974:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408978:	83 ec 0c             	sub    $0xc,%esp
c040897b:	50                   	push   %eax
c040897c:	e8 8e b5 ff ff       	call   c0403f0f <vmm_free>
c0408981:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(proc->lock), LOCK_WRITE);
c0408984:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408988:	83 c0 10             	add    $0x10,%eax
c040898b:	83 ec 08             	sub    $0x8,%esp
c040898e:	6a 01                	push   $0x1
c0408990:	50                   	push   %eax
c0408991:	e8 81 7c ff ff       	call   c0400617 <unlock_gate>
c0408996:	83 c4 10             	add    $0x10,%esp
			return NULL;
c0408999:	b8 00 00 00 00       	mov    $0x0,%eax
c040899e:	e9 b5 01 00 00       	jmp    c0408b58 <thread_new+0x33b>
	}

	/* search for an available thread id */
	while(!tid_free)
	{
		if(thread_find_thread(proc, proc->next_tid) == NULL)
c04089a3:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089a7:	8b 40 40             	mov    0x40(%eax),%eax
c04089aa:	83 ec 08             	sub    $0x8,%esp
c04089ad:	50                   	push   %eax
c04089ae:	ff 74 24 3c          	pushl  0x3c(%esp)
c04089b2:	e8 99 f9 ff ff       	call   c0408350 <thread_find_thread>
c04089b7:	83 c4 10             	add    $0x10,%esp
c04089ba:	85 c0                	test   %eax,%eax
c04089bc:	75 0a                	jne    c04089c8 <thread_new+0x1ab>
			tid_free = 1;
c04089be:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
c04089c5:	00 
c04089c6:	eb 2a                	jmp    c04089f2 <thread_new+0x1d5>
		else
		{
			proc->next_tid++;
c04089c8:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089cc:	8b 40 40             	mov    0x40(%eax),%eax
c04089cf:	8d 50 01             	lea    0x1(%eax),%edx
c04089d2:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089d6:	89 50 40             	mov    %edx,0x40(%eax)
			if(proc->next_tid >= THREAD_MAX_NR)
c04089d9:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089dd:	8b 40 40             	mov    0x40(%eax),%eax
c04089e0:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c04089e5:	76 0b                	jbe    c04089f2 <thread_new+0x1d5>
				proc->next_tid = FIRST_TID;
c04089e7:	8b 44 24 30          	mov    0x30(%esp),%eax
c04089eb:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)
			return NULL;
		}
	}

	/* search for an available thread id */
	while(!tid_free)
c04089f2:	83 7c 24 14 00       	cmpl   $0x0,0x14(%esp)
c04089f7:	74 aa                	je     c04089a3 <thread_new+0x186>
				proc->next_tid = FIRST_TID;
		}
	}

	/* assign our new TID */
	new->tid = proc->next_tid;
c04089f9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c04089fd:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408a01:	8b 52 40             	mov    0x40(%edx),%edx
c0408a04:	89 50 04             	mov    %edx,0x4(%eax)
	proc->next_tid++;
c0408a07:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a0b:	8b 40 40             	mov    0x40(%eax),%eax
c0408a0e:	8d 50 01             	lea    0x1(%eax),%edx
c0408a11:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a15:	89 50 40             	mov    %edx,0x40(%eax)
	if(proc->next_tid >= THREAD_MAX_NR)
c0408a18:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a1c:	8b 40 40             	mov    0x40(%eax),%eax
c0408a1f:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0408a24:	76 0b                	jbe    c0408a31 <thread_new+0x214>
		proc->next_tid = FIRST_TID;
c0408a26:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a2a:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)

	/* add it to the tid hash table of threads for this process */
	hash = new->tid % THREAD_HASH_BUCKETS;
c0408a31:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408a35:	8b 40 04             	mov    0x4(%eax),%eax
c0408a38:	83 e0 3f             	and    $0x3f,%eax
c0408a3b:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(proc->threads[hash])
c0408a3f:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a43:	8b 40 38             	mov    0x38(%eax),%eax
c0408a46:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408a4a:	c1 e2 02             	shl    $0x2,%edx
c0408a4d:	01 d0                	add    %edx,%eax
c0408a4f:	8b 00                	mov    (%eax),%eax
c0408a51:	85 c0                	test   %eax,%eax
c0408a53:	74 3a                	je     c0408a8f <thread_new+0x272>
	{
		proc->threads[hash]->hash_prev = new;
c0408a55:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408a59:	8b 40 38             	mov    0x38(%eax),%eax
c0408a5c:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408a60:	c1 e2 02             	shl    $0x2,%edx
c0408a63:	01 d0                	add    %edx,%eax
c0408a65:	8b 00                	mov    (%eax),%eax
c0408a67:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408a6b:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
		new->hash_next = proc->threads[hash];
c0408a71:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408a75:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408a79:	8b 52 38             	mov    0x38(%edx),%edx
c0408a7c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
c0408a80:	c1 e1 02             	shl    $0x2,%ecx
c0408a83:	01 ca                	add    %ecx,%edx
c0408a85:	8b 12                	mov    (%edx),%edx
c0408a87:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c0408a8d:	eb 0e                	jmp    c0408a9d <thread_new+0x280>
	}
	else
	{
		new->hash_next = NULL;
c0408a8f:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408a93:	c7 80 ec 00 00 00 00 	movl   $0x0,0xec(%eax)
c0408a9a:	00 00 00 
	}
	proc->threads[hash] = new;
c0408a9d:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408aa1:	8b 40 38             	mov    0x38(%eax),%eax
c0408aa4:	8b 54 24 18          	mov    0x18(%esp),%edx
c0408aa8:	c1 e2 02             	shl    $0x2,%edx
c0408aab:	8d 14 10             	lea    (%eax,%edx,1),%edx
c0408aae:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408ab2:	89 02                	mov    %eax,(%edx)
	new->hash_prev = NULL;
c0408ab4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408ab8:	c7 80 e8 00 00 00 00 	movl   $0x0,0xe8(%eax)
c0408abf:	00 00 00 

	/* fill in more details */
	new->proc = proc;
c0408ac2:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408ac6:	8b 54 24 30          	mov    0x30(%esp),%edx
c0408aca:	89 10                	mov    %edx,(%eax)
	proc->thread_count++;
c0408acc:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408ad0:	8b 40 3c             	mov    0x3c(%eax),%eax
c0408ad3:	8d 50 01             	lea    0x1(%eax),%edx
c0408ad6:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408ada:	89 50 3c             	mov    %edx,0x3c(%eax)

	/* create a vma for the thread's user stack - don't forget stacks grow down */
	stackbase = KERNEL_SPACE_BASE - (THREAD_MAX_STACK * MEM_PGSIZE * new->tid);
c0408add:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408ae1:	8b 40 04             	mov    0x4(%eax),%eax
c0408ae4:	ba 00 00 03 00       	mov    $0x30000,%edx
c0408ae9:	89 d1                	mov    %edx,%ecx
c0408aeb:	29 c1                	sub    %eax,%ecx
c0408aed:	89 c8                	mov    %ecx,%eax
c0408aef:	c1 e0 0e             	shl    $0xe,%eax
c0408af2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	vmm_add_vma(proc, stackbase - (THREAD_MAX_STACK * MEM_PGSIZE), (THREAD_MAX_STACK * MEM_PGSIZE),
c0408af6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0408afa:	2d 00 40 00 00       	sub    $0x4000,%eax
c0408aff:	83 ec 0c             	sub    $0xc,%esp
c0408b02:	6a 00                	push   $0x0
c0408b04:	6a 03                	push   $0x3
c0408b06:	68 00 40 00 00       	push   $0x4000
c0408b0b:	50                   	push   %eax
c0408b0c:	ff 74 24 4c          	pushl  0x4c(%esp)
c0408b10:	e8 c5 e2 ff ff       	call   c0406dda <vmm_add_vma>
c0408b15:	83 c4 20             	add    $0x20,%esp
					VMA_READABLE | VMA_WRITEABLE | VMA_MEMSOURCE, 0);
	new->stackbase = stackbase;
c0408b18:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408b1c:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0408b20:	89 50 2c             	mov    %edx,0x2c(%eax)

	/* stacks grow down... */
	new->kstackblk = kstack;
c0408b23:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408b27:	8b 54 24 08          	mov    0x8(%esp),%edx
c0408b2b:	89 50 34             	mov    %edx,0x34(%eax)
	new->kstackbase = (kstack + MEM_PGSIZE);
c0408b2e:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408b32:	8b 54 24 08          	mov    0x8(%esp),%edx
c0408b36:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0408b3c:	89 50 30             	mov    %edx,0x30(%eax)

	unlock_gate(&(proc->lock), LOCK_WRITE);
c0408b3f:	8b 44 24 30          	mov    0x30(%esp),%eax
c0408b43:	83 c0 10             	add    $0x10,%eax
c0408b46:	83 ec 08             	sub    $0x8,%esp
c0408b49:	6a 01                	push   $0x1
c0408b4b:	50                   	push   %eax
c0408b4c:	e8 c6 7a ff ff       	call   c0400617 <unlock_gate>
c0408b51:	83 c4 10             	add    $0x10,%esp

	THREAD_DEBUG("[thread:%i] created thread %p tid %i (ustack %p kstack %p) for process %i\n",
			  CPU_ID, new, new->tid, new->stackbase, new->kstackbase, proc->pid);

	return new;
c0408b54:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c0408b58:	83 c4 2c             	add    $0x2c,%esp
c0408b5b:	c3                   	ret    

c0408b5c <thread_kill>:
   => owner = process holding the thread
      victim = thread to kill or NULL for all threads - ONLY call on process shutdown
   <= success or e_failure if something went wrong
*/
kresult thread_kill(process *owner, thread *victim)
{
c0408b5c:	56                   	push   %esi
c0408b5d:	53                   	push   %ebx
c0408b5e:	83 ec 14             	sub    $0x14,%esp
	unsigned int physaddr;
	
	if(!owner) return e_failure;
c0408b61:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0408b66:	75 0a                	jne    c0408b72 <thread_kill+0x16>
c0408b68:	b8 01 00 00 00       	mov    $0x1,%eax
c0408b6d:	e9 8f 02 00 00       	jmp    c0408e01 <thread_kill+0x2a5>
		
	if(victim)
c0408b72:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0408b77:	0f 84 ed 01 00 00    	je     c0408d6a <thread_kill+0x20e>
	{
		if(victim->proc != owner) return e_failure;
c0408b7d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408b81:	8b 00                	mov    (%eax),%eax
c0408b83:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0408b87:	74 0a                	je     c0408b93 <thread_kill+0x37>
c0408b89:	b8 01 00 00 00       	mov    $0x1,%eax
c0408b8e:	e9 6e 02 00 00       	jmp    c0408e01 <thread_kill+0x2a5>
		
		/* stop this thread from running and lock it */
		if(lock_gate(&(victim->lock), LOCK_WRITE | LOCK_SELFDESTRUCT))
c0408b93:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408b97:	83 c0 1c             	add    $0x1c,%eax
c0408b9a:	83 ec 08             	sub    $0x8,%esp
c0408b9d:	6a 03                	push   $0x3
c0408b9f:	50                   	push   %eax
c0408ba0:	e8 f3 78 ff ff       	call   c0400498 <lock_gate>
c0408ba5:	83 c4 10             	add    $0x10,%esp
c0408ba8:	85 c0                	test   %eax,%eax
c0408baa:	74 0a                	je     c0408bb6 <thread_kill+0x5a>
			return e_failure;
c0408bac:	b8 01 00 00 00       	mov    $0x1,%eax
c0408bb1:	e9 4b 02 00 00       	jmp    c0408e01 <thread_kill+0x2a5>
		
		/* if we can't lock then assume it's this thread that's dying */
		if(sched_lock_thread(victim)) sched_remove(victim, dead);
c0408bb6:	83 ec 0c             	sub    $0xc,%esp
c0408bb9:	ff 74 24 30          	pushl  0x30(%esp)
c0408bbd:	e8 a2 9e ff ff       	call   c0402a64 <sched_lock_thread>
c0408bc2:	83 c4 10             	add    $0x10,%esp
c0408bc5:	85 c0                	test   %eax,%eax
c0408bc7:	74 11                	je     c0408bda <thread_kill+0x7e>
c0408bc9:	83 ec 08             	sub    $0x8,%esp
c0408bcc:	6a 06                	push   $0x6
c0408bce:	ff 74 24 30          	pushl  0x30(%esp)
c0408bd2:	e8 c0 ab ff ff       	call   c0403797 <sched_remove>
c0408bd7:	83 c4 10             	add    $0x10,%esp
		
		/* free the thread's user stack' physical pages and unset the table entries */
		if(pg_user2phys(&physaddr, owner->pgdir, victim->stackbase - MEM_PGSIZE) == success)
c0408bda:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408bde:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408be1:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
c0408be7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408beb:	8b 40 20             	mov    0x20(%eax),%eax
c0408bee:	83 ec 04             	sub    $0x4,%esp
c0408bf1:	52                   	push   %edx
c0408bf2:	50                   	push   %eax
c0408bf3:	8d 44 24 14          	lea    0x14(%esp),%eax
c0408bf7:	50                   	push   %eax
c0408bf8:	e8 e8 ee ff ff       	call   c0407ae5 <pg_user2phys>
c0408bfd:	83 c4 10             	add    $0x10,%esp
c0408c00:	85 c0                	test   %eax,%eax
c0408c02:	0f 85 8c 00 00 00    	jne    c0408c94 <thread_kill+0x138>
		{
			if(vmm_return_phys_pg((unsigned int *)physaddr) == success)
c0408c08:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408c0c:	83 ec 0c             	sub    $0xc,%esp
c0408c0f:	50                   	push   %eax
c0408c10:	e8 14 b7 ff ff       	call   c0404329 <vmm_return_phys_pg>
c0408c15:	83 c4 10             	add    $0x10,%esp
c0408c18:	85 c0                	test   %eax,%eax
c0408c1a:	75 24                	jne    c0408c40 <thread_kill+0xe4>
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
c0408c1c:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408c20:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408c23:	8d 90 00 f0 ff ff    	lea    -0x1000(%eax),%edx
c0408c29:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408c2d:	8b 40 20             	mov    0x20(%eax),%eax
c0408c30:	6a 00                	push   $0x0
c0408c32:	6a 00                	push   $0x0
c0408c34:	52                   	push   %edx
c0408c35:	50                   	push   %eax
c0408c36:	e8 a1 ef ff ff       	call   c0407bdc <pg_add_4K_mapping>
c0408c3b:	83 c4 10             	add    $0x10,%esp
c0408c3e:	eb 54                	jmp    c0408c94 <thread_kill+0x138>
			}
			else
			{
				KOOPS_DEBUG("[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n"
c0408c40:	8b 74 24 08          	mov    0x8(%esp),%esi
c0408c44:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408c48:	8b 58 2c             	mov    0x2c(%eax),%ebx
c0408c4b:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408c4f:	8b 08                	mov    (%eax),%ecx
c0408c51:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408c55:	8b 50 04             	mov    0x4(%eax),%edx
						       "            thread %i (%p) process %i (%p) usr %x phys %x\n",
						       CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
c0408c58:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
			}
			else
			{
				KOOPS_DEBUG("[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n"
c0408c5d:	3c 01                	cmp    $0x1,%al
c0408c5f:	76 0c                	jbe    c0408c6d <thread_kill+0x111>
						       "            thread %i (%p) process %i (%p) usr %x phys %x\n",
						       CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
c0408c61:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0408c66:	8b 00                	mov    (%eax),%eax
			{
				pg_add_4K_mapping(owner->pgdir, victim->stackbase - MEM_PGSIZE, NULL, 0);
			}
			else
			{
				KOOPS_DEBUG("[thread:%i] OMGWTF returning physical page from dying thread's stack failed\n"
c0408c68:	c1 e8 18             	shr    $0x18,%eax
c0408c6b:	eb 08                	jmp    c0408c75 <thread_kill+0x119>
c0408c6d:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0408c72:	0f b6 c0             	movzbl %al,%eax
c0408c75:	56                   	push   %esi
c0408c76:	53                   	push   %ebx
c0408c77:	ff 74 24 28          	pushl  0x28(%esp)
c0408c7b:	51                   	push   %ecx
c0408c7c:	ff 74 24 34          	pushl  0x34(%esp)
c0408c80:	52                   	push   %edx
c0408c81:	50                   	push   %eax
c0408c82:	68 e4 cf 40 c0       	push   $0xc040cfe4
c0408c87:	e8 f6 31 00 00       	call   c040be82 <debug_printf>
c0408c8c:	83 c4 20             	add    $0x20,%esp
						       "            thread %i (%p) process %i (%p) usr %x phys %x\n",
						       CPU_ID, victim->tid, victim, owner->pid, owner, victim->stackbase, physaddr);
				debug_stacktrace();
c0408c8f:	e8 df 2a 00 00       	call   c040b773 <debug_stacktrace>
			}
		}

		/* unlink thread from the process's thread hash table */
	  lock_gate(&(owner->lock), LOCK_WRITE);
c0408c94:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408c98:	83 c0 10             	add    $0x10,%eax
c0408c9b:	83 ec 08             	sub    $0x8,%esp
c0408c9e:	6a 01                	push   $0x1
c0408ca0:	50                   	push   %eax
c0408ca1:	e8 f2 77 ff ff       	call   c0400498 <lock_gate>
c0408ca6:	83 c4 10             	add    $0x10,%esp
					  
	  if(victim->hash_next)
c0408ca9:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408cad:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0408cb3:	85 c0                	test   %eax,%eax
c0408cb5:	74 1a                	je     c0408cd1 <thread_kill+0x175>
			victim->hash_next->hash_prev = victim->hash_prev;
c0408cb7:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408cbb:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0408cc1:	8b 54 24 24          	mov    0x24(%esp),%edx
c0408cc5:	8b 92 e8 00 00 00    	mov    0xe8(%edx),%edx
c0408ccb:	89 90 e8 00 00 00    	mov    %edx,0xe8(%eax)
	  if(victim->hash_prev)
c0408cd1:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408cd5:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
c0408cdb:	85 c0                	test   %eax,%eax
c0408cdd:	74 1c                	je     c0408cfb <thread_kill+0x19f>
			victim->hash_prev->hash_next = victim->hash_next;
c0408cdf:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408ce3:	8b 80 e8 00 00 00    	mov    0xe8(%eax),%eax
c0408ce9:	8b 54 24 24          	mov    0x24(%esp),%edx
c0408ced:	8b 92 ec 00 00 00    	mov    0xec(%edx),%edx
c0408cf3:	89 90 ec 00 00 00    	mov    %edx,0xec(%eax)
c0408cf9:	eb 22                	jmp    c0408d1d <thread_kill+0x1c1>
	  else
	  /* we were the hash table entry head, so fixup table */
			owner->threads[victim->tid % THREAD_HASH_BUCKETS] = victim->hash_next;
c0408cfb:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408cff:	8b 50 38             	mov    0x38(%eax),%edx
c0408d02:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408d06:	8b 40 04             	mov    0x4(%eax),%eax
c0408d09:	83 e0 3f             	and    $0x3f,%eax
c0408d0c:	c1 e0 02             	shl    $0x2,%eax
c0408d0f:	01 c2                	add    %eax,%edx
c0408d11:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408d15:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0408d1b:	89 02                	mov    %eax,(%edx)

		owner->thread_count--;
c0408d1d:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408d21:	8b 40 3c             	mov    0x3c(%eax),%eax
c0408d24:	8d 50 ff             	lea    -0x1(%eax),%edx
c0408d27:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408d2b:	89 50 3c             	mov    %edx,0x3c(%eax)
		unlock_gate(&(owner->lock), LOCK_WRITE);
c0408d2e:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408d32:	83 c0 10             	add    $0x10,%eax
c0408d35:	83 ec 08             	sub    $0x8,%esp
c0408d38:	6a 01                	push   $0x1
c0408d3a:	50                   	push   %eax
c0408d3b:	e8 d7 78 ff ff       	call   c0400617 <unlock_gate>
c0408d40:	83 c4 10             	add    $0x10,%esp
		
		/* free up resources */
		vmm_free((void *)(victim->kstackblk));
c0408d43:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408d47:	8b 40 34             	mov    0x34(%eax),%eax
c0408d4a:	83 ec 0c             	sub    $0xc,%esp
c0408d4d:	50                   	push   %eax
c0408d4e:	e8 bc b1 ff ff       	call   c0403f0f <vmm_free>
c0408d53:	83 c4 10             	add    $0x10,%esp
		vmm_free(victim);
c0408d56:	83 ec 0c             	sub    $0xc,%esp
c0408d59:	ff 74 24 30          	pushl  0x30(%esp)
c0408d5d:	e8 ad b1 ff ff       	call   c0403f0f <vmm_free>
c0408d62:	83 c4 10             	add    $0x10,%esp
c0408d65:	e9 92 00 00 00       	jmp    c0408dfc <thread_kill+0x2a0>
	else
	{
		/* destroy all threads one-by-one */
		unsigned int loop;
		
		lock_gate(&(owner->lock), LOCK_WRITE);
c0408d6a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408d6e:	83 c0 10             	add    $0x10,%eax
c0408d71:	83 ec 08             	sub    $0x8,%esp
c0408d74:	6a 01                	push   $0x1
c0408d76:	50                   	push   %eax
c0408d77:	e8 1c 77 ff ff       	call   c0400498 <lock_gate>
c0408d7c:	83 c4 10             	add    $0x10,%esp
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0408d7f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0408d86:	00 
c0408d87:	eb 44                	jmp    c0408dcd <thread_kill+0x271>
		{
			victim = owner->threads[loop];
c0408d89:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408d8d:	8b 40 38             	mov    0x38(%eax),%eax
c0408d90:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408d94:	c1 e2 02             	shl    $0x2,%edx
c0408d97:	01 d0                	add    %edx,%eax
c0408d99:	8b 00                	mov    (%eax),%eax
c0408d9b:	89 44 24 24          	mov    %eax,0x24(%esp)
			
			while(victim)
c0408d9f:	eb 21                	jmp    c0408dc2 <thread_kill+0x266>
			{
				thread_kill(owner, victim);
c0408da1:	83 ec 08             	sub    $0x8,%esp
c0408da4:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408da8:	ff 74 24 2c          	pushl  0x2c(%esp)
c0408dac:	e8 ab fd ff ff       	call   c0408b5c <thread_kill>
c0408db1:	83 c4 10             	add    $0x10,%esp
				victim = victim->hash_next;
c0408db4:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408db8:	8b 80 ec 00 00 00    	mov    0xec(%eax),%eax
c0408dbe:	89 44 24 24          	mov    %eax,0x24(%esp)
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
		{
			victim = owner->threads[loop];
			
			while(victim)
c0408dc2:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0408dc7:	75 d8                	jne    c0408da1 <thread_kill+0x245>
		/* destroy all threads one-by-one */
		unsigned int loop;
		
		lock_gate(&(owner->lock), LOCK_WRITE);
		
		for(loop = 0; loop < THREAD_HASH_BUCKETS; loop++)
c0408dc9:	ff 44 24 0c          	incl   0xc(%esp)
c0408dcd:	83 7c 24 0c 3f       	cmpl   $0x3f,0xc(%esp)
c0408dd2:	76 b5                	jbe    c0408d89 <thread_kill+0x22d>
				victim = victim->hash_next;
			}
		}
		
		/* release the thread hash table */
		vmm_free(owner->threads);
c0408dd4:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408dd8:	8b 40 38             	mov    0x38(%eax),%eax
c0408ddb:	83 ec 0c             	sub    $0xc,%esp
c0408dde:	50                   	push   %eax
c0408ddf:	e8 2b b1 ff ff       	call   c0403f0f <vmm_free>
c0408de4:	83 c4 10             	add    $0x10,%esp
		
		unlock_gate(&(owner->lock), LOCK_WRITE);
c0408de7:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408deb:	83 c0 10             	add    $0x10,%eax
c0408dee:	83 ec 08             	sub    $0x8,%esp
c0408df1:	6a 01                	push   $0x1
c0408df3:	50                   	push   %eax
c0408df4:	e8 1e 78 ff ff       	call   c0400617 <unlock_gate>
c0408df9:	83 c4 10             	add    $0x10,%esp
	}
	
	return success;
c0408dfc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0408e01:	83 c4 14             	add    $0x14,%esp
c0408e04:	5b                   	pop    %ebx
c0408e05:	5e                   	pop    %esi
c0408e06:	c3                   	ret    
	...

c0408e08 <proc_find_proc>:
rw_gate proc_lock;

/* proc_find_proc
	<= return a pointer to a process that matches the given pid, or NULL for failure */
process *proc_find_proc(unsigned int pid)
{
c0408e08:	83 ec 1c             	sub    $0x1c,%esp
	process *search;
	unsigned int hash = pid % PROC_HASH_BUCKETS;
c0408e0b:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408e0f:	83 e0 7f             	and    $0x7f,%eax
c0408e12:	89 44 24 0c          	mov    %eax,0xc(%esp)

	lock_gate(&proc_lock, LOCK_READ);
c0408e16:	83 ec 08             	sub    $0x8,%esp
c0408e19:	6a 00                	push   $0x0
c0408e1b:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0408e20:	e8 73 76 ff ff       	call   c0400498 <lock_gate>
c0408e25:	83 c4 10             	add    $0x10,%esp
	
	search = proc_table[hash];
c0408e28:	a1 0c 1d 41 c0       	mov    0xc0411d0c,%eax
c0408e2d:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408e31:	c1 e2 02             	shl    $0x2,%edx
c0408e34:	01 d0                	add    %edx,%eax
c0408e36:	8b 00                	mov    (%eax),%eax
c0408e38:	89 44 24 08          	mov    %eax,0x8(%esp)
	while(search)
c0408e3c:	eb 2f                	jmp    c0408e6d <proc_find_proc+0x65>
	{
		if(search->pid == pid)
c0408e3e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408e42:	8b 00                	mov    (%eax),%eax
c0408e44:	3b 44 24 20          	cmp    0x20(%esp),%eax
c0408e48:	75 18                	jne    c0408e62 <proc_find_proc+0x5a>
		{
			unlock_gate(&proc_lock, LOCK_READ);
c0408e4a:	83 ec 08             	sub    $0x8,%esp
c0408e4d:	6a 00                	push   $0x0
c0408e4f:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0408e54:	e8 be 77 ff ff       	call   c0400617 <unlock_gate>
c0408e59:	83 c4 10             	add    $0x10,%esp
			return search; /* foundya */
c0408e5c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408e60:	eb 29                	jmp    c0408e8b <proc_find_proc+0x83>
		}
			
		search = search->hash_next;
c0408e62:	8b 44 24 08          	mov    0x8(%esp),%eax
c0408e66:	8b 40 28             	mov    0x28(%eax),%eax
c0408e69:	89 44 24 08          	mov    %eax,0x8(%esp)
	unsigned int hash = pid % PROC_HASH_BUCKETS;

	lock_gate(&proc_lock, LOCK_READ);
	
	search = proc_table[hash];
	while(search)
c0408e6d:	83 7c 24 08 00       	cmpl   $0x0,0x8(%esp)
c0408e72:	75 ca                	jne    c0408e3e <proc_find_proc+0x36>
		}
			
		search = search->hash_next;
	}

	unlock_gate(&proc_lock, LOCK_READ);
c0408e74:	83 ec 08             	sub    $0x8,%esp
c0408e77:	6a 00                	push   $0x0
c0408e79:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0408e7e:	e8 94 77 ff ff       	call   c0400617 <unlock_gate>
c0408e83:	83 c4 10             	add    $0x10,%esp
	return NULL; /* not found! */
c0408e86:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0408e8b:	83 c4 1c             	add    $0x1c,%esp
c0408e8e:	c3                   	ret    

c0408e8f <proc_is_child>:
   <= success if child is a descdenant of parent
		e_not_found if the child couldn't be found
      e_failure if parameters are invalid
*/
kresult proc_is_child(process *parent, process *child)
{
c0408e8f:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int loop;
	
	/* sanity check.. */
	if(!parent || !child) return e_failure;
c0408e92:	83 7c 24 20 00       	cmpl   $0x0,0x20(%esp)
c0408e97:	74 07                	je     c0408ea0 <proc_is_child+0x11>
c0408e99:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c0408e9e:	75 0a                	jne    c0408eaa <proc_is_child+0x1b>
c0408ea0:	b8 01 00 00 00       	mov    $0x1,%eax
c0408ea5:	e9 89 00 00 00       	jmp    c0408f33 <proc_is_child+0xa4>
	
	if(lock_gate(&(parent->lock), LOCK_READ))
c0408eaa:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408eae:	83 c0 10             	add    $0x10,%eax
c0408eb1:	83 ec 08             	sub    $0x8,%esp
c0408eb4:	6a 00                	push   $0x0
c0408eb6:	50                   	push   %eax
c0408eb7:	e8 dc 75 ff ff       	call   c0400498 <lock_gate>
c0408ebc:	83 c4 10             	add    $0x10,%esp
c0408ebf:	85 c0                	test   %eax,%eax
c0408ec1:	74 07                	je     c0408eca <proc_is_child+0x3b>
		return e_failure;
c0408ec3:	b8 01 00 00 00       	mov    $0x1,%eax
c0408ec8:	eb 69                	jmp    c0408f33 <proc_is_child+0xa4>
	
	/* check the child on the parent's child list */
	for(loop = 0; loop < parent->child_list_size; loop++)
c0408eca:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0408ed1:	00 
c0408ed2:	eb 38                	jmp    c0408f0c <proc_is_child+0x7d>
		if(parent->children[loop] == child)
c0408ed4:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408ed8:	8b 40 2c             	mov    0x2c(%eax),%eax
c0408edb:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0408edf:	c1 e2 02             	shl    $0x2,%edx
c0408ee2:	01 d0                	add    %edx,%eax
c0408ee4:	8b 00                	mov    (%eax),%eax
c0408ee6:	3b 44 24 24          	cmp    0x24(%esp),%eax
c0408eea:	75 1c                	jne    c0408f08 <proc_is_child+0x79>
		{
			unlock_gate(&(parent->lock), LOCK_READ);
c0408eec:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408ef0:	83 c0 10             	add    $0x10,%eax
c0408ef3:	83 ec 08             	sub    $0x8,%esp
c0408ef6:	6a 00                	push   $0x0
c0408ef8:	50                   	push   %eax
c0408ef9:	e8 19 77 ff ff       	call   c0400617 <unlock_gate>
c0408efe:	83 c4 10             	add    $0x10,%esp
			return success;
c0408f01:	b8 00 00 00 00       	mov    $0x0,%eax
c0408f06:	eb 2b                	jmp    c0408f33 <proc_is_child+0xa4>
	
	if(lock_gate(&(parent->lock), LOCK_READ))
		return e_failure;
	
	/* check the child on the parent's child list */
	for(loop = 0; loop < parent->child_list_size; loop++)
c0408f08:	ff 44 24 0c          	incl   0xc(%esp)
c0408f0c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f10:	8b 40 30             	mov    0x30(%eax),%eax
c0408f13:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c0408f17:	77 bb                	ja     c0408ed4 <proc_is_child+0x45>
		{
			unlock_gate(&(parent->lock), LOCK_READ);
			return success;
		}

	unlock_gate(&(parent->lock), LOCK_READ);
c0408f19:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f1d:	83 c0 10             	add    $0x10,%eax
c0408f20:	83 ec 08             	sub    $0x8,%esp
c0408f23:	6a 00                	push   $0x0
c0408f25:	50                   	push   %eax
c0408f26:	e8 ec 76 ff ff       	call   c0400617 <unlock_gate>
c0408f2b:	83 c4 10             	add    $0x10,%esp
	return e_not_found;
c0408f2e:	b8 02 00 00 00       	mov    $0x2,%eax
}
c0408f33:	83 c4 1c             	add    $0x1c,%esp
c0408f36:	c3                   	ret    

c0408f37 <proc_attach_child>:
   Add a child process to a parent's table
   => parent and child = pointers to relevant process structures
   <= success or e_failure if something went wrong
*/
kresult proc_attach_child(process *parent, process *child)
{
c0408f37:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int child_loop;
	
	if(lock_gate(&(parent->lock), LOCK_WRITE))
c0408f3a:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f3e:	83 c0 10             	add    $0x10,%eax
c0408f41:	83 ec 08             	sub    $0x8,%esp
c0408f44:	6a 01                	push   $0x1
c0408f46:	50                   	push   %eax
c0408f47:	e8 4c 75 ff ff       	call   c0400498 <lock_gate>
c0408f4c:	83 c4 10             	add    $0x10,%esp
c0408f4f:	85 c0                	test   %eax,%eax
c0408f51:	74 0a                	je     c0408f5d <proc_attach_child+0x26>
		return e_failure;
c0408f53:	b8 01 00 00 00       	mov    $0x1,%eax
c0408f58:	e9 c6 01 00 00       	jmp    c0409123 <proc_attach_child+0x1ec>
	if(lock_gate(&(child->lock), LOCK_READ))
c0408f5d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408f61:	83 c0 10             	add    $0x10,%eax
c0408f64:	83 ec 08             	sub    $0x8,%esp
c0408f67:	6a 00                	push   $0x0
c0408f69:	50                   	push   %eax
c0408f6a:	e8 29 75 ff ff       	call   c0400498 <lock_gate>
c0408f6f:	83 c4 10             	add    $0x10,%esp
c0408f72:	85 c0                	test   %eax,%eax
c0408f74:	74 1f                	je     c0408f95 <proc_attach_child+0x5e>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
c0408f76:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f7a:	83 c0 10             	add    $0x10,%eax
c0408f7d:	83 ec 08             	sub    $0x8,%esp
c0408f80:	6a 01                	push   $0x1
c0408f82:	50                   	push   %eax
c0408f83:	e8 8f 76 ff ff       	call   c0400617 <unlock_gate>
c0408f88:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c0408f8b:	b8 01 00 00 00       	mov    $0x1,%eax
c0408f90:	e9 8e 01 00 00       	jmp    c0409123 <proc_attach_child+0x1ec>
	}
	
	/* add to the list of children - is the list big enough? */
	if(parent->child_count >= parent->child_list_size)
c0408f95:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408f99:	8b 50 34             	mov    0x34(%eax),%edx
c0408f9c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408fa0:	8b 40 30             	mov    0x30(%eax),%eax
c0408fa3:	39 c2                	cmp    %eax,%edx
c0408fa5:	0f 82 e1 00 00 00    	jb     c040908c <proc_attach_child+0x155>
	{
		process **new_list;
		/* we need to grow the list size */
		unsigned int new_size = parent->child_list_size * 2;
c0408fab:	8b 44 24 20          	mov    0x20(%esp),%eax
c0408faf:	8b 40 30             	mov    0x30(%eax),%eax
c0408fb2:	d1 e0                	shl    %eax
c0408fb4:	89 44 24 0c          	mov    %eax,0xc(%esp)
		
		if(!new_size) new_size = 64; /* initial size */
c0408fb8:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c0408fbd:	75 08                	jne    c0408fc7 <proc_attach_child+0x90>
c0408fbf:	c7 44 24 0c 40 00 00 	movl   $0x40,0xc(%esp)
c0408fc6:	00 
		if(vmm_malloc((void **)&new_list, new_size * sizeof(process *)))
c0408fc7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0408fcb:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0408fd2:	8d 44 24 04          	lea    0x4(%esp),%eax
c0408fd6:	83 ec 08             	sub    $0x8,%esp
c0408fd9:	52                   	push   %edx
c0408fda:	50                   	push   %eax
c0408fdb:	e8 08 ab ff ff       	call   c0403ae8 <vmm_malloc>
c0408fe0:	83 c4 10             	add    $0x10,%esp
c0408fe3:	85 c0                	test   %eax,%eax
c0408fe5:	74 34                	je     c040901b <proc_attach_child+0xe4>
		{
			unlock_gate(&(child->lock), LOCK_READ);
c0408fe7:	8b 44 24 24          	mov    0x24(%esp),%eax
c0408feb:	83 c0 10             	add    $0x10,%eax
c0408fee:	83 ec 08             	sub    $0x8,%esp
c0408ff1:	6a 00                	push   $0x0
c0408ff3:	50                   	push   %eax
c0408ff4:	e8 1e 76 ff ff       	call   c0400617 <unlock_gate>
c0408ff9:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(parent->lock), LOCK_WRITE);
c0408ffc:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409000:	83 c0 10             	add    $0x10,%eax
c0409003:	83 ec 08             	sub    $0x8,%esp
c0409006:	6a 01                	push   $0x1
c0409008:	50                   	push   %eax
c0409009:	e8 09 76 ff ff       	call   c0400617 <unlock_gate>
c040900e:	83 c4 10             	add    $0x10,%esp
			return e_failure; /* bail out of malloc fails! */
c0409011:	b8 01 00 00 00       	mov    $0x1,%eax
c0409016:	e9 08 01 00 00       	jmp    c0409123 <proc_attach_child+0x1ec>
		}
		
		vmm_memset(new_list, 0, new_size); /* clean the new list */
c040901b:	8b 44 24 04          	mov    0x4(%esp),%eax
c040901f:	83 ec 04             	sub    $0x4,%esp
c0409022:	ff 74 24 10          	pushl  0x10(%esp)
c0409026:	6a 00                	push   $0x0
c0409028:	50                   	push   %eax
c0409029:	e8 fe b9 ff ff       	call   c0404a2c <vmm_memset>
c040902e:	83 c4 10             	add    $0x10,%esp
		
		if(parent->children)
c0409031:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409035:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409038:	85 c0                	test   %eax,%eax
c040903a:	74 3a                	je     c0409076 <proc_attach_child+0x13f>
		{
			/* copy over the previous list */
			vmm_memcpy(new_list, parent->children, 
c040903c:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409040:	8b 40 30             	mov    0x30(%eax),%eax
						  parent->child_list_size * sizeof(process *));
c0409043:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
		vmm_memset(new_list, 0, new_size); /* clean the new list */
		
		if(parent->children)
		{
			/* copy over the previous list */
			vmm_memcpy(new_list, parent->children, 
c040904a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040904e:	8b 50 2c             	mov    0x2c(%eax),%edx
c0409051:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409055:	83 ec 04             	sub    $0x4,%esp
c0409058:	51                   	push   %ecx
c0409059:	52                   	push   %edx
c040905a:	50                   	push   %eax
c040905b:	e8 09 ba ff ff       	call   c0404a69 <vmm_memcpy>
c0409060:	83 c4 10             	add    $0x10,%esp
						  parent->child_list_size * sizeof(process *));
			vmm_free(parent->children); /* free the old list */
c0409063:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409067:	8b 40 2c             	mov    0x2c(%eax),%eax
c040906a:	83 ec 0c             	sub    $0xc,%esp
c040906d:	50                   	push   %eax
c040906e:	e8 9c ae ff ff       	call   c0403f0f <vmm_free>
c0409073:	83 c4 10             	add    $0x10,%esp
		}
		
		/* update the list's accounting */
		parent->children = new_list;
c0409076:	8b 54 24 04          	mov    0x4(%esp),%edx
c040907a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040907e:	89 50 2c             	mov    %edx,0x2c(%eax)
		parent->child_list_size = new_size;
c0409081:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409085:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0409089:	89 50 30             	mov    %edx,0x30(%eax)
	}
	
	/* find an empty slot and insert the new child's pointer */
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c040908c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c0409093:	00 
c0409094:	eb 51                	jmp    c04090e7 <proc_attach_child+0x1b0>
		if(parent->children[child_loop] == NULL)
c0409096:	8b 44 24 20          	mov    0x20(%esp),%eax
c040909a:	8b 40 2c             	mov    0x2c(%eax),%eax
c040909d:	8b 54 24 08          	mov    0x8(%esp),%edx
c04090a1:	c1 e2 02             	shl    $0x2,%edx
c04090a4:	01 d0                	add    %edx,%eax
c04090a6:	8b 00                	mov    (%eax),%eax
c04090a8:	85 c0                	test   %eax,%eax
c04090aa:	75 37                	jne    c04090e3 <proc_attach_child+0x1ac>
		{
			/* found a free slot, write in the new child's pointer */
			parent->children[child_loop] = child;
c04090ac:	8b 44 24 20          	mov    0x20(%esp),%eax
c04090b0:	8b 40 2c             	mov    0x2c(%eax),%eax
c04090b3:	8b 54 24 08          	mov    0x8(%esp),%edx
c04090b7:	c1 e2 02             	shl    $0x2,%edx
c04090ba:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04090bd:	8b 44 24 24          	mov    0x24(%esp),%eax
c04090c1:	89 02                	mov    %eax,(%edx)
			parent->child_count++;
c04090c3:	8b 44 24 20          	mov    0x20(%esp),%eax
c04090c7:	8b 40 34             	mov    0x34(%eax),%eax
c04090ca:	8d 50 01             	lea    0x1(%eax),%edx
c04090cd:	8b 44 24 20          	mov    0x20(%esp),%eax
c04090d1:	89 50 34             	mov    %edx,0x34(%eax)
			child->parentpid = parent->pid;
c04090d4:	8b 44 24 20          	mov    0x20(%esp),%eax
c04090d8:	8b 10                	mov    (%eax),%edx
c04090da:	8b 44 24 24          	mov    0x24(%esp),%eax
c04090de:	89 50 04             	mov    %edx,0x4(%eax)
			break;
c04090e1:	eb 11                	jmp    c04090f4 <proc_attach_child+0x1bd>
		parent->children = new_list;
		parent->child_list_size = new_size;
	}
	
	/* find an empty slot and insert the new child's pointer */
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c04090e3:	ff 44 24 08          	incl   0x8(%esp)
c04090e7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04090eb:	8b 40 30             	mov    0x30(%eax),%eax
c04090ee:	3b 44 24 08          	cmp    0x8(%esp),%eax
c04090f2:	77 a2                	ja     c0409096 <proc_attach_child+0x15f>
			parent->child_count++;
			child->parentpid = parent->pid;
			break;
		}
	
	unlock_gate(&(child->lock), LOCK_READ);
c04090f4:	8b 44 24 24          	mov    0x24(%esp),%eax
c04090f8:	83 c0 10             	add    $0x10,%eax
c04090fb:	83 ec 08             	sub    $0x8,%esp
c04090fe:	6a 00                	push   $0x0
c0409100:	50                   	push   %eax
c0409101:	e8 11 75 ff ff       	call   c0400617 <unlock_gate>
c0409106:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(parent->lock), LOCK_WRITE);
c0409109:	8b 44 24 20          	mov    0x20(%esp),%eax
c040910d:	83 c0 10             	add    $0x10,%eax
c0409110:	83 ec 08             	sub    $0x8,%esp
c0409113:	6a 01                	push   $0x1
c0409115:	50                   	push   %eax
c0409116:	e8 fc 74 ff ff       	call   c0400617 <unlock_gate>
c040911b:	83 c4 10             	add    $0x10,%esp
	return success;
c040911e:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409123:	83 c4 1c             	add    $0x1c,%esp
c0409126:	c3                   	ret    

c0409127 <proc_remove_child>:

/* proc_remove_child
	Take a child off a process's list */
kresult proc_remove_child(process *parent, process *child)
{
c0409127:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int child_loop;
	
	if(lock_gate(&(parent->lock), LOCK_WRITE))
c040912a:	8b 44 24 20          	mov    0x20(%esp),%eax
c040912e:	83 c0 10             	add    $0x10,%eax
c0409131:	83 ec 08             	sub    $0x8,%esp
c0409134:	6a 01                	push   $0x1
c0409136:	50                   	push   %eax
c0409137:	e8 5c 73 ff ff       	call   c0400498 <lock_gate>
c040913c:	83 c4 10             	add    $0x10,%esp
c040913f:	85 c0                	test   %eax,%eax
c0409141:	74 0a                	je     c040914d <proc_remove_child+0x26>
		return e_failure;
c0409143:	b8 01 00 00 00       	mov    $0x1,%eax
c0409148:	e9 ce 00 00 00       	jmp    c040921b <proc_remove_child+0xf4>
	if(lock_gate(&(child->lock), LOCK_READ))
c040914d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409151:	83 c0 10             	add    $0x10,%eax
c0409154:	83 ec 08             	sub    $0x8,%esp
c0409157:	6a 00                	push   $0x0
c0409159:	50                   	push   %eax
c040915a:	e8 39 73 ff ff       	call   c0400498 <lock_gate>
c040915f:	83 c4 10             	add    $0x10,%esp
c0409162:	85 c0                	test   %eax,%eax
c0409164:	74 1f                	je     c0409185 <proc_remove_child+0x5e>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
c0409166:	8b 44 24 20          	mov    0x20(%esp),%eax
c040916a:	83 c0 10             	add    $0x10,%eax
c040916d:	83 ec 08             	sub    $0x8,%esp
c0409170:	6a 01                	push   $0x1
c0409172:	50                   	push   %eax
c0409173:	e8 9f 74 ff ff       	call   c0400617 <unlock_gate>
c0409178:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040917b:	b8 01 00 00 00       	mov    $0x1,%eax
c0409180:	e9 96 00 00 00       	jmp    c040921b <proc_remove_child+0xf4>
	}
	
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c0409185:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040918c:	00 
c040918d:	eb 50                	jmp    c04091df <proc_remove_child+0xb8>
		if(parent->children[child_loop] == child)
c040918f:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409193:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409196:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040919a:	c1 e2 02             	shl    $0x2,%edx
c040919d:	01 d0                	add    %edx,%eax
c040919f:	8b 00                	mov    (%eax),%eax
c04091a1:	3b 44 24 24          	cmp    0x24(%esp),%eax
c04091a5:	75 34                	jne    c04091db <proc_remove_child+0xb4>
		{
			/* found a free slot, write in the new child's pointer */
			parent->children[child_loop] = NULL;
c04091a7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04091ab:	8b 40 2c             	mov    0x2c(%eax),%eax
c04091ae:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04091b2:	c1 e2 02             	shl    $0x2,%edx
c04091b5:	01 d0                	add    %edx,%eax
c04091b7:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			parent->child_count--;
c04091bd:	8b 44 24 20          	mov    0x20(%esp),%eax
c04091c1:	8b 40 34             	mov    0x34(%eax),%eax
c04091c4:	8d 50 ff             	lea    -0x1(%eax),%edx
c04091c7:	8b 44 24 20          	mov    0x20(%esp),%eax
c04091cb:	89 50 34             	mov    %edx,0x34(%eax)
			child->parentpid = 0;
c04091ce:	8b 44 24 24          	mov    0x24(%esp),%eax
c04091d2:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
			break;
c04091d9:	eb 11                	jmp    c04091ec <proc_remove_child+0xc5>
	{
		unlock_gate(&(parent->lock), LOCK_WRITE);
		return e_failure;
	}
	
	for(child_loop = 0; child_loop < parent->child_list_size; child_loop++)
c04091db:	ff 44 24 0c          	incl   0xc(%esp)
c04091df:	8b 44 24 20          	mov    0x20(%esp),%eax
c04091e3:	8b 40 30             	mov    0x30(%eax),%eax
c04091e6:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c04091ea:	77 a3                	ja     c040918f <proc_remove_child+0x68>
			parent->child_count--;
			child->parentpid = 0;
			break;
		}
	
	unlock_gate(&(child->lock), LOCK_READ);
c04091ec:	8b 44 24 24          	mov    0x24(%esp),%eax
c04091f0:	83 c0 10             	add    $0x10,%eax
c04091f3:	83 ec 08             	sub    $0x8,%esp
c04091f6:	6a 00                	push   $0x0
c04091f8:	50                   	push   %eax
c04091f9:	e8 19 74 ff ff       	call   c0400617 <unlock_gate>
c04091fe:	83 c4 10             	add    $0x10,%esp
	unlock_gate(&(parent->lock), LOCK_WRITE);
c0409201:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409205:	83 c0 10             	add    $0x10,%eax
c0409208:	83 ec 08             	sub    $0x8,%esp
c040920b:	6a 01                	push   $0x1
c040920d:	50                   	push   %eax
c040920e:	e8 04 74 ff ff       	call   c0400617 <unlock_gate>
c0409213:	83 c4 10             	add    $0x10,%esp
	return success;
c0409216:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040921b:	83 c4 1c             	add    $0x1c,%esp
c040921e:	c3                   	ret    

c040921f <proc_new>:
		caller = thread that invoked this function or NULL if
               the kernel called to generate a new process
 <= pointer to new process structure, or NULL for failure
*/
process *proc_new(process *current, thread *caller)
{
c040921f:	83 ec 2c             	sub    $0x2c,%esp
	unsigned char pid_free = 0;
c0409222:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
	process *new = NULL;
c0409227:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040922e:	00 
	unsigned int hash;
	thread *newthread = NULL;
c040922f:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c0409236:	00 
	kresult err;
	
	/* grab memory to hold the process structure and zero-fill it */
	err = vmm_malloc((void **)&new, sizeof(process));
c0409237:	8d 44 24 08          	lea    0x8(%esp),%eax
c040923b:	83 ec 08             	sub    $0x8,%esp
c040923e:	6a 60                	push   $0x60
c0409240:	50                   	push   %eax
c0409241:	e8 a2 a8 ff ff       	call   c0403ae8 <vmm_malloc>
c0409246:	83 c4 10             	add    $0x10,%esp
c0409249:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(err) return NULL; /* fail if we can't even alloc a process */
c040924d:	83 7c 24 18 00       	cmpl   $0x0,0x18(%esp)
c0409252:	74 0a                	je     c040925e <proc_new+0x3f>
c0409254:	b8 00 00 00 00       	mov    $0x0,%eax
c0409259:	e9 7d 03 00 00       	jmp    c04095db <proc_new+0x3bc>

	vmm_memset(new, 0, sizeof(process));
c040925e:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409262:	83 ec 04             	sub    $0x4,%esp
c0409265:	6a 60                	push   $0x60
c0409267:	6a 00                	push   $0x0
c0409269:	50                   	push   %eax
c040926a:	e8 bd b7 ff ff       	call   c0404a2c <vmm_memset>
c040926f:	83 c4 10             	add    $0x10,%esp
	
	lock_gate(&proc_lock, LOCK_WRITE);
c0409272:	83 ec 08             	sub    $0x8,%esp
c0409275:	6a 01                	push   $0x1
c0409277:	68 a0 f4 40 c0       	push   $0xc040f4a0
c040927c:	e8 17 72 ff ff       	call   c0400498 <lock_gate>
c0409281:	83 c4 10             	add    $0x10,%esp
	
	/* give up now if we have too many processes */
	if(proc_count >= PROC_MAX_NR)
c0409284:	a1 14 1d 41 c0       	mov    0xc0411d14,%eax
c0409289:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c040928e:	76 69                	jbe    c04092f9 <proc_new+0xda>
	{
		unlock_gate(&proc_lock, LOCK_WRITE);
c0409290:	83 ec 08             	sub    $0x8,%esp
c0409293:	6a 01                	push   $0x1
c0409295:	68 a0 f4 40 c0       	push   $0xc040f4a0
c040929a:	e8 78 73 ff ff       	call   c0400617 <unlock_gate>
c040929f:	83 c4 10             	add    $0x10,%esp
		vmm_free(new);
c04092a2:	8b 44 24 08          	mov    0x8(%esp),%eax
c04092a6:	83 ec 0c             	sub    $0xc,%esp
c04092a9:	50                   	push   %eax
c04092aa:	e8 60 ac ff ff       	call   c0403f0f <vmm_free>
c04092af:	83 c4 10             	add    $0x10,%esp
		return NULL;
c04092b2:	b8 00 00 00 00       	mov    $0x0,%eax
c04092b7:	e9 1f 03 00 00       	jmp    c04095db <proc_new+0x3bc>
	}

	/* search for an available PID */
	while(!pid_free)
	{
		if(proc_find_proc(next_pid) == NULL)
c04092bc:	a1 50 f0 40 c0       	mov    0xc040f050,%eax
c04092c1:	83 ec 0c             	sub    $0xc,%esp
c04092c4:	50                   	push   %eax
c04092c5:	e8 3e fb ff ff       	call   c0408e08 <proc_find_proc>
c04092ca:	83 c4 10             	add    $0x10,%esp
c04092cd:	85 c0                	test   %eax,%eax
c04092cf:	75 07                	jne    c04092d8 <proc_new+0xb9>
			pid_free = 1;
c04092d1:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
c04092d6:	eb 21                	jmp    c04092f9 <proc_new+0xda>
		else
		{
			next_pid++;
c04092d8:	a1 50 f0 40 c0       	mov    0xc040f050,%eax
c04092dd:	40                   	inc    %eax
c04092de:	a3 50 f0 40 c0       	mov    %eax,0xc040f050
			if(next_pid >= PROC_MAX_NR)
c04092e3:	a1 50 f0 40 c0       	mov    0xc040f050,%eax
c04092e8:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c04092ed:	76 0a                	jbe    c04092f9 <proc_new+0xda>
				next_pid = FIRST_PID;
c04092ef:	c7 05 50 f0 40 c0 01 	movl   $0x1,0xc040f050
c04092f6:	00 00 00 
		vmm_free(new);
		return NULL;
	}

	/* search for an available PID */
	while(!pid_free)
c04092f9:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c04092fe:	74 bc                	je     c04092bc <proc_new+0x9d>
				next_pid = FIRST_PID;
		}
	}
		
	/* assign our new PID */
	new->pid = next_pid;
c0409300:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409304:	8b 15 50 f0 40 c0    	mov    0xc040f050,%edx
c040930a:	89 10                	mov    %edx,(%eax)
	next_pid++;
c040930c:	a1 50 f0 40 c0       	mov    0xc040f050,%eax
c0409311:	40                   	inc    %eax
c0409312:	a3 50 f0 40 c0       	mov    %eax,0xc040f050
	if(next_pid >= PROC_MAX_NR)
c0409317:	a1 50 f0 40 c0       	mov    0xc040f050,%eax
c040931c:	3d ff 03 00 00       	cmp    $0x3ff,%eax
c0409321:	76 0a                	jbe    c040932d <proc_new+0x10e>
		next_pid = FIRST_PID;
c0409323:	c7 05 50 f0 40 c0 01 	movl   $0x1,0xc040f050
c040932a:	00 00 00 
	
	unlock_gate(&proc_lock, LOCK_WRITE);
c040932d:	83 ec 08             	sub    $0x8,%esp
c0409330:	6a 01                	push   $0x1
c0409332:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0409337:	e8 db 72 ff ff       	call   c0400617 <unlock_gate>
c040933c:	83 c4 10             	add    $0x10,%esp
	
	/* call the port-specific process creation code, with current=NULL to indicate
	   if we're calling from before userspace has been set up */
	pg_new_process(new, current);	
c040933f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409343:	83 ec 08             	sub    $0x8,%esp
c0409346:	ff 74 24 38          	pushl  0x38(%esp)
c040934a:	50                   	push   %eax
c040934b:	e8 26 e5 ff ff       	call   c0407876 <pg_new_process>
c0409350:	83 c4 10             	add    $0x10,%esp
	vmm_duplicate_vmas(new, current); /* and clone the vmas */
c0409353:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409357:	83 ec 08             	sub    $0x8,%esp
c040935a:	ff 74 24 38          	pushl  0x38(%esp)
c040935e:	50                   	push   %eax
c040935f:	e8 8c db ff ff       	call   c0406ef0 <vmm_duplicate_vmas>
c0409364:	83 c4 10             	add    $0x10,%esp
	
	/* inherit status/details from the parent process */
	if(current)
c0409367:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040936c:	0f 84 9a 01 00 00    	je     c040950c <proc_new+0x2ed>
	{
		thread *dupthread;
	
		if(lock_gate(&(current->lock), LOCK_WRITE))
c0409372:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409376:	83 c0 10             	add    $0x10,%eax
c0409379:	83 ec 08             	sub    $0x8,%esp
c040937c:	6a 01                	push   $0x1
c040937e:	50                   	push   %eax
c040937f:	e8 14 71 ff ff       	call   c0400498 <lock_gate>
c0409384:	83 c4 10             	add    $0x10,%esp
c0409387:	85 c0                	test   %eax,%eax
c0409389:	74 1a                	je     c04093a5 <proc_new+0x186>
		{
			vmm_free(new);
c040938b:	8b 44 24 08          	mov    0x8(%esp),%eax
c040938f:	83 ec 0c             	sub    $0xc,%esp
c0409392:	50                   	push   %eax
c0409393:	e8 77 ab ff ff       	call   c0403f0f <vmm_free>
c0409398:	83 c4 10             	add    $0x10,%esp
			return NULL;			
c040939b:	b8 00 00 00 00       	mov    $0x0,%eax
c04093a0:	e9 36 02 00 00       	jmp    c04095db <proc_new+0x3bc>
		}
		
		new->parentpid   = current->pid;
c04093a5:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093a9:	8b 54 24 30          	mov    0x30(%esp),%edx
c04093ad:	8b 12                	mov    (%edx),%edx
c04093af:	89 50 04             	mov    %edx,0x4(%eax)
		new->flags       = current->flags;
c04093b2:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093b6:	8b 54 24 30          	mov    0x30(%esp),%edx
c04093ba:	8a 52 0d             	mov    0xd(%edx),%dl
c04093bd:	88 50 0d             	mov    %dl,0xd(%eax)
		new->cpu         = current->cpu;
c04093c0:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093c4:	8b 54 24 30          	mov    0x30(%esp),%edx
c04093c8:	8a 52 0c             	mov    0xc(%edx),%dl
c04093cb:	88 50 0c             	mov    %dl,0xc(%eax)
		new->layer		  = current->layer;
c04093ce:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093d2:	8b 54 24 30          	mov    0x30(%esp),%edx
c04093d6:	8a 52 50             	mov    0x50(%edx),%dl
c04093d9:	88 50 50             	mov    %dl,0x50(%eax)
		new->rights		  = current->rights;
c04093dc:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093e0:	8b 54 24 30          	mov    0x30(%esp),%edx
c04093e4:	8b 52 4c             	mov    0x4c(%edx),%edx
c04093e7:	89 50 4c             	mov    %edx,0x4c(%eax)
		
		if(proc_attach_child(current, new))
c04093ea:	8b 44 24 08          	mov    0x8(%esp),%eax
c04093ee:	83 ec 08             	sub    $0x8,%esp
c04093f1:	50                   	push   %eax
c04093f2:	ff 74 24 3c          	pushl  0x3c(%esp)
c04093f6:	e8 3c fb ff ff       	call   c0408f37 <proc_attach_child>
c04093fb:	83 c4 10             	add    $0x10,%esp
c04093fe:	85 c0                	test   %eax,%eax
c0409400:	74 2f                	je     c0409431 <proc_new+0x212>
		{
			unlock_gate(&(current->lock), LOCK_WRITE);
c0409402:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409406:	83 c0 10             	add    $0x10,%eax
c0409409:	83 ec 08             	sub    $0x8,%esp
c040940c:	6a 01                	push   $0x1
c040940e:	50                   	push   %eax
c040940f:	e8 03 72 ff ff       	call   c0400617 <unlock_gate>
c0409414:	83 c4 10             	add    $0x10,%esp
			vmm_free(new);
c0409417:	8b 44 24 08          	mov    0x8(%esp),%eax
c040941b:	83 ec 0c             	sub    $0xc,%esp
c040941e:	50                   	push   %eax
c040941f:	e8 eb aa ff ff       	call   c0403f0f <vmm_free>
c0409424:	83 c4 10             	add    $0x10,%esp
			return NULL;
c0409427:	b8 00 00 00 00       	mov    $0x0,%eax
c040942c:	e9 aa 01 00 00       	jmp    c04095db <proc_new+0x3bc>
		}
		
		/* duplicate the running thread */
		if(thread_new_hash(new))
c0409431:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409435:	83 ec 0c             	sub    $0xc,%esp
c0409438:	50                   	push   %eax
c0409439:	e8 17 f3 ff ff       	call   c0408755 <thread_new_hash>
c040943e:	83 c4 10             	add    $0x10,%esp
c0409441:	85 c0                	test   %eax,%eax
c0409443:	74 43                	je     c0409488 <proc_new+0x269>
		{
			proc_remove_child(current, new);
c0409445:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409449:	83 ec 08             	sub    $0x8,%esp
c040944c:	50                   	push   %eax
c040944d:	ff 74 24 3c          	pushl  0x3c(%esp)
c0409451:	e8 d1 fc ff ff       	call   c0409127 <proc_remove_child>
c0409456:	83 c4 10             	add    $0x10,%esp
			vmm_free(new); /* tidy up */
c0409459:	8b 44 24 08          	mov    0x8(%esp),%eax
c040945d:	83 ec 0c             	sub    $0xc,%esp
c0409460:	50                   	push   %eax
c0409461:	e8 a9 aa ff ff       	call   c0403f0f <vmm_free>
c0409466:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(current->lock), LOCK_WRITE);
c0409469:	8b 44 24 30          	mov    0x30(%esp),%eax
c040946d:	83 c0 10             	add    $0x10,%eax
c0409470:	83 ec 08             	sub    $0x8,%esp
c0409473:	6a 01                	push   $0x1
c0409475:	50                   	push   %eax
c0409476:	e8 9c 71 ff ff       	call   c0400617 <unlock_gate>
c040947b:	83 c4 10             	add    $0x10,%esp
			return NULL;
c040947e:	b8 00 00 00 00       	mov    $0x0,%eax
c0409483:	e9 53 01 00 00       	jmp    c04095db <proc_new+0x3bc>
		}
		
		dupthread = thread_duplicate(new, caller);
c0409488:	8b 44 24 08          	mov    0x8(%esp),%eax
c040948c:	83 ec 08             	sub    $0x8,%esp
c040948f:	ff 74 24 3c          	pushl  0x3c(%esp)
c0409493:	50                   	push   %eax
c0409494:	e8 a9 ef ff ff       	call   c0408442 <thread_duplicate>
c0409499:	83 c4 10             	add    $0x10,%esp
c040949c:	89 44 24 1c          	mov    %eax,0x1c(%esp)
		if(!dupthread)
c04094a0:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c04094a5:	75 43                	jne    c04094ea <proc_new+0x2cb>
		{
			proc_remove_child(current, new);
c04094a7:	8b 44 24 08          	mov    0x8(%esp),%eax
c04094ab:	83 ec 08             	sub    $0x8,%esp
c04094ae:	50                   	push   %eax
c04094af:	ff 74 24 3c          	pushl  0x3c(%esp)
c04094b3:	e8 6f fc ff ff       	call   c0409127 <proc_remove_child>
c04094b8:	83 c4 10             	add    $0x10,%esp
			vmm_free(new); /* tidy up */
c04094bb:	8b 44 24 08          	mov    0x8(%esp),%eax
c04094bf:	83 ec 0c             	sub    $0xc,%esp
c04094c2:	50                   	push   %eax
c04094c3:	e8 47 aa ff ff       	call   c0403f0f <vmm_free>
c04094c8:	83 c4 10             	add    $0x10,%esp
			unlock_gate(&(current->lock), LOCK_WRITE);
c04094cb:	8b 44 24 30          	mov    0x30(%esp),%eax
c04094cf:	83 c0 10             	add    $0x10,%eax
c04094d2:	83 ec 08             	sub    $0x8,%esp
c04094d5:	6a 01                	push   $0x1
c04094d7:	50                   	push   %eax
c04094d8:	e8 3a 71 ff ff       	call   c0400617 <unlock_gate>
c04094dd:	83 c4 10             	add    $0x10,%esp
			return NULL;
c04094e0:	b8 00 00 00 00       	mov    $0x0,%eax
c04094e5:	e9 f1 00 00 00       	jmp    c04095db <proc_new+0x3bc>
		}
		new->thread_count = 1;
c04094ea:	8b 44 24 08          	mov    0x8(%esp),%eax
c04094ee:	c7 40 3c 01 00 00 00 	movl   $0x1,0x3c(%eax)
		
		unlock_gate(&(current->lock), LOCK_WRITE);
c04094f5:	8b 44 24 30          	mov    0x30(%esp),%eax
c04094f9:	83 c0 10             	add    $0x10,%eax
c04094fc:	83 ec 08             	sub    $0x8,%esp
c04094ff:	6a 01                	push   $0x1
c0409501:	50                   	push   %eax
c0409502:	e8 10 71 ff ff       	call   c0400617 <unlock_gate>
c0409507:	83 c4 10             	add    $0x10,%esp
c040950a:	eb 1f                	jmp    c040952b <proc_new+0x30c>
	}
	else
	{
		/* initialise the process's hash table of threads and 
		 create a new thread for execution */
		new->next_tid = FIRST_TID;
c040950c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409510:	c7 40 40 01 00 00 00 	movl   $0x1,0x40(%eax)
		newthread = thread_new(new);
c0409517:	8b 44 24 08          	mov    0x8(%esp),%eax
c040951b:	83 ec 0c             	sub    $0xc,%esp
c040951e:	50                   	push   %eax
c040951f:	e8 f9 f2 ff ff       	call   c040881d <thread_new>
c0409524:	83 c4 10             	add    $0x10,%esp
c0409527:	89 44 24 14          	mov    %eax,0x14(%esp)
	}
	
	/* add the new process to the pid hash table */
	lock_gate(&proc_lock, LOCK_WRITE);
c040952b:	83 ec 08             	sub    $0x8,%esp
c040952e:	6a 01                	push   $0x1
c0409530:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0409535:	e8 5e 6f ff ff       	call   c0400498 <lock_gate>
c040953a:	83 c4 10             	add    $0x10,%esp
	
	hash = new->pid % PROC_HASH_BUCKETS;
c040953d:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409541:	8b 00                	mov    (%eax),%eax
c0409543:	83 e0 7f             	and    $0x7f,%eax
c0409546:	89 44 24 10          	mov    %eax,0x10(%esp)
	if(proc_table[hash])
c040954a:	a1 0c 1d 41 c0       	mov    0xc0411d0c,%eax
c040954f:	8b 54 24 10          	mov    0x10(%esp),%edx
c0409553:	c1 e2 02             	shl    $0x2,%edx
c0409556:	01 d0                	add    %edx,%eax
c0409558:	8b 00                	mov    (%eax),%eax
c040955a:	85 c0                	test   %eax,%eax
c040955c:	74 31                	je     c040958f <proc_new+0x370>
	{
		proc_table[hash]->hash_prev = new;
c040955e:	a1 0c 1d 41 c0       	mov    0xc0411d0c,%eax
c0409563:	8b 54 24 10          	mov    0x10(%esp),%edx
c0409567:	c1 e2 02             	shl    $0x2,%edx
c040956a:	01 d0                	add    %edx,%eax
c040956c:	8b 00                	mov    (%eax),%eax
c040956e:	8b 54 24 08          	mov    0x8(%esp),%edx
c0409572:	89 50 24             	mov    %edx,0x24(%eax)
		new->hash_next = proc_table[hash];
c0409575:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409579:	8b 15 0c 1d 41 c0    	mov    0xc0411d0c,%edx
c040957f:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0409583:	c1 e1 02             	shl    $0x2,%ecx
c0409586:	01 ca                	add    %ecx,%edx
c0409588:	8b 12                	mov    (%edx),%edx
c040958a:	89 50 28             	mov    %edx,0x28(%eax)
c040958d:	eb 0b                	jmp    c040959a <proc_new+0x37b>
	}
	else
	{
		new->hash_next = NULL;
c040958f:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409593:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
	}
	proc_table[hash] = new;
c040959a:	a1 0c 1d 41 c0       	mov    0xc0411d0c,%eax
c040959f:	8b 54 24 10          	mov    0x10(%esp),%edx
c04095a3:	c1 e2 02             	shl    $0x2,%edx
c04095a6:	8d 14 10             	lea    (%eax,%edx,1),%edx
c04095a9:	8b 44 24 08          	mov    0x8(%esp),%eax
c04095ad:	89 02                	mov    %eax,(%edx)
	new->hash_prev = NULL;
c04095af:	8b 44 24 08          	mov    0x8(%esp),%eax
c04095b3:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
	proc_count++;
c04095ba:	a1 14 1d 41 c0       	mov    0xc0411d14,%eax
c04095bf:	40                   	inc    %eax
c04095c0:	a3 14 1d 41 c0       	mov    %eax,0xc0411d14
	unlock_gate(&proc_lock, LOCK_WRITE);
c04095c5:	83 ec 08             	sub    $0x8,%esp
c04095c8:	6a 01                	push   $0x1
c04095ca:	68 a0 f4 40 c0       	push   $0xc040f4a0
c04095cf:	e8 43 70 ff ff       	call   c0400617 <unlock_gate>
c04095d4:	83 c4 10             	add    $0x10,%esp
	
	PROC_DEBUG("[proc:%i] created new process %i (%p)\n", CPU_ID, new->pid, new);

	return new;
c04095d7:	8b 44 24 08          	mov    0x8(%esp),%eax
}
c04095db:	83 c4 2c             	add    $0x2c,%esp
c04095de:	c3                   	ret    

c04095df <proc_kill>:
   Request to kill the given process
   => victimpid = PID of process to destroy (USER-SUPPLIED)
      slayer    = pointer to process making the request
   <= 0 for success or an error code */
kresult proc_kill(unsigned int victimpid, process *slayer)
{
c04095df:	83 ec 1c             	sub    $0x1c,%esp
	process *victim, *parent;
	unsigned int loop;
	
	/* sanity checks */
	if((victimpid > PROC_MAX_NR) || !slayer) return e_failure;
c04095e2:	81 7c 24 20 00 04 00 	cmpl   $0x400,0x20(%esp)
c04095e9:	00 
c04095ea:	77 07                	ja     c04095f3 <proc_kill+0x14>
c04095ec:	83 7c 24 24 00       	cmpl   $0x0,0x24(%esp)
c04095f1:	75 0a                	jne    c04095fd <proc_kill+0x1e>
c04095f3:	b8 01 00 00 00       	mov    $0x1,%eax
c04095f8:	e9 55 02 00 00       	jmp    c0409852 <proc_kill+0x273>
	victim = proc_find_proc(victimpid);
c04095fd:	83 ec 0c             	sub    $0xc,%esp
c0409600:	ff 74 24 2c          	pushl  0x2c(%esp)
c0409604:	e8 ff f7 ff ff       	call   c0408e08 <proc_find_proc>
c0409609:	83 c4 10             	add    $0x10,%esp
c040960c:	89 44 24 04          	mov    %eax,0x4(%esp)
	if(!victim) return e_failure;
c0409610:	83 7c 24 04 00       	cmpl   $0x0,0x4(%esp)
c0409615:	75 0a                	jne    c0409621 <proc_kill+0x42>
c0409617:	b8 01 00 00 00       	mov    $0x1,%eax
c040961c:	e9 31 02 00 00       	jmp    c0409852 <proc_kill+0x273>
	
	lock_gate(&(slayer->lock), LOCK_READ);
c0409621:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409625:	83 c0 10             	add    $0x10,%eax
c0409628:	83 ec 08             	sub    $0x8,%esp
c040962b:	6a 00                	push   $0x0
c040962d:	50                   	push   %eax
c040962e:	e8 65 6e ff ff       	call   c0400498 <lock_gate>
c0409633:	83 c4 10             	add    $0x10,%esp
	
	/* rights checks */
	if(victim->layer > slayer->layer) goto do_proc_kill;
c0409636:	8b 44 24 04          	mov    0x4(%esp),%eax
c040963a:	8a 50 50             	mov    0x50(%eax),%dl
c040963d:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409641:	8a 40 50             	mov    0x50(%eax),%al
c0409644:	38 c2                	cmp    %al,%dl
c0409646:	77 36                	ja     c040967e <proc_kill+0x9f>
	if(proc_is_child(slayer, victim) != success) goto do_proc_kill;
c0409648:	83 ec 08             	sub    $0x8,%esp
c040964b:	ff 74 24 0c          	pushl  0xc(%esp)
c040964f:	ff 74 24 30          	pushl  0x30(%esp)
c0409653:	e8 37 f8 ff ff       	call   c0408e8f <proc_is_child>
c0409658:	83 c4 10             	add    $0x10,%esp
c040965b:	85 c0                	test   %eax,%eax
c040965d:	75 22                	jne    c0409681 <proc_kill+0xa2>
	
	/* failed to possess the correct rights to kill this victim */
	unlock_gate(&(slayer->lock), LOCK_READ);
c040965f:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409663:	83 c0 10             	add    $0x10,%eax
c0409666:	83 ec 08             	sub    $0x8,%esp
c0409669:	6a 00                	push   $0x0
c040966b:	50                   	push   %eax
c040966c:	e8 a6 6f ff ff       	call   c0400617 <unlock_gate>
c0409671:	83 c4 10             	add    $0x10,%esp
	return e_no_rights;
c0409674:	b8 06 00 00 00       	mov    $0x6,%eax
c0409679:	e9 d4 01 00 00       	jmp    c0409852 <proc_kill+0x273>
	if(!victim) return e_failure;
	
	lock_gate(&(slayer->lock), LOCK_READ);
	
	/* rights checks */
	if(victim->layer > slayer->layer) goto do_proc_kill;
c040967e:	90                   	nop
c040967f:	eb 01                	jmp    c0409682 <proc_kill+0xa3>
	if(proc_is_child(slayer, victim) != success) goto do_proc_kill;
c0409681:	90                   	nop
	/* failed to possess the correct rights to kill this victim */
	unlock_gate(&(slayer->lock), LOCK_READ);
	return e_no_rights;
	
do_proc_kill:
	unlock_gate(&(slayer->lock), LOCK_READ);
c0409682:	8b 44 24 24          	mov    0x24(%esp),%eax
c0409686:	83 c0 10             	add    $0x10,%eax
c0409689:	83 ec 08             	sub    $0x8,%esp
c040968c:	6a 00                	push   $0x0
c040968e:	50                   	push   %eax
c040968f:	e8 83 6f ff ff       	call   c0400617 <unlock_gate>
c0409694:	83 c4 10             	add    $0x10,%esp
	
	/* we have a green light, so reverse the process creation
	   routines in proc_new() */
	parent = proc_find_proc(victim->parentpid);
c0409697:	8b 44 24 04          	mov    0x4(%esp),%eax
c040969b:	8b 40 04             	mov    0x4(%eax),%eax
c040969e:	83 ec 0c             	sub    $0xc,%esp
c04096a1:	50                   	push   %eax
c04096a2:	e8 61 f7 ff ff       	call   c0408e08 <proc_find_proc>
c04096a7:	83 c4 10             	add    $0x10,%esp
c04096aa:	89 44 24 08          	mov    %eax,0x8(%esp)
	
	/* stop it from running but remember, there's no point
	   unblocking the process we're about to slay */
	if(lock_gate(&(victim->lock), LOCK_WRITE | LOCK_SELFDESTRUCT))
c04096ae:	8b 44 24 04          	mov    0x4(%esp),%eax
c04096b2:	83 c0 10             	add    $0x10,%eax
c04096b5:	83 ec 08             	sub    $0x8,%esp
c04096b8:	6a 03                	push   $0x3
c04096ba:	50                   	push   %eax
c04096bb:	e8 d8 6d ff ff       	call   c0400498 <lock_gate>
c04096c0:	83 c4 10             	add    $0x10,%esp
c04096c3:	85 c0                	test   %eax,%eax
c04096c5:	74 0a                	je     c04096d1 <proc_kill+0xf2>
		return e_failure;
c04096c7:	b8 01 00 00 00       	mov    $0x1,%eax
c04096cc:	e9 81 01 00 00       	jmp    c0409852 <proc_kill+0x273>
	sched_lock_proc(victim);
c04096d1:	83 ec 0c             	sub    $0xc,%esp
c04096d4:	ff 74 24 10          	pushl  0x10(%esp)
c04096d8:	e8 88 94 ff ff       	call   c0402b65 <sched_lock_proc>
c04096dd:	83 c4 10             	add    $0x10,%esp
	
	/* victim process is now effectively dead to the system */
	
	/* unlink it from the process table */
	lock_gate(&proc_lock, LOCK_WRITE);
c04096e0:	83 ec 08             	sub    $0x8,%esp
c04096e3:	6a 01                	push   $0x1
c04096e5:	68 a0 f4 40 c0       	push   $0xc040f4a0
c04096ea:	e8 a9 6d ff ff       	call   c0400498 <lock_gate>
c04096ef:	83 c4 10             	add    $0x10,%esp
	if(victim->hash_next)
c04096f2:	8b 44 24 04          	mov    0x4(%esp),%eax
c04096f6:	8b 40 28             	mov    0x28(%eax),%eax
c04096f9:	85 c0                	test   %eax,%eax
c04096fb:	74 11                	je     c040970e <proc_kill+0x12f>
		victim->hash_next->hash_prev = victim->hash_prev;
c04096fd:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409701:	8b 40 28             	mov    0x28(%eax),%eax
c0409704:	8b 54 24 04          	mov    0x4(%esp),%edx
c0409708:	8b 52 24             	mov    0x24(%edx),%edx
c040970b:	89 50 24             	mov    %edx,0x24(%eax)
	if(victim->hash_prev)
c040970e:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409712:	8b 40 24             	mov    0x24(%eax),%eax
c0409715:	85 c0                	test   %eax,%eax
c0409717:	74 13                	je     c040972c <proc_kill+0x14d>
		victim->hash_prev->hash_next = victim->hash_next;
c0409719:	8b 44 24 04          	mov    0x4(%esp),%eax
c040971d:	8b 40 24             	mov    0x24(%eax),%eax
c0409720:	8b 54 24 04          	mov    0x4(%esp),%edx
c0409724:	8b 52 28             	mov    0x28(%edx),%edx
c0409727:	89 50 28             	mov    %edx,0x28(%eax)
c040972a:	eb 1d                	jmp    c0409749 <proc_kill+0x16a>
	else
		/* we were the hash table entry head, so fixup table */
		proc_table[victim->pid % PROC_HASH_BUCKETS] = victim->hash_next;
c040972c:	8b 15 0c 1d 41 c0    	mov    0xc0411d0c,%edx
c0409732:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409736:	8b 00                	mov    (%eax),%eax
c0409738:	83 e0 7f             	and    $0x7f,%eax
c040973b:	c1 e0 02             	shl    $0x2,%eax
c040973e:	01 c2                	add    %eax,%edx
c0409740:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409744:	8b 40 28             	mov    0x28(%eax),%eax
c0409747:	89 02                	mov    %eax,(%edx)
	lock_gate(&proc_lock, LOCK_WRITE);
c0409749:	83 ec 08             	sub    $0x8,%esp
c040974c:	6a 01                	push   $0x1
c040974e:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0409753:	e8 40 6d ff ff       	call   c0400498 <lock_gate>
c0409758:	83 c4 10             	add    $0x10,%esp
	
	/* destroy the threads */
	thread_kill(victim, NULL);
c040975b:	83 ec 08             	sub    $0x8,%esp
c040975e:	6a 00                	push   $0x0
c0409760:	ff 74 24 10          	pushl  0x10(%esp)
c0409764:	e8 f3 f3 ff ff       	call   c0408b5c <thread_kill>
c0409769:	83 c4 10             	add    $0x10,%esp
	
	/* won't someone think of the children? */
	if(victim->children)
c040976c:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409770:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409773:	85 c0                	test   %eax,%eax
c0409775:	0f 84 92 00 00 00    	je     c040980d <proc_kill+0x22e>
	{
		/* attach the to-be-orphaned children to the system executive process */
		for(loop = 0; loop < victim->child_list_size; loop++)
c040977b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c0409782:	00 
c0409783:	eb 68                	jmp    c04097ed <proc_kill+0x20e>
		{
			if(victim->children[loop])
c0409785:	8b 44 24 04          	mov    0x4(%esp),%eax
c0409789:	8b 40 2c             	mov    0x2c(%eax),%eax
c040978c:	8b 54 24 0c          	mov    0xc(%esp),%edx
c0409790:	c1 e2 02             	shl    $0x2,%edx
c0409793:	01 d0                	add    %edx,%eax
c0409795:	8b 00                	mov    (%eax),%eax
c0409797:	85 c0                	test   %eax,%eax
c0409799:	74 4e                	je     c04097e9 <proc_kill+0x20a>
			{
				victim->children[loop]->prevparentpid = victim->children[loop]->parentpid;
c040979b:	8b 44 24 04          	mov    0x4(%esp),%eax
c040979f:	8b 40 2c             	mov    0x2c(%eax),%eax
c04097a2:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04097a6:	c1 e2 02             	shl    $0x2,%edx
c04097a9:	01 d0                	add    %edx,%eax
c04097ab:	8b 00                	mov    (%eax),%eax
c04097ad:	8b 54 24 04          	mov    0x4(%esp),%edx
c04097b1:	8b 52 2c             	mov    0x2c(%edx),%edx
c04097b4:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c04097b8:	c1 e1 02             	shl    $0x2,%ecx
c04097bb:	01 ca                	add    %ecx,%edx
c04097bd:	8b 12                	mov    (%edx),%edx
c04097bf:	8b 52 04             	mov    0x4(%edx),%edx
c04097c2:	89 50 08             	mov    %edx,0x8(%eax)
				proc_attach_child(proc_sys_executive, victim->children[loop]);
c04097c5:	8b 44 24 04          	mov    0x4(%esp),%eax
c04097c9:	8b 40 2c             	mov    0x2c(%eax),%eax
c04097cc:	8b 54 24 0c          	mov    0xc(%esp),%edx
c04097d0:	c1 e2 02             	shl    $0x2,%edx
c04097d3:	01 d0                	add    %edx,%eax
c04097d5:	8b 10                	mov    (%eax),%edx
c04097d7:	a1 10 1d 41 c0       	mov    0xc0411d10,%eax
c04097dc:	83 ec 08             	sub    $0x8,%esp
c04097df:	52                   	push   %edx
c04097e0:	50                   	push   %eax
c04097e1:	e8 51 f7 ff ff       	call   c0408f37 <proc_attach_child>
c04097e6:	83 c4 10             	add    $0x10,%esp
	
	/* won't someone think of the children? */
	if(victim->children)
	{
		/* attach the to-be-orphaned children to the system executive process */
		for(loop = 0; loop < victim->child_list_size; loop++)
c04097e9:	ff 44 24 0c          	incl   0xc(%esp)
c04097ed:	8b 44 24 04          	mov    0x4(%esp),%eax
c04097f1:	8b 40 30             	mov    0x30(%eax),%eax
c04097f4:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c04097f8:	77 8b                	ja     c0409785 <proc_kill+0x1a6>
				proc_attach_child(proc_sys_executive, victim->children[loop]);
			}
		}
		
		/* and free the table */
		vmm_free(victim->children);
c04097fa:	8b 44 24 04          	mov    0x4(%esp),%eax
c04097fe:	8b 40 2c             	mov    0x2c(%eax),%eax
c0409801:	83 ec 0c             	sub    $0xc,%esp
c0409804:	50                   	push   %eax
c0409805:	e8 05 a7 ff ff       	call   c0403f0f <vmm_free>
c040980a:	83 c4 10             	add    $0x10,%esp
	}
	
	/* destroy the architecture-specific part of the process */
	vmm_destroy_vmas(victim); /* unlink the vmas */
c040980d:	83 ec 0c             	sub    $0xc,%esp
c0409810:	ff 74 24 10          	pushl  0x10(%esp)
c0409814:	e8 a4 d7 ff ff       	call   c0406fbd <vmm_destroy_vmas>
c0409819:	83 c4 10             	add    $0x10,%esp
	pg_destroy_process(victim);
c040981c:	83 ec 0c             	sub    $0xc,%esp
c040981f:	ff 74 24 10          	pushl  0x10(%esp)
c0409823:	e8 9e e1 ff ff       	call   c04079c6 <pg_destroy_process>
c0409828:	83 c4 10             	add    $0x10,%esp
	
	/* give up the space held by the process structure */
	vmm_free(victim);
c040982b:	83 ec 0c             	sub    $0xc,%esp
c040982e:	ff 74 24 10          	pushl  0x10(%esp)
c0409832:	e8 d8 a6 ff ff       	call   c0403f0f <vmm_free>
c0409837:	83 c4 10             	add    $0x10,%esp
	
	/* don't forget to dispatch a signal to the parent and
	   don't fret if the parent shuns its moment of mourning */
	msg_send_signal(parent, SIGCHLD, 0);
c040983a:	83 ec 04             	sub    $0x4,%esp
c040983d:	6a 00                	push   $0x0
c040983f:	6a 14                	push   $0x14
c0409841:	ff 74 24 14          	pushl  0x14(%esp)
c0409845:	e8 f2 89 ff ff       	call   c040223c <msg_send_signal>
c040984a:	83 c4 10             	add    $0x10,%esp
	
	PROC_DEBUG("[proc:%i] killed process %i (%p)\n", CPU_ID, victim->pid, victim);
	
	return success;
c040984d:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409852:	83 c4 1c             	add    $0x1c,%esp
c0409855:	c3                   	ret    

c0409856 <proc_initialise>:

kresult proc_initialise(void)
{
c0409856:	57                   	push   %edi
c0409857:	56                   	push   %esi
c0409858:	53                   	push   %ebx
c0409859:	83 ec 60             	sub    $0x60,%esp
   payload_descr payload;
   mb_module_t *module = NULL;
c040985c:	c7 44 24 38 00 00 00 	movl   $0x0,0x38(%esp)
c0409863:	00 
	kresult err;
	unsigned int loop, module_loop;

	/* initialise critical section lock */
	vmm_memset(&proc_lock, 0, sizeof(rw_gate));
c0409864:	83 ec 04             	sub    $0x4,%esp
c0409867:	6a 10                	push   $0x10
c0409869:	6a 00                	push   $0x0
c040986b:	68 a0 f4 40 c0       	push   $0xc040f4a0
c0409870:	e8 b7 b1 ff ff       	call   c0404a2c <vmm_memset>
c0409875:	83 c4 10             	add    $0x10,%esp
	
	/* initialise proc hash table */
	err = vmm_malloc((void **)&proc_table, sizeof(process *) * PROC_HASH_BUCKETS);
c0409878:	b8 0c 1d 41 c0       	mov    $0xc0411d0c,%eax
c040987d:	83 ec 08             	sub    $0x8,%esp
c0409880:	68 00 02 00 00       	push   $0x200
c0409885:	50                   	push   %eax
c0409886:	e8 5d a2 ff ff       	call   c0403ae8 <vmm_malloc>
c040988b:	83 c4 10             	add    $0x10,%esp
c040988e:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if(err) return err; /* fail if we can't even alloc a process hash table */
c0409892:	83 7c 24 3c 00       	cmpl   $0x0,0x3c(%esp)
c0409897:	74 09                	je     c04098a2 <proc_initialise+0x4c>
c0409899:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040989d:	e9 9b 03 00 00       	jmp    c0409c3d <proc_initialise+0x3e7>
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
c04098a2:	c7 44 24 40 00 00 00 	movl   $0x0,0x40(%esp)
c04098a9:	00 
c04098aa:	eb 18                	jmp    c04098c4 <proc_initialise+0x6e>
		proc_table[loop] = NULL;
c04098ac:	a1 0c 1d 41 c0       	mov    0xc0411d0c,%eax
c04098b1:	8b 54 24 40          	mov    0x40(%esp),%edx
c04098b5:	c1 e2 02             	shl    $0x2,%edx
c04098b8:	01 d0                	add    %edx,%eax
c04098ba:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	
	/* initialise proc hash table */
	err = vmm_malloc((void **)&proc_table, sizeof(process *) * PROC_HASH_BUCKETS);
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
c04098c0:	ff 44 24 40          	incl   0x40(%esp)
c04098c4:	83 7c 24 40 7f       	cmpl   $0x7f,0x40(%esp)
c04098c9:	76 e1                	jbe    c04098ac <proc_initialise+0x56>
		proc_table[loop] = NULL;
	
	BOOT_DEBUG("[proc:%i] initialised process hash table %p... %i buckets %i max procs\n",
c04098cb:	8b 15 0c 1d 41 c0    	mov    0xc0411d0c,%edx
			     CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
c04098d1:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
		proc_table[loop] = NULL;
	
	BOOT_DEBUG("[proc:%i] initialised process hash table %p... %i buckets %i max procs\n",
c04098d6:	3c 01                	cmp    $0x1,%al
c04098d8:	76 0c                	jbe    c04098e6 <proc_initialise+0x90>
			     CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
c04098da:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04098df:	8b 00                	mov    (%eax),%eax
	if(err) return err; /* fail if we can't even alloc a process hash table */
	
	for(loop = 0; loop < PROC_HASH_BUCKETS; loop++)
		proc_table[loop] = NULL;
	
	BOOT_DEBUG("[proc:%i] initialised process hash table %p... %i buckets %i max procs\n",
c04098e1:	c1 e8 18             	shr    $0x18,%eax
c04098e4:	eb 08                	jmp    c04098ee <proc_initialise+0x98>
c04098e6:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04098eb:	0f b6 c0             	movzbl %al,%eax
c04098ee:	83 ec 0c             	sub    $0xc,%esp
c04098f1:	68 00 04 00 00       	push   $0x400
c04098f6:	68 80 00 00 00       	push   $0x80
c04098fb:	52                   	push   %edx
c04098fc:	50                   	push   %eax
c04098fd:	68 6c d0 40 c0       	push   $0xc040d06c
c0409902:	e8 7b 25 00 00       	call   c040be82 <debug_printf>
c0409907:	83 c4 20             	add    $0x20,%esp
			     CPU_ID, proc_table, PROC_HASH_BUCKETS, PROC_MAX_NR);
	
	/* get the lowlevel layer initialised before we start the operating system */
	lowlevel_proc_preinit();
c040990a:	e8 6d 75 ff ff       	call   c0400e7c <lowlevel_proc_preinit>
	
   /* turn loaded modules into processes ready to run */
   for(module_loop = 0; module_loop < payload_modulemax; module_loop++)
c040990f:	c7 44 24 44 00 00 00 	movl   $0x0,0x44(%esp)
c0409916:	00 
c0409917:	e9 0d 03 00 00       	jmp    c0409c29 <proc_initialise+0x3d3>
   {		
		process *new = NULL;
c040991c:	c7 44 24 48 00 00 00 	movl   $0x0,0x48(%esp)
c0409923:	00 
		unsigned int virtual, virtual_top, physical;
		payload_type type;
		
		module = payload_readmodule(module_loop);
c0409924:	83 ec 0c             	sub    $0xc,%esp
c0409927:	ff 74 24 50          	pushl  0x50(%esp)
c040992b:	e8 90 19 00 00       	call   c040b2c0 <payload_readmodule>
c0409930:	83 c4 10             	add    $0x10,%esp
c0409933:	89 44 24 38          	mov    %eax,0x38(%esp)
		
		type = payload_parsemodule(module, &payload);
c0409937:	83 ec 08             	sub    $0x8,%esp
c040993a:	8d 44 24 10          	lea    0x10(%esp),%eax
c040993e:	50                   	push   %eax
c040993f:	ff 74 24 44          	pushl  0x44(%esp)
c0409943:	e8 bf 19 00 00       	call   c040b307 <payload_parsemodule>
c0409948:	83 c4 10             	add    $0x10,%esp
c040994b:	89 44 24 58          	mov    %eax,0x58(%esp)
		
		/* give up if malformed binaries are in the payload */
		if(type == payload_bad)
c040994f:	83 7c 24 58 00       	cmpl   $0x0,0x58(%esp)
c0409954:	75 3c                	jne    c0409992 <proc_initialise+0x13c>
		{
         BOOT_DEBUG("[proc:%i] failed to parse payload module at %x !\n", CPU_ID, module);
c0409956:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040995b:	3c 01                	cmp    $0x1,%al
c040995d:	76 0c                	jbe    c040996b <proc_initialise+0x115>
c040995f:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409964:	8b 00                	mov    (%eax),%eax
c0409966:	c1 e8 18             	shr    $0x18,%eax
c0409969:	eb 08                	jmp    c0409973 <proc_initialise+0x11d>
c040996b:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0409970:	0f b6 c0             	movzbl %al,%eax
c0409973:	83 ec 04             	sub    $0x4,%esp
c0409976:	ff 74 24 3c          	pushl  0x3c(%esp)
c040997a:	50                   	push   %eax
c040997b:	68 b4 d0 40 c0       	push   $0xc040d0b4
c0409980:	e8 fd 24 00 00       	call   c040be82 <debug_printf>
c0409985:	83 c4 10             	add    $0x10,%esp
			return e_failure;
c0409988:	b8 01 00 00 00       	mov    $0x1,%eax
c040998d:	e9 ab 02 00 00       	jmp    c0409c3d <proc_initialise+0x3e7>
		}

		/* create a bare-bones process for an executable in the payload */
		if(type == payload_exe)
c0409992:	83 7c 24 58 01       	cmpl   $0x1,0x58(%esp)
c0409997:	0f 85 88 02 00 00    	jne    c0409c25 <proc_initialise+0x3cf>
		{
			new = proc_new(NULL, NULL);
c040999d:	83 ec 08             	sub    $0x8,%esp
c04099a0:	6a 00                	push   $0x0
c04099a2:	6a 00                	push   $0x0
c04099a4:	e8 76 f8 ff ff       	call   c040921f <proc_new>
c04099a9:	83 c4 10             	add    $0x10,%esp
c04099ac:	89 44 24 48          	mov    %eax,0x48(%esp)
			if(!new) return e_failure; /* bail if we can't start up our modules */
c04099b0:	83 7c 24 48 00       	cmpl   $0x0,0x48(%esp)
c04099b5:	75 0a                	jne    c04099c1 <proc_initialise+0x16b>
c04099b7:	b8 01 00 00 00       	mov    $0x1,%eax
c04099bc:	e9 7c 02 00 00       	jmp    c0409c3d <proc_initialise+0x3e7>
			
			/* build page tables for this module */
			BOOT_DEBUG("[proc:%i] preparing system process '%s'...\n", CPU_ID, payload.name);
c04099c1:	8b 54 24 34          	mov    0x34(%esp),%edx
c04099c5:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c04099ca:	3c 01                	cmp    $0x1,%al
c04099cc:	76 0c                	jbe    c04099da <proc_initialise+0x184>
c04099ce:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c04099d3:	8b 00                	mov    (%eax),%eax
c04099d5:	c1 e8 18             	shr    $0x18,%eax
c04099d8:	eb 08                	jmp    c04099e2 <proc_initialise+0x18c>
c04099da:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c04099df:	0f b6 c0             	movzbl %al,%eax
c04099e2:	83 ec 04             	sub    $0x4,%esp
c04099e5:	52                   	push   %edx
c04099e6:	50                   	push   %eax
c04099e7:	68 e8 d0 40 c0       	push   $0xc040d0e8
c04099ec:	e8 91 24 00 00       	call   c040be82 <debug_printf>
c04099f1:	83 c4 10             	add    $0x10,%esp
			
			if(payload.areas[PAYLOAD_CODE].flags & (PAYLOAD_READ | PAYLOAD_EXECUTE))
c04099f4:	8b 44 24 18          	mov    0x18(%esp),%eax
c04099f8:	83 e0 03             	and    $0x3,%eax
c04099fb:	85 c0                	test   %eax,%eax
c04099fd:	0f 84 a2 00 00 00    	je     c0409aa5 <proc_initialise+0x24f>
			{			
				BOOT_DEBUG("       code: entry %p virt %p phys %p size %u memsize %u flags %u\n", 
c0409a03:	8b 7c 24 18          	mov    0x18(%esp),%edi
c0409a07:	8b 74 24 14          	mov    0x14(%esp),%esi
c0409a0b:	8b 5c 24 10          	mov    0x10(%esp),%ebx
c0409a0f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c0409a13:	8b 54 24 08          	mov    0x8(%esp),%edx
c0409a17:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409a1b:	83 ec 04             	sub    $0x4,%esp
c0409a1e:	57                   	push   %edi
c0409a1f:	56                   	push   %esi
c0409a20:	53                   	push   %ebx
c0409a21:	51                   	push   %ecx
c0409a22:	52                   	push   %edx
c0409a23:	50                   	push   %eax
c0409a24:	68 14 d1 40 c0       	push   $0xc040d114
c0409a29:	e8 54 24 00 00       	call   c040be82 <debug_printf>
c0409a2e:	83 c4 20             	add    $0x20,%esp
						  payload.entry,
						  payload.areas[PAYLOAD_CODE].virtual, payload.areas[PAYLOAD_CODE].physical,
						  payload.areas[PAYLOAD_CODE].size, payload.areas[PAYLOAD_CODE].memsize,
						  payload.areas[PAYLOAD_CODE].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_CODE].virtual;
c0409a31:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409a35:	89 44 24 4c          	mov    %eax,0x4c(%esp)
				virtual_top = virtual + payload.areas[PAYLOAD_CODE].memsize;
c0409a39:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409a3d:	03 44 24 4c          	add    0x4c(%esp),%eax
c0409a41:	89 44 24 50          	mov    %eax,0x50(%esp)
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_CODE].physical);
c0409a45:	8b 44 24 0c          	mov    0xc(%esp),%eax
c0409a49:	05 00 00 00 40       	add    $0x40000000,%eax
c0409a4e:	89 44 24 54          	mov    %eax,0x54(%esp)
				while(virtual < virtual_top)
c0409a52:	eb 2a                	jmp    c0409a7e <proc_initialise+0x228>
				{
					pg_add_4K_mapping(new->pgdir, virtual, physical, PG_PRESENT | PG_PRIVLVL);
c0409a54:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409a58:	8b 40 20             	mov    0x20(%eax),%eax
c0409a5b:	6a 05                	push   $0x5
c0409a5d:	ff 74 24 58          	pushl  0x58(%esp)
c0409a61:	ff 74 24 54          	pushl  0x54(%esp)
c0409a65:	50                   	push   %eax
c0409a66:	e8 71 e1 ff ff       	call   c0407bdc <pg_add_4K_mapping>
c0409a6b:	83 c4 10             	add    $0x10,%esp
					virtual += MEM_PGSIZE;
c0409a6e:	81 44 24 4c 00 10 00 	addl   $0x1000,0x4c(%esp)
c0409a75:	00 
					physical += MEM_PGSIZE;
c0409a76:	81 44 24 54 00 10 00 	addl   $0x1000,0x54(%esp)
c0409a7d:	00 
						  payload.areas[PAYLOAD_CODE].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_CODE].virtual;
				virtual_top = virtual + payload.areas[PAYLOAD_CODE].memsize;
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_CODE].physical);
				while(virtual < virtual_top)
c0409a7e:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0409a82:	3b 44 24 50          	cmp    0x50(%esp),%eax
c0409a86:	72 cc                	jb     c0409a54 <proc_initialise+0x1fe>
					pg_add_4K_mapping(new->pgdir, virtual, physical, PG_PRESENT | PG_PRIVLVL);
					virtual += MEM_PGSIZE;
					physical += MEM_PGSIZE;
				}
				
				vmm_add_vma(new, (unsigned int)payload.areas[PAYLOAD_CODE].virtual,
c0409a88:	8b 54 24 14          	mov    0x14(%esp),%edx
c0409a8c:	8b 44 24 08          	mov    0x8(%esp),%eax
c0409a90:	83 ec 0c             	sub    $0xc,%esp
c0409a93:	6a 00                	push   $0x0
c0409a95:	6a 00                	push   $0x0
c0409a97:	52                   	push   %edx
c0409a98:	50                   	push   %eax
c0409a99:	ff 74 24 64          	pushl  0x64(%esp)
c0409a9d:	e8 38 d3 ff ff       	call   c0406dda <vmm_add_vma>
c0409aa2:	83 c4 20             	add    $0x20,%esp
								payload.areas[PAYLOAD_CODE].memsize, VMA_READABLE, 0);
			}
			if(payload.areas[PAYLOAD_DATA].flags & (PAYLOAD_READ))
c0409aa5:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0409aa9:	83 e0 02             	and    $0x2,%eax
c0409aac:	85 c0                	test   %eax,%eax
c0409aae:	0f 84 b7 00 00 00    	je     c0409b6b <proc_initialise+0x315>
			{
				unsigned int flags = PG_PRESENT | PG_PRIVLVL;
c0409ab4:	c7 44 24 5c 05 00 00 	movl   $0x5,0x5c(%esp)
c0409abb:	00 
				
				if(payload.areas[PAYLOAD_DATA].flags & PAYLOAD_WRITE)
c0409abc:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c0409ac0:	83 e0 04             	and    $0x4,%eax
c0409ac3:	85 c0                	test   %eax,%eax
c0409ac5:	74 05                	je     c0409acc <proc_initialise+0x276>
					flags = flags | PG_RW;
c0409ac7:	83 4c 24 5c 02       	orl    $0x2,0x5c(%esp)
				
				BOOT_DEBUG("       data:          virt %p phys %p size %u memsize %u flags %u\n", 
c0409acc:	8b 74 24 2c          	mov    0x2c(%esp),%esi
c0409ad0:	8b 5c 24 28          	mov    0x28(%esp),%ebx
c0409ad4:	8b 4c 24 24          	mov    0x24(%esp),%ecx
c0409ad8:	8b 54 24 20          	mov    0x20(%esp),%edx
c0409adc:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409ae0:	83 ec 08             	sub    $0x8,%esp
c0409ae3:	56                   	push   %esi
c0409ae4:	53                   	push   %ebx
c0409ae5:	51                   	push   %ecx
c0409ae6:	52                   	push   %edx
c0409ae7:	50                   	push   %eax
c0409ae8:	68 58 d1 40 c0       	push   $0xc040d158
c0409aed:	e8 90 23 00 00       	call   c040be82 <debug_printf>
c0409af2:	83 c4 20             	add    $0x20,%esp
						  payload.areas[PAYLOAD_DATA].virtual, payload.areas[PAYLOAD_DATA].physical,
						  payload.areas[PAYLOAD_DATA].size, payload.areas[PAYLOAD_DATA].memsize,
						  payload.areas[PAYLOAD_DATA].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_DATA].virtual;
c0409af5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409af9:	89 44 24 4c          	mov    %eax,0x4c(%esp)
				virtual_top = virtual + payload.areas[PAYLOAD_DATA].memsize;
c0409afd:	8b 44 24 28          	mov    0x28(%esp),%eax
c0409b01:	03 44 24 4c          	add    0x4c(%esp),%eax
c0409b05:	89 44 24 50          	mov    %eax,0x50(%esp)
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_DATA].physical);
c0409b09:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409b0d:	05 00 00 00 40       	add    $0x40000000,%eax
c0409b12:	89 44 24 54          	mov    %eax,0x54(%esp)
				while(virtual < virtual_top)
c0409b16:	eb 2c                	jmp    c0409b44 <proc_initialise+0x2ee>
				{
					pg_add_4K_mapping(new->pgdir, virtual, physical, flags);
c0409b18:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409b1c:	8b 40 20             	mov    0x20(%eax),%eax
c0409b1f:	ff 74 24 5c          	pushl  0x5c(%esp)
c0409b23:	ff 74 24 58          	pushl  0x58(%esp)
c0409b27:	ff 74 24 54          	pushl  0x54(%esp)
c0409b2b:	50                   	push   %eax
c0409b2c:	e8 ab e0 ff ff       	call   c0407bdc <pg_add_4K_mapping>
c0409b31:	83 c4 10             	add    $0x10,%esp
					virtual += MEM_PGSIZE;
c0409b34:	81 44 24 4c 00 10 00 	addl   $0x1000,0x4c(%esp)
c0409b3b:	00 
					physical += MEM_PGSIZE;
c0409b3c:	81 44 24 54 00 10 00 	addl   $0x1000,0x54(%esp)
c0409b43:	00 
						  payload.areas[PAYLOAD_DATA].flags);
				
				virtual = (unsigned int)payload.areas[PAYLOAD_DATA].virtual;
				virtual_top = virtual + payload.areas[PAYLOAD_DATA].memsize;
				physical = (unsigned int)KERNEL_LOG2PHYS(payload.areas[PAYLOAD_DATA].physical);
				while(virtual < virtual_top)
c0409b44:	8b 44 24 4c          	mov    0x4c(%esp),%eax
c0409b48:	3b 44 24 50          	cmp    0x50(%esp),%eax
c0409b4c:	72 ca                	jb     c0409b18 <proc_initialise+0x2c2>
					pg_add_4K_mapping(new->pgdir, virtual, physical, flags);
					virtual += MEM_PGSIZE;
					physical += MEM_PGSIZE;
				}
				
				vmm_add_vma(new, (unsigned int)payload.areas[PAYLOAD_DATA].virtual,
c0409b4e:	8b 54 24 28          	mov    0x28(%esp),%edx
c0409b52:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c0409b56:	83 ec 0c             	sub    $0xc,%esp
c0409b59:	6a 00                	push   $0x0
c0409b5b:	6a 01                	push   $0x1
c0409b5d:	52                   	push   %edx
c0409b5e:	50                   	push   %eax
c0409b5f:	ff 74 24 64          	pushl  0x64(%esp)
c0409b63:	e8 72 d2 ff ff       	call   c0406dda <vmm_add_vma>
c0409b68:	83 c4 20             	add    $0x20,%esp
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
c0409b6b:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409b6f:	8b 40 38             	mov    0x38(%eax),%eax
c0409b72:	83 c0 04             	add    $0x4,%eax
c0409b75:	8b 00                	mov    (%eax),%eax
c0409b77:	85 c0                	test   %eax,%eax
c0409b79:	75 46                	jne    c0409bc1 <proc_initialise+0x36b>
			{
				BOOT_DEBUG("[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n",
c0409b7b:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409b7f:	8b 10                	mov    (%eax),%edx
						     CPU_ID, new->pid, new);
c0409b81:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
			{
				BOOT_DEBUG("[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n",
c0409b86:	3c 01                	cmp    $0x1,%al
c0409b88:	76 0c                	jbe    c0409b96 <proc_initialise+0x340>
						     CPU_ID, new->pid, new);
c0409b8a:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409b8f:	8b 00                	mov    (%eax),%eax
								payload.areas[PAYLOAD_DATA].memsize, VMA_WRITEABLE, 0);
			}
			
			if(!(new->threads[FIRST_TID]))
			{
				BOOT_DEBUG("[proc:%i] OMGWTF system process %i (%p) thread creation failed!\n",
c0409b91:	c1 e8 18             	shr    $0x18,%eax
c0409b94:	eb 08                	jmp    c0409b9e <proc_initialise+0x348>
c0409b96:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0409b9b:	0f b6 c0             	movzbl %al,%eax
c0409b9e:	ff 74 24 48          	pushl  0x48(%esp)
c0409ba2:	52                   	push   %edx
c0409ba3:	50                   	push   %eax
c0409ba4:	68 9c d1 40 c0       	push   $0xc040d19c
c0409ba9:	e8 d4 22 00 00       	call   c040be82 <debug_printf>
c0409bae:	83 c4 10             	add    $0x10,%esp
						     CPU_ID, new->pid, new);
				debug_panic("failed to create first userland thread");
c0409bb1:	83 ec 0c             	sub    $0xc,%esp
c0409bb4:	68 e0 d1 40 c0       	push   $0xc040d1e0
c0409bb9:	e8 dc 1d 00 00       	call   c040b99a <debug_panic>
c0409bbe:	83 c4 10             	add    $0x10,%esp
			}
			
			/* kernel payload binaries start in the executive layer */
			new->layer  = LAYER_EXECUTIVE;
c0409bc1:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409bc5:	c6 40 50 01          	movb   $0x1,0x50(%eax)
			new->rights = RIGHTS_EXECUTIVE;
c0409bc9:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409bcd:	c7 40 4c 00 00 00 00 	movl   $0x0,0x4c(%eax)
			proc_sys_executive = new;
c0409bd4:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409bd8:	a3 10 1d 41 c0       	mov    %eax,0xc0411d10
			
			/* set the entry program counter and get ready to run it */
			new->entry = (unsigned int)payload.entry;
c0409bdd:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409be1:	89 c2                	mov    %eax,%edx
c0409be3:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409be7:	89 50 44             	mov    %edx,0x44(%eax)
			sched_add(CPU_ID, 1, new->threads[FIRST_TID]);
c0409bea:	8b 44 24 48          	mov    0x48(%esp),%eax
c0409bee:	8b 40 38             	mov    0x38(%eax),%eax
c0409bf1:	83 c0 04             	add    $0x4,%eax
c0409bf4:	8b 10                	mov    (%eax),%edx
c0409bf6:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0409bfb:	3c 01                	cmp    $0x1,%al
c0409bfd:	76 0f                	jbe    c0409c0e <proc_initialise+0x3b8>
c0409bff:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409c04:	8b 00                	mov    (%eax),%eax
c0409c06:	c1 e8 18             	shr    $0x18,%eax
c0409c09:	0f b6 c0             	movzbl %al,%eax
c0409c0c:	eb 08                	jmp    c0409c16 <proc_initialise+0x3c0>
c0409c0e:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0409c13:	0f b6 c0             	movzbl %al,%eax
c0409c16:	83 ec 04             	sub    $0x4,%esp
c0409c19:	52                   	push   %edx
c0409c1a:	6a 01                	push   $0x1
c0409c1c:	50                   	push   %eax
c0409c1d:	e8 a5 99 ff ff       	call   c04035c7 <sched_add>
c0409c22:	83 c4 10             	add    $0x10,%esp
	
	/* get the lowlevel layer initialised before we start the operating system */
	lowlevel_proc_preinit();
	
   /* turn loaded modules into processes ready to run */
   for(module_loop = 0; module_loop < payload_modulemax; module_loop++)
c0409c25:	ff 44 24 44          	incl   0x44(%esp)
c0409c29:	a1 24 1d 41 c0       	mov    0xc0411d24,%eax
c0409c2e:	39 44 24 44          	cmp    %eax,0x44(%esp)
c0409c32:	0f 82 e4 fc ff ff    	jb     c040991c <proc_initialise+0xc6>
			new->entry = (unsigned int)payload.entry;
			sched_add(CPU_ID, 1, new->threads[FIRST_TID]);
		}
   }

   return success;
c0409c38:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409c3d:	83 c4 60             	add    $0x60,%esp
c0409c40:	5b                   	pop    %ebx
c0409c41:	5e                   	pop    %esi
c0409c42:	5f                   	pop    %edi
c0409c43:	c3                   	ret    

c0409c44 <ioapic_irq_default>:
extern void irq39(); extern void irq40(); extern void irq41(); extern void irq42();
extern void irq43(); extern void irq44(); extern void irq45(); extern void irq46();

/* default handler for IOAPIC IRQs - just EOI the interrupt */
kresult ioapic_irq_default(unsigned char intnum, int_registers_block *regs)
{
c0409c44:	83 ec 1c             	sub    $0x1c,%esp
c0409c47:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c4b:	88 44 24 0c          	mov    %al,0xc(%esp)
	/* the local APIC generated this interrupt, so satisfy it */
	lapic_end_interrupt();
c0409c4f:	e8 47 07 00 00       	call   c040a39b <lapic_end_interrupt>
	return success;
c0409c54:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0409c59:	83 c4 1c             	add    $0x1c,%esp
c0409c5c:	c3                   	ret    

c0409c5d <ioapic_read>:
 => id = system id of IOAPIC to program
    reg = IOAPIC register number to write to
 <= the 32bit word in the selected register
*/
unsigned int ioapic_read(unsigned char id, unsigned char reg)
{
c0409c5d:	83 ec 18             	sub    $0x18,%esp
c0409c60:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0409c64:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409c68:	88 54 24 04          	mov    %dl,0x4(%esp)
c0409c6c:	88 04 24             	mov    %al,(%esp)
	unsigned int addr_reg = IOAPIC_REG_SELECT + (id * 0x100);
c0409c6f:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409c74:	05 00 c0 fe 00       	add    $0xfec000,%eax
c0409c79:	c1 e0 08             	shl    $0x8,%eax
c0409c7c:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int addr_val = IOAPIC_WINDOW_SELECT + (id * 0x100);
c0409c80:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409c85:	c1 e0 08             	shl    $0x8,%eax
c0409c88:	2d f0 ff 3f 01       	sub    $0x13ffff0,%eax
c0409c8d:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	/* write the target register into the select register */
	*((volatile unsigned int *)(addr_reg)) = reg;
c0409c91:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409c95:	0f b6 14 24          	movzbl (%esp),%edx
c0409c99:	89 10                	mov    %edx,(%eax)
	
	/* ..then read the data */
	return *((volatile unsigned int *)(addr_val));
c0409c9b:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409c9f:	8b 00                	mov    (%eax),%eax
}
c0409ca1:	83 c4 18             	add    $0x18,%esp
c0409ca4:	c3                   	ret    

c0409ca5 <ioapic_write>:
      reg = IOAPIC register number to write to
      value = the 32bit word to write in
   <= assumes success
*/
void ioapic_write(unsigned char id, unsigned char reg, unsigned int value)
{
c0409ca5:	83 ec 18             	sub    $0x18,%esp
c0409ca8:	8b 54 24 1c          	mov    0x1c(%esp),%edx
c0409cac:	8b 44 24 20          	mov    0x20(%esp),%eax
c0409cb0:	88 54 24 04          	mov    %dl,0x4(%esp)
c0409cb4:	88 04 24             	mov    %al,(%esp)
	unsigned int addr_reg = IOAPIC_REG_SELECT + (id * 0x100);
c0409cb7:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409cbc:	05 00 c0 fe 00       	add    $0xfec000,%eax
c0409cc1:	c1 e0 08             	shl    $0x8,%eax
c0409cc4:	89 44 24 10          	mov    %eax,0x10(%esp)
	unsigned int addr_val = IOAPIC_WINDOW_SELECT + (id * 0x100);
c0409cc8:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409ccd:	c1 e0 08             	shl    $0x8,%eax
c0409cd0:	2d f0 ff 3f 01       	sub    $0x13ffff0,%eax
c0409cd5:	89 44 24 14          	mov    %eax,0x14(%esp)
	
	/* write the target register into the select register */
	*((volatile unsigned int *)(addr_reg)) = reg;
c0409cd9:	8b 44 24 10          	mov    0x10(%esp),%eax
c0409cdd:	0f b6 14 24          	movzbl (%esp),%edx
c0409ce1:	89 10                	mov    %edx,(%eax)
	
	/* ..then the data */
	*((volatile unsigned int *)(addr_val)) = value;
c0409ce3:	8b 44 24 14          	mov    0x14(%esp),%eax
c0409ce7:	8b 54 24 24          	mov    0x24(%esp),%edx
c0409ceb:	89 10                	mov    %edx,(%eax)
}
c0409ced:	83 c4 18             	add    $0x18,%esp
c0409cf0:	c3                   	ret    

c0409cf1 <ioapic_route_set>:
      cpu = system id of CPU to route the interrupt to
      flags = flags to set in the IO redirection table
   <= assumes success
*/
void ioapic_route_set(unsigned char id, unsigned char entry, unsigned char cpu, unsigned int flags)
{
c0409cf1:	83 ec 0c             	sub    $0xc,%esp
c0409cf4:	8b 4c 24 10          	mov    0x10(%esp),%ecx
c0409cf8:	8b 54 24 14          	mov    0x14(%esp),%edx
c0409cfc:	8b 44 24 18          	mov    0x18(%esp),%eax
c0409d00:	88 4c 24 08          	mov    %cl,0x8(%esp)
c0409d04:	88 54 24 04          	mov    %dl,0x4(%esp)
c0409d08:	88 04 24             	mov    %al,(%esp)
	IOAPIC_DEBUG("[ioapic:%i] routing IOAPIC %i IRQ %i to CPU %i (flags %x)\n",
			  CPU_ID, id, entry, cpu, flags);
	
	/* the chip's IO redirection table is 64 bits wide:
	   the target cpu is in bits 63:56, the flags in bits 16:0 */
	ioapic_write(id, IOAPIC_REDIR_BASE + (entry * 2) + 0, flags);
c0409d0b:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409d10:	83 c0 08             	add    $0x8,%eax
c0409d13:	d1 e0                	shl    %eax
c0409d15:	0f b6 d0             	movzbl %al,%edx
c0409d18:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
c0409d1d:	ff 74 24 1c          	pushl  0x1c(%esp)
c0409d21:	52                   	push   %edx
c0409d22:	50                   	push   %eax
c0409d23:	e8 7d ff ff ff       	call   c0409ca5 <ioapic_write>
c0409d28:	83 c4 0c             	add    $0xc,%esp
	ioapic_write(id, IOAPIC_REDIR_BASE + (entry * 2) + 1, cpu << 24);
c0409d2b:	0f b6 04 24          	movzbl (%esp),%eax
c0409d2f:	c1 e0 18             	shl    $0x18,%eax
c0409d32:	89 c1                	mov    %eax,%ecx
c0409d34:	0f b6 44 24 04       	movzbl 0x4(%esp),%eax
c0409d39:	83 c0 08             	add    $0x8,%eax
c0409d3c:	d1 e0                	shl    %eax
c0409d3e:	40                   	inc    %eax
c0409d3f:	0f b6 d0             	movzbl %al,%edx
c0409d42:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
c0409d47:	51                   	push   %ecx
c0409d48:	52                   	push   %edx
c0409d49:	50                   	push   %eax
c0409d4a:	e8 56 ff ff ff       	call   c0409ca5 <ioapic_write>
c0409d4f:	83 c4 0c             	add    $0xc,%esp
}
c0409d52:	83 c4 0c             	add    $0xc,%esp
c0409d55:	c3                   	ret    

c0409d56 <ioapic_register_chip>:
*/
kresult ioapic_register_chip(unsigned int id, unsigned int physaddr)
{
	/* TODO: not implemented */
	
	return e_failure;
c0409d56:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0409d5b:	c3                   	ret    

c0409d5c <ioapic_initialise>:
/* int_initialise_ioapic
	Set up an IOAPIC on the system
   => id = ID of IOAPIC to initialise
*/
void ioapic_initialise(unsigned char id)
{		
c0409d5c:	53                   	push   %ebx
c0409d5d:	83 ec 28             	sub    $0x28,%esp
c0409d60:	8b 44 24 30          	mov    0x30(%esp),%eax
c0409d64:	88 44 24 0c          	mov    %al,0xc(%esp)
	unsigned int this_cpu = CPU_ID, loop;
c0409d68:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c0409d6d:	3c 01                	cmp    $0x1,%al
c0409d6f:	76 0c                	jbe    c0409d7d <ioapic_initialise+0x21>
c0409d71:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c0409d76:	8b 00                	mov    (%eax),%eax
c0409d78:	c1 e8 18             	shr    $0x18,%eax
c0409d7b:	eb 08                	jmp    c0409d85 <ioapic_initialise+0x29>
c0409d7d:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c0409d82:	0f b6 c0             	movzbl %al,%eax
c0409d85:	89 44 24 18          	mov    %eax,0x18(%esp)
	 23h, which receive address and data respectively. To access the IMCR, write a
	 value of 70h to I/O port 22h, which selects the IMCR. Then write the data to
	 I/O port 23h. The power-on default value is zero, which connects the NMI and
	 8259 INTR lines directly to the BSP. Write a value of 1 to route 8259/PIT
	 interrupts via the IOAPIC */
	x86_outportb(0x22, 0x70); /* begin IMCR access */
c0409d89:	83 ec 08             	sub    $0x8,%esp
c0409d8c:	6a 70                	push   $0x70
c0409d8e:	6a 22                	push   $0x22
c0409d90:	e8 61 69 ff ff       	call   c04006f6 <x86_outportb>
c0409d95:	83 c4 10             	add    $0x10,%esp
	x86_outportb(0x23, 1);    /* set bit 1 for SMP mode */
c0409d98:	83 ec 08             	sub    $0x8,%esp
c0409d9b:	6a 01                	push   $0x1
c0409d9d:	6a 23                	push   $0x23
c0409d9f:	e8 52 69 ff ff       	call   c04006f6 <x86_outportb>
c0409da4:	83 c4 10             	add    $0x10,%esp
	
	/* point the IOAPIC interrupt lines at specific reserved vectors and route
		to the boot processor for now */
	int_set_gate(IOAPIC_VECTOR_BASE + 0, (unsigned int)irq23, 0x18, 0x8E, 0);
c0409da7:	b8 f1 02 40 c0       	mov    $0xc04002f1,%eax
c0409dac:	83 ec 0c             	sub    $0xc,%esp
c0409daf:	6a 00                	push   $0x0
c0409db1:	68 8e 00 00 00       	push   $0x8e
c0409db6:	6a 18                	push   $0x18
c0409db8:	50                   	push   %eax
c0409db9:	6a 40                	push   $0x40
c0409dbb:	e8 28 0a 00 00       	call   c040a7e8 <int_set_gate>
c0409dc0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 1, (unsigned int)irq24, 0x18, 0x8E, 0);
c0409dc3:	b8 fb 02 40 c0       	mov    $0xc04002fb,%eax
c0409dc8:	83 ec 0c             	sub    $0xc,%esp
c0409dcb:	6a 00                	push   $0x0
c0409dcd:	68 8e 00 00 00       	push   $0x8e
c0409dd2:	6a 18                	push   $0x18
c0409dd4:	50                   	push   %eax
c0409dd5:	6a 41                	push   $0x41
c0409dd7:	e8 0c 0a 00 00       	call   c040a7e8 <int_set_gate>
c0409ddc:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 2, (unsigned int)irq25, 0x18, 0x8E, 0);
c0409ddf:	b8 05 03 40 c0       	mov    $0xc0400305,%eax
c0409de4:	83 ec 0c             	sub    $0xc,%esp
c0409de7:	6a 00                	push   $0x0
c0409de9:	68 8e 00 00 00       	push   $0x8e
c0409dee:	6a 18                	push   $0x18
c0409df0:	50                   	push   %eax
c0409df1:	6a 42                	push   $0x42
c0409df3:	e8 f0 09 00 00       	call   c040a7e8 <int_set_gate>
c0409df8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 3, (unsigned int)irq26, 0x18, 0x8E, 0);
c0409dfb:	b8 0f 03 40 c0       	mov    $0xc040030f,%eax
c0409e00:	83 ec 0c             	sub    $0xc,%esp
c0409e03:	6a 00                	push   $0x0
c0409e05:	68 8e 00 00 00       	push   $0x8e
c0409e0a:	6a 18                	push   $0x18
c0409e0c:	50                   	push   %eax
c0409e0d:	6a 43                	push   $0x43
c0409e0f:	e8 d4 09 00 00       	call   c040a7e8 <int_set_gate>
c0409e14:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 4, (unsigned int)irq27, 0x18, 0x8E, 0);
c0409e17:	b8 19 03 40 c0       	mov    $0xc0400319,%eax
c0409e1c:	83 ec 0c             	sub    $0xc,%esp
c0409e1f:	6a 00                	push   $0x0
c0409e21:	68 8e 00 00 00       	push   $0x8e
c0409e26:	6a 18                	push   $0x18
c0409e28:	50                   	push   %eax
c0409e29:	6a 44                	push   $0x44
c0409e2b:	e8 b8 09 00 00       	call   c040a7e8 <int_set_gate>
c0409e30:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 5, (unsigned int)irq28, 0x18, 0x8E, 0);
c0409e33:	b8 23 03 40 c0       	mov    $0xc0400323,%eax
c0409e38:	83 ec 0c             	sub    $0xc,%esp
c0409e3b:	6a 00                	push   $0x0
c0409e3d:	68 8e 00 00 00       	push   $0x8e
c0409e42:	6a 18                	push   $0x18
c0409e44:	50                   	push   %eax
c0409e45:	6a 45                	push   $0x45
c0409e47:	e8 9c 09 00 00       	call   c040a7e8 <int_set_gate>
c0409e4c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 6, (unsigned int)irq29, 0x18, 0x8E, 0);
c0409e4f:	b8 2d 03 40 c0       	mov    $0xc040032d,%eax
c0409e54:	83 ec 0c             	sub    $0xc,%esp
c0409e57:	6a 00                	push   $0x0
c0409e59:	68 8e 00 00 00       	push   $0x8e
c0409e5e:	6a 18                	push   $0x18
c0409e60:	50                   	push   %eax
c0409e61:	6a 46                	push   $0x46
c0409e63:	e8 80 09 00 00       	call   c040a7e8 <int_set_gate>
c0409e68:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 7, (unsigned int)irq30, 0x18, 0x8E, 0);
c0409e6b:	b8 37 03 40 c0       	mov    $0xc0400337,%eax
c0409e70:	83 ec 0c             	sub    $0xc,%esp
c0409e73:	6a 00                	push   $0x0
c0409e75:	68 8e 00 00 00       	push   $0x8e
c0409e7a:	6a 18                	push   $0x18
c0409e7c:	50                   	push   %eax
c0409e7d:	6a 47                	push   $0x47
c0409e7f:	e8 64 09 00 00       	call   c040a7e8 <int_set_gate>
c0409e84:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 8, (unsigned int)irq31, 0x18, 0x8E, 0);
c0409e87:	b8 41 03 40 c0       	mov    $0xc0400341,%eax
c0409e8c:	83 ec 0c             	sub    $0xc,%esp
c0409e8f:	6a 00                	push   $0x0
c0409e91:	68 8e 00 00 00       	push   $0x8e
c0409e96:	6a 18                	push   $0x18
c0409e98:	50                   	push   %eax
c0409e99:	6a 48                	push   $0x48
c0409e9b:	e8 48 09 00 00       	call   c040a7e8 <int_set_gate>
c0409ea0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 9, (unsigned int)irq32, 0x18, 0x8E, 0);
c0409ea3:	b8 4b 03 40 c0       	mov    $0xc040034b,%eax
c0409ea8:	83 ec 0c             	sub    $0xc,%esp
c0409eab:	6a 00                	push   $0x0
c0409ead:	68 8e 00 00 00       	push   $0x8e
c0409eb2:	6a 18                	push   $0x18
c0409eb4:	50                   	push   %eax
c0409eb5:	6a 49                	push   $0x49
c0409eb7:	e8 2c 09 00 00       	call   c040a7e8 <int_set_gate>
c0409ebc:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 10, (unsigned int)irq33, 0x18, 0x8E, 0);
c0409ebf:	b8 55 03 40 c0       	mov    $0xc0400355,%eax
c0409ec4:	83 ec 0c             	sub    $0xc,%esp
c0409ec7:	6a 00                	push   $0x0
c0409ec9:	68 8e 00 00 00       	push   $0x8e
c0409ece:	6a 18                	push   $0x18
c0409ed0:	50                   	push   %eax
c0409ed1:	6a 4a                	push   $0x4a
c0409ed3:	e8 10 09 00 00       	call   c040a7e8 <int_set_gate>
c0409ed8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 11, (unsigned int)irq34, 0x18, 0x8E, 0);
c0409edb:	b8 5f 03 40 c0       	mov    $0xc040035f,%eax
c0409ee0:	83 ec 0c             	sub    $0xc,%esp
c0409ee3:	6a 00                	push   $0x0
c0409ee5:	68 8e 00 00 00       	push   $0x8e
c0409eea:	6a 18                	push   $0x18
c0409eec:	50                   	push   %eax
c0409eed:	6a 4b                	push   $0x4b
c0409eef:	e8 f4 08 00 00       	call   c040a7e8 <int_set_gate>
c0409ef4:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 12, (unsigned int)irq35, 0x18, 0x8E, 0);
c0409ef7:	b8 69 03 40 c0       	mov    $0xc0400369,%eax
c0409efc:	83 ec 0c             	sub    $0xc,%esp
c0409eff:	6a 00                	push   $0x0
c0409f01:	68 8e 00 00 00       	push   $0x8e
c0409f06:	6a 18                	push   $0x18
c0409f08:	50                   	push   %eax
c0409f09:	6a 4c                	push   $0x4c
c0409f0b:	e8 d8 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f10:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 13, (unsigned int)irq36, 0x18, 0x8E, 0);
c0409f13:	b8 73 03 40 c0       	mov    $0xc0400373,%eax
c0409f18:	83 ec 0c             	sub    $0xc,%esp
c0409f1b:	6a 00                	push   $0x0
c0409f1d:	68 8e 00 00 00       	push   $0x8e
c0409f22:	6a 18                	push   $0x18
c0409f24:	50                   	push   %eax
c0409f25:	6a 4d                	push   $0x4d
c0409f27:	e8 bc 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f2c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 14, (unsigned int)irq37, 0x18, 0x8E, 0);
c0409f2f:	b8 7d 03 40 c0       	mov    $0xc040037d,%eax
c0409f34:	83 ec 0c             	sub    $0xc,%esp
c0409f37:	6a 00                	push   $0x0
c0409f39:	68 8e 00 00 00       	push   $0x8e
c0409f3e:	6a 18                	push   $0x18
c0409f40:	50                   	push   %eax
c0409f41:	6a 4e                	push   $0x4e
c0409f43:	e8 a0 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f48:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 15, (unsigned int)irq38, 0x18, 0x8E, 0);
c0409f4b:	b8 87 03 40 c0       	mov    $0xc0400387,%eax
c0409f50:	83 ec 0c             	sub    $0xc,%esp
c0409f53:	6a 00                	push   $0x0
c0409f55:	68 8e 00 00 00       	push   $0x8e
c0409f5a:	6a 18                	push   $0x18
c0409f5c:	50                   	push   %eax
c0409f5d:	6a 4f                	push   $0x4f
c0409f5f:	e8 84 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f64:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 16, (unsigned int)irq39, 0x18, 0x8E, 0);
c0409f67:	b8 91 03 40 c0       	mov    $0xc0400391,%eax
c0409f6c:	83 ec 0c             	sub    $0xc,%esp
c0409f6f:	6a 00                	push   $0x0
c0409f71:	68 8e 00 00 00       	push   $0x8e
c0409f76:	6a 18                	push   $0x18
c0409f78:	50                   	push   %eax
c0409f79:	6a 50                	push   $0x50
c0409f7b:	e8 68 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f80:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 17, (unsigned int)irq40, 0x18, 0x8E, 0);
c0409f83:	b8 9b 03 40 c0       	mov    $0xc040039b,%eax
c0409f88:	83 ec 0c             	sub    $0xc,%esp
c0409f8b:	6a 00                	push   $0x0
c0409f8d:	68 8e 00 00 00       	push   $0x8e
c0409f92:	6a 18                	push   $0x18
c0409f94:	50                   	push   %eax
c0409f95:	6a 51                	push   $0x51
c0409f97:	e8 4c 08 00 00       	call   c040a7e8 <int_set_gate>
c0409f9c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 18, (unsigned int)irq41, 0x18, 0x8E, 0);
c0409f9f:	b8 a5 03 40 c0       	mov    $0xc04003a5,%eax
c0409fa4:	83 ec 0c             	sub    $0xc,%esp
c0409fa7:	6a 00                	push   $0x0
c0409fa9:	68 8e 00 00 00       	push   $0x8e
c0409fae:	6a 18                	push   $0x18
c0409fb0:	50                   	push   %eax
c0409fb1:	6a 52                	push   $0x52
c0409fb3:	e8 30 08 00 00       	call   c040a7e8 <int_set_gate>
c0409fb8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 19, (unsigned int)irq42, 0x18, 0x8E, 0);
c0409fbb:	b8 af 03 40 c0       	mov    $0xc04003af,%eax
c0409fc0:	83 ec 0c             	sub    $0xc,%esp
c0409fc3:	6a 00                	push   $0x0
c0409fc5:	68 8e 00 00 00       	push   $0x8e
c0409fca:	6a 18                	push   $0x18
c0409fcc:	50                   	push   %eax
c0409fcd:	6a 53                	push   $0x53
c0409fcf:	e8 14 08 00 00       	call   c040a7e8 <int_set_gate>
c0409fd4:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 20, (unsigned int)irq43, 0x18, 0x8E, 0);
c0409fd7:	b8 b9 03 40 c0       	mov    $0xc04003b9,%eax
c0409fdc:	83 ec 0c             	sub    $0xc,%esp
c0409fdf:	6a 00                	push   $0x0
c0409fe1:	68 8e 00 00 00       	push   $0x8e
c0409fe6:	6a 18                	push   $0x18
c0409fe8:	50                   	push   %eax
c0409fe9:	6a 54                	push   $0x54
c0409feb:	e8 f8 07 00 00       	call   c040a7e8 <int_set_gate>
c0409ff0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 21, (unsigned int)irq44, 0x18, 0x8E, 0);
c0409ff3:	b8 c3 03 40 c0       	mov    $0xc04003c3,%eax
c0409ff8:	83 ec 0c             	sub    $0xc,%esp
c0409ffb:	6a 00                	push   $0x0
c0409ffd:	68 8e 00 00 00       	push   $0x8e
c040a002:	6a 18                	push   $0x18
c040a004:	50                   	push   %eax
c040a005:	6a 55                	push   $0x55
c040a007:	e8 dc 07 00 00       	call   c040a7e8 <int_set_gate>
c040a00c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 22, (unsigned int)irq45, 0x18, 0x8E, 0);
c040a00f:	b8 cd 03 40 c0       	mov    $0xc04003cd,%eax
c040a014:	83 ec 0c             	sub    $0xc,%esp
c040a017:	6a 00                	push   $0x0
c040a019:	68 8e 00 00 00       	push   $0x8e
c040a01e:	6a 18                	push   $0x18
c040a020:	50                   	push   %eax
c040a021:	6a 56                	push   $0x56
c040a023:	e8 c0 07 00 00       	call   c040a7e8 <int_set_gate>
c040a028:	83 c4 20             	add    $0x20,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 23, (unsigned int)irq46, 0x18, 0x8E, 1); /* reload IDT */
c040a02b:	b8 d7 03 40 c0       	mov    $0xc04003d7,%eax
c040a030:	83 ec 0c             	sub    $0xc,%esp
c040a033:	6a 01                	push   $0x1
c040a035:	68 8e 00 00 00       	push   $0x8e
c040a03a:	6a 18                	push   $0x18
c040a03c:	50                   	push   %eax
c040a03d:	6a 57                	push   $0x57
c040a03f:	e8 a4 07 00 00       	call   c040a7e8 <int_set_gate>
c040a044:	83 c4 20             	add    $0x20,%esp

	/* register the default handlers */
	for(loop = 0; loop < 24; loop++)
c040a047:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c040a04e:	00 
c040a04f:	eb 1d                	jmp    c040a06e <ioapic_initialise+0x312>
		irq_register_driver(IOAPIC_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &ioapic_irq_default);
c040a051:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040a055:	83 c0 40             	add    $0x40,%eax
c040a058:	68 44 9c 40 c0       	push   $0xc0409c44
c040a05d:	6a 00                	push   $0x0
c040a05f:	6a 02                	push   $0x2
c040a061:	50                   	push   %eax
c040a062:	e8 a4 78 ff ff       	call   c040190b <irq_register_driver>
c040a067:	83 c4 10             	add    $0x10,%esp
	int_set_gate(IOAPIC_VECTOR_BASE + 21, (unsigned int)irq44, 0x18, 0x8E, 0);
	int_set_gate(IOAPIC_VECTOR_BASE + 22, (unsigned int)irq45, 0x18, 0x8E, 0);
	int_set_gate(IOAPIC_VECTOR_BASE + 23, (unsigned int)irq46, 0x18, 0x8E, 1); /* reload IDT */

	/* register the default handlers */
	for(loop = 0; loop < 24; loop++)
c040a06a:	ff 44 24 1c          	incl   0x1c(%esp)
c040a06e:	83 7c 24 1c 17       	cmpl   $0x17,0x1c(%esp)
c040a073:	76 dc                	jbe    c040a051 <ioapic_initialise+0x2f5>
		irq_register_driver(IOAPIC_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &ioapic_irq_default);
		
	/* route the IRQ lines to our boot cpu */
	for(loop = 0; loop < 24; loop++)
c040a075:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
c040a07c:	00 
c040a07d:	eb 2a                	jmp    c040a0a9 <ioapic_initialise+0x34d>
		ioapic_route_set(id, loop, this_cpu, (IOAPIC_VECTOR_BASE + loop));
c040a07f:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040a083:	8d 58 40             	lea    0x40(%eax),%ebx
c040a086:	8b 44 24 18          	mov    0x18(%esp),%eax
c040a08a:	0f b6 c8             	movzbl %al,%ecx
c040a08d:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040a091:	0f b6 d0             	movzbl %al,%edx
c040a094:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a099:	53                   	push   %ebx
c040a09a:	51                   	push   %ecx
c040a09b:	52                   	push   %edx
c040a09c:	50                   	push   %eax
c040a09d:	e8 4f fc ff ff       	call   c0409cf1 <ioapic_route_set>
c040a0a2:	83 c4 10             	add    $0x10,%esp
	/* register the default handlers */
	for(loop = 0; loop < 24; loop++)
		irq_register_driver(IOAPIC_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &ioapic_irq_default);
		
	/* route the IRQ lines to our boot cpu */
	for(loop = 0; loop < 24; loop++)
c040a0a5:	ff 44 24 1c          	incl   0x1c(%esp)
c040a0a9:	83 7c 24 1c 17       	cmpl   $0x17,0x1c(%esp)
c040a0ae:	76 cf                	jbe    c040a07f <ioapic_initialise+0x323>
		ioapic_route_set(id, loop, this_cpu, (IOAPIC_VECTOR_BASE + loop));
}
c040a0b0:	83 c4 28             	add    $0x28,%esp
c040a0b3:	5b                   	pop    %ebx
c040a0b4:	c3                   	ret    
c040a0b5:	00 00                	add    %al,(%eax)
	...

c040a0b8 <pic_irq_default>:
extern void irq8();  extern void irq9();  extern void irq10(); extern void irq11();
extern void irq12(); extern void irq13(); extern void irq14(); extern void irq15();

/* the default PIC interrupt handler */
kresult pic_irq_default(unsigned char intnum, int_registers_block *regs)
{
c040a0b8:	83 ec 1c             	sub    $0x1c,%esp
c040a0bb:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a0bf:	88 44 24 0c          	mov    %al,0xc(%esp)
	/* clear the int from the chip */
	if(intnum >= PIC_SLAVE_VECTOR_BASE)
c040a0c3:	80 7c 24 0c 27       	cmpb   $0x27,0xc(%esp)
c040a0c8:	76 0d                	jbe    c040a0d7 <pic_irq_default+0x1f>
		x86_pic_reset(2); /* reset the slave if necessary */
c040a0ca:	83 ec 0c             	sub    $0xc,%esp
c040a0cd:	6a 02                	push   $0x2
c040a0cf:	e8 55 6d ff ff       	call   c0400e29 <x86_pic_reset>
c040a0d4:	83 c4 10             	add    $0x10,%esp
	x86_pic_reset(1); /* as well as the master */
c040a0d7:	83 ec 0c             	sub    $0xc,%esp
c040a0da:	6a 01                	push   $0x1
c040a0dc:	e8 48 6d ff ff       	call   c0400e29 <x86_pic_reset>
c040a0e1:	83 c4 10             	add    $0x10,%esp
	
	return success;
c040a0e4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040a0e9:	83 c4 1c             	add    $0x1c,%esp
c040a0ec:	c3                   	ret    

c040a0ed <pic_initialise>:

/* initialise the common entries in the int table for uni and multiproc systems */
void pic_initialise(void)
{
c040a0ed:	83 ec 1c             	sub    $0x1c,%esp
	PIC_DEBUG("[pic:%i] initialising common x86 interrupt handlers... \n", CPU_ID);
	
	/* reprogram the basic PICs so that any old-world interrupts
	 get sent to the 16 vectors above the cpu exceptions.
	 Run the PIC vectors from 32 (0x20) to 47 (0x2F) */
	x86_pic_remap(PIC_MASTER_VECTOR_BASE, PIC_SLAVE_VECTOR_BASE);
c040a0f0:	83 ec 08             	sub    $0x8,%esp
c040a0f3:	6a 28                	push   $0x28
c040a0f5:	6a 20                	push   $0x20
c040a0f7:	e8 74 6c ff ff       	call   c0400d70 <x86_pic_remap>
c040a0fc:	83 c4 10             	add    $0x10,%esp
	
	/* ..and direct the old-world hardware interrupts at the right vectors */
	int_set_gate(PIC_MASTER_VECTOR_BASE + 0, (unsigned int)irq0,  0x18, 0x8E, 0);
c040a0ff:	b8 0b 02 40 c0       	mov    $0xc040020b,%eax
c040a104:	83 ec 0c             	sub    $0xc,%esp
c040a107:	6a 00                	push   $0x0
c040a109:	68 8e 00 00 00       	push   $0x8e
c040a10e:	6a 18                	push   $0x18
c040a110:	50                   	push   %eax
c040a111:	6a 20                	push   $0x20
c040a113:	e8 d0 06 00 00       	call   c040a7e8 <int_set_gate>
c040a118:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 1, (unsigned int)irq1,  0x18, 0x8E, 0);
c040a11b:	b8 15 02 40 c0       	mov    $0xc0400215,%eax
c040a120:	83 ec 0c             	sub    $0xc,%esp
c040a123:	6a 00                	push   $0x0
c040a125:	68 8e 00 00 00       	push   $0x8e
c040a12a:	6a 18                	push   $0x18
c040a12c:	50                   	push   %eax
c040a12d:	6a 21                	push   $0x21
c040a12f:	e8 b4 06 00 00       	call   c040a7e8 <int_set_gate>
c040a134:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 2, (unsigned int)irq2,  0x18, 0x8E, 0);
c040a137:	b8 1f 02 40 c0       	mov    $0xc040021f,%eax
c040a13c:	83 ec 0c             	sub    $0xc,%esp
c040a13f:	6a 00                	push   $0x0
c040a141:	68 8e 00 00 00       	push   $0x8e
c040a146:	6a 18                	push   $0x18
c040a148:	50                   	push   %eax
c040a149:	6a 22                	push   $0x22
c040a14b:	e8 98 06 00 00       	call   c040a7e8 <int_set_gate>
c040a150:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 3, (unsigned int)irq3,  0x18, 0x8E, 0);
c040a153:	b8 29 02 40 c0       	mov    $0xc0400229,%eax
c040a158:	83 ec 0c             	sub    $0xc,%esp
c040a15b:	6a 00                	push   $0x0
c040a15d:	68 8e 00 00 00       	push   $0x8e
c040a162:	6a 18                	push   $0x18
c040a164:	50                   	push   %eax
c040a165:	6a 23                	push   $0x23
c040a167:	e8 7c 06 00 00       	call   c040a7e8 <int_set_gate>
c040a16c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 4, (unsigned int)irq4,  0x18, 0x8E, 0);
c040a16f:	b8 33 02 40 c0       	mov    $0xc0400233,%eax
c040a174:	83 ec 0c             	sub    $0xc,%esp
c040a177:	6a 00                	push   $0x0
c040a179:	68 8e 00 00 00       	push   $0x8e
c040a17e:	6a 18                	push   $0x18
c040a180:	50                   	push   %eax
c040a181:	6a 24                	push   $0x24
c040a183:	e8 60 06 00 00       	call   c040a7e8 <int_set_gate>
c040a188:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 5, (unsigned int)irq5,  0x18, 0x8E, 0);
c040a18b:	b8 3d 02 40 c0       	mov    $0xc040023d,%eax
c040a190:	83 ec 0c             	sub    $0xc,%esp
c040a193:	6a 00                	push   $0x0
c040a195:	68 8e 00 00 00       	push   $0x8e
c040a19a:	6a 18                	push   $0x18
c040a19c:	50                   	push   %eax
c040a19d:	6a 25                	push   $0x25
c040a19f:	e8 44 06 00 00       	call   c040a7e8 <int_set_gate>
c040a1a4:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 6, (unsigned int)irq6,  0x18, 0x8E, 0);
c040a1a7:	b8 47 02 40 c0       	mov    $0xc0400247,%eax
c040a1ac:	83 ec 0c             	sub    $0xc,%esp
c040a1af:	6a 00                	push   $0x0
c040a1b1:	68 8e 00 00 00       	push   $0x8e
c040a1b6:	6a 18                	push   $0x18
c040a1b8:	50                   	push   %eax
c040a1b9:	6a 26                	push   $0x26
c040a1bb:	e8 28 06 00 00       	call   c040a7e8 <int_set_gate>
c040a1c0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_MASTER_VECTOR_BASE + 7, (unsigned int)irq7,  0x18, 0x8E, 0);
c040a1c3:	b8 51 02 40 c0       	mov    $0xc0400251,%eax
c040a1c8:	83 ec 0c             	sub    $0xc,%esp
c040a1cb:	6a 00                	push   $0x0
c040a1cd:	68 8e 00 00 00       	push   $0x8e
c040a1d2:	6a 18                	push   $0x18
c040a1d4:	50                   	push   %eax
c040a1d5:	6a 27                	push   $0x27
c040a1d7:	e8 0c 06 00 00       	call   c040a7e8 <int_set_gate>
c040a1dc:	83 c4 20             	add    $0x20,%esp
	
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 0, (unsigned int)irq8,  0x18, 0x8E, 0);
c040a1df:	b8 5b 02 40 c0       	mov    $0xc040025b,%eax
c040a1e4:	83 ec 0c             	sub    $0xc,%esp
c040a1e7:	6a 00                	push   $0x0
c040a1e9:	68 8e 00 00 00       	push   $0x8e
c040a1ee:	6a 18                	push   $0x18
c040a1f0:	50                   	push   %eax
c040a1f1:	6a 28                	push   $0x28
c040a1f3:	e8 f0 05 00 00       	call   c040a7e8 <int_set_gate>
c040a1f8:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 1, (unsigned int)irq9,  0x18, 0x8E, 0);
c040a1fb:	b8 65 02 40 c0       	mov    $0xc0400265,%eax
c040a200:	83 ec 0c             	sub    $0xc,%esp
c040a203:	6a 00                	push   $0x0
c040a205:	68 8e 00 00 00       	push   $0x8e
c040a20a:	6a 18                	push   $0x18
c040a20c:	50                   	push   %eax
c040a20d:	6a 29                	push   $0x29
c040a20f:	e8 d4 05 00 00       	call   c040a7e8 <int_set_gate>
c040a214:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 2, (unsigned int)irq10, 0x18, 0x8E, 0);
c040a217:	b8 6f 02 40 c0       	mov    $0xc040026f,%eax
c040a21c:	83 ec 0c             	sub    $0xc,%esp
c040a21f:	6a 00                	push   $0x0
c040a221:	68 8e 00 00 00       	push   $0x8e
c040a226:	6a 18                	push   $0x18
c040a228:	50                   	push   %eax
c040a229:	6a 2a                	push   $0x2a
c040a22b:	e8 b8 05 00 00       	call   c040a7e8 <int_set_gate>
c040a230:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 3, (unsigned int)irq11, 0x18, 0x8E, 0);
c040a233:	b8 79 02 40 c0       	mov    $0xc0400279,%eax
c040a238:	83 ec 0c             	sub    $0xc,%esp
c040a23b:	6a 00                	push   $0x0
c040a23d:	68 8e 00 00 00       	push   $0x8e
c040a242:	6a 18                	push   $0x18
c040a244:	50                   	push   %eax
c040a245:	6a 2b                	push   $0x2b
c040a247:	e8 9c 05 00 00       	call   c040a7e8 <int_set_gate>
c040a24c:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 4, (unsigned int)irq12, 0x18, 0x8E, 0);
c040a24f:	b8 83 02 40 c0       	mov    $0xc0400283,%eax
c040a254:	83 ec 0c             	sub    $0xc,%esp
c040a257:	6a 00                	push   $0x0
c040a259:	68 8e 00 00 00       	push   $0x8e
c040a25e:	6a 18                	push   $0x18
c040a260:	50                   	push   %eax
c040a261:	6a 2c                	push   $0x2c
c040a263:	e8 80 05 00 00       	call   c040a7e8 <int_set_gate>
c040a268:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 5, (unsigned int)irq13, 0x18, 0x8E, 0);
c040a26b:	b8 8d 02 40 c0       	mov    $0xc040028d,%eax
c040a270:	83 ec 0c             	sub    $0xc,%esp
c040a273:	6a 00                	push   $0x0
c040a275:	68 8e 00 00 00       	push   $0x8e
c040a27a:	6a 18                	push   $0x18
c040a27c:	50                   	push   %eax
c040a27d:	6a 2d                	push   $0x2d
c040a27f:	e8 64 05 00 00       	call   c040a7e8 <int_set_gate>
c040a284:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 6, (unsigned int)irq14, 0x18, 0x8E, 0);
c040a287:	b8 97 02 40 c0       	mov    $0xc0400297,%eax
c040a28c:	83 ec 0c             	sub    $0xc,%esp
c040a28f:	6a 00                	push   $0x0
c040a291:	68 8e 00 00 00       	push   $0x8e
c040a296:	6a 18                	push   $0x18
c040a298:	50                   	push   %eax
c040a299:	6a 2e                	push   $0x2e
c040a29b:	e8 48 05 00 00       	call   c040a7e8 <int_set_gate>
c040a2a0:	83 c4 20             	add    $0x20,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 7, (unsigned int)irq15, 0x18, 0x8E, 1);
c040a2a3:	b8 a1 02 40 c0       	mov    $0xc04002a1,%eax
c040a2a8:	83 ec 0c             	sub    $0xc,%esp
c040a2ab:	6a 01                	push   $0x1
c040a2ad:	68 8e 00 00 00       	push   $0x8e
c040a2b2:	6a 18                	push   $0x18
c040a2b4:	50                   	push   %eax
c040a2b5:	6a 2f                	push   $0x2f
c040a2b7:	e8 2c 05 00 00       	call   c040a7e8 <int_set_gate>
c040a2bc:	83 c4 20             	add    $0x20,%esp
	
	/* install the default handler - route the IRQ lines to our boot cpu */
	for(loop = 0; loop < 8; loop++)
c040a2bf:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040a2c6:	00 
c040a2c7:	eb 1d                	jmp    c040a2e6 <pic_initialise+0x1f9>
		irq_register_driver(PIC_MASTER_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &pic_irq_default);
c040a2c9:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a2cd:	83 c0 20             	add    $0x20,%eax
c040a2d0:	68 b8 a0 40 c0       	push   $0xc040a0b8
c040a2d5:	6a 00                	push   $0x0
c040a2d7:	6a 02                	push   $0x2
c040a2d9:	50                   	push   %eax
c040a2da:	e8 2c 76 ff ff       	call   c040190b <irq_register_driver>
c040a2df:	83 c4 10             	add    $0x10,%esp
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 5, (unsigned int)irq13, 0x18, 0x8E, 0);
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 6, (unsigned int)irq14, 0x18, 0x8E, 0);
	int_set_gate(PIC_SLAVE_VECTOR_BASE + 7, (unsigned int)irq15, 0x18, 0x8E, 1);
	
	/* install the default handler - route the IRQ lines to our boot cpu */
	for(loop = 0; loop < 8; loop++)
c040a2e2:	ff 44 24 0c          	incl   0xc(%esp)
c040a2e6:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
c040a2eb:	76 dc                	jbe    c040a2c9 <pic_initialise+0x1dc>
		irq_register_driver(PIC_MASTER_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &pic_irq_default);
	
	for(loop = 0; loop < 8; loop++)
c040a2ed:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040a2f4:	00 
c040a2f5:	eb 1d                	jmp    c040a314 <pic_initialise+0x227>
		irq_register_driver(PIC_SLAVE_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &pic_irq_default);
c040a2f7:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a2fb:	83 c0 28             	add    $0x28,%eax
c040a2fe:	68 b8 a0 40 c0       	push   $0xc040a0b8
c040a303:	6a 00                	push   $0x0
c040a305:	6a 02                	push   $0x2
c040a307:	50                   	push   %eax
c040a308:	e8 fe 75 ff ff       	call   c040190b <irq_register_driver>
c040a30d:	83 c4 10             	add    $0x10,%esp
	
	/* install the default handler - route the IRQ lines to our boot cpu */
	for(loop = 0; loop < 8; loop++)
		irq_register_driver(PIC_MASTER_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &pic_irq_default);
	
	for(loop = 0; loop < 8; loop++)
c040a310:	ff 44 24 0c          	incl   0xc(%esp)
c040a314:	83 7c 24 0c 07       	cmpl   $0x7,0xc(%esp)
c040a319:	76 dc                	jbe    c040a2f7 <pic_initialise+0x20a>
		irq_register_driver(PIC_SLAVE_VECTOR_BASE + loop, IRQ_DRIVER_FUNCTION, 0, &pic_irq_default);
	
	/* register the timer handler for the scheduler */
	irq_register_driver(ISA_8254_IRQ, IRQ_DRIVER_FUNCTION, 0, &int_common_timer);
c040a31b:	68 a0 a8 40 c0       	push   $0xc040a8a0
c040a320:	6a 00                	push   $0x0
c040a322:	6a 02                	push   $0x2
c040a324:	6a 00                	push   $0x0
c040a326:	e8 e0 75 ff ff       	call   c040190b <irq_register_driver>
c040a32b:	83 c4 10             	add    $0x10,%esp
}
c040a32e:	83 c4 1c             	add    $0x1c,%esp
c040a331:	c3                   	ret    
	...

c040a334 <lapic_irq_default>:
volatile unsigned int lapic_preflight_timer_lap[4];
volatile unsigned int lapic_preflight_timer_init;

/* default handler for local APIC's IRQs - just EOI the interrupt */
kresult lapic_irq_default(unsigned char intnum, int_registers_block *regs)
{
c040a334:	83 ec 1c             	sub    $0x1c,%esp
c040a337:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a33b:	88 44 24 0c          	mov    %al,0xc(%esp)
	lapic_end_interrupt();
c040a33f:	e8 57 00 00 00       	call   c040a39b <lapic_end_interrupt>
	return success;
c040a344:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040a349:	83 c4 1c             	add    $0x1c,%esp
c040a34c:	c3                   	ret    

c040a34d <lapic_preflight_timer>:

/* Local APIC timer handler during timer preflight check - used to calibrated the
   lAPIC timer for the scheduler */
unsigned int lapic_preflight_timer(unsigned char intnum, int_registers_block *regs)
{
c040a34d:	83 ec 1c             	sub    $0x1c,%esp
c040a350:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a354:	88 44 24 0c          	mov    %al,0xc(%esp)
	/* sample the lAPIC's current timer value */
	lapic_preflight_timer_lap[lapic_preflight_timer_pass] = (*LAPIC_TIMERNOW) / 4;
c040a358:	a0 18 1d 41 c0       	mov    0xc0411d18,%al
c040a35d:	0f b6 c0             	movzbl %al,%eax
c040a360:	ba 90 03 e0 fe       	mov    $0xfee00390,%edx
c040a365:	8b 12                	mov    (%edx),%edx
c040a367:	c1 ea 02             	shr    $0x2,%edx
c040a36a:	89 14 85 c0 f4 40 c0 	mov    %edx,-0x3fbf0b40(,%eax,4)
	if(lapic_preflight_timer_pass < 4) lapic_preflight_timer_pass++;
c040a371:	a0 18 1d 41 c0       	mov    0xc0411d18,%al
c040a376:	3c 03                	cmp    $0x3,%al
c040a378:	77 0b                	ja     c040a385 <lapic_preflight_timer+0x38>
c040a37a:	a0 18 1d 41 c0       	mov    0xc0411d18,%al
c040a37f:	40                   	inc    %eax
c040a380:	a2 18 1d 41 c0       	mov    %al,0xc0411d18
	
	/* reload to max value */
	lapic_write(LAPIC_TIMERINIT, 0xffffffff);
c040a385:	83 ec 08             	sub    $0x8,%esp
c040a388:	6a ff                	push   $0xffffffff
c040a38a:	68 80 03 e0 fe       	push   $0xfee00380
c040a38f:	e8 20 00 00 00       	call   c040a3b4 <lapic_write>
c040a394:	83 c4 10             	add    $0x10,%esp
}
c040a397:	83 c4 1c             	add    $0x1c,%esp
c040a39a:	c3                   	ret    

c040a39b <lapic_end_interrupt>:

/* lapic_end_interrupt 
	Signal the end of handling an interrupt in this lAPIC */
void lapic_end_interrupt(void)
{
c040a39b:	83 ec 0c             	sub    $0xc,%esp
	LAPIC_DEBUG("[lapic:%i] ending interrupt\n", CPU_ID);
	
	lapic_write(LAPIC_EOI, 0);
c040a39e:	83 ec 08             	sub    $0x8,%esp
c040a3a1:	6a 00                	push   $0x0
c040a3a3:	68 b0 00 e0 fe       	push   $0xfee000b0
c040a3a8:	e8 07 00 00 00       	call   c040a3b4 <lapic_write>
c040a3ad:	83 c4 10             	add    $0x10,%esp
}
c040a3b0:	83 c4 0c             	add    $0xc,%esp
c040a3b3:	c3                   	ret    

c040a3b4 <lapic_write>:
#ifdef BUGS_PENTIUM_LAPIC_RW
	volatile unsigned int read = *addr;
#endif
	
	/* simple, eh? */
	*addr = value;
c040a3b4:	8b 54 24 08          	mov    0x8(%esp),%edx
c040a3b8:	8b 44 24 04          	mov    0x4(%esp),%eax
c040a3bc:	89 10                	mov    %edx,(%eax)
}
c040a3be:	c3                   	ret    

c040a3bf <lapic_icr_ready>:

/* int_apic_icr_ready
   Wait until the local APIC's IPI-pending flag is zero */
void lapic_icr_ready(void)
{
	while((*LAPIC_ICR_LO) & LAPIC_PENDING) __asm__ __volatile__("pause");
c040a3bf:	eb 02                	jmp    c040a3c3 <lapic_icr_ready+0x4>
c040a3c1:	f3 90                	pause  
c040a3c3:	b8 00 03 e0 fe       	mov    $0xfee00300,%eax
c040a3c8:	8b 00                	mov    (%eax),%eax
c040a3ca:	25 00 10 00 00       	and    $0x1000,%eax
c040a3cf:	85 c0                	test   %eax,%eax
c040a3d1:	75 ee                	jne    c040a3c1 <lapic_icr_ready+0x2>
}
c040a3d3:	c3                   	ret    

c040a3d4 <lapic_ipi_send_init>:
void lapic_ipi_send_init(unsigned int destination)
{
	LAPIC_DEBUG("[lapic:%i] sending INIT IPI (%x) to AP %i..\n",
					CPU_ID, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT, destination);

	lapic_icr_ready(); /* wait for the command reg to be ready */
c040a3d4:	e8 e6 ff ff ff       	call   c040a3bf <lapic_icr_ready>
	
	/* write to HI, then LO to send */
	lapic_write(LAPIC_ICR_HI, destination << LAPIC_DEST_SHIFT);
c040a3d9:	8b 44 24 04          	mov    0x4(%esp),%eax
c040a3dd:	c1 e0 18             	shl    $0x18,%eax
c040a3e0:	50                   	push   %eax
c040a3e1:	68 10 03 e0 fe       	push   $0xfee00310
c040a3e6:	e8 c9 ff ff ff       	call   c040a3b4 <lapic_write>
c040a3eb:	83 c4 08             	add    $0x8,%esp
	lapic_write(LAPIC_ICR_LO, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ASSERT);
c040a3ee:	68 00 c5 00 00       	push   $0xc500
c040a3f3:	68 00 03 e0 fe       	push   $0xfee00300
c040a3f8:	e8 b7 ff ff ff       	call   c040a3b4 <lapic_write>
c040a3fd:	83 c4 08             	add    $0x8,%esp
	
	/* don't forget to deassert the INIT */
	lapic_write(LAPIC_ICR_LO, LAPIC_TYPE_INIT | LAPIC_TRG_LEVEL | LAPIC_ALLINCSEL);
c040a400:	68 00 85 08 00       	push   $0x88500
c040a405:	68 00 03 e0 fe       	push   $0xfee00300
c040a40a:	e8 a5 ff ff ff       	call   c040a3b4 <lapic_write>
c040a40f:	83 c4 08             	add    $0x8,%esp
}
c040a412:	c3                   	ret    

c040a413 <lapic_ipi_send_startup>:

/* int_ipi_send_startup
	Send a startup IPI to the given processor using the given vector
*/
void lapic_ipi_send_startup(unsigned int destination, unsigned char vector)
{
c040a413:	83 ec 04             	sub    $0x4,%esp
c040a416:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040a41a:	88 04 24             	mov    %al,(%esp)
	LAPIC_DEBUG("[lapic:%i] sending startup IPI (%x) to AP %i..\n",
					CPU_ID, vector | LAPIC_TYPE_START | LAPIC_ASSERT, destination);
	
	lapic_icr_ready(); /* wait for the command reg to be ready */
c040a41d:	e8 9d ff ff ff       	call   c040a3bf <lapic_icr_ready>

	/* write to HI, then LO to send */
	lapic_write(LAPIC_ICR_HI, destination << LAPIC_DEST_SHIFT);
c040a422:	8b 44 24 08          	mov    0x8(%esp),%eax
c040a426:	c1 e0 18             	shl    $0x18,%eax
c040a429:	50                   	push   %eax
c040a42a:	68 10 03 e0 fe       	push   $0xfee00310
c040a42f:	e8 80 ff ff ff       	call   c040a3b4 <lapic_write>
c040a434:	83 c4 08             	add    $0x8,%esp
	lapic_write(LAPIC_ICR_LO, vector | LAPIC_TYPE_START | LAPIC_ASSERT);
c040a437:	0f b6 04 24          	movzbl (%esp),%eax
c040a43b:	80 cc 46             	or     $0x46,%ah
c040a43e:	50                   	push   %eax
c040a43f:	68 00 03 e0 fe       	push   $0xfee00300
c040a444:	e8 6b ff ff ff       	call   c040a3b4 <lapic_write>
c040a449:	83 c4 08             	add    $0x8,%esp
}
c040a44c:	83 c4 04             	add    $0x4,%esp
c040a44f:	c3                   	ret    

c040a450 <lapic_initialise>:
	Set up a cpu's local APIC on a multiprocessor system
   => flags = flag up who's calling this function
				  INT_IAMBSP = 1 for the BSP, which will create the int table
*/
void lapic_initialise(unsigned char flags)
{	
c040a450:	83 ec 2c             	sub    $0x2c,%esp
c040a453:	8b 44 24 30          	mov    0x30(%esp),%eax
c040a457:	88 44 24 0c          	mov    %al,0xc(%esp)
	LAPIC_DEBUG("[lapic:%i] programming APIC on cpu %i\n", CPU_ID, CPU_ID);
	
	if(flags & INT_IAMBSP)
c040a45b:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a460:	83 e0 01             	and    $0x1,%eax
c040a463:	84 c0                	test   %al,%al
c040a465:	0f 84 49 01 00 00    	je     c040a5b4 <lapic_initialise+0x164>
	{
		/* install the APIC int handlers */
		int_set_gate(IRQ_APIC_TIMER,    (unsigned int)irq16, 0x18, 0x8E, 0);
c040a46b:	b8 ab 02 40 c0       	mov    $0xc04002ab,%eax
c040a470:	83 ec 0c             	sub    $0xc,%esp
c040a473:	6a 00                	push   $0x0
c040a475:	68 8e 00 00 00       	push   $0x8e
c040a47a:	6a 18                	push   $0x18
c040a47c:	50                   	push   %eax
c040a47d:	6a 30                	push   $0x30
c040a47f:	e8 64 03 00 00       	call   c040a7e8 <int_set_gate>
c040a484:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_TIMER, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a487:	68 34 a3 40 c0       	push   $0xc040a334
c040a48c:	6a 00                	push   $0x0
c040a48e:	6a 02                	push   $0x2
c040a490:	6a 30                	push   $0x30
c040a492:	e8 74 74 ff ff       	call   c040190b <irq_register_driver>
c040a497:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_LINT0,    (unsigned int)irq17, 0x18, 0x8E, 0);
c040a49a:	b8 b5 02 40 c0       	mov    $0xc04002b5,%eax
c040a49f:	83 ec 0c             	sub    $0xc,%esp
c040a4a2:	6a 00                	push   $0x0
c040a4a4:	68 8e 00 00 00       	push   $0x8e
c040a4a9:	6a 18                	push   $0x18
c040a4ab:	50                   	push   %eax
c040a4ac:	6a 31                	push   $0x31
c040a4ae:	e8 35 03 00 00       	call   c040a7e8 <int_set_gate>
c040a4b3:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_LINT0, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a4b6:	68 34 a3 40 c0       	push   $0xc040a334
c040a4bb:	6a 00                	push   $0x0
c040a4bd:	6a 02                	push   $0x2
c040a4bf:	6a 31                	push   $0x31
c040a4c1:	e8 45 74 ff ff       	call   c040190b <irq_register_driver>
c040a4c6:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_LINT1,    (unsigned int)irq18, 0x18, 0x8E, 0);
c040a4c9:	b8 bf 02 40 c0       	mov    $0xc04002bf,%eax
c040a4ce:	83 ec 0c             	sub    $0xc,%esp
c040a4d1:	6a 00                	push   $0x0
c040a4d3:	68 8e 00 00 00       	push   $0x8e
c040a4d8:	6a 18                	push   $0x18
c040a4da:	50                   	push   %eax
c040a4db:	6a 32                	push   $0x32
c040a4dd:	e8 06 03 00 00       	call   c040a7e8 <int_set_gate>
c040a4e2:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_LINT1, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a4e5:	68 34 a3 40 c0       	push   $0xc040a334
c040a4ea:	6a 00                	push   $0x0
c040a4ec:	6a 02                	push   $0x2
c040a4ee:	6a 32                	push   $0x32
c040a4f0:	e8 16 74 ff ff       	call   c040190b <irq_register_driver>
c040a4f5:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_PCINT,    (unsigned int)irq19, 0x18, 0x8E, 0);
c040a4f8:	b8 c9 02 40 c0       	mov    $0xc04002c9,%eax
c040a4fd:	83 ec 0c             	sub    $0xc,%esp
c040a500:	6a 00                	push   $0x0
c040a502:	68 8e 00 00 00       	push   $0x8e
c040a507:	6a 18                	push   $0x18
c040a509:	50                   	push   %eax
c040a50a:	6a 33                	push   $0x33
c040a50c:	e8 d7 02 00 00       	call   c040a7e8 <int_set_gate>
c040a511:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_PCINT, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a514:	68 34 a3 40 c0       	push   $0xc040a334
c040a519:	6a 00                	push   $0x0
c040a51b:	6a 02                	push   $0x2
c040a51d:	6a 33                	push   $0x33
c040a51f:	e8 e7 73 ff ff       	call   c040190b <irq_register_driver>
c040a524:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_SPURIOUS, (unsigned int)irq20, 0x18, 0x8E, 0);
c040a527:	b8 d3 02 40 c0       	mov    $0xc04002d3,%eax
c040a52c:	83 ec 0c             	sub    $0xc,%esp
c040a52f:	6a 00                	push   $0x0
c040a531:	68 8e 00 00 00       	push   $0x8e
c040a536:	6a 18                	push   $0x18
c040a538:	50                   	push   %eax
c040a539:	6a 3f                	push   $0x3f
c040a53b:	e8 a8 02 00 00       	call   c040a7e8 <int_set_gate>
c040a540:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_SPURIOUS, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a543:	68 34 a3 40 c0       	push   $0xc040a334
c040a548:	6a 00                	push   $0x0
c040a54a:	6a 02                	push   $0x2
c040a54c:	6a 3f                	push   $0x3f
c040a54e:	e8 b8 73 ff ff       	call   c040190b <irq_register_driver>
c040a553:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_THERMAL,  (unsigned int)irq21, 0x18, 0x8E, 0);
c040a556:	b8 dd 02 40 c0       	mov    $0xc04002dd,%eax
c040a55b:	83 ec 0c             	sub    $0xc,%esp
c040a55e:	6a 00                	push   $0x0
c040a560:	68 8e 00 00 00       	push   $0x8e
c040a565:	6a 18                	push   $0x18
c040a567:	50                   	push   %eax
c040a568:	6a 34                	push   $0x34
c040a56a:	e8 79 02 00 00       	call   c040a7e8 <int_set_gate>
c040a56f:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_THERMAL, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a572:	68 34 a3 40 c0       	push   $0xc040a334
c040a577:	6a 00                	push   $0x0
c040a579:	6a 02                	push   $0x2
c040a57b:	6a 34                	push   $0x34
c040a57d:	e8 89 73 ff ff       	call   c040190b <irq_register_driver>
c040a582:	83 c4 10             	add    $0x10,%esp
		
		int_set_gate(IRQ_APIC_ERROR,    (unsigned int)irq22, 0x18, 0x8E, 1); /* reload idt */
c040a585:	b8 e7 02 40 c0       	mov    $0xc04002e7,%eax
c040a58a:	83 ec 0c             	sub    $0xc,%esp
c040a58d:	6a 01                	push   $0x1
c040a58f:	68 8e 00 00 00       	push   $0x8e
c040a594:	6a 18                	push   $0x18
c040a596:	50                   	push   %eax
c040a597:	6a 35                	push   $0x35
c040a599:	e8 4a 02 00 00       	call   c040a7e8 <int_set_gate>
c040a59e:	83 c4 20             	add    $0x20,%esp
		irq_register_driver(IRQ_APIC_ERROR, IRQ_DRIVER_FUNCTION, 0, &lapic_irq_default);
c040a5a1:	68 34 a3 40 c0       	push   $0xc040a334
c040a5a6:	6a 00                	push   $0x0
c040a5a8:	6a 02                	push   $0x2
c040a5aa:	6a 35                	push   $0x35
c040a5ac:	e8 5a 73 ff ff       	call   c040190b <irq_register_driver>
c040a5b1:	83 c4 10             	add    $0x10,%esp
	}
	
	/* program the APIC's registers so that interrupts point towards
	   the correct entries in the table of handlers  - start with the 
	   destination and task priority registers before enabling the APIC */
	lapic_write(LAPIC_DESTID,  0xff000000);
c040a5b4:	83 ec 08             	sub    $0x8,%esp
c040a5b7:	68 00 00 00 ff       	push   $0xff000000
c040a5bc:	68 d0 00 e0 fe       	push   $0xfee000d0
c040a5c1:	e8 ee fd ff ff       	call   c040a3b4 <lapic_write>
c040a5c6:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_DESTFMT, 0xffffffff); /* force into flat SMP mode */
c040a5c9:	83 ec 08             	sub    $0x8,%esp
c040a5cc:	6a ff                	push   $0xffffffff
c040a5ce:	68 e0 00 e0 fe       	push   $0xfee000e0
c040a5d3:	e8 dc fd ff ff       	call   c040a3b4 <lapic_write>
c040a5d8:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TASKPRI, 0); /* clear the task priority reg so all ints are handled */
c040a5db:	83 ec 08             	sub    $0x8,%esp
c040a5de:	6a 00                	push   $0x0
c040a5e0:	68 80 00 e0 fe       	push   $0xfee00080
c040a5e5:	e8 ca fd ff ff       	call   c040a3b4 <lapic_write>
c040a5ea:	83 c4 10             	add    $0x10,%esp
		
	lapic_write(LAPIC_SPURIOUS_REG, IRQ_APIC_SPURIOUS | LAPIC_ENABLE);
c040a5ed:	83 ec 08             	sub    $0x8,%esp
c040a5f0:	68 3f 01 00 00       	push   $0x13f
c040a5f5:	68 f0 00 e0 fe       	push   $0xfee000f0
c040a5fa:	e8 b5 fd ff ff       	call   c040a3b4 <lapic_write>
c040a5ff:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_TIMER,    IRQ_APIC_TIMER);
c040a602:	83 ec 08             	sub    $0x8,%esp
c040a605:	6a 30                	push   $0x30
c040a607:	68 20 03 e0 fe       	push   $0xfee00320
c040a60c:	e8 a3 fd ff ff       	call   c040a3b4 <lapic_write>
c040a611:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_LINT0,    IRQ_APIC_LINT0);
c040a614:	83 ec 08             	sub    $0x8,%esp
c040a617:	6a 31                	push   $0x31
c040a619:	68 50 03 e0 fe       	push   $0xfee00350
c040a61e:	e8 91 fd ff ff       	call   c040a3b4 <lapic_write>
c040a623:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_LINT1,    IRQ_APIC_LINT1 | LAPIC_LVT_NMI);
c040a626:	83 ec 08             	sub    $0x8,%esp
c040a629:	68 32 04 00 00       	push   $0x432
c040a62e:	68 60 03 e0 fe       	push   $0xfee00360
c040a633:	e8 7c fd ff ff       	call   c040a3b4 <lapic_write>
c040a638:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_PCOUNTER, IRQ_APIC_PCINT | LAPIC_LVT_MASK);
c040a63b:	83 ec 08             	sub    $0x8,%esp
c040a63e:	68 33 00 01 00       	push   $0x10033
c040a643:	68 40 03 e0 fe       	push   $0xfee00340
c040a648:	e8 67 fd ff ff       	call   c040a3b4 <lapic_write>
c040a64d:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_THERMAL,  IRQ_APIC_THERMAL);
c040a650:	83 ec 08             	sub    $0x8,%esp
c040a653:	6a 34                	push   $0x34
c040a655:	68 30 03 e0 fe       	push   $0xfee00330
c040a65a:	e8 55 fd ff ff       	call   c040a3b4 <lapic_write>
c040a65f:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_LVT_ERROR,    IRQ_APIC_ERROR);
c040a662:	83 ec 08             	sub    $0x8,%esp
c040a665:	6a 35                	push   $0x35
c040a667:	68 70 03 e0 fe       	push   $0xfee00370
c040a66c:	e8 43 fd ff ff       	call   c040a3b4 <lapic_write>
c040a671:	83 c4 10             	add    $0x10,%esp
	
	/* allow the boot processor to perform one-time system init and pre-flight checks */
	if(flags & INT_IAMBSP)
c040a674:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a679:	83 e0 01             	and    $0x1,%eax
c040a67c:	84 c0                	test   %al,%al
c040a67e:	0f 84 f4 00 00 00    	je     c040a778 <lapic_initialise+0x328>
		
		/* calculate average CPU bus speed and, thus, the local APIC's timer period */
		LAPIC_DEBUG("[lapic:%i] performing APIC pre-flight checks...\n", CPU_ID);
		
		/* attach the preflight timer handler to the correct IRQ line */
		if(bus_find_irq(&irq, "ISA", ISA_8254_IRQ) != success)
c040a684:	83 ec 04             	sub    $0x4,%esp
c040a687:	6a 00                	push   $0x0
c040a689:	68 08 d2 40 c0       	push   $0xc040d208
c040a68e:	8d 44 24 2b          	lea    0x2b(%esp),%eax
c040a692:	50                   	push   %eax
c040a693:	e8 30 01 00 00       	call   c040a7c8 <bus_find_irq>
c040a698:	83 c4 10             	add    $0x10,%esp
c040a69b:	85 c0                	test   %eax,%eax
c040a69d:	74 10                	je     c040a6af <lapic_initialise+0x25f>
			debug_panic("cannot find a motherboard timer to calibrate lAPIC timer");
c040a69f:	83 ec 0c             	sub    $0xc,%esp
c040a6a2:	68 0c d2 40 c0       	push   $0xc040d20c
c040a6a7:	e8 ee 12 00 00       	call   c040b99a <debug_panic>
c040a6ac:	83 c4 10             	add    $0x10,%esp
		irq_register_driver(irq, IRQ_DRIVER_FUNCTION, 0, &lapic_preflight_timer);
c040a6af:	ba 4d a3 40 c0       	mov    $0xc040a34d,%edx
c040a6b4:	8a 44 24 1f          	mov    0x1f(%esp),%al
c040a6b8:	0f b6 c0             	movzbl %al,%eax
c040a6bb:	52                   	push   %edx
c040a6bc:	6a 00                	push   $0x0
c040a6be:	6a 02                	push   $0x2
c040a6c0:	50                   	push   %eax
c040a6c1:	e8 45 72 ff ff       	call   c040190b <irq_register_driver>
c040a6c6:	83 c4 10             	add    $0x10,%esp

		/* set the old-world timer to fire every at the rate expcted by the scheduler
		 and see how far the CPU's APIC counts down in those periods */
		lapic_write(LAPIC_TIMERDIV, LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040a6c9:	83 ec 08             	sub    $0x8,%esp
c040a6cc:	6a 0a                	push   $0xa
c040a6ce:	68 e0 03 e0 fe       	push   $0xfee003e0
c040a6d3:	e8 dc fc ff ff       	call   c040a3b4 <lapic_write>
c040a6d8:	83 c4 10             	add    $0x10,%esp
		x86_timer_init(SCHED_FREQUENCY);
c040a6db:	83 ec 0c             	sub    $0xc,%esp
c040a6de:	6a 64                	push   $0x64
c040a6e0:	e8 8c 60 ff ff       	call   c0400771 <x86_timer_init>
c040a6e5:	83 c4 10             	add    $0x10,%esp
		lapic_write(LAPIC_TIMERINIT, 0xffffffff);
c040a6e8:	83 ec 08             	sub    $0x8,%esp
c040a6eb:	6a ff                	push   $0xffffffff
c040a6ed:	68 80 03 e0 fe       	push   $0xfee00380
c040a6f2:	e8 bd fc ff ff       	call   c040a3b4 <lapic_write>
c040a6f7:	83 c4 10             	add    $0x10,%esp
		x86_enable_interrupts();
c040a6fa:	e8 5b 67 ff ff       	call   c0400e5a <x86_enable_interrupts>
		
		/* loop until all done */
		while(lapic_preflight_timer_pass < 4) __asm__ __volatile__("pause"); 
c040a6ff:	eb 02                	jmp    c040a703 <lapic_initialise+0x2b3>
c040a701:	f3 90                	pause  
c040a703:	a0 18 1d 41 c0       	mov    0xc0411d18,%al
c040a708:	3c 03                	cmp    $0x3,%al
c040a70a:	76 f5                	jbe    c040a701 <lapic_initialise+0x2b1>

		/* tear down this preflight check */
		x86_disable_interrupts();
c040a70c:	e8 4b 67 ff ff       	call   c0400e5c <x86_disable_interrupts>
		x86_timer_init(0);
c040a711:	83 ec 0c             	sub    $0xc,%esp
c040a714:	6a 00                	push   $0x0
c040a716:	e8 56 60 ff ff       	call   c0400771 <x86_timer_init>
c040a71b:	83 c4 10             	add    $0x10,%esp
		irq_deregister_driver(irq, IRQ_DRIVER_FUNCTION, 0, &lapic_preflight_timer);
c040a71e:	ba 4d a3 40 c0       	mov    $0xc040a34d,%edx
c040a723:	8a 44 24 1f          	mov    0x1f(%esp),%al
c040a727:	0f b6 c0             	movzbl %al,%eax
c040a72a:	52                   	push   %edx
c040a72b:	6a 00                	push   $0x0
c040a72d:	6a 02                	push   $0x2
c040a72f:	50                   	push   %eax
c040a730:	e8 0a 71 ff ff       	call   c040183f <irq_deregister_driver>
c040a735:	83 c4 10             	add    $0x10,%esp
		
		/* calculate the average init value for the apic timer - each value has
		   already been divided by four */
		lapic_preflight_timer_init = lapic_preflight_timer_lap[0] + lapic_preflight_timer_lap[1] +
c040a738:	8b 15 c0 f4 40 c0    	mov    0xc040f4c0,%edx
c040a73e:	a1 c4 f4 40 c0       	mov    0xc040f4c4,%eax
c040a743:	01 c2                	add    %eax,%edx
											  lapic_preflight_timer_lap[2] + lapic_preflight_timer_lap[3];
c040a745:	a1 c8 f4 40 c0       	mov    0xc040f4c8,%eax
c040a74a:	01 c2                	add    %eax,%edx
c040a74c:	a1 cc f4 40 c0       	mov    0xc040f4cc,%eax
		x86_timer_init(0);
		irq_deregister_driver(irq, IRQ_DRIVER_FUNCTION, 0, &lapic_preflight_timer);
		
		/* calculate the average init value for the apic timer - each value has
		   already been divided by four */
		lapic_preflight_timer_init = lapic_preflight_timer_lap[0] + lapic_preflight_timer_lap[1] +
c040a751:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040a754:	a3 d0 f4 40 c0       	mov    %eax,0xc040f4d0
											  lapic_preflight_timer_lap[2] + lapic_preflight_timer_lap[3];
		lapic_preflight_timer_init = 0xffffffff - lapic_preflight_timer_init;
c040a759:	a1 d0 f4 40 c0       	mov    0xc040f4d0,%eax
c040a75e:	f7 d0                	not    %eax
c040a760:	a3 d0 f4 40 c0       	mov    %eax,0xc040f4d0
		
		irq_register_driver(IRQ_APIC_TIMER, IRQ_DRIVER_FUNCTION, 0, &int_common_timer);
c040a765:	68 a0 a8 40 c0       	push   $0xc040a8a0
c040a76a:	6a 00                	push   $0x0
c040a76c:	6a 02                	push   $0x2
c040a76e:	6a 30                	push   $0x30
c040a770:	e8 96 71 ff ff       	call   c040190b <irq_register_driver>
c040a775:	83 c4 10             	add    $0x10,%esp
	}
	
	LAPIC_DEBUG("[lapic:%i] programming APIC timer with reload value of %x\n", CPU_ID, lapic_preflight_timer_init);

	/* program the apic timer to fire every so many ticks */
	lapic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER | LAPIC_TIMER_TP);
c040a778:	83 ec 08             	sub    $0x8,%esp
c040a77b:	68 30 00 02 00       	push   $0x20030
c040a780:	68 20 03 e0 fe       	push   $0xfee00320
c040a785:	e8 2a fc ff ff       	call   c040a3b4 <lapic_write>
c040a78a:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040a78d:	83 ec 08             	sub    $0x8,%esp
c040a790:	6a 0a                	push   $0xa
c040a792:	68 e0 03 e0 fe       	push   $0xfee003e0
c040a797:	e8 18 fc ff ff       	call   c040a3b4 <lapic_write>
c040a79c:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERINIT, lapic_preflight_timer_init);
c040a79f:	a1 d0 f4 40 c0       	mov    0xc040f4d0,%eax
c040a7a4:	83 ec 08             	sub    $0x8,%esp
c040a7a7:	50                   	push   %eax
c040a7a8:	68 80 03 e0 fe       	push   $0xfee00380
c040a7ad:	e8 02 fc ff ff       	call   c040a3b4 <lapic_write>
c040a7b2:	83 c4 10             	add    $0x10,%esp
}
c040a7b5:	83 c4 2c             	add    $0x2c,%esp
c040a7b8:	c3                   	ret    
c040a7b9:	00 00                	add    %al,(%eax)
	...

c040a7bc <bus_register_name>:
{
	BUS_DEBUG("[bus:%i] registering bus %i as '%s'\n", CPU_ID, id, name);
	
	/* TODO: unimplemented */
	
	return e_failure;
c040a7bc:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040a7c1:	c3                   	ret    

c040a7c2 <bus_add_route>:
	BUS_DEBUG("[bus:%1] adding route: bus %i irq % ==> ioapic %i irq %i (flags %i)\n", CPU_ID,
				 busid, busirq, ioapicid, ioapicirq, flags);
	
	/* TODO: unimplemented */
	
	return e_failure;
c040a7c2:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040a7c7:	c3                   	ret    

c040a7c8 <bus_find_irq>:
      busirq = irq line on the bus
   <= 0 for success or failure code
*/
kresult bus_find_irq(unsigned char *cpuirq, char *busname, unsigned int busirq)
{
	return e_failure;
c040a7c8:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040a7cd:	c3                   	ret    
	...

c040a7d0 <int_reload_idtr>:


/* int_reload_idtr
	Reload the idtr on this cpu */
void int_reload_idtr(void)
{
c040a7d0:	83 ec 0c             	sub    $0xc,%esp
	INT_DEBUG("[int:%i] loading idtr with %p (%x %x)\n",
				 CPU_ID, &int_table_ptr, int_table_ptr.base, int_table_ptr.limit);	
	
	x86_load_idtr((unsigned int *)&int_table_ptr); /* in start.s */
c040a7d3:	b8 e0 fc 40 c0       	mov    $0xc040fce0,%eax
c040a7d8:	83 ec 0c             	sub    $0xc,%esp
c040a7db:	50                   	push   %eax
c040a7dc:	e8 58 5c ff ff       	call   c0400439 <x86_load_idtr>
c040a7e1:	83 c4 10             	add    $0x10,%esp
}
c040a7e4:	83 c4 0c             	add    $0xc,%esp
c040a7e7:	c3                   	ret    

c040a7e8 <int_set_gate>:
		segment = kernel segment selector for routine
		flags   = handler descriptor flags
		flush   = set to non-zero to force a reload of the cpu idt reg
*/
void int_set_gate(unsigned char intnum, unsigned int base, unsigned short segment, unsigned char flags, unsigned char flush)
{
c040a7e8:	53                   	push   %ebx
c040a7e9:	83 ec 18             	sub    $0x18,%esp
c040a7ec:	8b 5c 24 20          	mov    0x20(%esp),%ebx
c040a7f0:	8b 44 24 28          	mov    0x28(%esp),%eax
c040a7f4:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
c040a7f8:	8b 54 24 30          	mov    0x30(%esp),%edx
c040a7fc:	88 5c 24 0c          	mov    %bl,0xc(%esp)
c040a800:	66 89 44 24 08       	mov    %ax,0x8(%esp)
c040a805:	88 4c 24 04          	mov    %cl,0x4(%esp)
c040a809:	88 14 24             	mov    %dl,(%esp)
	INT_DEBUG("[int:%i] setting gate: #%i = %x:%x\n", CPU_ID, intnum, segment, base);
	
	int_idt_table[intnum].base_lo  = base & 0xFFFF;
c040a80c:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040a811:	8b 44 24 24          	mov    0x24(%esp),%eax
c040a815:	66 89 04 d5 e0 f4 40 	mov    %ax,-0x3fbf0b20(,%edx,8)
c040a81c:	c0 
   int_idt_table[intnum].base_hi  = (base >> 16) & 0xFFFF;
c040a81d:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040a822:	8b 44 24 24          	mov    0x24(%esp),%eax
c040a826:	c1 e8 10             	shr    $0x10,%eax
c040a829:	66 89 04 d5 e6 f4 40 	mov    %ax,-0x3fbf0b1a(,%edx,8)
c040a830:	c0 
   int_idt_table[intnum].segment = segment;
c040a831:	0f b6 54 24 0c       	movzbl 0xc(%esp),%edx
c040a836:	8b 44 24 08          	mov    0x8(%esp),%eax
c040a83a:	66 89 04 d5 e2 f4 40 	mov    %ax,-0x3fbf0b1e(,%edx,8)
c040a841:	c0 
   int_idt_table[intnum].always0  = 0; /* mandatory zero */
c040a842:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a847:	c6 04 c5 e4 f4 40 c0 	movb   $0x0,-0x3fbf0b1c(,%eax,8)
c040a84e:	00 
   int_idt_table[intnum].flags    = flags;
c040a84f:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a854:	8a 54 24 04          	mov    0x4(%esp),%dl
c040a858:	88 14 c5 e5 f4 40 c0 	mov    %dl,-0x3fbf0b1b(,%eax,8)
	
	if(flush)
c040a85f:	80 3c 24 00          	cmpb   $0x0,(%esp)
c040a863:	74 05                	je     c040a86a <int_set_gate+0x82>
		int_reload_idtr();
c040a865:	e8 66 ff ff ff       	call   c040a7d0 <int_reload_idtr>
}
c040a86a:	83 c4 18             	add    $0x18,%esp
c040a86d:	5b                   	pop    %ebx
c040a86e:	c3                   	ret    

c040a86f <int_table_initialise>:


/* initialise the common entries in the int table for uni and multiproc systems */
void int_table_initialise(void)
{
c040a86f:	83 ec 0c             	sub    $0xc,%esp
	INT_DEBUG("[int:%i] initialising interrupt vector table... \n", CPU_ID);
	
	/* initialise table pointer and idt table */
	int_table_ptr.limit = (sizeof(int_idt_descr) * 256) - 1;
c040a872:	66 c7 05 e0 fc 40 c0 	movw   $0x7ff,0xc040fce0
c040a879:	ff 07 
	int_table_ptr.base  = (unsigned int)&int_idt_table;
c040a87b:	b8 e0 f4 40 c0       	mov    $0xc040f4e0,%eax
c040a880:	a3 e2 fc 40 c0       	mov    %eax,0xc040fce2
	vmm_memset(&int_idt_table, 0, (sizeof(int_idt_descr) * 256));
c040a885:	83 ec 04             	sub    $0x4,%esp
c040a888:	68 00 08 00 00       	push   $0x800
c040a88d:	6a 00                	push   $0x0
c040a88f:	68 e0 f4 40 c0       	push   $0xc040f4e0
c040a894:	e8 93 a1 ff ff       	call   c0404a2c <vmm_memset>
c040a899:	83 c4 10             	add    $0x10,%esp
}
c040a89c:	83 c4 0c             	add    $0xc,%esp
c040a89f:	c3                   	ret    

c040a8a0 <int_common_timer>:

/* default timer handler for the scheduler */
kresult int_common_timer(unsigned char intnum, int_registers_block *regs)
{
c040a8a0:	83 ec 1c             	sub    $0x1c,%esp
c040a8a3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a8a7:	88 44 24 0c          	mov    %al,0xc(%esp)
	/* nudge the timeslice counters for the current thread */
	sched_tick(regs);
c040a8ab:	83 ec 0c             	sub    $0xc,%esp
c040a8ae:	ff 74 24 30          	pushl  0x30(%esp)
c040a8b2:	e8 d4 87 ff ff       	call   c040308b <sched_tick>
c040a8b7:	83 c4 10             	add    $0x10,%esp
	return success;
c040a8ba:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040a8bf:	83 c4 1c             	add    $0x1c,%esp
c040a8c2:	c3                   	ret    

c040a8c3 <int_initialise_common>:

/* initialise the common entries in the int table for uni and multiproc systems */
void int_initialise_common(void)
{
c040a8c3:	83 ec 0c             	sub    $0xc,%esp
	int_table_initialise();
c040a8c6:	e8 a4 ff ff ff       	call   c040a86f <int_table_initialise>
	exceptions_initialise();
c040a8cb:	e8 53 6a ff ff       	call   c0401323 <exceptions_initialise>
	pic_initialise();
c040a8d0:	e8 18 f8 ff ff       	call   c040a0ed <pic_initialise>
}
c040a8d5:	83 c4 0c             	add    $0xc,%esp
c040a8d8:	c3                   	ret    

c040a8d9 <int_initialise_mproc>:
 Set up a cpu on a multiprocessor system
 => flags = flag up who's calling this function
 INT_IAMBSP = 1 for the BSP, which will create the int table
 */
void int_initialise_mproc(unsigned char flags)
{
c040a8d9:	83 ec 1c             	sub    $0x1c,%esp
c040a8dc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040a8e0:	88 44 24 0c          	mov    %al,0xc(%esp)
	if(flags & INT_IAMBSP)
c040a8e4:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040a8e9:	83 e0 01             	and    $0x1,%eax
c040a8ec:	84 c0                	test   %al,%al
c040a8ee:	74 05                	je     c040a8f5 <int_initialise_mproc+0x1c>
		int_initialise_common();
c040a8f0:	e8 ce ff ff ff       	call   c040a8c3 <int_initialise_common>
	
	/* initialise the system's IOAPIC */
	if(mp_ioapics)
c040a8f5:	a0 1d 1d 41 c0       	mov    0xc0411d1d,%al
c040a8fa:	84 c0                	test   %al,%al
c040a8fc:	74 0d                	je     c040a90b <int_initialise_mproc+0x32>
		ioapic_initialise(0);
c040a8fe:	83 ec 0c             	sub    $0xc,%esp
c040a901:	6a 00                	push   $0x0
c040a903:	e8 54 f4 ff ff       	call   c0409d5c <ioapic_initialise>
c040a908:	83 c4 10             	add    $0x10,%esp
	
	/* initialise the boot cpu's local APIC */
	lapic_initialise(INT_IAMBSP);
c040a90b:	83 ec 0c             	sub    $0xc,%esp
c040a90e:	6a 01                	push   $0x1
c040a910:	e8 3b fb ff ff       	call   c040a450 <lapic_initialise>
c040a915:	83 c4 10             	add    $0x10,%esp
}	
c040a918:	83 c4 1c             	add    $0x1c,%esp
c040a91b:	c3                   	ret    

c040a91c <int_initialise_uniproc>:

/* int_initialise_uniproc
 Set up the machine's sole cpu with exception and
 interrupt handlers and program the timer */
void int_initialise_uniproc(void)
{
c040a91c:	83 ec 0c             	sub    $0xc,%esp
	int_initialise_common();
c040a91f:	e8 9f ff ff ff       	call   c040a8c3 <int_initialise_common>
	
	/* set up a 100Hz ticker for the scheduler  */
	x86_timer_init(SCHED_FREQUENCY);
c040a924:	83 ec 0c             	sub    $0xc,%esp
c040a927:	6a 64                	push   $0x64
c040a929:	e8 43 5e ff ff       	call   c0400771 <x86_timer_init>
c040a92e:	83 c4 10             	add    $0x10,%esp
	INT_DEBUG("[int:%i] uniproc: set up timer (%iHz)...\n", CPU_ID, SCHED_FREQUENCY);
}
c040a931:	83 c4 0c             	add    $0xc,%esp
c040a934:	c3                   	ret    
c040a935:	00 00                	add    %al,(%eax)
	...

c040a938 <_mp_catch_ap>:
volatile unsigned char mp_ap_ready = 0;

/* mp_catch_ap
   This is the point where an application processor joins the kernel proper */
void _mp_catch_ap(void)
{
c040a938:	83 ec 1c             	sub    $0x1c,%esp
	unsigned int me = CPU_ID;
c040a93b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040a940:	3c 01                	cmp    $0x1,%al
c040a942:	76 0c                	jbe    c040a950 <_mp_catch_ap+0x18>
c040a944:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040a949:	8b 00                	mov    (%eax),%eax
c040a94b:	c1 e8 18             	shr    $0x18,%eax
c040a94e:	eb 08                	jmp    c040a958 <_mp_catch_ap+0x20>
c040a950:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040a955:	0f b6 c0             	movzbl %al,%eax
c040a958:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	MP_DEBUG("[mp:%i] I'm alive! application processor waiting for work\n", me);
	
	/* signal that we're done */
	mp_ap_ready = 1;
c040a95c:	c6 05 20 1d 41 c0 01 	movb   $0x1,0xc0411d20
	
	/* don't forget to initialise interrupts for this cpu */
	int_initialise_mproc(0); /* 0 = not boot processor */
c040a963:	83 ec 0c             	sub    $0xc,%esp
c040a966:	6a 00                	push   $0x0
c040a968:	e8 6c ff ff ff       	call   c040a8d9 <int_initialise_mproc>
c040a96d:	83 c4 10             	add    $0x10,%esp
c040a970:	eb 01                	jmp    c040a973 <_mp_catch_ap+0x3b>
	/* loop waiting for the first thread to run */
	while(1)
	{		
		/* we've got one! */
		if((volatile unsigned int)(cpu_table[me].queue_head)) lowlevel_kickstart();
	}
c040a972:	90                   	nop
		
	/* loop waiting for the first thread to run */
	while(1)
	{		
		/* we've got one! */
		if((volatile unsigned int)(cpu_table[me].queue_head)) lowlevel_kickstart();
c040a973:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040a978:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040a97c:	c1 e2 06             	shl    $0x6,%edx
c040a97f:	01 d0                	add    %edx,%eax
c040a981:	8b 40 18             	mov    0x18(%eax),%eax
c040a984:	85 c0                	test   %eax,%eax
c040a986:	74 ea                	je     c040a972 <_mp_catch_ap+0x3a>
c040a988:	e8 fb 64 ff ff       	call   c0400e88 <lowlevel_kickstart>
	}
c040a98d:	eb e4                	jmp    c040a973 <_mp_catch_ap+0x3b>

c040a98f <mp_delay>:

/* mp_delay
   Cause the processor to pause for a few cycles - the length of a normal
   scheduling quantum */
void mp_delay(void)
{	
c040a98f:	83 ec 0c             	sub    $0xc,%esp
	/* put the local APIC timer into one-shot mode and wait for it to hit zero */
	lapic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER);
c040a992:	83 ec 08             	sub    $0x8,%esp
c040a995:	6a 30                	push   $0x30
c040a997:	68 20 03 e0 fe       	push   $0xfee00320
c040a99c:	e8 13 fa ff ff       	call   c040a3b4 <lapic_write>
c040a9a1:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040a9a4:	83 ec 08             	sub    $0x8,%esp
c040a9a7:	6a 0a                	push   $0xa
c040a9a9:	68 e0 03 e0 fe       	push   $0xfee003e0
c040a9ae:	e8 01 fa ff ff       	call   c040a3b4 <lapic_write>
c040a9b3:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERINIT, *(LAPIC_TIMERINIT));
c040a9b6:	b8 80 03 e0 fe       	mov    $0xfee00380,%eax
c040a9bb:	8b 00                	mov    (%eax),%eax
c040a9bd:	83 ec 08             	sub    $0x8,%esp
c040a9c0:	50                   	push   %eax
c040a9c1:	68 80 03 e0 fe       	push   $0xfee00380
c040a9c6:	e8 e9 f9 ff ff       	call   c040a3b4 <lapic_write>
c040a9cb:	83 c4 10             	add    $0x10,%esp

	while(*(LAPIC_TIMERNOW)) __asm__ __volatile__("pause");
c040a9ce:	eb 02                	jmp    c040a9d2 <mp_delay+0x43>
c040a9d0:	f3 90                	pause  
c040a9d2:	b8 90 03 e0 fe       	mov    $0xfee00390,%eax
c040a9d7:	8b 00                	mov    (%eax),%eax
c040a9d9:	85 c0                	test   %eax,%eax
c040a9db:	75 f3                	jne    c040a9d0 <mp_delay+0x41>
			
	/* restore the local APIC timer settings */
	lapic_write(LAPIC_LVT_TIMER, IRQ_APIC_TIMER | LAPIC_TIMER_TP);
c040a9dd:	83 ec 08             	sub    $0x8,%esp
c040a9e0:	68 30 00 02 00       	push   $0x20030
c040a9e5:	68 20 03 e0 fe       	push   $0xfee00320
c040a9ea:	e8 c5 f9 ff ff       	call   c040a3b4 <lapic_write>
c040a9ef:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERDIV,  LAPIC_DIV_128); /* divide down the bus clock by 128 */
c040a9f2:	83 ec 08             	sub    $0x8,%esp
c040a9f5:	6a 0a                	push   $0xa
c040a9f7:	68 e0 03 e0 fe       	push   $0xfee003e0
c040a9fc:	e8 b3 f9 ff ff       	call   c040a3b4 <lapic_write>
c040aa01:	83 c4 10             	add    $0x10,%esp
	lapic_write(LAPIC_TIMERINIT, *(LAPIC_TIMERINIT));
c040aa04:	b8 80 03 e0 fe       	mov    $0xfee00380,%eax
c040aa09:	8b 00                	mov    (%eax),%eax
c040aa0b:	83 ec 08             	sub    $0x8,%esp
c040aa0e:	50                   	push   %eax
c040aa0f:	68 80 03 e0 fe       	push   $0xfee00380
c040aa14:	e8 9b f9 ff ff       	call   c040a3b4 <lapic_write>
c040aa19:	83 c4 10             	add    $0x10,%esp
}
c040aa1c:	83 c4 0c             	add    $0xc,%esp
c040aa1f:	c3                   	ret    

c040aa20 <mp_init_ap>:
/* mp_init_ap
   Initialise and start up an application processor
   => id = target CPU's local APIC ID
*/
kresult mp_init_ap(unsigned int id)
{
c040aa20:	83 ec 2c             	sub    $0x2c,%esp
	volatile unsigned int ap_timeout = 0xffffff; /* sufficiently crude timeout */
c040aa23:	c7 44 24 14 ff ff ff 	movl   $0xffffff,0x14(%esp)
c040aa2a:	00 
	unsigned int apstack_top, gdtsize, newgdt, is_not_82489dx;
	
	/* determine APIC version - if a 82489dx is present (external APIC)
	   then the APIC version byte will be 0 */
	is_not_82489dx = (*LAPIC_VER_REG) & 0xff;
c040aa2b:	b8 30 00 e0 fe       	mov    $0xfee00030,%eax
c040aa30:	8b 00                	mov    (%eax),%eax
c040aa32:	25 ff 00 00 00       	and    $0xff,%eax
c040aa37:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	
	/* allocate about 1K memory for the ap boot stack to stash away */
	if(vmm_malloc((void **)&apstack_top, MP_AP_START_STACK_SIZE))
c040aa3b:	8d 44 24 10          	lea    0x10(%esp),%eax
c040aa3f:	83 ec 08             	sub    $0x8,%esp
c040aa42:	68 00 04 00 00       	push   $0x400
c040aa47:	50                   	push   %eax
c040aa48:	e8 9b 90 ff ff       	call   c0403ae8 <vmm_malloc>
c040aa4d:	83 c4 10             	add    $0x10,%esp
c040aa50:	85 c0                	test   %eax,%eax
c040aa52:	74 0a                	je     c040aa5e <mp_init_ap+0x3e>
	{
		MP_DEBUG("[mp:%i] unable to allocate boot stack for AP %i\n", CPU_ID, id);
		return e_failure;
c040aa54:	b8 01 00 00 00       	mov    $0x1,%eax
c040aa59:	e9 58 01 00 00       	jmp    c040abb6 <mp_init_ap+0x196>
	}
	
	/* duplicate the BSP's GDT */
	gdtsize = (unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT;
c040aa5e:	ba 38 f0 40 c0       	mov    $0xc040f038,%edx
c040aa63:	b8 00 f0 40 c0       	mov    $0xc040f000,%eax
c040aa68:	89 d1                	mov    %edx,%ecx
c040aa6a:	29 c1                	sub    %eax,%ecx
c040aa6c:	89 c8                	mov    %ecx,%eax
c040aa6e:	89 44 24 18          	mov    %eax,0x18(%esp)
	if(vmm_malloc((void **)&newgdt, gdtsize))
c040aa72:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040aa76:	83 ec 08             	sub    $0x8,%esp
c040aa79:	ff 74 24 20          	pushl  0x20(%esp)
c040aa7d:	50                   	push   %eax
c040aa7e:	e8 65 90 ff ff       	call   c0403ae8 <vmm_malloc>
c040aa83:	83 c4 10             	add    $0x10,%esp
c040aa86:	85 c0                	test   %eax,%eax
c040aa88:	74 1a                	je     c040aaa4 <mp_init_ap+0x84>
	{
		MP_DEBUG("[mp:%i] unable to allocate fresh GDT for AP %i\n", CPU_ID, id);
		vmm_free((void *)apstack_top);
c040aa8a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040aa8e:	83 ec 0c             	sub    $0xc,%esp
c040aa91:	50                   	push   %eax
c040aa92:	e8 78 94 ff ff       	call   c0403f0f <vmm_free>
c040aa97:	83 c4 10             	add    $0x10,%esp
		return e_failure;
c040aa9a:	b8 01 00 00 00       	mov    $0x1,%eax
c040aa9f:	e9 12 01 00 00       	jmp    c040abb6 <mp_init_ap+0x196>
	}
	vmm_memcpy((void *)newgdt, &KernelGDT, gdtsize);
c040aaa4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040aaa8:	83 ec 04             	sub    $0x4,%esp
c040aaab:	ff 74 24 1c          	pushl  0x1c(%esp)
c040aaaf:	68 00 f0 40 c0       	push   $0xc040f000
c040aab4:	50                   	push   %eax
c040aab5:	e8 af 9f ff ff       	call   c0404a69 <vmm_memcpy>
c040aaba:	83 c4 10             	add    $0x10,%esp
	
	/* set up the GDT pointers for the cpu */
	cpu_table[id].gdtptr.size = gdtsize - 1;
c040aabd:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040aac2:	8b 54 24 30          	mov    0x30(%esp),%edx
c040aac6:	c1 e2 06             	shl    $0x6,%edx
c040aac9:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040aacc:	8b 44 24 18          	mov    0x18(%esp),%eax
c040aad0:	48                   	dec    %eax
c040aad1:	66 89 42 34          	mov    %ax,0x34(%edx)
	cpu_table[id].gdtptr.ptr = newgdt;
c040aad5:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040aada:	8b 54 24 30          	mov    0x30(%esp),%edx
c040aade:	c1 e2 06             	shl    $0x6,%edx
c040aae1:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040aae4:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040aae8:	89 42 36             	mov    %eax,0x36(%edx)
	/* TSS selector is in the final selector slot in the GDT.. */
	cpu_table[id].tssentry = (gdt_entry *)((newgdt + gdtsize) - sizeof(gdt_entry));
c040aaeb:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040aaf0:	8b 54 24 30          	mov    0x30(%esp),%edx
c040aaf4:	c1 e2 06             	shl    $0x6,%edx
c040aaf7:	8d 14 10             	lea    (%eax,%edx,1),%edx
c040aafa:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040aafe:	03 44 24 18          	add    0x18(%esp),%eax
c040ab02:	83 e8 08             	sub    $0x8,%eax
c040ab05:	89 42 3c             	mov    %eax,0x3c(%edx)
	
	/* update the word holding the stack pointer */
	apstack_top += MP_AP_START_STACK_SIZE; /* stacks grow down.. */
c040ab08:	8b 44 24 10          	mov    0x10(%esp),%eax
c040ab0c:	05 00 04 00 00       	add    $0x400,%eax
c040ab11:	89 44 24 10          	mov    %eax,0x10(%esp)
	*((volatile unsigned int *)&APStack) = apstack_top;
c040ab15:	b8 3e f0 40 c0       	mov    $0xc040f03e,%eax
c040ab1a:	8b 54 24 10          	mov    0x10(%esp),%edx
c040ab1e:	89 10                	mov    %edx,(%eax)
	
	MP_DEBUG("[mp:%i] initialising AP %i: GDT %x boot stack %x APIC version %x...\n",
			  CPU_ID, id, newgdt, apstack_top, is_not_82489dx);
	
	mp_ap_ready = 0; /* the AP will set this flag when it's done initialising */
c040ab20:	c6 05 20 1d 41 c0 00 	movb   $0x0,0xc0411d20

	/* following the intel MP spec docs.. */
	lapic_ipi_send_init(id); /* send INIT IPI to the AP */
c040ab27:	83 ec 0c             	sub    $0xc,%esp
c040ab2a:	ff 74 24 3c          	pushl  0x3c(%esp)
c040ab2e:	e8 a1 f8 ff ff       	call   c040a3d4 <lapic_ipi_send_init>
c040ab33:	83 c4 10             	add    $0x10,%esp
	mp_delay();
c040ab36:	e8 54 fe ff ff       	call   c040a98f <mp_delay>
	if(is_not_82489dx)
c040ab3b:	83 7c 24 1c 00       	cmpl   $0x0,0x1c(%esp)
c040ab40:	74 4a                	je     c040ab8c <mp_init_ap+0x16c>
	{

		MP_DEBUG("[mp:%i] sending startup IPI..\n", CPU_ID);

		/* pulse startup IPIs until it wakes up */
		lapic_ipi_send_startup(id, MP_AP_START_VECTOR);
c040ab42:	83 ec 08             	sub    $0x8,%esp
c040ab45:	68 80 00 00 00       	push   $0x80
c040ab4a:	ff 74 24 3c          	pushl  0x3c(%esp)
c040ab4e:	e8 c0 f8 ff ff       	call   c040a413 <lapic_ipi_send_startup>
c040ab53:	83 c4 10             	add    $0x10,%esp
		mp_delay();
c040ab56:	e8 34 fe ff ff       	call   c040a98f <mp_delay>
		if(!mp_ap_ready)
c040ab5b:	a0 20 1d 41 c0       	mov    0xc0411d20,%al
c040ab60:	84 c0                	test   %al,%al
c040ab62:	75 2b                	jne    c040ab8f <mp_init_ap+0x16f>
		{
			lapic_ipi_send_startup(id, MP_AP_START_VECTOR);
c040ab64:	83 ec 08             	sub    $0x8,%esp
c040ab67:	68 80 00 00 00       	push   $0x80
c040ab6c:	ff 74 24 3c          	pushl  0x3c(%esp)
c040ab70:	e8 9e f8 ff ff       	call   c040a413 <lapic_ipi_send_startup>
c040ab75:	83 c4 10             	add    $0x10,%esp
			mp_delay();
c040ab78:	e8 12 fe ff ff       	call   c040a98f <mp_delay>
	}
	
	MP_DEBUG("[mp:%i] waiting for AP %i to wake up..\n", CPU_ID, id);
	
	/* wait for AP to signal it's done initialising or give up waiting */
	while(!mp_ap_ready && ap_timeout)
c040ab7d:	eb 11                	jmp    c040ab90 <mp_init_ap+0x170>
	{
		ap_timeout--;
c040ab7f:	8b 44 24 14          	mov    0x14(%esp),%eax
c040ab83:	48                   	dec    %eax
c040ab84:	89 44 24 14          	mov    %eax,0x14(%esp)
		__asm__ __volatile__("pause");
c040ab88:	f3 90                	pause  
c040ab8a:	eb 04                	jmp    c040ab90 <mp_init_ap+0x170>
	}
	
	MP_DEBUG("[mp:%i] waiting for AP %i to wake up..\n", CPU_ID, id);
	
	/* wait for AP to signal it's done initialising or give up waiting */
	while(!mp_ap_ready && ap_timeout)
c040ab8c:	90                   	nop
c040ab8d:	eb 01                	jmp    c040ab90 <mp_init_ap+0x170>
c040ab8f:	90                   	nop
c040ab90:	a0 20 1d 41 c0       	mov    0xc0411d20,%al
c040ab95:	84 c0                	test   %al,%al
c040ab97:	75 08                	jne    c040aba1 <mp_init_ap+0x181>
c040ab99:	8b 44 24 14          	mov    0x14(%esp),%eax
c040ab9d:	85 c0                	test   %eax,%eax
c040ab9f:	75 de                	jne    c040ab7f <mp_init_ap+0x15f>
	{
		ap_timeout--;
		__asm__ __volatile__("pause");
	}
	
	if(mp_ap_ready)
c040aba1:	a0 20 1d 41 c0       	mov    0xc0411d20,%al
c040aba6:	84 c0                	test   %al,%al
c040aba8:	74 07                	je     c040abb1 <mp_init_ap+0x191>
	{
		MP_DEBUG("[mp:%i] AP %i is cooking on gas\n", CPU_ID, id);
		return success;
c040abaa:	b8 00 00 00 00       	mov    $0x0,%eax
c040abaf:	eb 05                	jmp    c040abb6 <mp_init_ap+0x196>
	}

	MP_DEBUG("[mp:%i] initialisation of AP %i timed out\n", CPU_ID, id);
	return e_failure;
c040abb1:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040abb6:	83 c4 2c             	add    $0x2c,%esp
c040abb9:	c3                   	ret    

c040abba <mp_init_cpu_table>:

/* mp_init_cpu_table
   Initialise the table of present cpus and prepare the slave cpu launch trampoline */
void mp_init_cpu_table(void)
{
c040abba:	83 ec 0c             	sub    $0xc,%esp
	if(vmm_malloc((void **)&cpu_table, sizeof(mp_core) * mp_cpus))
c040abbd:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040abc2:	0f b6 c0             	movzbl %al,%eax
c040abc5:	89 c2                	mov    %eax,%edx
c040abc7:	c1 e2 06             	shl    $0x6,%edx
c040abca:	b8 e8 fc 40 c0       	mov    $0xc040fce8,%eax
c040abcf:	83 ec 08             	sub    $0x8,%esp
c040abd2:	52                   	push   %edx
c040abd3:	50                   	push   %eax
c040abd4:	e8 0f 8f ff ff       	call   c0403ae8 <vmm_malloc>
c040abd9:	83 c4 10             	add    $0x10,%esp
c040abdc:	85 c0                	test   %eax,%eax
c040abde:	74 03                	je     c040abe3 <mp_init_cpu_table+0x29>
	{
		MP_DEBUG("[mp:%i] can't allocate cpu table! halting...\n");
c040abe0:	90                   	nop
		while(1);
c040abe1:	eb fe                	jmp    c040abe1 <mp_init_cpu_table+0x27>
	}
	vmm_memset((void *)cpu_table, 0, sizeof(mp_core) * mp_cpus);
c040abe3:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040abe8:	0f b6 c0             	movzbl %al,%eax
c040abeb:	89 c2                	mov    %eax,%edx
c040abed:	c1 e2 06             	shl    $0x6,%edx
c040abf0:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040abf5:	83 ec 04             	sub    $0x4,%esp
c040abf8:	52                   	push   %edx
c040abf9:	6a 00                	push   $0x0
c040abfb:	50                   	push   %eax
c040abfc:	e8 2b 9e ff ff       	call   c0404a2c <vmm_memset>
c040ac01:	83 c4 10             	add    $0x10,%esp
	
	MP_DEBUG("[mp:%i] initialised run-time cpu table %p (%i cpus)\n", CPU_ID, cpu_table, mp_cpus);
}
c040ac04:	83 c4 0c             	add    $0xc,%esp
c040ac07:	c3                   	ret    

c040ac08 <mp_post_initialise>:

/* mp_post_initialise
	Bring up processors prior to running the first processes */
void mp_post_initialise(void)
{
c040ac08:	83 ec 2c             	sub    $0x2c,%esp
	unsigned int ap_loop, wokenup = 0;
c040ac0b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040ac12:	00 
	unsigned int *kaddr, phys_gdt, phys_gdtptr, phys_pgdir;
	gdtptr_descr gdtptr;
	
	/* get the processors ready to run */
	mp_init_cpu_table();
c040ac13:	e8 a2 ff ff ff       	call   c040abba <mp_init_cpu_table>
	
	if(mp_cpus < 2) return; /* uniproc machines need not apply for the rest */
c040ac18:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040ac1d:	3c 01                	cmp    $0x1,%al
c040ac1f:	0f 86 c9 01 00 00    	jbe    c040adee <mp_post_initialise+0x1e6>

	/* calculate address to copy the trampoline code into */
	kaddr = KERNEL_PHYS2LOG(MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT);
c040ac25:	c7 44 24 10 00 00 08 	movl   $0xc0080000,0x10(%esp)
c040ac2c:	c0 

	/* copy trampoline code into a low physical page */
	vmm_memcpy(kaddr, &x86_start_ap, (unsigned int)&x86_start_ap_end - (unsigned int)&x86_start_ap);
c040ac2d:	ba d7 00 40 c0       	mov    $0xc04000d7,%edx
c040ac32:	b8 60 00 40 c0       	mov    $0xc0400060,%eax
c040ac37:	89 d1                	mov    %edx,%ecx
c040ac39:	29 c1                	sub    %eax,%ecx
c040ac3b:	89 c8                	mov    %ecx,%eax
c040ac3d:	83 ec 04             	sub    $0x4,%esp
c040ac40:	50                   	push   %eax
c040ac41:	68 60 00 40 c0       	push   $0xc0400060
c040ac46:	ff 74 24 1c          	pushl  0x1c(%esp)
c040ac4a:	e8 1a 9e ff ff       	call   c0404a69 <vmm_memcpy>
c040ac4f:	83 c4 10             	add    $0x10,%esp
	
	/* stash the kernel's GDT ptr into the base of the physical page above the trampoline code
	   plus the actual boot GDT into the base of the page above that and a copy of the kernel's
	   boot page directory in the page above that */
	phys_gdtptr = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + MEM_PGSIZE;
c040ac52:	c7 44 24 18 00 10 08 	movl   $0x81000,0x18(%esp)
c040ac59:	00 
	phys_gdt    = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + (2 * MEM_PGSIZE);
c040ac5a:	c7 44 24 14 00 20 08 	movl   $0x82000,0x14(%esp)
c040ac61:	00 
	phys_pgdir  = (MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT) + (3 * MEM_PGSIZE);
c040ac62:	c7 44 24 1c 00 30 08 	movl   $0x83000,0x1c(%esp)
c040ac69:	00 
	gdtptr.size = (unsigned int)&KernelGDTEnd - (unsigned int)&KernelGDT;
c040ac6a:	b8 38 f0 40 c0       	mov    $0xc040f038,%eax
c040ac6f:	89 c2                	mov    %eax,%edx
c040ac71:	b8 00 f0 40 c0       	mov    $0xc040f000,%eax
c040ac76:	89 d1                	mov    %edx,%ecx
c040ac78:	66 29 c1             	sub    %ax,%cx
c040ac7b:	89 c8                	mov    %ecx,%eax
c040ac7d:	66 89 44 24 02       	mov    %ax,0x2(%esp)
	gdtptr.ptr = phys_gdt;
c040ac82:	8b 44 24 14          	mov    0x14(%esp),%eax
c040ac86:	89 44 24 04          	mov    %eax,0x4(%esp)
	
	/* copy the gdtptr into the base of the page above the trampoline and the GDT into the
	   second page above the trampoline */
	vmm_memcpy(KERNEL_PHYS2LOG(phys_gdtptr), &gdtptr, sizeof(gdtptr_descr));
c040ac8a:	8b 44 24 18          	mov    0x18(%esp),%eax
c040ac8e:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040ac93:	83 ec 04             	sub    $0x4,%esp
c040ac96:	6a 06                	push   $0x6
c040ac98:	8d 54 24 0a          	lea    0xa(%esp),%edx
c040ac9c:	52                   	push   %edx
c040ac9d:	50                   	push   %eax
c040ac9e:	e8 c6 9d ff ff       	call   c0404a69 <vmm_memcpy>
c040aca3:	83 c4 10             	add    $0x10,%esp
	vmm_memcpy(KERNEL_PHYS2LOG(phys_gdt), &KernelGDT, gdtptr.size);
c040aca6:	66 8b 44 24 02       	mov    0x2(%esp),%ax
c040acab:	0f b7 d0             	movzwl %ax,%edx
c040acae:	8b 44 24 14          	mov    0x14(%esp),%eax
c040acb2:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040acb7:	83 ec 04             	sub    $0x4,%esp
c040acba:	52                   	push   %edx
c040acbb:	68 00 f0 40 c0       	push   $0xc040f000
c040acc0:	50                   	push   %eax
c040acc1:	e8 a3 9d ff ff       	call   c0404a69 <vmm_memcpy>
c040acc6:	83 c4 10             	add    $0x10,%esp
	vmm_memcpy(KERNEL_PHYS2LOG(phys_pgdir), &KernelPageDirectory, 1024 * sizeof(unsigned int));
c040acc9:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040accd:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040acd2:	83 ec 04             	sub    $0x4,%esp
c040acd5:	68 00 10 00 00       	push   $0x1000
c040acda:	68 00 e0 40 c0       	push   $0xc040e000
c040acdf:	50                   	push   %eax
c040ace0:	e8 84 9d ff ff       	call   c0404a69 <vmm_memcpy>
c040ace5:	83 c4 10             	add    $0x10,%esp
			  kaddr, (unsigned int)&x86_start_ap_end - (unsigned int)&x86_start_ap,
			  phys_gdt, phys_gdtptr, gdtptr.size, phys_pgdir);
	
	/* an init'd AP will reboot and jump to 0x467 (40:67) for a start address
	   if we set the warm-boot flag */
	*(volatile unsigned int *)KERNEL_PHYS2LOG(0x467) = MP_AP_START_VECTOR << MP_AP_START_VECTOR_SHIFT;	
c040ace8:	b8 67 04 00 c0       	mov    $0xc0000467,%eax
c040aced:	c7 00 00 00 08 00    	movl   $0x80000,(%eax)

	/* program the BIOS CMOS for a warm reset - see: http://wiki.osdev.org/CMOS */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_WARM);	
c040acf3:	83 ec 08             	sub    $0x8,%esp
c040acf6:	6a 0a                	push   $0xa
c040acf8:	68 f0 00 00 00       	push   $0xf0
c040acfd:	e8 3a 5a ff ff       	call   c040073c <x86_cmos_write>
c040ad02:	83 c4 10             	add    $0x10,%esp
	
	/* and let's do battle.. */
	for(ap_loop = 0; ap_loop < mp_cpus; ap_loop++)
c040ad05:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040ad0c:	00 
c040ad0d:	eb 7e                	jmp    c040ad8d <mp_post_initialise+0x185>
	{
		/* don't boot the already running bootstrap cpu */
		if(ap_loop != CPU_ID)
c040ad0f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040ad14:	3c 01                	cmp    $0x1,%al
c040ad16:	76 0c                	jbe    c040ad24 <mp_post_initialise+0x11c>
c040ad18:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040ad1d:	8b 00                	mov    (%eax),%eax
c040ad1f:	c1 e8 18             	shr    $0x18,%eax
c040ad22:	eb 08                	jmp    c040ad2c <mp_post_initialise+0x124>
c040ad24:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040ad29:	0f b6 c0             	movzbl %al,%eax
c040ad2c:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040ad30:	74 43                	je     c040ad75 <mp_post_initialise+0x16d>
		{
			if(mp_init_ap(ap_loop) == success)
c040ad32:	83 ec 0c             	sub    $0xc,%esp
c040ad35:	ff 74 24 14          	pushl  0x14(%esp)
c040ad39:	e8 e2 fc ff ff       	call   c040aa20 <mp_init_ap>
c040ad3e:	83 c4 10             	add    $0x10,%esp
c040ad41:	85 c0                	test   %eax,%eax
c040ad43:	75 1a                	jne    c040ad5f <mp_post_initialise+0x157>
			{
				wokenup++;
c040ad45:	ff 44 24 0c          	incl   0xc(%esp)
				cpu_table[ap_loop].state = enabled;
c040ad49:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040ad4e:	8b 54 24 08          	mov    0x8(%esp),%edx
c040ad52:	c1 e2 06             	shl    $0x6,%edx
c040ad55:	01 d0                	add    %edx,%eax
c040ad57:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
			}
			else
				/* stop the scheduler from using APs that haven't been started up */
				cpu_table[ap_loop].state = disabled;
c040ad5d:	eb 2a                	jmp    c040ad89 <mp_post_initialise+0x181>
c040ad5f:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040ad64:	8b 54 24 08          	mov    0x8(%esp),%edx
c040ad68:	c1 e2 06             	shl    $0x6,%edx
c040ad6b:	01 d0                	add    %edx,%eax
c040ad6d:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
c040ad73:	eb 14                	jmp    c040ad89 <mp_post_initialise+0x181>
		}
		else
			cpu_table[ap_loop].state = enabled; /* enabled boot processor is enabled */
c040ad75:	a1 e8 fc 40 c0       	mov    0xc040fce8,%eax
c040ad7a:	8b 54 24 08          	mov    0x8(%esp),%edx
c040ad7e:	c1 e2 06             	shl    $0x6,%edx
c040ad81:	01 d0                	add    %edx,%eax
c040ad83:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

	/* program the BIOS CMOS for a warm reset - see: http://wiki.osdev.org/CMOS */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_WARM);	
	
	/* and let's do battle.. */
	for(ap_loop = 0; ap_loop < mp_cpus; ap_loop++)
c040ad89:	ff 44 24 08          	incl   0x8(%esp)
c040ad8d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040ad92:	0f b6 c0             	movzbl %al,%eax
c040ad95:	3b 44 24 08          	cmp    0x8(%esp),%eax
c040ad99:	0f 87 70 ff ff ff    	ja     c040ad0f <mp_post_initialise+0x107>
		}
		else
			cpu_table[ap_loop].state = enabled; /* enabled boot processor is enabled */
	}

	BOOT_DEBUG("[mp:%i] woke up %i application processor(s) out of %i\n", CPU_ID, wokenup, mp_cpus - 1);
c040ad9f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040ada4:	0f b6 c0             	movzbl %al,%eax
c040ada7:	8d 50 ff             	lea    -0x1(%eax),%edx
c040adaa:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040adaf:	3c 01                	cmp    $0x1,%al
c040adb1:	76 0c                	jbe    c040adbf <mp_post_initialise+0x1b7>
c040adb3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040adb8:	8b 00                	mov    (%eax),%eax
c040adba:	c1 e8 18             	shr    $0x18,%eax
c040adbd:	eb 08                	jmp    c040adc7 <mp_post_initialise+0x1bf>
c040adbf:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040adc4:	0f b6 c0             	movzbl %al,%eax
c040adc7:	52                   	push   %edx
c040adc8:	ff 74 24 10          	pushl  0x10(%esp)
c040adcc:	50                   	push   %eax
c040adcd:	68 48 d2 40 c0       	push   $0xc040d248
c040add2:	e8 ab 10 00 00       	call   c040be82 <debug_printf>
c040add7:	83 c4 10             	add    $0x10,%esp
	
	/* put the CMOS byte back to normal */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_COLD);
c040adda:	83 ec 08             	sub    $0x8,%esp
c040addd:	6a 00                	push   $0x0
c040addf:	68 f0 00 00 00       	push   $0xf0
c040ade4:	e8 53 59 ff ff       	call   c040073c <x86_cmos_write>
c040ade9:	83 c4 10             	add    $0x10,%esp
c040adec:	eb 01                	jmp    c040adef <mp_post_initialise+0x1e7>
	gdtptr_descr gdtptr;
	
	/* get the processors ready to run */
	mp_init_cpu_table();
	
	if(mp_cpus < 2) return; /* uniproc machines need not apply for the rest */
c040adee:	90                   	nop

	BOOT_DEBUG("[mp:%i] woke up %i application processor(s) out of %i\n", CPU_ID, wokenup, mp_cpus - 1);
	
	/* put the CMOS byte back to normal */
	x86_cmos_write(X86_CMOS_RESET_BYTE, X86_CMOS_RESET_COLD);
}
c040adef:	83 c4 2c             	add    $0x2c,%esp
c040adf2:	c3                   	ret    

c040adf3 <mp_initialise>:

kresult mp_initialise(void)
{
c040adf3:	56                   	push   %esi
c040adf4:	53                   	push   %ebx
c040adf5:	83 ec 24             	sub    $0x24,%esp
	unsigned char i;
	unsigned int search;
	unsigned char mp_found = 0;
c040adf8:	c6 44 24 0f 00       	movb   $0x0,0xf(%esp)
	mp_header_block *mp_header= NULL;
c040adfd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
c040ae04:	00 
	mp_config_block *mp_config = NULL;
c040ae05:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
c040ae0c:	00 
	
	/* search for the magic MP signature word to determine if this is a UP or MP machine */
	
	/* start with the extended BIOS data area (128K - 0xA0000) */
	MP_DEBUG("[mp] searching for multiprocessor info in EBDA...\n");
	for(search = MP_EBDA_START; search < MP_EBDA_END; search += sizeof(mp_header_block *))
c040ae0d:	c7 44 24 08 00 00 08 	movl   $0x80000,0x8(%esp)
c040ae14:	00 
c040ae15:	eb 21                	jmp    c040ae38 <mp_initialise+0x45>
	{
		mp_header = (mp_header_block *)search;
c040ae17:	8b 44 24 08          	mov    0x8(%esp),%eax
c040ae1b:	89 44 24 10          	mov    %eax,0x10(%esp)
		if(mp_header->signature == MP_MAGIC_SIG)
c040ae1f:	8b 44 24 10          	mov    0x10(%esp),%eax
c040ae23:	8b 00                	mov    (%eax),%eax
c040ae25:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040ae2a:	75 07                	jne    c040ae33 <mp_initialise+0x40>
		{
			mp_found = 1;
c040ae2c:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
			break;
c040ae31:	eb 0f                	jmp    c040ae42 <mp_initialise+0x4f>
	
	/* search for the magic MP signature word to determine if this is a UP or MP machine */
	
	/* start with the extended BIOS data area (128K - 0xA0000) */
	MP_DEBUG("[mp] searching for multiprocessor info in EBDA...\n");
	for(search = MP_EBDA_START; search < MP_EBDA_END; search += sizeof(mp_header_block *))
c040ae33:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040ae38:	81 7c 24 08 ff ff 08 	cmpl   $0x8ffff,0x8(%esp)
c040ae3f:	00 
c040ae40:	76 d5                	jbe    c040ae17 <mp_initialise+0x24>
			mp_found = 1;
			break;
		}
	}
	
	if(!mp_found)
c040ae42:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040ae47:	75 35                	jne    c040ae7e <mp_initialise+0x8b>
	{
		/* search the last 1024 bytes of base memory (ends at 640K) */
		MP_DEBUG("[mp] searching for multiprocessor info in top of base memory...\n");
		for(search = MP_LASTK_START; search < MP_LASTK_END; search += sizeof(mp_header_block *))
c040ae49:	c7 44 24 08 00 fc 09 	movl   $0x9fc00,0x8(%esp)
c040ae50:	00 
c040ae51:	eb 21                	jmp    c040ae74 <mp_initialise+0x81>
		{
			mp_header = (mp_header_block *)search;
c040ae53:	8b 44 24 08          	mov    0x8(%esp),%eax
c040ae57:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(mp_header->signature == MP_MAGIC_SIG)
c040ae5b:	8b 44 24 10          	mov    0x10(%esp),%eax
c040ae5f:	8b 00                	mov    (%eax),%eax
c040ae61:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040ae66:	75 07                	jne    c040ae6f <mp_initialise+0x7c>
			{
				mp_found = 1;
c040ae68:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
				break;
c040ae6d:	eb 0f                	jmp    c040ae7e <mp_initialise+0x8b>
	
	if(!mp_found)
	{
		/* search the last 1024 bytes of base memory (ends at 640K) */
		MP_DEBUG("[mp] searching for multiprocessor info in top of base memory...\n");
		for(search = MP_LASTK_START; search < MP_LASTK_END; search += sizeof(mp_header_block *))
c040ae6f:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040ae74:	81 7c 24 08 ff ff 09 	cmpl   $0x9ffff,0x8(%esp)
c040ae7b:	00 
c040ae7c:	76 d5                	jbe    c040ae53 <mp_initialise+0x60>
				break;
			}
		}
	}

	if(!mp_found)
c040ae7e:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040ae83:	75 35                	jne    c040aeba <mp_initialise+0xc7>
	{
		/* search the BIOS ROM space */
		MP_DEBUG("[mp] searching for multiprocessor info in the BIOS...\n");	
		for(search = MP_ROM_START; search < MP_ROM_END; search += sizeof(mp_header_block *))
c040ae85:	c7 44 24 08 00 00 0f 	movl   $0xf0000,0x8(%esp)
c040ae8c:	00 
c040ae8d:	eb 21                	jmp    c040aeb0 <mp_initialise+0xbd>
		{
			mp_header = (mp_header_block *)search;
c040ae8f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040ae93:	89 44 24 10          	mov    %eax,0x10(%esp)
			if(mp_header->signature == MP_MAGIC_SIG)
c040ae97:	8b 44 24 10          	mov    0x10(%esp),%eax
c040ae9b:	8b 00                	mov    (%eax),%eax
c040ae9d:	3d 5f 4d 50 5f       	cmp    $0x5f504d5f,%eax
c040aea2:	75 07                	jne    c040aeab <mp_initialise+0xb8>
			{
				mp_found = 1;
c040aea4:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
				break;
c040aea9:	eb 0f                	jmp    c040aeba <mp_initialise+0xc7>

	if(!mp_found)
	{
		/* search the BIOS ROM space */
		MP_DEBUG("[mp] searching for multiprocessor info in the BIOS...\n");	
		for(search = MP_ROM_START; search < MP_ROM_END; search += sizeof(mp_header_block *))
c040aeab:	83 44 24 08 04       	addl   $0x4,0x8(%esp)
c040aeb0:	81 7c 24 08 fe ff 0f 	cmpl   $0xffffe,0x8(%esp)
c040aeb7:	00 
c040aeb8:	76 d5                	jbe    c040ae8f <mp_initialise+0x9c>
			}
		}
	}
	
	/* must be a single processor system if we can't find the signature :( */
	if(!mp_found)
c040aeba:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
c040aebf:	75 2d                	jne    c040aeee <mp_initialise+0xfb>
	{
		BOOT_DEBUG("[mp] assuming uniprocessor machine\n");
c040aec1:	83 ec 0c             	sub    $0xc,%esp
c040aec4:	68 80 d2 40 c0       	push   $0xc040d280
c040aec9:	e8 b4 0f 00 00       	call   c040be82 <debug_printf>
c040aece:	83 c4 10             	add    $0x10,%esp
		mp_cpus = 1;
c040aed1:	c6 05 1c 1d 41 c0 01 	movb   $0x1,0xc0411d1c
		mp_boot_cpu = 0;
c040aed8:	c6 05 1e 1d 41 c0 00 	movb   $0x0,0xc0411d1e
		int_initialise_uniproc();
c040aedf:	e8 38 fa ff ff       	call   c040a91c <int_initialise_uniproc>
		return success;
c040aee4:	b8 00 00 00 00       	mov    $0x0,%eax
c040aee9:	e9 c1 02 00 00       	jmp    c040b1af <mp_initialise+0x3bc>
	}

	/* we're in multiprocessor territory now */
	
	BOOT_DEBUG("[mp] multiprocessor machine detected\n");
c040aeee:	83 ec 0c             	sub    $0xc,%esp
c040aef1:	68 a4 d2 40 c0       	push   $0xc040d2a4
c040aef6:	e8 87 0f 00 00       	call   c040be82 <debug_printf>
c040aefb:	83 c4 10             	add    $0x10,%esp
	
	/* start pulling apart system info */
	mp_config = mp_header->configptr;
c040aefe:	8b 44 24 10          	mov    0x10(%esp),%eax
c040af02:	8b 40 04             	mov    0x4(%eax),%eax
c040af05:	89 44 24 14          	mov    %eax,0x14(%esp)
	BOOT_DEBUG("[mp] system: ");
c040af09:	83 ec 0c             	sub    $0xc,%esp
c040af0c:	68 ca d2 40 c0       	push   $0xc040d2ca
c040af11:	e8 6c 0f 00 00       	call   c040be82 <debug_printf>
c040af16:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 8; i++)
c040af19:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040af1e:	eb 25                	jmp    c040af45 <mp_initialise+0x152>
		BOOT_DEBUG("%c", mp_config->oemid[i]);
c040af20:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c040af25:	8b 54 24 14          	mov    0x14(%esp),%edx
c040af29:	8a 44 02 08          	mov    0x8(%edx,%eax,1),%al
c040af2d:	0f b6 c0             	movzbl %al,%eax
c040af30:	83 ec 08             	sub    $0x8,%esp
c040af33:	50                   	push   %eax
c040af34:	68 d8 d2 40 c0       	push   $0xc040d2d8
c040af39:	e8 44 0f 00 00       	call   c040be82 <debug_printf>
c040af3e:	83 c4 10             	add    $0x10,%esp
	BOOT_DEBUG("[mp] multiprocessor machine detected\n");
	
	/* start pulling apart system info */
	mp_config = mp_header->configptr;
	BOOT_DEBUG("[mp] system: ");
	for(i = 0; i < 8; i++)
c040af41:	fe 44 24 07          	incb   0x7(%esp)
c040af45:	80 7c 24 07 07       	cmpb   $0x7,0x7(%esp)
c040af4a:	76 d4                	jbe    c040af20 <mp_initialise+0x12d>
		BOOT_DEBUG("%c", mp_config->oemid[i]);
	BOOT_DEBUG(" ");
c040af4c:	83 ec 0c             	sub    $0xc,%esp
c040af4f:	68 db d2 40 c0       	push   $0xc040d2db
c040af54:	e8 29 0f 00 00       	call   c040be82 <debug_printf>
c040af59:	83 c4 10             	add    $0x10,%esp
				  
	BOOT_DEBUG(" ");
c040af5c:	83 ec 0c             	sub    $0xc,%esp
c040af5f:	68 db d2 40 c0       	push   $0xc040d2db
c040af64:	e8 19 0f 00 00       	call   c040be82 <debug_printf>
c040af69:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 12; i++)
c040af6c:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040af71:	eb 25                	jmp    c040af98 <mp_initialise+0x1a5>
		BOOT_DEBUG("%c", mp_config->productid[i]);
c040af73:	0f b6 44 24 07       	movzbl 0x7(%esp),%eax
c040af78:	8b 54 24 14          	mov    0x14(%esp),%edx
c040af7c:	8a 44 02 10          	mov    0x10(%edx,%eax,1),%al
c040af80:	0f b6 c0             	movzbl %al,%eax
c040af83:	83 ec 08             	sub    $0x8,%esp
c040af86:	50                   	push   %eax
c040af87:	68 d8 d2 40 c0       	push   $0xc040d2d8
c040af8c:	e8 f1 0e 00 00       	call   c040be82 <debug_printf>
c040af91:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < 8; i++)
		BOOT_DEBUG("%c", mp_config->oemid[i]);
	BOOT_DEBUG(" ");
				  
	BOOT_DEBUG(" ");
	for(i = 0; i < 12; i++)
c040af94:	fe 44 24 07          	incb   0x7(%esp)
c040af98:	80 7c 24 07 0b       	cmpb   $0xb,0x7(%esp)
c040af9d:	76 d4                	jbe    c040af73 <mp_initialise+0x180>
		BOOT_DEBUG("%c", mp_config->productid[i]);
	BOOT_DEBUG("\n");
c040af9f:	83 ec 0c             	sub    $0xc,%esp
c040afa2:	68 dd d2 40 c0       	push   $0xc040d2dd
c040afa7:	e8 d6 0e 00 00       	call   c040be82 <debug_printf>
c040afac:	83 c4 10             	add    $0x10,%esp

	info_block = (mp_entry_block *)((unsigned int)mp_config + sizeof(mp_config_block));
c040afaf:	8b 44 24 14          	mov    0x14(%esp),%eax
c040afb3:	83 c0 2c             	add    $0x2c,%eax
c040afb6:	89 44 24 18          	mov    %eax,0x18(%esp)
	for(i = 0; i < mp_config->entry_count; i++)
c040afba:	c6 44 24 07 00       	movb   $0x0,0x7(%esp)
c040afbf:	e9 c3 01 00 00       	jmp    c040b187 <mp_initialise+0x394>
	{
		unsigned char block_size;
		
		switch(info_block->type)
c040afc4:	8b 44 24 18          	mov    0x18(%esp),%eax
c040afc8:	8a 00                	mov    (%eax),%al
c040afca:	0f b6 c0             	movzbl %al,%eax
c040afcd:	83 f8 01             	cmp    $0x1,%eax
c040afd0:	0f 84 af 00 00 00    	je     c040b085 <mp_initialise+0x292>
c040afd6:	83 f8 01             	cmp    $0x1,%eax
c040afd9:	7f 09                	jg     c040afe4 <mp_initialise+0x1f1>
c040afdb:	85 c0                	test   %eax,%eax
c040afdd:	74 1c                	je     c040affb <mp_initialise+0x208>
c040afdf:	e9 8a 01 00 00       	jmp    c040b16e <mp_initialise+0x37b>
c040afe4:	83 f8 02             	cmp    $0x2,%eax
c040afe7:	0f 84 c0 00 00 00    	je     c040b0ad <mp_initialise+0x2ba>
c040afed:	83 f8 03             	cmp    $0x3,%eax
c040aff0:	0f 84 2e 01 00 00    	je     c040b124 <mp_initialise+0x331>
c040aff6:	e9 73 01 00 00       	jmp    c040b16e <mp_initialise+0x37b>
		{
			case 0: /* cpu */
				BOOT_DEBUG("[mp] found cpu %i (flags %x) ",
				     		  info_block->id, info_block->entry.cpu.flags);
c040affb:	8b 44 24 18          	mov    0x18(%esp),%eax
c040afff:	8a 40 03             	mov    0x3(%eax),%al
		unsigned char block_size;
		
		switch(info_block->type)
		{
			case 0: /* cpu */
				BOOT_DEBUG("[mp] found cpu %i (flags %x) ",
c040b002:	0f b6 d0             	movzbl %al,%edx
				     		  info_block->id, info_block->entry.cpu.flags);
c040b005:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b009:	8a 40 01             	mov    0x1(%eax),%al
		unsigned char block_size;
		
		switch(info_block->type)
		{
			case 0: /* cpu */
				BOOT_DEBUG("[mp] found cpu %i (flags %x) ",
c040b00c:	0f b6 c0             	movzbl %al,%eax
c040b00f:	83 ec 04             	sub    $0x4,%esp
c040b012:	52                   	push   %edx
c040b013:	50                   	push   %eax
c040b014:	68 df d2 40 c0       	push   $0xc040d2df
c040b019:	e8 64 0e 00 00       	call   c040be82 <debug_printf>
c040b01e:	83 c4 10             	add    $0x10,%esp
				     		  info_block->id, info_block->entry.cpu.flags);
				if(info_block->entry.cpu.flags & MP_IS_BSP)
c040b021:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b025:	8a 40 03             	mov    0x3(%eax),%al
c040b028:	0f b6 c0             	movzbl %al,%eax
c040b02b:	83 e0 02             	and    $0x2,%eax
c040b02e:	85 c0                	test   %eax,%eax
c040b030:	74 1e                	je     c040b050 <mp_initialise+0x25d>
				{
					mp_boot_cpu = info_block->id;
c040b032:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b036:	8a 40 01             	mov    0x1(%eax),%al
c040b039:	a2 1e 1d 41 c0       	mov    %al,0xc0411d1e
					BOOT_DEBUG("[boot processor]");
c040b03e:	83 ec 0c             	sub    $0xc,%esp
c040b041:	68 fd d2 40 c0       	push   $0xc040d2fd
c040b046:	e8 37 0e 00 00       	call   c040be82 <debug_printf>
c040b04b:	83 c4 10             	add    $0x10,%esp
c040b04e:	eb 10                	jmp    c040b060 <mp_initialise+0x26d>
				}
				else
				{
					BOOT_DEBUG("[application processor]");
c040b050:	83 ec 0c             	sub    $0xc,%esp
c040b053:	68 0e d3 40 c0       	push   $0xc040d30e
c040b058:	e8 25 0e 00 00       	call   c040be82 <debug_printf>
c040b05d:	83 c4 10             	add    $0x10,%esp
				}
				BOOT_DEBUG("\n");
c040b060:	83 ec 0c             	sub    $0xc,%esp
c040b063:	68 dd d2 40 c0       	push   $0xc040d2dd
c040b068:	e8 15 0e 00 00       	call   c040be82 <debug_printf>
c040b06d:	83 c4 10             	add    $0x10,%esp
				mp_cpus++;
c040b070:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b075:	40                   	inc    %eax
c040b076:	a2 1c 1d 41 c0       	mov    %al,0xc0411d1c
				block_size = 20;
c040b07b:	c6 44 24 1f 14       	movb   $0x14,0x1f(%esp)
				break;
c040b080:	e9 ee 00 00 00       	jmp    c040b173 <mp_initialise+0x380>
				
			case 1: /* bus entry */
				bus_register_name(info_block->id, &(info_block->entry.bus.name));
c040b085:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b089:	8d 50 02             	lea    0x2(%eax),%edx
c040b08c:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b090:	8a 40 01             	mov    0x1(%eax),%al
c040b093:	0f b6 c0             	movzbl %al,%eax
c040b096:	83 ec 08             	sub    $0x8,%esp
c040b099:	52                   	push   %edx
c040b09a:	50                   	push   %eax
c040b09b:	e8 1c f7 ff ff       	call   c040a7bc <bus_register_name>
c040b0a0:	83 c4 10             	add    $0x10,%esp
				block_size = 8;
c040b0a3:	c6 44 24 1f 08       	movb   $0x8,0x1f(%esp)
				break;
c040b0a8:	e9 c6 00 00 00       	jmp    c040b173 <mp_initialise+0x380>
				
			case 2: /* ioapic */
				BOOT_DEBUG("[mp] found ioapic %i (id %i flags %x addr %p)\n", mp_ioapics,
c040b0ad:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b0b1:	8b 58 06             	mov    0x6(%eax),%ebx
						     info_block->id, info_block->entry.ioapic.flags, info_block->entry.ioapic.physaddr);
c040b0b4:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b0b8:	8a 40 03             	mov    0x3(%eax),%al
				bus_register_name(info_block->id, &(info_block->entry.bus.name));
				block_size = 8;
				break;
				
			case 2: /* ioapic */
				BOOT_DEBUG("[mp] found ioapic %i (id %i flags %x addr %p)\n", mp_ioapics,
c040b0bb:	0f b6 c8             	movzbl %al,%ecx
						     info_block->id, info_block->entry.ioapic.flags, info_block->entry.ioapic.physaddr);
c040b0be:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b0c2:	8a 40 01             	mov    0x1(%eax),%al
				bus_register_name(info_block->id, &(info_block->entry.bus.name));
				block_size = 8;
				break;
				
			case 2: /* ioapic */
				BOOT_DEBUG("[mp] found ioapic %i (id %i flags %x addr %p)\n", mp_ioapics,
c040b0c5:	0f b6 d0             	movzbl %al,%edx
c040b0c8:	a0 1d 1d 41 c0       	mov    0xc0411d1d,%al
c040b0cd:	0f b6 c0             	movzbl %al,%eax
c040b0d0:	83 ec 0c             	sub    $0xc,%esp
c040b0d3:	53                   	push   %ebx
c040b0d4:	51                   	push   %ecx
c040b0d5:	52                   	push   %edx
c040b0d6:	50                   	push   %eax
c040b0d7:	68 28 d3 40 c0       	push   $0xc040d328
c040b0dc:	e8 a1 0d 00 00       	call   c040be82 <debug_printf>
c040b0e1:	83 c4 20             	add    $0x20,%esp
						     info_block->id, info_block->entry.ioapic.flags, info_block->entry.ioapic.physaddr);
				if(info_block->entry.ioapic.flags & MP_IS_IOAPIC_ENABLED)
c040b0e4:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b0e8:	8a 40 03             	mov    0x3(%eax),%al
c040b0eb:	0f b6 c0             	movzbl %al,%eax
c040b0ee:	83 e0 01             	and    $0x1,%eax
c040b0f1:	84 c0                	test   %al,%al
c040b0f3:	74 2f                	je     c040b124 <mp_initialise+0x331>
				{
					/* if this chip is set to go, then register it with the system */
					if(ioapic_register_chip(info_block->id, info_block->entry.ioapic.physaddr) == success)
c040b0f5:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b0f9:	8b 40 06             	mov    0x6(%eax),%eax
c040b0fc:	89 c2                	mov    %eax,%edx
c040b0fe:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b102:	8a 40 01             	mov    0x1(%eax),%al
c040b105:	0f b6 c0             	movzbl %al,%eax
c040b108:	83 ec 08             	sub    $0x8,%esp
c040b10b:	52                   	push   %edx
c040b10c:	50                   	push   %eax
c040b10d:	e8 44 ec ff ff       	call   c0409d56 <ioapic_register_chip>
c040b112:	83 c4 10             	add    $0x10,%esp
c040b115:	85 c0                	test   %eax,%eax
c040b117:	75 0b                	jne    c040b124 <mp_initialise+0x331>
						mp_ioapics++;
c040b119:	a0 1d 1d 41 c0       	mov    0xc0411d1d,%al
c040b11e:	40                   	inc    %eax
c040b11f:	a2 1d 1d 41 c0       	mov    %al,0xc0411d1d
			case 3: /* ->ioapic routing info */
				bus_add_route(info_block->entry.interrupt.flags,
								  info_block->entry.interrupt.source_bus_id,
								  info_block->entry.interrupt.source_bus_irq,
								  info_block->entry.interrupt.dest_ioapic_id,
								  info_block->entry.interrupt.dest_ioapic_irq);
c040b124:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b128:	8a 40 07             	mov    0x7(%eax),%al
					if(ioapic_register_chip(info_block->id, info_block->entry.ioapic.physaddr) == success)
						mp_ioapics++;
				}

			case 3: /* ->ioapic routing info */
				bus_add_route(info_block->entry.interrupt.flags,
c040b12b:	0f b6 f0             	movzbl %al,%esi
								  info_block->entry.interrupt.source_bus_id,
								  info_block->entry.interrupt.source_bus_irq,
								  info_block->entry.interrupt.dest_ioapic_id,
c040b12e:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b132:	8a 40 06             	mov    0x6(%eax),%al
					if(ioapic_register_chip(info_block->id, info_block->entry.ioapic.physaddr) == success)
						mp_ioapics++;
				}

			case 3: /* ->ioapic routing info */
				bus_add_route(info_block->entry.interrupt.flags,
c040b135:	0f b6 d8             	movzbl %al,%ebx
								  info_block->entry.interrupt.source_bus_id,
								  info_block->entry.interrupt.source_bus_irq,
c040b138:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b13c:	8a 40 05             	mov    0x5(%eax),%al
					if(ioapic_register_chip(info_block->id, info_block->entry.ioapic.physaddr) == success)
						mp_ioapics++;
				}

			case 3: /* ->ioapic routing info */
				bus_add_route(info_block->entry.interrupt.flags,
c040b13f:	0f b6 c8             	movzbl %al,%ecx
								  info_block->entry.interrupt.source_bus_id,
c040b142:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b146:	8a 40 04             	mov    0x4(%eax),%al
					if(ioapic_register_chip(info_block->id, info_block->entry.ioapic.physaddr) == success)
						mp_ioapics++;
				}

			case 3: /* ->ioapic routing info */
				bus_add_route(info_block->entry.interrupt.flags,
c040b149:	0f b6 d0             	movzbl %al,%edx
c040b14c:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b150:	66 8b 40 02          	mov    0x2(%eax),%ax
c040b154:	0f b7 c0             	movzwl %ax,%eax
c040b157:	83 ec 0c             	sub    $0xc,%esp
c040b15a:	56                   	push   %esi
c040b15b:	53                   	push   %ebx
c040b15c:	51                   	push   %ecx
c040b15d:	52                   	push   %edx
c040b15e:	50                   	push   %eax
c040b15f:	e8 5e f6 ff ff       	call   c040a7c2 <bus_add_route>
c040b164:	83 c4 20             	add    $0x20,%esp
								  info_block->entry.interrupt.source_bus_id,
								  info_block->entry.interrupt.source_bus_irq,
								  info_block->entry.interrupt.dest_ioapic_id,
								  info_block->entry.interrupt.dest_ioapic_irq);
				block_size = 8;
c040b167:	c6 44 24 1f 08       	movb   $0x8,0x1f(%esp)
				break;
c040b16c:	eb 05                	jmp    c040b173 <mp_initialise+0x380>
				
			default:
				block_size = 8;
c040b16e:	c6 44 24 1f 08       	movb   $0x8,0x1f(%esp)
				break;
		}
		
		info_block = (mp_entry_block *)((unsigned int)info_block + block_size);
c040b173:	0f b6 54 24 1f       	movzbl 0x1f(%esp),%edx
c040b178:	8b 44 24 18          	mov    0x18(%esp),%eax
c040b17c:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b17f:	89 44 24 18          	mov    %eax,0x18(%esp)
	for(i = 0; i < 12; i++)
		BOOT_DEBUG("%c", mp_config->productid[i]);
	BOOT_DEBUG("\n");

	info_block = (mp_entry_block *)((unsigned int)mp_config + sizeof(mp_config_block));
	for(i = 0; i < mp_config->entry_count; i++)
c040b183:	fe 44 24 07          	incb   0x7(%esp)
c040b187:	0f b6 54 24 07       	movzbl 0x7(%esp),%edx
c040b18c:	8b 44 24 14          	mov    0x14(%esp),%eax
c040b190:	66 8b 40 22          	mov    0x22(%eax),%ax
c040b194:	66 39 c2             	cmp    %ax,%dx
c040b197:	0f 82 27 fe ff ff    	jb     c040afc4 <mp_initialise+0x1d1>
	
	MP_DEBUG("[mp] checking apic reg access... bsp apic id %i version %x\n",
			  *(LAPIC_ID_REG), *(LAPIC_VER_REG));
	
	/* let the bootstrap processor continue the initialisation */
	int_initialise_mproc(INT_IAMBSP);
c040b19d:	83 ec 0c             	sub    $0xc,%esp
c040b1a0:	6a 01                	push   $0x1
c040b1a2:	e8 32 f7 ff ff       	call   c040a8d9 <int_initialise_mproc>
c040b1a7:	83 c4 10             	add    $0x10,%esp
	
	return success;
c040b1aa:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b1af:	83 c4 24             	add    $0x24,%esp
c040b1b2:	5b                   	pop    %ebx
c040b1b3:	5e                   	pop    %esi
c040b1b4:	c3                   	ret    
c040b1b5:	00 00                	add    %al,(%eax)
	...

c040b1b8 <_main>:
      essential.
   => mbd = ptr to multiboot data about the system we're running in
      magic = special word passed by the bootloader to prove it is multiboot capable
*/
void _main(multiboot_info_t *mbd, unsigned int magic)
{
c040b1b8:	83 ec 0c             	sub    $0xc,%esp
   if(DEBUG) debug_initialise();
c040b1bb:	e8 80 10 00 00       	call   c040c240 <debug_initialise>
   dprintf("[core] diosix-hyatt rev %s" " " __TIME__ " " __DATE__ " (built with GCC " __VERSION__ ")\n", SVN_REV);
c040b1c0:	83 ec 08             	sub    $0x8,%esp
c040b1c3:	68 58 d3 40 c0       	push   $0xc040d358
c040b1c8:	68 60 d3 40 c0       	push   $0xc040d360
c040b1cd:	e8 b0 0c 00 00       	call   c040be82 <debug_printf>
c040b1d2:	83 c4 10             	add    $0x10,%esp
	
	if(magic != MULTIBOOT_MAGIC) /* as defined in the multiboot spec */
c040b1d5:	81 7c 24 14 02 b0 ad 	cmpl   $0x2badb002,0x14(%esp)
c040b1dc:	2b 
c040b1dd:	74 19                	je     c040b1f8 <_main+0x40>
		dprintf("*** warning: bootloader magic was %x (expecting %x).\n", magic, MULTIBOOT_MAGIC);
c040b1df:	83 ec 04             	sub    $0x4,%esp
c040b1e2:	68 02 b0 ad 2b       	push   $0x2badb002
c040b1e7:	ff 74 24 1c          	pushl  0x1c(%esp)
c040b1eb:	68 a8 d3 40 c0       	push   $0xc040d3a8
c040b1f0:	e8 8d 0c 00 00       	call   c040be82 <debug_printf>
c040b1f5:	83 c4 10             	add    $0x10,%esp
	
	/* ---- multiboot + SMP data must be preserved during these calls ------- */
	/* initialise interrupt handling and discover processor(s) */
   if(mp_initialise()) goto goforhalt;
c040b1f8:	e8 f6 fb ff ff       	call   c040adf3 <mp_initialise>
c040b1fd:	85 c0                	test   %eax,%eax
c040b1ff:	75 40                	jne    c040b241 <_main+0x89>
	
	/* parse modules payloaded by the boot loader, best halt if there are none? */
   if(payload_preinit(mbd)) goto goforhalt;
c040b201:	83 ec 0c             	sub    $0xc,%esp
c040b204:	ff 74 24 1c          	pushl  0x1c(%esp)
c040b208:	e8 e1 03 00 00       	call   c040b5ee <payload_preinit>
c040b20d:	83 c4 10             	add    $0x10,%esp
c040b210:	85 c0                	test   %eax,%eax
c040b212:	75 30                	jne    c040b244 <_main+0x8c>

   /* initialise the memory manager or halt if it fails */
   if(vmm_initialise(mbd)) goto goforhalt;
c040b214:	83 ec 0c             	sub    $0xc,%esp
c040b217:	ff 74 24 1c          	pushl  0x1c(%esp)
c040b21b:	e8 ff 93 ff ff       	call   c040461f <vmm_initialise>
c040b220:	83 c4 10             	add    $0x10,%esp
c040b223:	85 c0                	test   %eax,%eax
c040b225:	75 20                	jne    c040b247 <_main+0x8f>

   /* initialise process and thread management, prepare first processes */
	sched_pre_initalise();
c040b227:	e8 68 88 ff ff       	call   c0403a94 <sched_pre_initalise>
	
	/* bring up the processor(s) */
	mp_post_initialise();
c040b22c:	e8 d7 f9 ff ff       	call   c040ac08 <mp_post_initialise>
	
   if(proc_initialise()) goto goforhalt;
c040b231:	e8 20 e6 ff ff       	call   c0409856 <proc_initialise>
c040b236:	85 c0                	test   %eax,%eax
c040b238:	75 10                	jne    c040b24a <_main+0x92>
   /* ---- multiboot + SMP data is no longer required by this point ------- */

	/* hocus pocus, mumbo jumbo, black magic */
	sched_initialise(); /* enable interrupts and start the execution of
c040b23a:	e8 70 88 ff ff       	call   c0403aaf <sched_initialise>
c040b23f:	eb 0a                	jmp    c040b24b <_main+0x93>
	if(magic != MULTIBOOT_MAGIC) /* as defined in the multiboot spec */
		dprintf("*** warning: bootloader magic was %x (expecting %x).\n", magic, MULTIBOOT_MAGIC);
	
	/* ---- multiboot + SMP data must be preserved during these calls ------- */
	/* initialise interrupt handling and discover processor(s) */
   if(mp_initialise()) goto goforhalt;
c040b241:	90                   	nop
c040b242:	eb 07                	jmp    c040b24b <_main+0x93>
	
	/* parse modules payloaded by the boot loader, best halt if there are none? */
   if(payload_preinit(mbd)) goto goforhalt;
c040b244:	90                   	nop
c040b245:	eb 04                	jmp    c040b24b <_main+0x93>

   /* initialise the memory manager or halt if it fails */
   if(vmm_initialise(mbd)) goto goforhalt;
c040b247:	90                   	nop
c040b248:	eb 01                	jmp    c040b24b <_main+0x93>
	sched_pre_initalise();
	
	/* bring up the processor(s) */
	mp_post_initialise();
	
   if(proc_initialise()) goto goforhalt;
c040b24a:	90                   	nop
								  userspace processes */
	/* shouldn't fall through... but halt if so */
	
goforhalt:
   /* halt here - there is nothing to return to */
   debug_panic("unexpected end-of-boot");
c040b24b:	83 ec 0c             	sub    $0xc,%esp
c040b24e:	68 de d3 40 c0       	push   $0xc040d3de
c040b253:	e8 42 07 00 00       	call   c040b99a <debug_panic>
c040b258:	83 c4 10             	add    $0x10,%esp
}
c040b25b:	83 c4 0c             	add    $0xc,%esp
c040b25e:	c3                   	ret    
	...

c040b260 <payload_exist_here>:
   rather inefficient if there are lots of modules...
   => ptr = address to check
   <= 0 if no payload object at addr, or result code
*/
kresult payload_exist_here(unsigned int ptr)
{
c040b260:	83 ec 1c             	sub    $0x1c,%esp
   mb_module_t *module = NULL;
c040b263:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
c040b26a:	00 
	unsigned int loop;

   for(loop = 0; loop < payload_modulemax; loop++)
c040b26b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b272:	00 
c040b273:	eb 37                	jmp    c040b2ac <payload_exist_here+0x4c>
   {
		module = payload_readmodule(loop);
c040b275:	83 ec 0c             	sub    $0xc,%esp
c040b278:	ff 74 24 18          	pushl  0x18(%esp)
c040b27c:	e8 3f 00 00 00       	call   c040b2c0 <payload_readmodule>
c040b281:	83 c4 10             	add    $0x10,%esp
c040b284:	89 44 24 08          	mov    %eax,0x8(%esp)
		
      if(ptr >= module->mod_start && ptr < module->mod_end)
c040b288:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b28c:	8b 00                	mov    (%eax),%eax
c040b28e:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040b292:	77 14                	ja     c040b2a8 <payload_exist_here+0x48>
c040b294:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b298:	8b 40 04             	mov    0x4(%eax),%eax
c040b29b:	3b 44 24 20          	cmp    0x20(%esp),%eax
c040b29f:	76 07                	jbe    c040b2a8 <payload_exist_here+0x48>
         return e_payload_obj_here;
c040b2a1:	b8 0e 00 00 00       	mov    $0xe,%eax
c040b2a6:	eb 14                	jmp    c040b2bc <payload_exist_here+0x5c>
kresult payload_exist_here(unsigned int ptr)
{
   mb_module_t *module = NULL;
	unsigned int loop;

   for(loop = 0; loop < payload_modulemax; loop++)
c040b2a8:	ff 44 24 0c          	incl   0xc(%esp)
c040b2ac:	a1 24 1d 41 c0       	mov    0xc0411d24,%eax
c040b2b1:	39 44 24 0c          	cmp    %eax,0xc(%esp)
c040b2b5:	72 be                	jb     c040b275 <payload_exist_here+0x15>
		
      if(ptr >= module->mod_start && ptr < module->mod_end)
         return e_payload_obj_here;
   }

   return success; /* fall through */
c040b2b7:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b2bc:	83 c4 1c             	add    $0x1c,%esp
c040b2bf:	c3                   	ret    

c040b2c0 <payload_readmodule>:
   Look up a module loaded with the kernel and return details about it.
   => modulenum = module number, 0 for first module
   <= pointer to multiboot module data or NULL for no more
*/
mb_module_t *payload_readmodule(unsigned int modulenum)
{
c040b2c0:	83 ec 1c             	sub    $0x1c,%esp
	mb_module_t *module = (mb_module_t *)mbd_ptr->mods_addr;
c040b2c3:	a1 28 1d 41 c0       	mov    0xc0411d28,%eax
c040b2c8:	8b 40 18             	mov    0x18(%eax),%eax
c040b2cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
	
	if(!module)
c040b2cf:	83 7c 24 0c 00       	cmpl   $0x0,0xc(%esp)
c040b2d4:	75 10                	jne    c040b2e6 <payload_readmodule+0x26>
		debug_panic("trying to probe payloads before preinit");
c040b2d6:	83 ec 0c             	sub    $0xc,%esp
c040b2d9:	68 f8 d3 40 c0       	push   $0xc040d3f8
c040b2de:	e8 b7 06 00 00       	call   c040b99a <debug_panic>
c040b2e3:	83 c4 10             	add    $0x10,%esp
	
	module = (mb_module_t *)((unsigned int)module + 
									 (sizeof(mb_module_t) * modulenum));
c040b2e6:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b2ea:	89 c2                	mov    %eax,%edx
c040b2ec:	c1 e2 04             	shl    $0x4,%edx
	mb_module_t *module = (mb_module_t *)mbd_ptr->mods_addr;
	
	if(!module)
		debug_panic("trying to probe payloads before preinit");
	
	module = (mb_module_t *)((unsigned int)module + 
c040b2ef:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040b2f3:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b2f6:	89 44 24 0c          	mov    %eax,0xc(%esp)
									 (sizeof(mb_module_t) * modulenum));
	
   return (mb_module_t *)KERNEL_PHYS2LOG(module);
c040b2fa:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040b2fe:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c040b303:	83 c4 1c             	add    $0x1c,%esp
c040b306:	c3                   	ret    

c040b307 <payload_parsemodule>:
   => module = pointer to structure describing the payload module to parse
      payload = pointer to payload info structure to fill in
   <= payload type or 0 for failure
*/
payload_type payload_parsemodule(mb_module_t *module, payload_descr *payload)
{
c040b307:	53                   	push   %ebx
c040b308:	83 ec 18             	sub    $0x18,%esp
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
c040b30b:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b30f:	8b 00                	mov    (%eax),%eax
c040b311:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040b316:	89 04 24             	mov    %eax,(%esp)
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040b319:	8b 04 24             	mov    (%esp),%eax
c040b31c:	8a 00                	mov    (%eax),%al
c040b31e:	3c 4b                	cmp    $0x4b,%al
c040b320:	0f 85 99 00 00 00    	jne    c040b3bf <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
c040b326:	8b 04 24             	mov    (%esp),%eax
c040b329:	40                   	inc    %eax
c040b32a:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040b32c:	3c 53                	cmp    $0x53,%al
c040b32e:	0f 85 8b 00 00 00    	jne    c040b3bf <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
c040b334:	8b 04 24             	mov    (%esp),%eax
c040b337:	83 c0 02             	add    $0x2,%eax
c040b33a:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040b33c:	3c 59                	cmp    $0x59,%al
c040b33e:	75 7f                	jne    c040b3bf <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
c040b340:	8b 04 24             	mov    (%esp),%eax
c040b343:	83 c0 03             	add    $0x3,%eax
c040b346:	8a 00                	mov    (%eax),%al
   unsigned char *magic = (unsigned char *)KERNEL_PHYS2LOG(module->mod_start);
   Elf32_Ehdr *fheader;
   Elf32_Phdr *pheader;

	/* is this a symbol table for debugging? */
	if(magic[0] == 'K' &&
c040b348:	3c 4d                	cmp    $0x4d,%al
c040b34a:	75 73                	jne    c040b3bf <payload_parsemodule+0xb8>
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      BOOT_DEBUG("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040b34c:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b350:	8b 48 04             	mov    0x4(%eax),%ecx
c040b353:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b357:	8b 10                	mov    (%eax),%edx
				     CPU_ID, module->mod_start, module->mod_end);
c040b359:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	if(magic[0] == 'K' &&
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      BOOT_DEBUG("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040b35e:	3c 01                	cmp    $0x1,%al
c040b360:	76 0c                	jbe    c040b36e <payload_parsemodule+0x67>
				     CPU_ID, module->mod_start, module->mod_end);
c040b362:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b367:	8b 00                	mov    (%eax),%eax
	if(magic[0] == 'K' &&
      magic[1] == 'S' &&
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      BOOT_DEBUG("[payload:%i] found a kernel symbol table (%x - %x)\n",
c040b369:	c1 e8 18             	shr    $0x18,%eax
c040b36c:	eb 08                	jmp    c040b376 <payload_parsemodule+0x6f>
c040b36e:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b373:	0f b6 c0             	movzbl %al,%eax
c040b376:	51                   	push   %ecx
c040b377:	52                   	push   %edx
c040b378:	50                   	push   %eax
c040b379:	68 20 d4 40 c0       	push   $0xc040d420
c040b37e:	e8 ff 0a 00 00       	call   c040be82 <debug_printf>
c040b383:	83 c4 10             	add    $0x10,%esp
				     CPU_ID, module->mod_start, module->mod_end);
      if(debug_init_sym_table((char *)((unsigned int)magic + (sizeof(char) * 5)),
										(char *)KERNEL_PHYS2LOG(module->mod_end)) == success)
c040b386:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b38a:	8b 40 04             	mov    0x4(%eax),%eax
c040b38d:	2d 00 00 00 40       	sub    $0x40000000,%eax
      magic[2] == 'Y' &&
      magic[3] == 'M')
   {
      BOOT_DEBUG("[payload:%i] found a kernel symbol table (%x - %x)\n",
				     CPU_ID, module->mod_start, module->mod_end);
      if(debug_init_sym_table((char *)((unsigned int)magic + (sizeof(char) * 5)),
c040b392:	89 c2                	mov    %eax,%edx
c040b394:	8b 04 24             	mov    (%esp),%eax
c040b397:	83 c0 05             	add    $0x5,%eax
c040b39a:	83 ec 08             	sub    $0x8,%esp
c040b39d:	52                   	push   %edx
c040b39e:	50                   	push   %eax
c040b39f:	e8 28 0b 00 00       	call   c040becc <debug_init_sym_table>
c040b3a4:	83 c4 10             	add    $0x10,%esp
c040b3a7:	85 c0                	test   %eax,%eax
c040b3a9:	75 0a                	jne    c040b3b5 <payload_parsemodule+0xae>
										(char *)KERNEL_PHYS2LOG(module->mod_end)) == success)
			return payload_sym;
c040b3ab:	b8 02 00 00 00       	mov    $0x2,%eax
c040b3b0:	e9 34 02 00 00       	jmp    c040b5e9 <payload_parsemodule+0x2e2>
		else
			return payload_bad;
c040b3b5:	b8 00 00 00 00       	mov    $0x0,%eax
c040b3ba:	e9 2a 02 00 00       	jmp    c040b5e9 <payload_parsemodule+0x2e2>
   }
	
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
c040b3bf:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3c3:	8b 00                	mov    (%eax),%eax
c040b3c5:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040b3ca:	89 44 24 04          	mov    %eax,0x4(%esp)
   BOOT_DEBUG("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
c040b3ce:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b3d2:	8b 40 08             	mov    0x8(%eax),%eax
c040b3d5:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040b3da:	89 c2                	mov    %eax,%edx
c040b3dc:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b3e1:	3c 01                	cmp    $0x1,%al
c040b3e3:	76 0c                	jbe    c040b3f1 <payload_parsemodule+0xea>
c040b3e5:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b3ea:	8b 00                	mov    (%eax),%eax
c040b3ec:	c1 e8 18             	shr    $0x18,%eax
c040b3ef:	eb 08                	jmp    c040b3f9 <payload_parsemodule+0xf2>
c040b3f1:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b3f6:	0f b6 c0             	movzbl %al,%eax
c040b3f9:	ff 74 24 04          	pushl  0x4(%esp)
c040b3fd:	52                   	push   %edx
c040b3fe:	50                   	push   %eax
c040b3ff:	68 54 d4 40 c0       	push   $0xc040d454
c040b404:	e8 79 0a 00 00       	call   c040be82 <debug_printf>
c040b409:	83 c4 10             	add    $0x10,%esp
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040b40c:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b410:	8a 00                	mov    (%eax),%al
c040b412:	3c 7f                	cmp    $0x7f,%al
c040b414:	75 21                	jne    c040b437 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
c040b416:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b41a:	8a 40 01             	mov    0x1(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   BOOT_DEBUG("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040b41d:	3c 45                	cmp    $0x45,%al
c040b41f:	75 16                	jne    c040b437 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
c040b421:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b425:	8a 40 02             	mov    0x2(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   BOOT_DEBUG("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040b428:	3c 4c                	cmp    $0x4c,%al
c040b42a:	75 0b                	jne    c040b437 <payload_parsemodule+0x130>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
      fheader->e_ident[3] != 'F')
c040b42c:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b430:	8a 40 03             	mov    0x3(%eax),%al
	/* is this an ELF to load as a user process? */
	fheader = (Elf32_Ehdr *)KERNEL_PHYS2LOG(module->mod_start);
   BOOT_DEBUG("[payload:%i] parsing binary: %s (%x)", CPU_ID, (char *)KERNEL_PHYS2LOG(module->string), fheader);	
	
   /* sanity check the ELF we're trying to load */
   if(fheader->e_ident[0] != 0x7f ||
c040b433:	3c 46                	cmp    $0x46,%al
c040b435:	74 1a                	je     c040b451 <payload_parsemodule+0x14a>
      fheader->e_ident[1] != 'E'  ||
      fheader->e_ident[2] != 'L'  ||
      fheader->e_ident[3] != 'F')
   {
      BOOT_DEBUG(" ... is not a valid ELF\n");
c040b437:	83 ec 0c             	sub    $0xc,%esp
c040b43a:	68 79 d4 40 c0       	push   $0xc040d479
c040b43f:	e8 3e 0a 00 00       	call   c040be82 <debug_printf>
c040b444:	83 c4 10             	add    $0x10,%esp
      return payload_bad;
c040b447:	b8 00 00 00 00       	mov    $0x0,%eax
c040b44c:	e9 98 01 00 00       	jmp    c040b5e9 <payload_parsemodule+0x2e2>
   }

   if(fheader->e_machine != EM_PORT)
c040b451:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b455:	66 8b 40 12          	mov    0x12(%eax),%ax
c040b459:	66 83 f8 03          	cmp    $0x3,%ax
c040b45d:	74 26                	je     c040b485 <payload_parsemodule+0x17e>
   {
      BOOT_DEBUG(" ... is incompatible with this machine (%x)\n", fheader->e_machine);
c040b45f:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b463:	66 8b 40 12          	mov    0x12(%eax),%ax
c040b467:	0f b7 c0             	movzwl %ax,%eax
c040b46a:	83 ec 08             	sub    $0x8,%esp
c040b46d:	50                   	push   %eax
c040b46e:	68 94 d4 40 c0       	push   $0xc040d494
c040b473:	e8 0a 0a 00 00       	call   c040be82 <debug_printf>
c040b478:	83 c4 10             	add    $0x10,%esp
      return payload_bad;
c040b47b:	b8 00 00 00 00       	mov    $0x0,%eax
c040b480:	e9 64 01 00 00       	jmp    c040b5e9 <payload_parsemodule+0x2e2>
   }

   /* fill in some basic info about this module */
   payload->name = (char *)KERNEL_PHYS2LOG(module->string);
c040b485:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b489:	8b 40 08             	mov    0x8(%eax),%eax
c040b48c:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040b491:	89 c2                	mov    %eax,%edx
c040b493:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b497:	89 50 2c             	mov    %edx,0x2c(%eax)
   payload->entry = (void *)fheader->e_entry;
c040b49a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b49e:	8b 40 18             	mov    0x18(%eax),%eax
c040b4a1:	89 c2                	mov    %eax,%edx
c040b4a3:	8b 44 24 24          	mov    0x24(%esp),%eax
c040b4a7:	89 50 28             	mov    %edx,0x28(%eax)

   /* now inspect the various headers to pull out the code and data */
   if(fheader->e_phoff)
c040b4aa:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b4ae:	8b 40 1c             	mov    0x1c(%eax),%eax
c040b4b1:	85 c0                	test   %eax,%eax
c040b4b3:	0f 84 1b 01 00 00    	je     c040b5d4 <payload_parsemodule+0x2cd>
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
c040b4b9:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b4c0:	00 
c040b4c1:	e9 fa 00 00 00       	jmp    c040b5c0 <payload_parsemodule+0x2b9>
      {
         pheader = (Elf32_Phdr *)((unsigned int)fheader + fheader->e_phoff +
c040b4c6:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b4ca:	8b 50 1c             	mov    0x1c(%eax),%edx
c040b4cd:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b4d1:	01 c2                	add    %eax,%edx
                                  (p_loop * sizeof(Elf32_Phdr)));
c040b4d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040b4d7:	c1 e0 05             	shl    $0x5,%eax
   if(fheader->e_phoff)
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
      {
         pheader = (Elf32_Phdr *)((unsigned int)fheader + fheader->e_phoff +
c040b4da:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b4dd:	89 44 24 08          	mov    %eax,0x8(%esp)
                                  (p_loop * sizeof(Elf32_Phdr)));

         if(pheader->p_type == PT_LOAD)
c040b4e1:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b4e5:	8b 00                	mov    (%eax),%eax
c040b4e7:	83 f8 01             	cmp    $0x1,%eax
c040b4ea:	0f 85 cc 00 00 00    	jne    c040b5bc <payload_parsemodule+0x2b5>
         {
            /* we expect two areas: code and then data, and nothing else */
            if(p_loop > PAYLOAD_DATA)
c040b4f0:	83 7c 24 0c 01       	cmpl   $0x1,0xc(%esp)
c040b4f5:	7e 1a                	jle    c040b511 <payload_parsemodule+0x20a>
            {
               BOOT_DEBUG(" ... has unexpected areas!\n");
c040b4f7:	83 ec 0c             	sub    $0xc,%esp
c040b4fa:	68 c1 d4 40 c0       	push   $0xc040d4c1
c040b4ff:	e8 7e 09 00 00       	call   c040be82 <debug_printf>
c040b504:	83 c4 10             	add    $0x10,%esp
               return payload_bad;
c040b507:	b8 00 00 00 00       	mov    $0x0,%eax
c040b50c:	e9 d8 00 00 00       	jmp    c040b5e9 <payload_parsemodule+0x2e2>
            }

            payload->areas[p_loop].virtual = (void *)pheader->p_vaddr;
c040b511:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
c040b515:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b519:	8b 40 08             	mov    0x8(%eax),%eax
c040b51c:	89 c1                	mov    %eax,%ecx
c040b51e:	8b 54 24 24          	mov    0x24(%esp),%edx
c040b522:	89 d8                	mov    %ebx,%eax
c040b524:	c1 e0 02             	shl    $0x2,%eax
c040b527:	01 d8                	add    %ebx,%eax
c040b529:	c1 e0 02             	shl    $0x2,%eax
c040b52c:	89 0c 10             	mov    %ecx,(%eax,%edx,1)
            payload->areas[p_loop].physical = (void *)(pheader->p_offset +
c040b52f:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040b533:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b537:	8b 50 04             	mov    0x4(%eax),%edx
c040b53a:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b53e:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b541:	89 c2                	mov    %eax,%edx
c040b543:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040b547:	89 c8                	mov    %ecx,%eax
c040b549:	c1 e0 02             	shl    $0x2,%eax
c040b54c:	01 c8                	add    %ecx,%eax
c040b54e:	c1 e0 02             	shl    $0x2,%eax
c040b551:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040b554:	83 c0 04             	add    $0x4,%eax
c040b557:	89 10                	mov    %edx,(%eax)
                                              (unsigned int)fheader);
            payload->areas[p_loop].size = pheader->p_filesz;
c040b559:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040b55d:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b561:	8b 50 10             	mov    0x10(%eax),%edx
c040b564:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040b568:	89 c8                	mov    %ecx,%eax
c040b56a:	c1 e0 02             	shl    $0x2,%eax
c040b56d:	01 c8                	add    %ecx,%eax
c040b56f:	c1 e0 02             	shl    $0x2,%eax
c040b572:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040b575:	83 c0 08             	add    $0x8,%eax
c040b578:	89 10                	mov    %edx,(%eax)
            payload->areas[p_loop].memsize = pheader->p_memsz;
c040b57a:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040b57e:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b582:	8b 50 14             	mov    0x14(%eax),%edx
c040b585:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040b589:	89 c8                	mov    %ecx,%eax
c040b58b:	c1 e0 02             	shl    $0x2,%eax
c040b58e:	01 c8                	add    %ecx,%eax
c040b590:	c1 e0 02             	shl    $0x2,%eax
c040b593:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040b596:	83 c0 0c             	add    $0xc,%eax
c040b599:	89 10                	mov    %edx,(%eax)
            payload->areas[p_loop].flags = pheader->p_flags;
c040b59b:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
c040b59f:	8b 44 24 08          	mov    0x8(%esp),%eax
c040b5a3:	8b 50 18             	mov    0x18(%eax),%edx
c040b5a6:	8b 5c 24 24          	mov    0x24(%esp),%ebx
c040b5aa:	89 c8                	mov    %ecx,%eax
c040b5ac:	c1 e0 02             	shl    $0x2,%eax
c040b5af:	01 c8                	add    %ecx,%eax
c040b5b1:	c1 e0 02             	shl    $0x2,%eax
c040b5b4:	8d 04 03             	lea    (%ebx,%eax,1),%eax
c040b5b7:	83 c0 10             	add    $0x10,%eax
c040b5ba:	89 10                	mov    %edx,(%eax)

   /* now inspect the various headers to pull out the code and data */
   if(fheader->e_phoff)
   {
      int p_loop;
      for(p_loop = 0; p_loop < fheader->e_phnum; p_loop++)
c040b5bc:	ff 44 24 0c          	incl   0xc(%esp)
c040b5c0:	8b 44 24 04          	mov    0x4(%esp),%eax
c040b5c4:	8b 40 2c             	mov    0x2c(%eax),%eax
c040b5c7:	0f b7 c0             	movzwl %ax,%eax
c040b5ca:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040b5ce:	0f 8f f2 fe ff ff    	jg     c040b4c6 <payload_parsemodule+0x1bf>
            payload->areas[p_loop].flags = pheader->p_flags;
         }
      }
   }

   BOOT_DEBUG(" ... done\n");
c040b5d4:	83 ec 0c             	sub    $0xc,%esp
c040b5d7:	68 dd d4 40 c0       	push   $0xc040d4dd
c040b5dc:	e8 a1 08 00 00       	call   c040be82 <debug_printf>
c040b5e1:	83 c4 10             	add    $0x10,%esp
   return payload_exe;
c040b5e4:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040b5e9:	83 c4 18             	add    $0x18,%esp
c040b5ec:	5b                   	pop    %ebx
c040b5ed:	c3                   	ret    

c040b5ee <payload_preinit>:
   to be rather dull with just the microkernel present.
   => mbd = pointer to multiboot info in physical memory
   <= 0 for success, or result code
*/
kresult payload_preinit(multiboot_info_t *mbd)
{	
c040b5ee:	83 ec 0c             	sub    $0xc,%esp
	mbd = (multiboot_info_t *)KERNEL_PHYS2LOG(mbd);
c040b5f1:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b5f5:	2d 00 00 00 40       	sub    $0x40000000,%eax
c040b5fa:	89 44 24 10          	mov    %eax,0x10(%esp)

   /* keep a copy of the multiboot info pointer */
   mbd_ptr = mbd;
c040b5fe:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b602:	a3 28 1d 41 c0       	mov    %eax,0xc0411d28

   /* bit 3 indicates modules loaded, although we must also check mods_count */
   if(!((mbd->flags & (1<<3)) && mbd->mods_count))
c040b607:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b60b:	8b 00                	mov    (%eax),%eax
c040b60d:	83 e0 08             	and    $0x8,%eax
c040b610:	85 c0                	test   %eax,%eax
c040b612:	74 0b                	je     c040b61f <payload_preinit+0x31>
c040b614:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b618:	8b 40 14             	mov    0x14(%eax),%eax
c040b61b:	85 c0                	test   %eax,%eax
c040b61d:	75 35                	jne    c040b654 <payload_preinit+0x66>
   {
      BOOT_DEBUG("[payload:%i] No modules loaded with kernel.\n", CPU_ID);
c040b61f:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b624:	3c 01                	cmp    $0x1,%al
c040b626:	76 0c                	jbe    c040b634 <payload_preinit+0x46>
c040b628:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b62d:	8b 00                	mov    (%eax),%eax
c040b62f:	c1 e8 18             	shr    $0x18,%eax
c040b632:	eb 08                	jmp    c040b63c <payload_preinit+0x4e>
c040b634:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b639:	0f b6 c0             	movzbl %al,%eax
c040b63c:	83 ec 08             	sub    $0x8,%esp
c040b63f:	50                   	push   %eax
c040b640:	68 e8 d4 40 c0       	push   $0xc040d4e8
c040b645:	e8 38 08 00 00       	call   c040be82 <debug_printf>
c040b64a:	83 c4 10             	add    $0x10,%esp
      return e_payload_missing;
c040b64d:	b8 0f 00 00 00       	mov    $0xf,%eax
c040b652:	eb 47                	jmp    c040b69b <payload_preinit+0xad>
   }

   BOOT_DEBUG("[payload:%i] %i module(s) in payload\n", CPU_ID, mbd->mods_count);
c040b654:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b658:	8b 50 14             	mov    0x14(%eax),%edx
c040b65b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b660:	3c 01                	cmp    $0x1,%al
c040b662:	76 0c                	jbe    c040b670 <payload_preinit+0x82>
c040b664:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b669:	8b 00                	mov    (%eax),%eax
c040b66b:	c1 e8 18             	shr    $0x18,%eax
c040b66e:	eb 08                	jmp    c040b678 <payload_preinit+0x8a>
c040b670:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b675:	0f b6 c0             	movzbl %al,%eax
c040b678:	83 ec 04             	sub    $0x4,%esp
c040b67b:	52                   	push   %edx
c040b67c:	50                   	push   %eax
c040b67d:	68 18 d5 40 c0       	push   $0xc040d518
c040b682:	e8 fb 07 00 00       	call   c040be82 <debug_printf>
c040b687:	83 c4 10             	add    $0x10,%esp

	payload_modulemax = mbd->mods_count;
c040b68a:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b68e:	8b 40 14             	mov    0x14(%eax),%eax
c040b691:	a3 24 1d 41 c0       	mov    %eax,0xc0411d24
	
   return success;
c040b696:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b69b:	83 c4 0c             	add    $0xc,%esp
c040b69e:	c3                   	ret    
	...

c040b6a0 <serial_writebyte>:
/* serial_writebyte
   Write a byte out out to the serial port
   => c = character to output
*/
void serial_writebyte(unsigned char c)
{
c040b6a0:	83 ec 1c             	sub    $0x1c,%esp
c040b6a3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b6a7:	88 44 24 0c          	mov    %al,0xc(%esp)
   /* loop waiting for bit 5 of the line status register to set, indicating
      data can be written */
   while((x86_inportb(SERIAL_HW + 5) & 0x20) == 0) __asm__ __volatile("pause");
c040b6ab:	eb 02                	jmp    c040b6af <serial_writebyte+0xf>
c040b6ad:	f3 90                	pause  
c040b6af:	83 ec 0c             	sub    $0xc,%esp
c040b6b2:	68 fd 03 00 00       	push   $0x3fd
c040b6b7:	e8 1c 50 ff ff       	call   c04006d8 <x86_inportb>
c040b6bc:	83 c4 10             	add    $0x10,%esp
c040b6bf:	83 e0 20             	and    $0x20,%eax
c040b6c2:	85 c0                	test   %eax,%eax
c040b6c4:	74 e7                	je     c040b6ad <serial_writebyte+0xd>
   x86_outportb(SERIAL_HW + 0, c);
c040b6c6:	0f b6 44 24 0c       	movzbl 0xc(%esp),%eax
c040b6cb:	83 ec 08             	sub    $0x8,%esp
c040b6ce:	50                   	push   %eax
c040b6cf:	68 f8 03 00 00       	push   $0x3f8
c040b6d4:	e8 1d 50 ff ff       	call   c04006f6 <x86_outportb>
c040b6d9:	83 c4 10             	add    $0x10,%esp
}
c040b6dc:	83 c4 1c             	add    $0x1c,%esp
c040b6df:	c3                   	ret    

c040b6e0 <serial_initialise>:

/* serial_initialise
   Start up the serial debugging output */
void serial_initialise(void)
{
c040b6e0:	83 ec 0c             	sub    $0xc,%esp
   /* set baud, etc */
   x86_outportb(SERIAL_HW + 3, 0x80);
c040b6e3:	83 ec 08             	sub    $0x8,%esp
c040b6e6:	68 80 00 00 00       	push   $0x80
c040b6eb:	68 fb 03 00 00       	push   $0x3fb
c040b6f0:	e8 01 50 ff ff       	call   c04006f6 <x86_outportb>
c040b6f5:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 0, 0x30);
c040b6f8:	83 ec 08             	sub    $0x8,%esp
c040b6fb:	6a 30                	push   $0x30
c040b6fd:	68 f8 03 00 00       	push   $0x3f8
c040b702:	e8 ef 4f ff ff       	call   c04006f6 <x86_outportb>
c040b707:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 1, 0x00);
c040b70a:	83 ec 08             	sub    $0x8,%esp
c040b70d:	6a 00                	push   $0x0
c040b70f:	68 f9 03 00 00       	push   $0x3f9
c040b714:	e8 dd 4f ff ff       	call   c04006f6 <x86_outportb>
c040b719:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 3, 0x03);
c040b71c:	83 ec 08             	sub    $0x8,%esp
c040b71f:	6a 03                	push   $0x3
c040b721:	68 fb 03 00 00       	push   $0x3fb
c040b726:	e8 cb 4f ff ff       	call   c04006f6 <x86_outportb>
c040b72b:	83 c4 10             	add    $0x10,%esp
   x86_outportb(SERIAL_HW + 4, 0x00);
c040b72e:	83 ec 08             	sub    $0x8,%esp
c040b731:	6a 00                	push   $0x0
c040b733:	68 fc 03 00 00       	push   $0x3fc
c040b738:	e8 b9 4f ff ff       	call   c04006f6 <x86_outportb>
c040b73d:	83 c4 10             	add    $0x10,%esp
   x86_inportb(SERIAL_HW);
c040b740:	83 ec 0c             	sub    $0xc,%esp
c040b743:	68 f8 03 00 00       	push   $0x3f8
c040b748:	e8 8b 4f ff ff       	call   c04006d8 <x86_inportb>
c040b74d:	83 c4 10             	add    $0x10,%esp
}
c040b750:	83 c4 0c             	add    $0xc,%esp
c040b753:	c3                   	ret    

c040b754 <debug_writebyte>:
   Write a byte out to the debugging output stream, usually a serial port
   => c = character to write
      ptr = unused
*/
static int debug_writebyte(unsigned c, void **ptr)
{
c040b754:	83 ec 0c             	sub    $0xc,%esp
   serial_writebyte(c); /* port-specific */
c040b757:	8b 44 24 10          	mov    0x10(%esp),%eax
c040b75b:	0f b6 c0             	movzbl %al,%eax
c040b75e:	83 ec 0c             	sub    $0xc,%esp
c040b761:	50                   	push   %eax
c040b762:	e8 39 ff ff ff       	call   c040b6a0 <serial_writebyte>
c040b767:	83 c4 10             	add    $0x10,%esp
   return 0;
c040b76a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040b76f:	83 c4 0c             	add    $0xc,%esp
c040b772:	c3                   	ret    

c040b773 <debug_stacktrace>:

/* debug_stacktrace
   Dump a copy of the current kernel stack in a not-so-pretty way */
void debug_stacktrace(void)
{
c040b773:	53                   	push   %ebx
c040b774:	83 ec 48             	sub    $0x48,%esp
	unsigned int *ptr, *base, sym_base;
	unsigned int tid, pid;
	char buffer[32];
	
	/* first, work out where the stack starts */
	if(cpu_table[CPU_ID].current)
c040b777:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040b77d:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b782:	3c 01                	cmp    $0x1,%al
c040b784:	76 0f                	jbe    c040b795 <debug_stacktrace+0x22>
c040b786:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b78b:	8b 00                	mov    (%eax),%eax
c040b78d:	c1 e8 18             	shr    $0x18,%eax
c040b790:	c1 e0 06             	shl    $0x6,%eax
c040b793:	eb 0b                	jmp    c040b7a0 <debug_stacktrace+0x2d>
c040b795:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b79a:	0f b6 c0             	movzbl %al,%eax
c040b79d:	c1 e0 06             	shl    $0x6,%eax
c040b7a0:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b7a3:	8b 40 04             	mov    0x4(%eax),%eax
c040b7a6:	85 c0                	test   %eax,%eax
c040b7a8:	0f 84 a5 00 00 00    	je     c040b853 <debug_stacktrace+0xe0>
	{
		/* we're running threads, so find the current thread's kernel
		   stack base */
		base = (unsigned int *)cpu_table[CPU_ID].current->tss.esp0;
c040b7ae:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040b7b4:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b7b9:	3c 01                	cmp    $0x1,%al
c040b7bb:	76 0f                	jbe    c040b7cc <debug_stacktrace+0x59>
c040b7bd:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b7c2:	8b 00                	mov    (%eax),%eax
c040b7c4:	c1 e8 18             	shr    $0x18,%eax
c040b7c7:	c1 e0 06             	shl    $0x6,%eax
c040b7ca:	eb 0b                	jmp    c040b7d7 <debug_stacktrace+0x64>
c040b7cc:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b7d1:	0f b6 c0             	movzbl %al,%eax
c040b7d4:	c1 e0 06             	shl    $0x6,%eax
c040b7d7:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b7da:	8b 40 04             	mov    0x4(%eax),%eax
c040b7dd:	8b 40 3c             	mov    0x3c(%eax),%eax
c040b7e0:	89 44 24 34          	mov    %eax,0x34(%esp)
		tid = cpu_table[CPU_ID].current->tid;
c040b7e4:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040b7ea:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b7ef:	3c 01                	cmp    $0x1,%al
c040b7f1:	76 0f                	jbe    c040b802 <debug_stacktrace+0x8f>
c040b7f3:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b7f8:	8b 00                	mov    (%eax),%eax
c040b7fa:	c1 e8 18             	shr    $0x18,%eax
c040b7fd:	c1 e0 06             	shl    $0x6,%eax
c040b800:	eb 0b                	jmp    c040b80d <debug_stacktrace+0x9a>
c040b802:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b807:	0f b6 c0             	movzbl %al,%eax
c040b80a:	c1 e0 06             	shl    $0x6,%eax
c040b80d:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b810:	8b 40 04             	mov    0x4(%eax),%eax
c040b813:	8b 40 04             	mov    0x4(%eax),%eax
c040b816:	89 44 24 38          	mov    %eax,0x38(%esp)
		pid = cpu_table[CPU_ID].current->proc->pid;
c040b81a:	8b 15 e8 fc 40 c0    	mov    0xc040fce8,%edx
c040b820:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
c040b825:	3c 01                	cmp    $0x1,%al
c040b827:	76 0f                	jbe    c040b838 <debug_stacktrace+0xc5>
c040b829:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b82e:	8b 00                	mov    (%eax),%eax
c040b830:	c1 e8 18             	shr    $0x18,%eax
c040b833:	c1 e0 06             	shl    $0x6,%eax
c040b836:	eb 0b                	jmp    c040b843 <debug_stacktrace+0xd0>
c040b838:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b83d:	0f b6 c0             	movzbl %al,%eax
c040b840:	c1 e0 06             	shl    $0x6,%eax
c040b843:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040b846:	8b 40 04             	mov    0x4(%eax),%eax
c040b849:	8b 00                	mov    (%eax),%eax
c040b84b:	8b 00                	mov    (%eax),%eax
c040b84d:	89 44 24 3c          	mov    %eax,0x3c(%esp)
c040b851:	eb 18                	jmp    c040b86b <debug_stacktrace+0xf8>
	}
	else
	{
		/* kernel is still booting and using the initial stack */
		base = (unsigned int *)&(KernelBootStackBase);
c040b853:	c7 44 24 34 ec 1c 41 	movl   $0xc0411cec,0x34(%esp)
c040b85a:	c0 
		tid = pid = 0;
c040b85b:	c7 44 24 3c 00 00 00 	movl   $0x0,0x3c(%esp)
c040b862:	00 
c040b863:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040b867:	89 44 24 38          	mov    %eax,0x38(%esp)
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
c040b86b:	89 e0                	mov    %esp,%eax
c040b86d:	89 44 24 30          	mov    %eax,0x30(%esp)
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040b871:	8b 54 24 34          	mov    0x34(%esp),%edx
c040b875:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b879:	29 c2                	sub    %eax,%edx
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);
c040b87b:	a0 1c 1d 41 c0       	mov    0xc0411d1c,%al
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040b880:	3c 01                	cmp    $0x1,%al
c040b882:	76 0c                	jbe    c040b890 <debug_stacktrace+0x11d>
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);
c040b884:	b8 20 00 e0 fe       	mov    $0xfee00020,%eax
c040b889:	8b 00                	mov    (%eax),%eax
	}
	
	/* grab a copy of the stack pointer */
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
c040b88b:	c1 e8 18             	shr    $0x18,%eax
c040b88e:	eb 08                	jmp    c040b898 <debug_stacktrace+0x125>
c040b890:	a0 1e 1d 41 c0       	mov    0xc0411d1e,%al
c040b895:	0f b6 c0             	movzbl %al,%eax
c040b898:	83 ec 04             	sub    $0x4,%esp
c040b89b:	ff 74 24 40          	pushl  0x40(%esp)
c040b89f:	ff 74 24 40          	pushl  0x40(%esp)
c040b8a3:	52                   	push   %edx
c040b8a4:	ff 74 24 40          	pushl  0x40(%esp)
c040b8a8:	ff 74 24 48          	pushl  0x48(%esp)
c040b8ac:	50                   	push   %eax
c040b8ad:	68 40 d5 40 c0       	push   $0xc040d540
c040b8b2:	e8 cb 05 00 00       	call   c040be82 <debug_printf>
c040b8b7:	83 c4 20             	add    $0x20,%esp
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);

	while(base >= ptr)
c040b8ba:	e9 81 00 00 00       	jmp    c040b940 <debug_stacktrace+0x1cd>
	{
		/* look up a kernel symbol if relevant */
		if((*(base) >= KERNEL_VIRTUAL_BASE) && (*(base) < KERNEL_VIRTUAL_END))
c040b8bf:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b8c3:	8b 00                	mov    (%eax),%eax
c040b8c5:	3d ff ff 3f c0       	cmp    $0xc03fffff,%eax
c040b8ca:	76 6f                	jbe    c040b93b <debug_stacktrace+0x1c8>
c040b8cc:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b8d0:	8b 00                	mov    (%eax),%eax
c040b8d2:	b9 38 1d 41 c0       	mov    $0xc0411d38,%ecx
c040b8d7:	ba 00 00 40 c0       	mov    $0xc0400000,%edx
c040b8dc:	89 cb                	mov    %ecx,%ebx
c040b8de:	29 d3                	sub    %edx,%ebx
c040b8e0:	89 da                	mov    %ebx,%edx
c040b8e2:	c1 fa 02             	sar    $0x2,%edx
c040b8e5:	81 ea 00 00 c0 3f    	sub    $0x3fc00000,%edx
c040b8eb:	39 d0                	cmp    %edx,%eax
c040b8ed:	73 4c                	jae    c040b93b <debug_stacktrace+0x1c8>
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
c040b8ef:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b8f3:	8b 00                	mov    (%eax),%eax
c040b8f5:	8d 54 24 2c          	lea    0x2c(%esp),%edx
c040b8f9:	52                   	push   %edx
c040b8fa:	6a 20                	push   $0x20
c040b8fc:	8d 54 24 14          	lea    0x14(%esp),%edx
c040b900:	52                   	push   %edx
c040b901:	50                   	push   %eax
c040b902:	e8 2f 08 00 00       	call   c040c136 <debug_lookup_symbol>
c040b907:	83 c4 10             	add    $0x10,%esp
c040b90a:	85 c0                	test   %eax,%eax
c040b90c:	75 2d                	jne    c040b93b <debug_stacktrace+0x1c8>
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
						  base, *(base), buffer, (*base) - sym_base);
c040b90e:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b912:	8b 10                	mov    (%eax),%edx
	while(base >= ptr)
	{
		/* look up a kernel symbol if relevant */
		if((*(base) >= KERNEL_VIRTUAL_BASE) && (*(base) < KERNEL_VIRTUAL_END))
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
c040b914:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040b918:	29 c2                	sub    %eax,%edx
c040b91a:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b91e:	8b 00                	mov    (%eax),%eax
c040b920:	83 ec 0c             	sub    $0xc,%esp
c040b923:	52                   	push   %edx
c040b924:	8d 54 24 1c          	lea    0x1c(%esp),%edx
c040b928:	52                   	push   %edx
c040b929:	50                   	push   %eax
c040b92a:	ff 74 24 4c          	pushl  0x4c(%esp)
c040b92e:	68 9c d5 40 c0       	push   $0xc040d59c
c040b933:	e8 4a 05 00 00       	call   c040be82 <debug_printf>
c040b938:	83 c4 20             	add    $0x20,%esp
						  base, *(base), buffer, (*base) - sym_base);
		base--;
c040b93b:	83 6c 24 34 04       	subl   $0x4,0x34(%esp)
	__asm__ __volatile__("movl %%esp, %0" : "=a" (ptr));
	
	dprintf("[debug:%i] kernel stack backtrace requested: base %p stackptr %p size %i (tid %i pid %i)\n",
			  CPU_ID, base, ptr, ((unsigned int)base - (unsigned int)ptr), tid, pid);

	while(base >= ptr)
c040b940:	8b 44 24 34          	mov    0x34(%esp),%eax
c040b944:	3b 44 24 30          	cmp    0x30(%esp),%eax
c040b948:	0f 83 71 ff ff ff    	jae    c040b8bf <debug_stacktrace+0x14c>
			if(debug_lookup_symbol(*(base), buffer, 32, &sym_base) == success)
				dprintf("        [0x%p]  0x%x [func %s + 0x%x]\n",
						  base, *(base), buffer, (*base) - sym_base);
		base--;
	}
	dprintf("\n");
c040b94e:	83 ec 0c             	sub    $0xc,%esp
c040b951:	68 c3 d5 40 c0       	push   $0xc040d5c3
c040b956:	e8 27 05 00 00       	call   c040be82 <debug_printf>
c040b95b:	83 c4 10             	add    $0x10,%esp
#endif
}
c040b95e:	83 c4 48             	add    $0x48,%esp
c040b961:	5b                   	pop    %ebx
c040b962:	c3                   	ret    

c040b963 <debug_assert>:

/* debug_assert
 Report an assert() failure and halt. Code taken from: 
 http://www.acm.uiuc.edu/sigops/roll_your_own/2.a.html */
void debug_assert(char *exp, char *file, char *basefile, unsigned int line)
{
c040b963:	83 ec 0c             	sub    $0xc,%esp
	debug_printf("[debug] assert(%s) failed in file %s (included from %s), line %d\n",
c040b966:	83 ec 0c             	sub    $0xc,%esp
c040b969:	ff 74 24 28          	pushl  0x28(%esp)
c040b96d:	ff 74 24 28          	pushl  0x28(%esp)
c040b971:	ff 74 24 28          	pushl  0x28(%esp)
c040b975:	ff 74 24 28          	pushl  0x28(%esp)
c040b979:	68 c8 d5 40 c0       	push   $0xc040d5c8
c040b97e:	e8 ff 04 00 00       	call   c040be82 <debug_printf>
c040b983:	83 c4 20             	add    $0x20,%esp
					 exp, file, basefile, line);
	debug_panic("assert() failed");
c040b986:	83 ec 0c             	sub    $0xc,%esp
c040b989:	68 0a d6 40 c0       	push   $0xc040d60a
c040b98e:	e8 07 00 00 00       	call   c040b99a <debug_panic>
c040b993:	83 c4 10             	add    $0x10,%esp
}
c040b996:	83 c4 0c             	add    $0xc,%esp
c040b999:	c3                   	ret    

c040b99a <debug_panic>:
/* debug_panic
   Report a kernel panic, and either recover, restart or halt
   => str = message to display
*/
void debug_panic(const char *str)
{
c040b99a:	83 ec 0c             	sub    $0xc,%esp
	dprintf("*** PANIC: %s -- halting\n");
c040b99d:	83 ec 0c             	sub    $0xc,%esp
c040b9a0:	68 1a d6 40 c0       	push   $0xc040d61a
c040b9a5:	e8 d8 04 00 00       	call   c040be82 <debug_printf>
c040b9aa:	83 c4 10             	add    $0x10,%esp
	
	x86_disable_interrupts();
c040b9ad:	e8 aa 54 ff ff       	call   c0400e5c <x86_disable_interrupts>
	while(1);
c040b9b2:	eb fe                	jmp    c040b9b2 <debug_panic+0x18>

c040b9b4 <strlen>:
   ANSI strlen() implementation
   => str = nul-terminated string to calculate length of
   <= number of characters
*/
unsigned int strlen(const unsigned char *str)
{
c040b9b4:	83 ec 10             	sub    $0x10,%esp
   unsigned int ret_val;

   for(ret_val = 0; *str != '\0'; str++)
c040b9b7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040b9be:	00 
c040b9bf:	eb 08                	jmp    c040b9c9 <strlen+0x15>
      ret_val++;
c040b9c1:	ff 44 24 0c          	incl   0xc(%esp)
*/
unsigned int strlen(const unsigned char *str)
{
   unsigned int ret_val;

   for(ret_val = 0; *str != '\0'; str++)
c040b9c5:	ff 44 24 14          	incl   0x14(%esp)
c040b9c9:	8b 44 24 14          	mov    0x14(%esp),%eax
c040b9cd:	8a 00                	mov    (%eax),%al
c040b9cf:	84 c0                	test   %al,%al
c040b9d1:	75 ee                	jne    c040b9c1 <strlen+0xd>
      ret_val++;
   return ret_val;
c040b9d3:	8b 44 24 0c          	mov    0xc(%esp),%eax
}
c040b9d7:	83 c4 10             	add    $0x10,%esp
c040b9da:	c3                   	ret    

c040b9db <debug_do_printf>:
      fn = function to call with arg 'ptr' for each character to be output
           ie: fn(character, ptr);
   <= total number of characters output
*/
static int debug_do_printf(const char *fmt, va_list args, fnptr_t fn, void *ptr)
{
c040b9db:	83 ec 4c             	sub    $0x4c,%esp
   unsigned state, flags, radix, actual_wd, count, given_wd;
   unsigned char *where, buf[PR_BUFLEN];
   long num;

   state = flags = count = given_wd = 0;
c040b9de:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040b9e5:	00 
c040b9e6:	8b 44 24 30          	mov    0x30(%esp),%eax
c040b9ea:	89 44 24 2c          	mov    %eax,0x2c(%esp)
c040b9ee:	8b 44 24 2c          	mov    0x2c(%esp),%eax
c040b9f2:	89 44 24 20          	mov    %eax,0x20(%esp)
c040b9f6:	8b 44 24 20          	mov    0x20(%esp),%eax
c040b9fa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
   /* begin scanning format specifier list */
   for(; *fmt; fmt++)
c040b9fe:	e9 69 04 00 00       	jmp    c040be6c <debug_do_printf+0x491>
   {
      switch(state)
c040ba03:	83 7c 24 1c 04       	cmpl   $0x4,0x1c(%esp)
c040ba08:	0f 87 3f 04 00 00    	ja     c040be4d <debug_do_printf+0x472>
c040ba0e:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040ba12:	c1 e0 02             	shl    $0x2,%eax
c040ba15:	8b 80 34 d6 40 c0    	mov    -0x3fbf29cc(%eax),%eax
c040ba1b:	ff e0                	jmp    *%eax
      {
         /* STATE 0: AWAITING % */
         case 0:
            if(*fmt != '%')     /* not %... */
c040ba1d:	8b 44 24 50          	mov    0x50(%esp),%eax
c040ba21:	8a 00                	mov    (%eax),%al
c040ba23:	3c 25                	cmp    $0x25,%al
c040ba25:	74 24                	je     c040ba4b <debug_do_printf+0x70>
            {
               fn(*fmt, &ptr);  /* ...just echo it */
c040ba27:	8b 44 24 50          	mov    0x50(%esp),%eax
c040ba2b:	8a 00                	mov    (%eax),%al
c040ba2d:	0f be c0             	movsbl %al,%eax
c040ba30:	83 ec 08             	sub    $0x8,%esp
c040ba33:	8d 54 24 64          	lea    0x64(%esp),%edx
c040ba37:	52                   	push   %edx
c040ba38:	50                   	push   %eax
c040ba39:	8b 44 24 68          	mov    0x68(%esp),%eax
c040ba3d:	ff d0                	call   *%eax
c040ba3f:	83 c4 10             	add    $0x10,%esp
               count++;
c040ba42:	ff 44 24 2c          	incl   0x2c(%esp)
               break;
c040ba46:	e9 1d 04 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }
            /* found %, get next char and advance state to check if
               next char is a flag */
            state++;
c040ba4b:	ff 44 24 1c          	incl   0x1c(%esp)
            fmt++;
c040ba4f:	ff 44 24 50          	incl   0x50(%esp)
            /* FALL THROUGH */

         /* STATE 1: AWAITING FLAGS (%-0) */
         case 1:
            if(*fmt == '%')     /* %% */
c040ba53:	8b 44 24 50          	mov    0x50(%esp),%eax
c040ba57:	8a 00                	mov    (%eax),%al
c040ba59:	3c 25                	cmp    $0x25,%al
c040ba5b:	75 3c                	jne    c040ba99 <debug_do_printf+0xbe>
            {
               fn(*fmt, &ptr);
c040ba5d:	8b 44 24 50          	mov    0x50(%esp),%eax
c040ba61:	8a 00                	mov    (%eax),%al
c040ba63:	0f be c0             	movsbl %al,%eax
c040ba66:	83 ec 08             	sub    $0x8,%esp
c040ba69:	8d 54 24 64          	lea    0x64(%esp),%edx
c040ba6d:	52                   	push   %edx
c040ba6e:	50                   	push   %eax
c040ba6f:	8b 44 24 68          	mov    0x68(%esp),%eax
c040ba73:	ff d0                	call   *%eax
c040ba75:	83 c4 10             	add    $0x10,%esp
               count++;
c040ba78:	ff 44 24 2c          	incl   0x2c(%esp)
               state = flags = given_wd = 0;
c040ba7c:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040ba83:	00 
c040ba84:	8b 44 24 30          	mov    0x30(%esp),%eax
c040ba88:	89 44 24 20          	mov    %eax,0x20(%esp)
c040ba8c:	8b 44 24 20          	mov    0x20(%esp),%eax
c040ba90:	89 44 24 1c          	mov    %eax,0x1c(%esp)
               break;
c040ba94:	e9 cf 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }
            if(*fmt == '-')
c040ba99:	8b 44 24 50          	mov    0x50(%esp),%eax
c040ba9d:	8a 00                	mov    (%eax),%al
c040ba9f:	3c 2d                	cmp    $0x2d,%al
c040baa1:	75 32                	jne    c040bad5 <debug_do_printf+0xfa>
            {
               if(flags & PR_LJ)/* %-- is illegal */
c040baa3:	8b 44 24 20          	mov    0x20(%esp),%eax
c040baa7:	83 e0 01             	and    $0x1,%eax
c040baaa:	84 c0                	test   %al,%al
c040baac:	74 1d                	je     c040bacb <debug_do_printf+0xf0>
                  state = flags = given_wd = 0;
c040baae:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040bab5:	00 
c040bab6:	8b 44 24 30          	mov    0x30(%esp),%eax
c040baba:	89 44 24 20          	mov    %eax,0x20(%esp)
c040babe:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bac2:	89 44 24 1c          	mov    %eax,0x1c(%esp)
               else
                  flags |= PR_LJ;
               break;
c040bac6:	e9 9d 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            if(*fmt == '-')
            {
               if(flags & PR_LJ)/* %-- is illegal */
                  state = flags = given_wd = 0;
               else
                  flags |= PR_LJ;
c040bacb:	83 4c 24 20 01       	orl    $0x1,0x20(%esp)
               break;
c040bad0:	e9 93 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }

            /* not a flag char: advance state to check if it's field width */
            state++;
c040bad5:	ff 44 24 1c          	incl   0x1c(%esp)

            /* check now for '%0...' */
            if(*fmt == '0')
c040bad9:	8b 44 24 50          	mov    0x50(%esp),%eax
c040badd:	8a 00                	mov    (%eax),%al
c040badf:	3c 30                	cmp    $0x30,%al
c040bae1:	75 09                	jne    c040baec <debug_do_printf+0x111>
            {
               flags |= PR_LZ;
c040bae3:	83 4c 24 20 40       	orl    $0x40,0x20(%esp)
               fmt++;
c040bae8:	ff 44 24 50          	incl   0x50(%esp)
            }
            /* FALL THROUGH */

         /* STATE 2: AWAITING (NUMERIC) FIELD WIDTH */
         case 2:
            if(*fmt >= '0' && *fmt <= '9')
c040baec:	8b 44 24 50          	mov    0x50(%esp),%eax
c040baf0:	8a 00                	mov    (%eax),%al
c040baf2:	3c 2f                	cmp    $0x2f,%al
c040baf4:	7e 31                	jle    c040bb27 <debug_do_printf+0x14c>
c040baf6:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bafa:	8a 00                	mov    (%eax),%al
c040bafc:	3c 39                	cmp    $0x39,%al
c040bafe:	7f 27                	jg     c040bb27 <debug_do_printf+0x14c>
            {
               given_wd = 10 * given_wd + (*fmt - '0');
c040bb00:	8b 54 24 30          	mov    0x30(%esp),%edx
c040bb04:	89 d0                	mov    %edx,%eax
c040bb06:	c1 e0 02             	shl    $0x2,%eax
c040bb09:	01 d0                	add    %edx,%eax
c040bb0b:	d1 e0                	shl    %eax
c040bb0d:	89 c2                	mov    %eax,%edx
c040bb0f:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb13:	8a 00                	mov    (%eax),%al
c040bb15:	0f be c0             	movsbl %al,%eax
c040bb18:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040bb1b:	83 e8 30             	sub    $0x30,%eax
c040bb1e:	89 44 24 30          	mov    %eax,0x30(%esp)
               break;
c040bb22:	e9 41 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }

            /* not field width: advance state to check if it's a modifier */
            state++;
c040bb27:	ff 44 24 1c          	incl   0x1c(%esp)

            /* FALL THROUGH */
         /* STATE 3: AWAITING MODIFIER CHARS (FNlh) */
         case 3:
            if(*fmt == 'F')
c040bb2b:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb2f:	8a 00                	mov    (%eax),%al
c040bb31:	3c 46                	cmp    $0x46,%al
c040bb33:	75 0d                	jne    c040bb42 <debug_do_printf+0x167>
            {
               flags |= PR_FP;
c040bb35:	81 4c 24 20 80 00 00 	orl    $0x80,0x20(%esp)
c040bb3c:	00 
               break;
c040bb3d:	e9 26 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }
            if(*fmt == 'N') break;
c040bb42:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb46:	8a 00                	mov    (%eax),%al
c040bb48:	3c 4e                	cmp    $0x4e,%al
c040bb4a:	0f 84 17 03 00 00    	je     c040be67 <debug_do_printf+0x48c>
            if(*fmt == 'l')
c040bb50:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb54:	8a 00                	mov    (%eax),%al
c040bb56:	3c 6c                	cmp    $0x6c,%al
c040bb58:	75 0a                	jne    c040bb64 <debug_do_printf+0x189>
            {
               flags |= PR_32;
c040bb5a:	83 4c 24 20 08       	orl    $0x8,0x20(%esp)
               break;
c040bb5f:	e9 04 03 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }
            if(*fmt == 'h')
c040bb64:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb68:	8a 00                	mov    (%eax),%al
c040bb6a:	3c 68                	cmp    $0x68,%al
c040bb6c:	75 0a                	jne    c040bb78 <debug_do_printf+0x19d>
            {
               flags |= PR_16;
c040bb6e:	83 4c 24 20 10       	orl    $0x10,0x20(%esp)
               break;
c040bb73:	e9 f0 02 00 00       	jmp    c040be68 <debug_do_printf+0x48d>
            }

            /* not modifier: advance state to check if it's a conversion char */
            state++;
c040bb78:	ff 44 24 1c          	incl   0x1c(%esp)
            /* FALL THROUGH */

         /* STATE 4: AWAITING CONVERSION CHARS (Xxpndiuocs) */
         case 4:
            where = buf + PR_BUFLEN - 1;
c040bb7c:	8d 44 24 0c          	lea    0xc(%esp),%eax
c040bb80:	83 c0 0f             	add    $0xf,%eax
c040bb83:	89 44 24 34          	mov    %eax,0x34(%esp)
            *where = '\0';
c040bb87:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bb8b:	c6 00 00             	movb   $0x0,(%eax)
            switch(*fmt)
c040bb8e:	8b 44 24 50          	mov    0x50(%esp),%eax
c040bb92:	8a 00                	mov    (%eax),%al
c040bb94:	0f be c0             	movsbl %al,%eax
c040bb97:	83 e8 58             	sub    $0x58,%eax
c040bb9a:	83 f8 20             	cmp    $0x20,%eax
c040bb9d:	0f 87 aa 02 00 00    	ja     c040be4d <debug_do_printf+0x472>
c040bba3:	8b 04 85 48 d6 40 c0 	mov    -0x3fbf29b8(,%eax,4),%eax
c040bbaa:	ff e0                	jmp    *%eax
            {
               case 'X':
                  flags |= PR_CA;
c040bbac:	83 4c 24 20 02       	orl    $0x2,0x20(%esp)
                  /* FALL THROUGH */
               /* xxx - far pointers (%Fp, %Fn) not yet supported */
               case 'x':
               case 'p':
               case 'n':
                  radix = 16;
c040bbb1:	c7 44 24 24 10 00 00 	movl   $0x10,0x24(%esp)
c040bbb8:	00 
                  goto DO_NUM;
c040bbb9:	eb 17                	jmp    c040bbd2 <debug_do_printf+0x1f7>
               case 'd':
               case 'i':
                  flags |= PR_SG;
c040bbbb:	83 4c 24 20 04       	orl    $0x4,0x20(%esp)
                  /* FALL THROUGH */
               case 'u':
                  radix = 10;
c040bbc0:	c7 44 24 24 0a 00 00 	movl   $0xa,0x24(%esp)
c040bbc7:	00 
                  goto DO_NUM;
c040bbc8:	eb 08                	jmp    c040bbd2 <debug_do_printf+0x1f7>
               case 'o':
                  radix = 8;
c040bbca:	c7 44 24 24 08 00 00 	movl   $0x8,0x24(%esp)
c040bbd1:	00 

/* load the value to be printed. l=long=32 bits: */
DO_NUM:          if(flags & PR_32)
c040bbd2:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bbd6:	83 e0 08             	and    $0x8,%eax
c040bbd9:	85 c0                	test   %eax,%eax
c040bbdb:	74 14                	je     c040bbf1 <debug_do_printf+0x216>
                     num = va_arg(args, unsigned long);
c040bbdd:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bbe2:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bbe6:	83 e8 04             	sub    $0x4,%eax
c040bbe9:	8b 00                	mov    (%eax),%eax
c040bbeb:	89 44 24 38          	mov    %eax,0x38(%esp)
c040bbef:	eb 75                	jmp    c040bc66 <debug_do_printf+0x28b>
                  /* h=short=16 bits (signed or unsigned) */
                  else
                     if(flags & PR_16)
c040bbf1:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bbf5:	83 e0 10             	and    $0x10,%eax
c040bbf8:	85 c0                	test   %eax,%eax
c040bbfa:	74 39                	je     c040bc35 <debug_do_printf+0x25a>
                     {
                        if(flags & PR_SG)
c040bbfc:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bc00:	83 e0 04             	and    $0x4,%eax
c040bc03:	85 c0                	test   %eax,%eax
c040bc05:	74 16                	je     c040bc1d <debug_do_printf+0x242>
                           num = va_arg(args, short);
c040bc07:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bc0c:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bc10:	83 e8 04             	sub    $0x4,%eax
c040bc13:	66 8b 00             	mov    (%eax),%ax
c040bc16:	98                   	cwtl   
c040bc17:	89 44 24 38          	mov    %eax,0x38(%esp)
                        else
                           num = va_arg(args, unsigned short);
c040bc1b:	eb 49                	jmp    c040bc66 <debug_do_printf+0x28b>
c040bc1d:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bc22:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bc26:	83 e8 04             	sub    $0x4,%eax
c040bc29:	66 8b 00             	mov    (%eax),%ax
c040bc2c:	0f b7 c0             	movzwl %ax,%eax
c040bc2f:	89 44 24 38          	mov    %eax,0x38(%esp)
c040bc33:	eb 31                	jmp    c040bc66 <debug_do_printf+0x28b>
                     }
                     /* no h nor l: sizeof(int) bits (signed or unsigned) */
                     else
                     {
                        if(flags & PR_SG)
c040bc35:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bc39:	83 e0 04             	and    $0x4,%eax
c040bc3c:	85 c0                	test   %eax,%eax
c040bc3e:	74 14                	je     c040bc54 <debug_do_printf+0x279>
                           num = va_arg(args, int);
c040bc40:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bc45:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bc49:	83 e8 04             	sub    $0x4,%eax
c040bc4c:	8b 00                	mov    (%eax),%eax
c040bc4e:	89 44 24 38          	mov    %eax,0x38(%esp)
c040bc52:	eb 12                	jmp    c040bc66 <debug_do_printf+0x28b>
                        else
                           num = va_arg(args, unsigned int);
c040bc54:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bc59:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bc5d:	83 e8 04             	sub    $0x4,%eax
c040bc60:	8b 00                	mov    (%eax),%eax
c040bc62:	89 44 24 38          	mov    %eax,0x38(%esp)
                     }
                     /* take care of sign */
                     if(flags & PR_SG)
c040bc66:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bc6a:	83 e0 04             	and    $0x4,%eax
c040bc6d:	85 c0                	test   %eax,%eax
c040bc6f:	74 10                	je     c040bc81 <debug_do_printf+0x2a6>
                     {
                        if(num < 0)
c040bc71:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c040bc76:	79 09                	jns    c040bc81 <debug_do_printf+0x2a6>
                        {
                           flags |= PR_WS;
c040bc78:	83 4c 24 20 20       	orl    $0x20,0x20(%esp)
                           num = -num;
c040bc7d:	f7 5c 24 38          	negl   0x38(%esp)
   OK, I found my mistake. The math here is _always_ unsigned */
                     do
                     {
                        unsigned long temp;
          
                        temp = (unsigned long)num % radix;
c040bc81:	8b 44 24 38          	mov    0x38(%esp),%eax
c040bc85:	ba 00 00 00 00       	mov    $0x0,%edx
c040bc8a:	f7 74 24 24          	divl   0x24(%esp)
c040bc8e:	89 54 24 3c          	mov    %edx,0x3c(%esp)
                        where--;
c040bc92:	ff 4c 24 34          	decl   0x34(%esp)
                        if(temp < 10)
c040bc96:	83 7c 24 3c 09       	cmpl   $0x9,0x3c(%esp)
c040bc9b:	77 0f                	ja     c040bcac <debug_do_printf+0x2d1>
                           *where = temp + '0';
c040bc9d:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040bca1:	8d 50 30             	lea    0x30(%eax),%edx
c040bca4:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bca8:	88 10                	mov    %dl,(%eax)
c040bcaa:	eb 27                	jmp    c040bcd3 <debug_do_printf+0x2f8>
                        else
                           if(flags & PR_CA)
c040bcac:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bcb0:	83 e0 02             	and    $0x2,%eax
c040bcb3:	85 c0                	test   %eax,%eax
c040bcb5:	74 0f                	je     c040bcc6 <debug_do_printf+0x2eb>
                              *where = temp - 10 + 'A';
c040bcb7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040bcbb:	8d 50 37             	lea    0x37(%eax),%edx
c040bcbe:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bcc2:	88 10                	mov    %dl,(%eax)
c040bcc4:	eb 0d                	jmp    c040bcd3 <debug_do_printf+0x2f8>
                           else
                              *where = temp - 10 + 'a';
c040bcc6:	8b 44 24 3c          	mov    0x3c(%esp),%eax
c040bcca:	8d 50 57             	lea    0x57(%eax),%edx
c040bccd:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bcd1:	88 10                	mov    %dl,(%eax)
                        num = (unsigned long)num / radix;
c040bcd3:	8b 44 24 38          	mov    0x38(%esp),%eax
c040bcd7:	ba 00 00 00 00       	mov    $0x0,%edx
c040bcdc:	f7 74 24 24          	divl   0x24(%esp)
c040bce0:	89 44 24 38          	mov    %eax,0x38(%esp)
                     }
                     while(num != 0);
c040bce4:	83 7c 24 38 00       	cmpl   $0x0,0x38(%esp)
c040bce9:	75 96                	jne    c040bc81 <debug_do_printf+0x2a6>
                     goto EMIT;
c040bceb:	eb 3e                	jmp    c040bd2b <debug_do_printf+0x350>

               case 'c':
/* disallow pad-left-with-zeroes for %c */
                  flags &= ~PR_LZ;
c040bced:	83 64 24 20 bf       	andl   $0xffffffbf,0x20(%esp)
                  where--;
c040bcf2:	ff 4c 24 34          	decl   0x34(%esp)
                  *where = (unsigned char)va_arg(args, unsigned char);
c040bcf6:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bcfb:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bcff:	83 e8 04             	sub    $0x4,%eax
c040bd02:	8a 10                	mov    (%eax),%dl
c040bd04:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bd08:	88 10                	mov    %dl,(%eax)
                  actual_wd = 1;
c040bd0a:	c7 44 24 28 01 00 00 	movl   $0x1,0x28(%esp)
c040bd11:	00 
                  goto EMIT2;
c040bd12:	eb 5c                	jmp    c040bd70 <debug_do_printf+0x395>

               case 's':
/* disallow pad-left-with-zeroes for %s */
                  flags &= ~PR_LZ;
c040bd14:	83 64 24 20 bf       	andl   $0xffffffbf,0x20(%esp)
                  where = va_arg(args, unsigned char *);
c040bd19:	83 44 24 54 04       	addl   $0x4,0x54(%esp)
c040bd1e:	8b 44 24 54          	mov    0x54(%esp),%eax
c040bd22:	83 e8 04             	sub    $0x4,%eax
c040bd25:	8b 00                	mov    (%eax),%eax
c040bd27:	89 44 24 34          	mov    %eax,0x34(%esp)

EMIT:
                  actual_wd = strlen(where);
c040bd2b:	83 ec 0c             	sub    $0xc,%esp
c040bd2e:	ff 74 24 40          	pushl  0x40(%esp)
c040bd32:	e8 7d fc ff ff       	call   c040b9b4 <strlen>
c040bd37:	83 c4 10             	add    $0x10,%esp
c040bd3a:	89 44 24 28          	mov    %eax,0x28(%esp)
                  if(flags & PR_WS)
c040bd3e:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bd42:	83 e0 20             	and    $0x20,%eax
c040bd45:	85 c0                	test   %eax,%eax
c040bd47:	74 04                	je     c040bd4d <debug_do_printf+0x372>
                     actual_wd++;
c040bd49:	ff 44 24 28          	incl   0x28(%esp)
/* if we pad left with ZEROES, do the sign now */
                  if((flags & (PR_WS | PR_LZ)) == (PR_WS | PR_LZ))
c040bd4d:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bd51:	83 e0 60             	and    $0x60,%eax
c040bd54:	83 f8 60             	cmp    $0x60,%eax
c040bd57:	75 17                	jne    c040bd70 <debug_do_printf+0x395>
                  {
                     fn('-', &ptr);
c040bd59:	83 ec 08             	sub    $0x8,%esp
c040bd5c:	8d 44 24 64          	lea    0x64(%esp),%eax
c040bd60:	50                   	push   %eax
c040bd61:	6a 2d                	push   $0x2d
c040bd63:	8b 44 24 68          	mov    0x68(%esp),%eax
c040bd67:	ff d0                	call   *%eax
c040bd69:	83 c4 10             	add    $0x10,%esp
                     count++;
c040bd6c:	ff 44 24 2c          	incl   0x2c(%esp)
                  }
/* pad on left with spaces or zeroes (for right justify) */
EMIT2:            if((flags & PR_LJ) == 0)
c040bd70:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bd74:	83 e0 01             	and    $0x1,%eax
c040bd77:	85 c0                	test   %eax,%eax
c040bd79:	75 3d                	jne    c040bdb8 <debug_do_printf+0x3dd>
                  {
                     while(given_wd > actual_wd)
c040bd7b:	eb 31                	jmp    c040bdae <debug_do_printf+0x3d3>
                     {
                        fn(flags & PR_LZ ? '0' : ' ', &ptr);
c040bd7d:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bd81:	83 e0 40             	and    $0x40,%eax
c040bd84:	85 c0                	test   %eax,%eax
c040bd86:	74 07                	je     c040bd8f <debug_do_printf+0x3b4>
c040bd88:	b8 30 00 00 00       	mov    $0x30,%eax
c040bd8d:	eb 05                	jmp    c040bd94 <debug_do_printf+0x3b9>
c040bd8f:	b8 20 00 00 00       	mov    $0x20,%eax
c040bd94:	83 ec 08             	sub    $0x8,%esp
c040bd97:	8d 54 24 64          	lea    0x64(%esp),%edx
c040bd9b:	52                   	push   %edx
c040bd9c:	50                   	push   %eax
c040bd9d:	8b 44 24 68          	mov    0x68(%esp),%eax
c040bda1:	ff d0                	call   *%eax
c040bda3:	83 c4 10             	add    $0x10,%esp
                        count++;
c040bda6:	ff 44 24 2c          	incl   0x2c(%esp)
                        given_wd--;
c040bdaa:	ff 4c 24 30          	decl   0x30(%esp)
                     count++;
                  }
/* pad on left with spaces or zeroes (for right justify) */
EMIT2:            if((flags & PR_LJ) == 0)
                  {
                     while(given_wd > actual_wd)
c040bdae:	8b 44 24 30          	mov    0x30(%esp),%eax
c040bdb2:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040bdb6:	77 c5                	ja     c040bd7d <debug_do_printf+0x3a2>
                        count++;
                        given_wd--;
                     }
                  }
/* if we pad left with SPACES, do the sign now */
                  if((flags & (PR_WS | PR_LZ)) == PR_WS)
c040bdb8:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bdbc:	83 e0 60             	and    $0x60,%eax
c040bdbf:	83 f8 20             	cmp    $0x20,%eax
c040bdc2:	75 3e                	jne    c040be02 <debug_do_printf+0x427>
                  {
                     fn('-', &ptr);
c040bdc4:	83 ec 08             	sub    $0x8,%esp
c040bdc7:	8d 44 24 64          	lea    0x64(%esp),%eax
c040bdcb:	50                   	push   %eax
c040bdcc:	6a 2d                	push   $0x2d
c040bdce:	8b 44 24 68          	mov    0x68(%esp),%eax
c040bdd2:	ff d0                	call   *%eax
c040bdd4:	83 c4 10             	add    $0x10,%esp
                     count++;
c040bdd7:	ff 44 24 2c          	incl   0x2c(%esp)
                  }
/* emit string/char/converted number */
                  while(*where != '\0')
c040bddb:	eb 26                	jmp    c040be03 <debug_do_printf+0x428>
                  {
                     fn(*where++, &ptr);
c040bddd:	8b 44 24 34          	mov    0x34(%esp),%eax
c040bde1:	8a 00                	mov    (%eax),%al
c040bde3:	0f b6 c0             	movzbl %al,%eax
c040bde6:	ff 44 24 34          	incl   0x34(%esp)
c040bdea:	83 ec 08             	sub    $0x8,%esp
c040bded:	8d 54 24 64          	lea    0x64(%esp),%edx
c040bdf1:	52                   	push   %edx
c040bdf2:	50                   	push   %eax
c040bdf3:	8b 44 24 68          	mov    0x68(%esp),%eax
c040bdf7:	ff d0                	call   *%eax
c040bdf9:	83 c4 10             	add    $0x10,%esp
                     count++;
c040bdfc:	ff 44 24 2c          	incl   0x2c(%esp)
c040be00:	eb 01                	jmp    c040be03 <debug_do_printf+0x428>
                  {
                     fn('-', &ptr);
                     count++;
                  }
/* emit string/char/converted number */
                  while(*where != '\0')
c040be02:	90                   	nop
c040be03:	8b 44 24 34          	mov    0x34(%esp),%eax
c040be07:	8a 00                	mov    (%eax),%al
c040be09:	84 c0                	test   %al,%al
c040be0b:	75 d0                	jne    c040bddd <debug_do_printf+0x402>
                  {
                     fn(*where++, &ptr);
                     count++;
                  }
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
c040be0d:	8b 44 24 30          	mov    0x30(%esp),%eax
c040be11:	3b 44 24 28          	cmp    0x28(%esp),%eax
c040be15:	73 0a                	jae    c040be21 <debug_do_printf+0x446>
                     given_wd = 0;
c040be17:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040be1e:	00 
                  else
                     given_wd -= actual_wd;
                  for(; given_wd; given_wd--)
c040be1f:	eb 25                	jmp    c040be46 <debug_do_printf+0x46b>
                  }
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
                     given_wd = 0;
                  else
                     given_wd -= actual_wd;
c040be21:	8b 44 24 28          	mov    0x28(%esp),%eax
c040be25:	29 44 24 30          	sub    %eax,0x30(%esp)
                  for(; given_wd; given_wd--)
c040be29:	eb 1b                	jmp    c040be46 <debug_do_printf+0x46b>
                  {
                     fn(' ', &ptr);
c040be2b:	83 ec 08             	sub    $0x8,%esp
c040be2e:	8d 44 24 64          	lea    0x64(%esp),%eax
c040be32:	50                   	push   %eax
c040be33:	6a 20                	push   $0x20
c040be35:	8b 44 24 68          	mov    0x68(%esp),%eax
c040be39:	ff d0                	call   *%eax
c040be3b:	83 c4 10             	add    $0x10,%esp
                     count++;
c040be3e:	ff 44 24 2c          	incl   0x2c(%esp)
/* pad on right with spaces (for left justify) */
                  if(given_wd < actual_wd)
                     given_wd = 0;
                  else
                     given_wd -= actual_wd;
                  for(; given_wd; given_wd--)
c040be42:	ff 4c 24 30          	decl   0x30(%esp)
c040be46:	83 7c 24 30 00       	cmpl   $0x0,0x30(%esp)
c040be4b:	75 de                	jne    c040be2b <debug_do_printf+0x450>
               default:
                  break;
            }

            default:
               state = flags = given_wd = 0;
c040be4d:	c7 44 24 30 00 00 00 	movl   $0x0,0x30(%esp)
c040be54:	00 
c040be55:	8b 44 24 30          	mov    0x30(%esp),%eax
c040be59:	89 44 24 20          	mov    %eax,0x20(%esp)
c040be5d:	8b 44 24 20          	mov    0x20(%esp),%eax
c040be61:	89 44 24 1c          	mov    %eax,0x1c(%esp)
c040be65:	eb 01                	jmp    c040be68 <debug_do_printf+0x48d>
            if(*fmt == 'F')
            {
               flags |= PR_FP;
               break;
            }
            if(*fmt == 'N') break;
c040be67:	90                   	nop
   unsigned char *where, buf[PR_BUFLEN];
   long num;

   state = flags = count = given_wd = 0;
   /* begin scanning format specifier list */
   for(; *fmt; fmt++)
c040be68:	ff 44 24 50          	incl   0x50(%esp)
c040be6c:	8b 44 24 50          	mov    0x50(%esp),%eax
c040be70:	8a 00                	mov    (%eax),%al
c040be72:	84 c0                	test   %al,%al
c040be74:	0f 85 89 fb ff ff    	jne    c040ba03 <debug_do_printf+0x28>
               state = flags = given_wd = 0;
               break;
         }
      }

   return count;
c040be7a:	8b 44 24 2c          	mov    0x2c(%esp),%eax
}
c040be7e:	83 c4 4c             	add    $0x4c,%esp
c040be81:	c3                   	ret    

c040be82 <debug_printf>:
   Output a formatted string to the user via the kernel's serial channel
   => as per ANSI C's printf()
   <= none
*/
void debug_printf(const char *fmt, ...)
{
c040be82:	83 ec 1c             	sub    $0x1c,%esp
   va_list args;

	/* gain exclusive access to the debug output stream */
	lock_spin(&debug_spinlock);
c040be85:	83 ec 0c             	sub    $0xc,%esp
c040be88:	68 2c 1d 41 c0       	push   $0xc0411d2c
c040be8d:	e8 ce 45 ff ff       	call   c0400460 <lock_spin>
c040be92:	83 c4 10             	add    $0x10,%esp
	
   va_start(args, fmt);
c040be95:	8d 44 24 20          	lea    0x20(%esp),%eax
c040be99:	83 c0 04             	add    $0x4,%eax
c040be9c:	89 44 24 0c          	mov    %eax,0xc(%esp)
   (void)debug_do_printf(fmt, args, debug_writebyte, NULL);
c040bea0:	8b 44 24 20          	mov    0x20(%esp),%eax
c040bea4:	6a 00                	push   $0x0
c040bea6:	68 54 b7 40 c0       	push   $0xc040b754
c040beab:	ff 74 24 14          	pushl  0x14(%esp)
c040beaf:	50                   	push   %eax
c040beb0:	e8 26 fb ff ff       	call   c040b9db <debug_do_printf>
c040beb5:	83 c4 10             	add    $0x10,%esp
   va_end(args);
	
	/* release the debug output stream */
	unlock_spin(&debug_spinlock);
c040beb8:	83 ec 0c             	sub    $0xc,%esp
c040bebb:	68 2c 1d 41 c0       	push   $0xc0411d2c
c040bec0:	e8 c8 45 ff ff       	call   c040048d <unlock_spin>
c040bec5:	83 c4 10             	add    $0x10,%esp
}
c040bec8:	83 c4 1c             	add    $0x1c,%esp
c040becb:	c3                   	ret    

c040becc <debug_init_sym_table>:
      end = pointer to the end of the symbol table in memory
   <= success or an error code
*/
kresult debug_init_sym_table(char *table, char *end)
{	
	debug_sym_tbl_start = table;
c040becc:	8b 44 24 04          	mov    0x4(%esp),%eax
c040bed0:	a3 30 1d 41 c0       	mov    %eax,0xc0411d30
	debug_sym_tbl_end = end;
c040bed5:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bed9:	a3 34 1d 41 c0       	mov    %eax,0xc0411d34

	return success;
c040bede:	b8 00 00 00 00       	mov    $0x0,%eax
}
c040bee3:	c3                   	ret    

c040bee4 <debug_ascii2uint>:
            this pointer is updated to point to the end of the string
		base = 10 for unsigned decimal text or 16 for unsigned hex text
   <= converted unsigned int
*/
unsigned int debug_ascii2uint(char **str, unsigned char base)
{
c040bee4:	83 ec 14             	sub    $0x14,%esp
c040bee7:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040beeb:	88 04 24             	mov    %al,(%esp)
	unsigned int value = 0, power = 1;
c040beee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
c040bef5:	00 
c040bef6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
c040befd:	00 
	char *ptr = *str;
c040befe:	8b 44 24 18          	mov    0x18(%esp),%eax
c040bf02:	8b 00                	mov    (%eax),%eax
c040bf04:	89 44 24 0c          	mov    %eax,0xc(%esp)
	char *start = *str;
c040bf08:	8b 44 24 18          	mov    0x18(%esp),%eax
c040bf0c:	8b 00                	mov    (%eax),%eax
c040bf0e:	89 44 24 10          	mov    %eax,0x10(%esp)
	
	/* skip to the end of the string */
	while(*ptr != ' ')
c040bf12:	eb 04                	jmp    c040bf18 <debug_ascii2uint+0x34>
		ptr++;
c040bf14:	ff 44 24 0c          	incl   0xc(%esp)
	unsigned int value = 0, power = 1;
	char *ptr = *str;
	char *start = *str;
	
	/* skip to the end of the string */
	while(*ptr != ' ')
c040bf18:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040bf1c:	8a 00                	mov    (%eax),%al
c040bf1e:	3c 20                	cmp    $0x20,%al
c040bf20:	75 f2                	jne    c040bf14 <debug_ascii2uint+0x30>
		ptr++;

	/* update the pointer to the end of the string */
	*str = ptr;
c040bf22:	8b 44 24 18          	mov    0x18(%esp),%eax
c040bf26:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040bf2a:	89 10                	mov    %edx,(%eax)

	ptr--; /* reverse over the space terminator */
c040bf2c:	ff 4c 24 0c          	decl   0xc(%esp)
	
	/* now work our way back through the string... */
	while((unsigned int)ptr >= (unsigned int)start)
c040bf30:	e9 e9 01 00 00       	jmp    c040c11e <debug_ascii2uint+0x23a>
	{
		/* ...converting the digits */
		switch(*ptr)
c040bf35:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040bf39:	8a 00                	mov    (%eax),%al
c040bf3b:	0f be c0             	movsbl %al,%eax
c040bf3e:	83 e8 30             	sub    $0x30,%eax
c040bf41:	83 f8 36             	cmp    $0x36,%eax
c040bf44:	0f 87 c1 01 00 00    	ja     c040c10b <debug_ascii2uint+0x227>
c040bf4a:	8b 04 85 cc d6 40 c0 	mov    -0x3fbf2934(,%eax,4),%eax
c040bf51:	ff e0                	jmp    *%eax
		{
			case '0': value = value + (0 * power); break;
			case '1': value = value + (1 * power); break;
c040bf53:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bf57:	01 44 24 04          	add    %eax,0x4(%esp)
c040bf5b:	e9 ab 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '2': value = value + (2 * power); break;
c040bf60:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bf64:	d1 e0                	shl    %eax
c040bf66:	01 44 24 04          	add    %eax,0x4(%esp)
c040bf6a:	e9 9c 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '3': value = value + (3 * power); break;
c040bf6f:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bf73:	89 d0                	mov    %edx,%eax
c040bf75:	d1 e0                	shl    %eax
c040bf77:	01 d0                	add    %edx,%eax
c040bf79:	01 44 24 04          	add    %eax,0x4(%esp)
c040bf7d:	e9 89 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '4': value = value + (4 * power); break;
c040bf82:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bf86:	c1 e0 02             	shl    $0x2,%eax
c040bf89:	01 44 24 04          	add    %eax,0x4(%esp)
c040bf8d:	e9 79 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '5': value = value + (5 * power); break;
c040bf92:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bf96:	89 d0                	mov    %edx,%eax
c040bf98:	c1 e0 02             	shl    $0x2,%eax
c040bf9b:	01 d0                	add    %edx,%eax
c040bf9d:	01 44 24 04          	add    %eax,0x4(%esp)
c040bfa1:	e9 65 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '6': value = value + (6 * power); break;
c040bfa6:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bfaa:	89 d0                	mov    %edx,%eax
c040bfac:	d1 e0                	shl    %eax
c040bfae:	01 d0                	add    %edx,%eax
c040bfb0:	d1 e0                	shl    %eax
c040bfb2:	01 44 24 04          	add    %eax,0x4(%esp)
c040bfb6:	e9 50 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '7': value = value + (7 * power); break;
c040bfbb:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bfbf:	89 c2                	mov    %eax,%edx
c040bfc1:	c1 e2 03             	shl    $0x3,%edx
c040bfc4:	89 d1                	mov    %edx,%ecx
c040bfc6:	29 c1                	sub    %eax,%ecx
c040bfc8:	89 c8                	mov    %ecx,%eax
c040bfca:	01 44 24 04          	add    %eax,0x4(%esp)
c040bfce:	e9 38 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '8': value = value + (8 * power); break;
c040bfd3:	8b 44 24 08          	mov    0x8(%esp),%eax
c040bfd7:	c1 e0 03             	shl    $0x3,%eax
c040bfda:	01 44 24 04          	add    %eax,0x4(%esp)
c040bfde:	e9 28 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case '9': value = value + (9 * power); break;
c040bfe3:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bfe7:	89 d0                	mov    %edx,%eax
c040bfe9:	c1 e0 03             	shl    $0x3,%eax
c040bfec:	01 d0                	add    %edx,%eax
c040bfee:	01 44 24 04          	add    %eax,0x4(%esp)
c040bff2:	e9 14 01 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			/* uppercase hex codes */
			case 'A': value = value + (10 * power); break;
c040bff7:	8b 54 24 08          	mov    0x8(%esp),%edx
c040bffb:	89 d0                	mov    %edx,%eax
c040bffd:	c1 e0 02             	shl    $0x2,%eax
c040c000:	01 d0                	add    %edx,%eax
c040c002:	d1 e0                	shl    %eax
c040c004:	01 44 24 04          	add    %eax,0x4(%esp)
c040c008:	e9 fe 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'B': value = value + (11 * power); break;
c040c00d:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c011:	89 d0                	mov    %edx,%eax
c040c013:	c1 e0 02             	shl    $0x2,%eax
c040c016:	01 d0                	add    %edx,%eax
c040c018:	d1 e0                	shl    %eax
c040c01a:	01 d0                	add    %edx,%eax
c040c01c:	01 44 24 04          	add    %eax,0x4(%esp)
c040c020:	e9 e6 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'C': value = value + (12 * power); break;
c040c025:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c029:	89 d0                	mov    %edx,%eax
c040c02b:	d1 e0                	shl    %eax
c040c02d:	01 d0                	add    %edx,%eax
c040c02f:	c1 e0 02             	shl    $0x2,%eax
c040c032:	01 44 24 04          	add    %eax,0x4(%esp)
c040c036:	e9 d0 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'D': value = value + (13 * power); break;
c040c03b:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c03f:	89 d0                	mov    %edx,%eax
c040c041:	d1 e0                	shl    %eax
c040c043:	01 d0                	add    %edx,%eax
c040c045:	c1 e0 02             	shl    $0x2,%eax
c040c048:	01 d0                	add    %edx,%eax
c040c04a:	01 44 24 04          	add    %eax,0x4(%esp)
c040c04e:	e9 b8 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'E': value = value + (14 * power); break;
c040c053:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c057:	d1 e0                	shl    %eax
c040c059:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c040c060:	89 d1                	mov    %edx,%ecx
c040c062:	29 c1                	sub    %eax,%ecx
c040c064:	89 c8                	mov    %ecx,%eax
c040c066:	01 44 24 04          	add    %eax,0x4(%esp)
c040c06a:	e9 9c 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'F': value = value + (15 * power); break;
c040c06f:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c073:	89 d0                	mov    %edx,%eax
c040c075:	d1 e0                	shl    %eax
c040c077:	01 d0                	add    %edx,%eax
c040c079:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040c080:	01 d0                	add    %edx,%eax
c040c082:	01 44 24 04          	add    %eax,0x4(%esp)
c040c086:	e9 80 00 00 00       	jmp    c040c10b <debug_ascii2uint+0x227>
			/* lowercase hex codes */
			case 'a': value = value + (10 * power); break;
c040c08b:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c08f:	89 d0                	mov    %edx,%eax
c040c091:	c1 e0 02             	shl    $0x2,%eax
c040c094:	01 d0                	add    %edx,%eax
c040c096:	d1 e0                	shl    %eax
c040c098:	01 44 24 04          	add    %eax,0x4(%esp)
c040c09c:	eb 6d                	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'b': value = value + (11 * power); break;
c040c09e:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c0a2:	89 d0                	mov    %edx,%eax
c040c0a4:	c1 e0 02             	shl    $0x2,%eax
c040c0a7:	01 d0                	add    %edx,%eax
c040c0a9:	d1 e0                	shl    %eax
c040c0ab:	01 d0                	add    %edx,%eax
c040c0ad:	01 44 24 04          	add    %eax,0x4(%esp)
c040c0b1:	eb 58                	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'c': value = value + (12 * power); break;
c040c0b3:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c0b7:	89 d0                	mov    %edx,%eax
c040c0b9:	d1 e0                	shl    %eax
c040c0bb:	01 d0                	add    %edx,%eax
c040c0bd:	c1 e0 02             	shl    $0x2,%eax
c040c0c0:	01 44 24 04          	add    %eax,0x4(%esp)
c040c0c4:	eb 45                	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'd': value = value + (13 * power); break;
c040c0c6:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c0ca:	89 d0                	mov    %edx,%eax
c040c0cc:	d1 e0                	shl    %eax
c040c0ce:	01 d0                	add    %edx,%eax
c040c0d0:	c1 e0 02             	shl    $0x2,%eax
c040c0d3:	01 d0                	add    %edx,%eax
c040c0d5:	01 44 24 04          	add    %eax,0x4(%esp)
c040c0d9:	eb 30                	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'e': value = value + (14 * power); break;
c040c0db:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c0df:	d1 e0                	shl    %eax
c040c0e1:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c040c0e8:	89 d1                	mov    %edx,%ecx
c040c0ea:	29 c1                	sub    %eax,%ecx
c040c0ec:	89 c8                	mov    %ecx,%eax
c040c0ee:	01 44 24 04          	add    %eax,0x4(%esp)
c040c0f2:	eb 17                	jmp    c040c10b <debug_ascii2uint+0x227>
			case 'f': value = value + (15 * power); break;
c040c0f4:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c0f8:	89 d0                	mov    %edx,%eax
c040c0fa:	d1 e0                	shl    %eax
c040c0fc:	01 d0                	add    %edx,%eax
c040c0fe:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c040c105:	01 d0                	add    %edx,%eax
c040c107:	01 44 24 04          	add    %eax,0x4(%esp)
		}

		ptr--;
c040c10b:	ff 4c 24 0c          	decl   0xc(%esp)
		power = power * base;
c040c10f:	0f b6 04 24          	movzbl (%esp),%eax
c040c113:	8b 54 24 08          	mov    0x8(%esp),%edx
c040c117:	0f af c2             	imul   %edx,%eax
c040c11a:	89 44 24 08          	mov    %eax,0x8(%esp)
	*str = ptr;

	ptr--; /* reverse over the space terminator */
	
	/* now work our way back through the string... */
	while((unsigned int)ptr >= (unsigned int)start)
c040c11e:	8b 54 24 0c          	mov    0xc(%esp),%edx
c040c122:	8b 44 24 10          	mov    0x10(%esp),%eax
c040c126:	39 c2                	cmp    %eax,%edx
c040c128:	0f 83 07 fe ff ff    	jae    c040bf35 <debug_ascii2uint+0x51>

		ptr--;
		power = power * base;
	}
	
	return value;
c040c12e:	8b 44 24 04          	mov    0x4(%esp),%eax
}
c040c132:	83 c4 14             	add    $0x14,%esp
c040c135:	c3                   	ret    

c040c136 <debug_lookup_symbol>:
      size = buffer size in bytes
      symbol = pointer to word to write in base address of found symbol
   <= success or a failure code
*/
kresult debug_lookup_symbol(unsigned int addr, char *buffer, unsigned int size, unsigned int *symbol)
{
c040c136:	83 ec 10             	sub    $0x10,%esp
	/* give up now if we don't have a symbol table */
	if(!debug_sym_tbl_start || !debug_sym_tbl_end) return e_not_found;
c040c139:	a1 30 1d 41 c0       	mov    0xc0411d30,%eax
c040c13e:	85 c0                	test   %eax,%eax
c040c140:	74 09                	je     c040c14b <debug_lookup_symbol+0x15>
c040c142:	a1 34 1d 41 c0       	mov    0xc0411d34,%eax
c040c147:	85 c0                	test   %eax,%eax
c040c149:	75 0a                	jne    c040c155 <debug_lookup_symbol+0x1f>
c040c14b:	b8 02 00 00 00       	mov    $0x2,%eax
c040c150:	e9 e7 00 00 00       	jmp    c040c23c <debug_lookup_symbol+0x106>
	
	char *ptr = debug_sym_tbl_start;
c040c155:	a1 30 1d 41 c0       	mov    0xc0411d30,%eax
c040c15a:	89 04 24             	mov    %eax,(%esp)
	unsigned int sym_addr, sym_size;
	
	KSYM_DEBUG("[debug:%i] looking up symbol for %x\n", CPU_ID, addr);
	
	/* attempt to parse a line in the symbol file - rather brute force */
	while(ptr < debug_sym_tbl_end)
c040c15d:	e9 c5 00 00 00       	jmp    c040c227 <debug_lookup_symbol+0xf1>
	{
		/* convert values, remembering to jump over space seperator */
		sym_addr = debug_ascii2uint(&ptr, 16); ptr++;
c040c162:	6a 10                	push   $0x10
c040c164:	8d 44 24 04          	lea    0x4(%esp),%eax
c040c168:	50                   	push   %eax
c040c169:	e8 76 fd ff ff       	call   c040bee4 <debug_ascii2uint>
c040c16e:	83 c4 08             	add    $0x8,%esp
c040c171:	89 44 24 04          	mov    %eax,0x4(%esp)
c040c175:	8b 04 24             	mov    (%esp),%eax
c040c178:	40                   	inc    %eax
c040c179:	89 04 24             	mov    %eax,(%esp)
		sym_size = debug_ascii2uint(&ptr, 10); ptr++;
c040c17c:	6a 0a                	push   $0xa
c040c17e:	8d 44 24 04          	lea    0x4(%esp),%eax
c040c182:	50                   	push   %eax
c040c183:	e8 5c fd ff ff       	call   c040bee4 <debug_ascii2uint>
c040c188:	83 c4 08             	add    $0x8,%esp
c040c18b:	89 44 24 08          	mov    %eax,0x8(%esp)
c040c18f:	8b 04 24             	mov    (%esp),%eax
c040c192:	40                   	inc    %eax
c040c193:	89 04 24             	mov    %eax,(%esp)
		
		KSYM_DEBUG("[debug:%i] found a symbol for %x size %i\n", CPU_ID, sym_addr, sym_size);
		
		/* look for an address match */
		if(addr >= sym_addr && addr < (sym_addr + sym_size))
c040c196:	8b 44 24 14          	mov    0x14(%esp),%eax
c040c19a:	3b 44 24 04          	cmp    0x4(%esp),%eax
c040c19e:	72 73                	jb     c040c213 <debug_lookup_symbol+0xdd>
c040c1a0:	8b 44 24 08          	mov    0x8(%esp),%eax
c040c1a4:	8b 54 24 04          	mov    0x4(%esp),%edx
c040c1a8:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040c1ab:	3b 44 24 14          	cmp    0x14(%esp),%eax
c040c1af:	76 65                	jbe    c040c216 <debug_lookup_symbol+0xe0>
		{
			/* copy the symbol string into the buffer */
			unsigned int loop = 0;
c040c1b1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
c040c1b8:	00 
			
			while(*ptr != '\n' && loop < (size - sizeof(char)))
c040c1b9:	eb 1c                	jmp    c040c1d7 <debug_lookup_symbol+0xa1>
			{
				buffer[loop] = *ptr;
c040c1bb:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c1bf:	8b 54 24 18          	mov    0x18(%esp),%edx
c040c1c3:	01 c2                	add    %eax,%edx
c040c1c5:	8b 04 24             	mov    (%esp),%eax
c040c1c8:	8a 00                	mov    (%eax),%al
c040c1ca:	88 02                	mov    %al,(%edx)
				loop++;
c040c1cc:	ff 44 24 0c          	incl   0xc(%esp)
				ptr++;
c040c1d0:	8b 04 24             	mov    (%esp),%eax
c040c1d3:	40                   	inc    %eax
c040c1d4:	89 04 24             	mov    %eax,(%esp)
		if(addr >= sym_addr && addr < (sym_addr + sym_size))
		{
			/* copy the symbol string into the buffer */
			unsigned int loop = 0;
			
			while(*ptr != '\n' && loop < (size - sizeof(char)))
c040c1d7:	8b 04 24             	mov    (%esp),%eax
c040c1da:	8a 00                	mov    (%eax),%al
c040c1dc:	3c 0a                	cmp    $0xa,%al
c040c1de:	74 0b                	je     c040c1eb <debug_lookup_symbol+0xb5>
c040c1e0:	8b 44 24 1c          	mov    0x1c(%esp),%eax
c040c1e4:	48                   	dec    %eax
c040c1e5:	3b 44 24 0c          	cmp    0xc(%esp),%eax
c040c1e9:	77 d0                	ja     c040c1bb <debug_lookup_symbol+0x85>
				loop++;
				ptr++;
			}
			
			/* write in the sym base address, terminate the string and get out of here */
			*symbol = sym_addr;
c040c1eb:	8b 44 24 20          	mov    0x20(%esp),%eax
c040c1ef:	8b 54 24 04          	mov    0x4(%esp),%edx
c040c1f3:	89 10                	mov    %edx,(%eax)
			buffer[loop] = NULL;
c040c1f5:	8b 44 24 0c          	mov    0xc(%esp),%eax
c040c1f9:	8b 54 24 18          	mov    0x18(%esp),%edx
c040c1fd:	8d 04 02             	lea    (%edx,%eax,1),%eax
c040c200:	c6 00 00             	movb   $0x0,(%eax)
			return success;
c040c203:	b8 00 00 00 00       	mov    $0x0,%eax
c040c208:	eb 32                	jmp    c040c23c <debug_lookup_symbol+0x106>
		}
		
		/* skip to the end of the line */
		while(*ptr != '\n') ptr++;
c040c20a:	8b 04 24             	mov    (%esp),%eax
c040c20d:	40                   	inc    %eax
c040c20e:	89 04 24             	mov    %eax,(%esp)
c040c211:	eb 04                	jmp    c040c217 <debug_lookup_symbol+0xe1>
c040c213:	90                   	nop
c040c214:	eb 01                	jmp    c040c217 <debug_lookup_symbol+0xe1>
c040c216:	90                   	nop
c040c217:	8b 04 24             	mov    (%esp),%eax
c040c21a:	8a 00                	mov    (%eax),%al
c040c21c:	3c 0a                	cmp    $0xa,%al
c040c21e:	75 ea                	jne    c040c20a <debug_lookup_symbol+0xd4>
		ptr++; /* skip over the newline terminator */
c040c220:	8b 04 24             	mov    (%esp),%eax
c040c223:	40                   	inc    %eax
c040c224:	89 04 24             	mov    %eax,(%esp)
	unsigned int sym_addr, sym_size;
	
	KSYM_DEBUG("[debug:%i] looking up symbol for %x\n", CPU_ID, addr);
	
	/* attempt to parse a line in the symbol file - rather brute force */
	while(ptr < debug_sym_tbl_end)
c040c227:	8b 14 24             	mov    (%esp),%edx
c040c22a:	a1 34 1d 41 c0       	mov    0xc0411d34,%eax
c040c22f:	39 c2                	cmp    %eax,%edx
c040c231:	0f 82 2b ff ff ff    	jb     c040c162 <debug_lookup_symbol+0x2c>
		while(*ptr != '\n') ptr++;
		ptr++; /* skip over the newline terminator */
	}
	
	/* fail if we're still here */
	return e_failure;
c040c237:	b8 01 00 00 00       	mov    $0x1,%eax
}
c040c23c:	83 c4 10             	add    $0x10,%esp
c040c23f:	c3                   	ret    

c040c240 <debug_initialise>:

/* debug_initialise
   The kernel wants to do some low level debugging. By default, the i386 port
   uses the first IBM PC serial port. */
void debug_initialise(void)
{
c040c240:	83 ec 0c             	sub    $0xc,%esp
#ifdef DEBUG
   serial_initialise(); /* port-specific */
c040c243:	e8 98 f4 ff ff       	call   c040b6e0 <serial_initialise>
	
   /* can I get a witness? */
   dprintf("[core] Now debugging to serial port.\n");
c040c248:	83 ec 0c             	sub    $0xc,%esp
c040c24b:	68 a8 d7 40 c0       	push   $0xc040d7a8
c040c250:	e8 2d fc ff ff       	call   c040be82 <debug_printf>
c040c255:	83 c4 10             	add    $0x10,%esp
#endif
}
c040c258:	83 c4 0c             	add    $0xc,%esp
c040c25b:	c3                   	ret    
c040c25c:	0a 20                	or     (%eax),%ah
c040c25e:	5f                   	pop    %edi
c040c25f:	7c 5f                	jl     c040c2c0 <debug_initialise+0x80>
c040c261:	7c 5f                	jl     c040c2c2 <debug_initialise+0x82>
c040c263:	7c 20                	jl     c040c285 <debug_initialise+0x45>
c040c265:	20 20                	and    %ah,(%eax)
c040c267:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c26a:	20 20                	and    %ah,(%eax)
c040c26c:	20 20                	and    %ah,(%eax)
c040c26e:	5f                   	pop    %edi
c040c26f:	7c 5f                	jl     c040c2d0 <debug_initialise+0x90>
c040c271:	7c 20                	jl     c040c293 <debug_initialise+0x53>
c040c273:	20 20                	and    %ah,(%eax)
c040c275:	20 20                	and    %ah,(%eax)
c040c277:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c27a:	5f                   	pop    %edi
c040c27b:	7c 5f                	jl     c040c2dc <debug_initialise+0x9c>
c040c27d:	7c 20                	jl     c040c29f <debug_initialise+0x5f>
c040c27f:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c282:	20 20                	and    %ah,(%eax)
c040c284:	20 20                	and    %ah,(%eax)
c040c286:	20 20                	and    %ah,(%eax)
c040c288:	20 20                	and    %ah,(%eax)
c040c28a:	20 20                	and    %ah,(%eax)
c040c28c:	20 20                	and    %ah,(%eax)
c040c28e:	0a 20                	or     (%eax),%ah
c040c290:	5f                   	pop    %edi
c040c291:	7c 20                	jl     c040c2b3 <debug_initialise+0x73>
c040c293:	20 20                	and    %ah,(%eax)
c040c295:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c298:	20 20                	and    %ah,(%eax)
c040c29a:	20 20                	and    %ah,(%eax)
c040c29c:	20 20                	and    %ah,(%eax)
c040c29e:	5f                   	pop    %edi
c040c29f:	7c 20                	jl     c040c2c1 <debug_initialise+0x81>
c040c2a1:	20 20                	and    %ah,(%eax)
c040c2a3:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2a6:	20 20                	and    %ah,(%eax)
c040c2a8:	5f                   	pop    %edi
c040c2a9:	7c 20                	jl     c040c2cb <debug_initialise+0x8b>
c040c2ab:	20 20                	and    %ah,(%eax)
c040c2ad:	20 20                	and    %ah,(%eax)
c040c2af:	20 20                	and    %ah,(%eax)
c040c2b1:	20 20                	and    %ah,(%eax)
c040c2b3:	20 20                	and    %ah,(%eax)
c040c2b5:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2b8:	20 20                	and    %ah,(%eax)
c040c2ba:	20 20                	and    %ah,(%eax)
c040c2bc:	5f                   	pop    %edi
c040c2bd:	7c 20                	jl     c040c2df <debug_initialise+0x9f>
c040c2bf:	20 0a                	and    %cl,(%edx)
c040c2c1:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2c4:	20 20                	and    %ah,(%eax)
c040c2c6:	20 20                	and    %ah,(%eax)
c040c2c8:	5f                   	pop    %edi
c040c2c9:	7c 20                	jl     c040c2eb <debug_initialise+0xab>
c040c2cb:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2ce:	20 20                	and    %ah,(%eax)
c040c2d0:	5f                   	pop    %edi
c040c2d1:	7c 20                	jl     c040c2f3 <debug_initialise+0xb3>
c040c2d3:	20 20                	and    %ah,(%eax)
c040c2d5:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2d8:	20 20                	and    %ah,(%eax)
c040c2da:	20 20                	and    %ah,(%eax)
c040c2dc:	5f                   	pop    %edi
c040c2dd:	7c 5f                	jl     c040c33e <debug_initialise+0xfe>
c040c2df:	7c 20                	jl     c040c301 <debug_initialise+0xc1>
c040c2e1:	20 20                	and    %ah,(%eax)
c040c2e3:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2e6:	20 20                	and    %ah,(%eax)
c040c2e8:	20 20                	and    %ah,(%eax)
c040c2ea:	5f                   	pop    %edi
c040c2eb:	7c 5f                	jl     c040c34c <debug_initialise+0x10c>
c040c2ed:	7c 20                	jl     c040c30f <debug_initialise+0xcf>
c040c2ef:	20 20                	and    %ah,(%eax)
c040c2f1:	20 0a                	and    %cl,(%edx)
c040c2f3:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c2f6:	20 20                	and    %ah,(%eax)
c040c2f8:	20 20                	and    %ah,(%eax)
c040c2fa:	5f                   	pop    %edi
c040c2fb:	7c 20                	jl     c040c31d <debug_initialise+0xdd>
c040c2fd:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c300:	20 20                	and    %ah,(%eax)
c040c302:	5f                   	pop    %edi
c040c303:	7c 20                	jl     c040c325 <debug_initialise+0xe5>
c040c305:	20 20                	and    %ah,(%eax)
c040c307:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c30a:	20 20                	and    %ah,(%eax)
c040c30c:	20 20                	and    %ah,(%eax)
c040c30e:	20 20                	and    %ah,(%eax)
c040c310:	20 20                	and    %ah,(%eax)
c040c312:	5f                   	pop    %edi
c040c313:	7c 20                	jl     c040c335 <debug_initialise+0xf5>
c040c315:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c318:	20 20                	and    %ah,(%eax)
c040c31a:	5f                   	pop    %edi
c040c31b:	7c 20                	jl     c040c33d <debug_initialise+0xfd>
c040c31d:	20 20                	and    %ah,(%eax)
c040c31f:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c322:	20 20                	and    %ah,(%eax)
c040c324:	0a 20                	or     (%eax),%ah
c040c326:	5f                   	pop    %edi
c040c327:	7c 5f                	jl     c040c388 <debug_initialise+0x148>
c040c329:	7c 5f                	jl     c040c38a <debug_initialise+0x14a>
c040c32b:	7c 20                	jl     c040c34d <debug_initialise+0x10d>
c040c32d:	20 20                	and    %ah,(%eax)
c040c32f:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c332:	20 20                	and    %ah,(%eax)
c040c334:	20 20                	and    %ah,(%eax)
c040c336:	5f                   	pop    %edi
c040c337:	7c 5f                	jl     c040c398 <debug_initialise+0x158>
c040c339:	7c 20                	jl     c040c35b <debug_initialise+0x11b>
c040c33b:	20 20                	and    %ah,(%eax)
c040c33d:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c340:	5f                   	pop    %edi
c040c341:	7c 5f                	jl     c040c3a2 <debug_initialise+0x162>
c040c343:	7c 20                	jl     c040c365 <debug_initialise+0x125>
c040c345:	20 20                	and    %ah,(%eax)
c040c347:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c34a:	20 20                	and    %ah,(%eax)
c040c34c:	5f                   	pop    %edi
c040c34d:	7c 20                	jl     c040c36f <debug_initialise+0x12f>
c040c34f:	20 20                	and    %ah,(%eax)
c040c351:	20 5f 7c             	and    %bl,0x7c(%edi)
c040c354:	20 20                	and    %ah,(%eax)
c040c356:	0a 0a                	or     (%edx),%cl
c040c358:	20 43 6f             	and    %al,0x6f(%ebx)
c040c35b:	70 79                	jo     c040c3d6 <debug_initialise+0x196>
c040c35d:	72 69                	jb     c040c3c8 <debug_initialise+0x188>
c040c35f:	67 68 74 20 28 63    	addr16 push $0x63282074
c040c365:	29 20                	sub    %esp,(%eax)
c040c367:	43                   	inc    %ebx
c040c368:	68 72 69 73 20       	push   $0x20736972
c040c36d:	57                   	push   %edi
c040c36e:	69 6c 6c 69 61 6d 73 	imul   $0x20736d61,0x69(%esp,%ebp,2),%ebp
c040c375:	20 
c040c376:	61                   	popa   
c040c377:	6e                   	outsb  %ds:(%esi),(%dx)
c040c378:	64 20 63 6f          	and    %ah,%fs:0x6f(%ebx)
c040c37c:	6e                   	outsb  %ds:(%esi),(%dx)
c040c37d:	74 72                	je     c040c3f1 <debug_initialise+0x1b1>
c040c37f:	69 62 75 74 6f 72 73 	imul   $0x73726f74,0x75(%edx),%esp
c040c386:	2c 20                	sub    $0x20,%al
c040c388:	32 30                	xor    (%eax),%dh
c040c38a:	30 39                	xor    %bh,(%ecx)
c040c38c:	2d 32 30 31 30       	sub    $0x30313032,%eax
c040c391:	2e 0a 20             	or     %cs:(%eax),%ah
c040c394:	53                   	push   %ebx
c040c395:	65 65 20 68 74       	and    %ch,%gs:0x74(%eax)
c040c39a:	74 70                	je     c040c40c <debug_initialise+0x1cc>
c040c39c:	3a 2f                	cmp    (%edi),%ch
c040c39e:	2f                   	das    
c040c39f:	64 69 6f 64 65 73 69 	imul   $0x67697365,%fs:0x64(%edi),%ebp
c040c3a6:	67 
c040c3a7:	6e                   	outsb  %ds:(%esi),(%dx)
c040c3a8:	2e 63 6f 2e          	arpl   %bp,%cs:0x2e(%edi)
c040c3ac:	75 6b                	jne    c040c419 <debug_initialise+0x1d9>
c040c3ae:	2f                   	das    
c040c3af:	20 66 6f             	and    %ah,0x6f(%esi)
c040c3b2:	72 20                	jb     c040c3d4 <debug_initialise+0x194>
c040c3b4:	75 73                	jne    c040c429 <debug_initialise+0x1e9>
c040c3b6:	61                   	popa   
c040c3b7:	67 65 20 61 6e       	addr16 and %ah,%gs:0x6e(%bx,%di)
c040c3bc:	64 20 6c 69 63       	and    %ch,%fs:0x63(%ecx,%ebp,2)
c040c3c1:	65 6e                	outsb  %gs:(%esi),(%dx)
c040c3c3:	63 65 2e             	arpl   %sp,0x2e(%ebp)
c040c3c6:	0a 0a                	or     (%edx),%cl
c040c3c8:	5b                   	pop    %ebx
c040c3c9:	78 38                	js     c040c403 <debug_initialise+0x1c3>
c040c3cb:	36                   	ss
c040c3cc:	5d                   	pop    %ebp
c040c3cd:	20 69 33             	and    %ch,0x33(%ecx)
c040c3d0:	38 36                	cmp    %dh,(%esi)
c040c3d2:	20 70 6f             	and    %dh,0x6f(%eax)
c040c3d5:	72 74                	jb     c040c44b <debug_initialise+0x20b>
c040c3d7:	20 69 6e             	and    %ch,0x6e(%ecx)
c040c3da:	69 74 69 61 6c 69 73 	imul   $0x6573696c,0x61(%ecx,%ebp,2),%esi
c040c3e1:	65 
c040c3e2:	64 0a 00             	or     %fs:(%eax),%al
c040c3e5:	00 00                	add    %al,(%eax)
c040c3e7:	00 5b 78             	add    %bl,0x78(%ebx)
c040c3ea:	38 36                	cmp    %dh,(%esi)
c040c3ec:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c3f2:	4d                   	dec    %ebp
c040c3f3:	47                   	inc    %edi
c040c3f4:	57                   	push   %edi
c040c3f5:	54                   	push   %esp
c040c3f6:	46                   	inc    %esi
c040c3f7:	3a 20                	cmp    (%eax),%ah
c040c3f9:	63 61 6e             	arpl   %sp,0x6e(%ecx)
c040c3fc:	6e                   	outsb  %ds:(%esi),(%dx)
c040c3fd:	6f                   	outsl  %ds:(%esi),(%dx)
c040c3fe:	74 20                	je     c040c420 <debug_initialise+0x1e0>
c040c400:	66 69 6e 64 20 61    	imul   $0x6120,0x64(%esi),%bp
c040c406:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040c40a:	65                   	gs
c040c40b:	61                   	popa   
c040c40c:	64 20 74 6f 20       	and    %dh,%fs:0x20(%edi,%ebp,2)
c040c411:	6b 69 63 6b          	imul   $0x6b,0x63(%ecx),%ebp
c040c415:	73 74                	jae    c040c48b <debug_initialise+0x24b>
c040c417:	61                   	popa   
c040c418:	72 74                	jb     c040c48e <debug_initialise+0x24e>
c040c41a:	2e 0a 00             	or     %cs:(%eax),%al
c040c41d:	00 00                	add    %al,(%eax)
c040c41f:	00 75 6e             	add    %dh,0x6e(%ebp)
c040c422:	68 61 6e 64 6c       	push   $0x6c646e61
c040c427:	65 64 20 73 65       	and    %dh,%fs:%gs:0x65(%ebx)
c040c42c:	72 69                	jb     c040c497 <debug_initialise+0x257>
c040c42e:	6f                   	outsl  %ds:(%esi),(%dx)
c040c42f:	75 73                	jne    c040c4a4 <debug_initialise+0x264>
c040c431:	20 66 61             	and    %ah,0x61(%esi)
c040c434:	75 6c                	jne    c040c4a2 <debug_initialise+0x262>
c040c436:	74 20                	je     c040c458 <debug_initialise+0x218>
c040c438:	69 6e 20 74 68 65 20 	imul   $0x20656874,0x20(%esi),%ebp
c040c43f:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040c443:	65                   	gs
c040c444:	6c                   	insb   (%dx),%es:(%edi)
c040c445:	00 00                	add    %al,(%eax)
c040c447:	00 55 12             	add    %dl,0x12(%ebp)
c040c44a:	40                   	inc    %eax
c040c44b:	c0 6a 12 40          	shrb   $0x40,0x12(%edx)
c040c44f:	c0 7c 12 40 c0       	sarb   $0xc0,0x40(%edx,%edx,1)
c040c454:	8e 12                	mov    (%edx),%ss
c040c456:	40                   	inc    %eax
c040c457:	c0 a0 12 40 c0 b2 12 	shlb   $0x12,-0x4d3fbfee(%eax)
c040c45e:	40                   	inc    %eax
c040c45f:	c0 c4 12             	rol    $0x12,%ah
c040c462:	40                   	inc    %eax
c040c463:	c0 d6 12             	rcl    $0x12,%dh
c040c466:	40                   	inc    %eax
c040c467:	c0 e8 12             	shr    $0x12,%al
c040c46a:	40                   	inc    %eax
c040c46b:	c0 5b 6d 73          	rcrb   $0x73,0x6d(%ebx)
c040c46f:	67 3a 25             	addr16 cmp (%di),%ah
c040c472:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040c479:	54                   	push   %esp
c040c47a:	46                   	inc    %esi
c040c47b:	20 6d 73             	and    %ch,0x73(%ebp)
c040c47e:	67 5f                	addr16 pop %edi
c040c480:	74 65                	je     c040c4e7 <debug_initialise+0x2a7>
c040c482:	73 74                	jae    c040c4f8 <debug_initialise+0x2b8>
c040c484:	5f                   	pop    %edi
c040c485:	72 65                	jb     c040c4ec <debug_initialise+0x2ac>
c040c487:	63 65 69             	arpl   %sp,0x69(%ebp)
c040c48a:	76 65                	jbe    c040c4f1 <debug_initialise+0x2b1>
c040c48c:	72 28                	jb     c040c4b6 <debug_initialise+0x276>
c040c48e:	29 20                	sub    %esp,(%eax)
c040c490:	63 61 6c             	arpl   %sp,0x6c(%ecx)
c040c493:	6c                   	insb   (%dx),%es:(%edi)
c040c494:	65 64 20 77 69       	and    %dh,%fs:%gs:0x69(%edi)
c040c499:	74 68                	je     c040c503 <debug_initialise+0x2c3>
c040c49b:	20 73 65             	and    %dh,0x65(%ebx)
c040c49e:	6e                   	outsb  %ds:(%esi),(%dx)
c040c49f:	64                   	fs
c040c4a0:	65                   	gs
c040c4a1:	72 20                	jb     c040c4c3 <debug_initialise+0x283>
c040c4a3:	25 70 20 74 61       	and    $0x61742070,%eax
c040c4a8:	72 67                	jb     c040c511 <debug_initialise+0x2d1>
c040c4aa:	65                   	gs
c040c4ab:	74 20                	je     c040c4cd <debug_initialise+0x28d>
c040c4ad:	25 70 20 6d 73       	and    $0x736d2070,%eax
c040c4b2:	67 20 25             	addr16 and %ah,(%di)
c040c4b5:	70 0a                	jo     c040c4c1 <debug_initialise+0x281>
c040c4b7:	00 5b 73             	add    %bl,0x73(%ebx)
c040c4ba:	63 68 65             	arpl   %bp,0x65(%eax)
c040c4bd:	64 3a 25 69 5d 20 73 	cmp    %fs:0x73205d69,%ah
c040c4c4:	74 61                	je     c040c527 <debug_initialise+0x2e7>
c040c4c6:	72 74                	jb     c040c53c <debug_initialise+0x2fc>
c040c4c8:	69 6e 67 20 6f 70 65 	imul   $0x65706f20,0x67(%esi),%ebp
c040c4cf:	72 61                	jb     c040c532 <debug_initialise+0x2f2>
c040c4d1:	74 69                	je     c040c53c <debug_initialise+0x2fc>
c040c4d3:	6e                   	outsb  %ds:(%esi),(%dx)
c040c4d4:	67 20 73 79          	addr16 and %dh,0x79(%bp,%di)
c040c4d8:	73 74                	jae    c040c54e <debug_initialise+0x30e>
c040c4da:	65                   	gs
c040c4db:	6d                   	insl   (%dx),%es:(%edi)
c040c4dc:	2e 2e 2e 0a 00       	or     %cs:(%eax),%al
c040c4e1:	00 00                	add    %al,(%eax)
c040c4e3:	00 5b 76             	add    %bl,0x76(%ebx)
c040c4e6:	6d                   	insl   (%dx),%es:(%edi)
c040c4e7:	6d                   	insl   (%dx),%es:(%edi)
c040c4e8:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c4ee:	4d                   	dec    %ebp
c040c4ef:	47                   	inc    %edi
c040c4f0:	57                   	push   %edi
c040c4f1:	54                   	push   %esp
c040c4f2:	46                   	inc    %esi
c040c4f3:	21 20                	and    %esp,(%eax)
c040c4f5:	76 6d                	jbe    c040c564 <debug_initialise+0x324>
c040c4f7:	6d                   	insl   (%dx),%es:(%edi)
c040c4f8:	5f                   	pop    %edi
c040c4f9:	66                   	data16
c040c4fa:	72 65                	jb     c040c561 <debug_initialise+0x321>
c040c4fc:	65 3a 20             	cmp    %gs:(%eax),%ah
c040c4ff:	67 69 76 65 6e 20 6e 	addr16 imul $0x6f6e206e,0x65(%bp),%esi
c040c506:	6f 
c040c507:	6e                   	outsb  %ds:(%esi),(%dx)
c040c508:	73 65                	jae    c040c56f <debug_initialise+0x32f>
c040c50a:	6e                   	outsb  %ds:(%esi),(%dx)
c040c50b:	73 65                	jae    c040c572 <debug_initialise+0x332>
c040c50d:	20 61 64             	and    %ah,0x64(%ecx)
c040c510:	64                   	fs
c040c511:	72 65                	jb     c040c578 <debug_initialise+0x338>
c040c513:	73 73                	jae    c040c588 <debug_initialise+0x348>
c040c515:	20 25 78 0a 00 00    	and    %ah,0xa78
c040c51b:	00 5b 76             	add    %bl,0x76(%ebx)
c040c51e:	6d                   	insl   (%dx),%es:(%edi)
c040c51f:	6d                   	insl   (%dx),%es:(%edi)
c040c520:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c526:	4d                   	dec    %ebp
c040c527:	47                   	inc    %edi
c040c528:	57                   	push   %edi
c040c529:	54                   	push   %esp
c040c52a:	46                   	inc    %esi
c040c52b:	21 20                	and    %esp,(%eax)
c040c52d:	76 6d                	jbe    c040c59c <debug_initialise+0x35c>
c040c52f:	6d                   	insl   (%dx),%es:(%edi)
c040c530:	5f                   	pop    %edi
c040c531:	66                   	data16
c040c532:	72 65                	jb     c040c599 <debug_initialise+0x359>
c040c534:	65 3a 20             	cmp    %gs:(%eax),%ah
c040c537:	62 6c 6f 63          	bound  %ebp,0x63(%edi,%ebp,2)
c040c53b:	6b 20 25             	imul   $0x25,(%eax),%esp
c040c53e:	78 20                	js     c040c560 <debug_initialise+0x320>
c040c540:	68 61 73 20 77       	push   $0x77207361
c040c545:	72 6f                	jb     c040c5b6 <debug_initialise+0x376>
c040c547:	6e                   	outsb  %ds:(%esi),(%dx)
c040c548:	67 20 6d 61          	addr16 and %ch,0x61(%di)
c040c54c:	67 69 63 20 25 78 0a 	addr16 imul $0xa7825,0x20(%bp,%di),%esp
c040c553:	00 
c040c554:	5b                   	pop    %ebx
c040c555:	76 6d                	jbe    c040c5c4 <debug_initialise+0x384>
c040c557:	6d                   	insl   (%dx),%es:(%edi)
c040c558:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c55e:	4d                   	dec    %ebp
c040c55f:	47                   	inc    %edi
c040c560:	57                   	push   %edi
c040c561:	54                   	push   %esp
c040c562:	46                   	inc    %esi
c040c563:	20 74 72 69          	and    %dh,0x69(%edx,%esi,2)
c040c567:	65 64 20 74 6f 20    	and    %dh,%fs:%gs:0x20(%edi,%ebp,2)
c040c56d:	61                   	popa   
c040c56e:	6c                   	insb   (%dx),%es:(%edi)
c040c56f:	74 65                	je     c040c5d6 <debug_initialise+0x396>
c040c571:	72 20                	jb     c040c593 <debug_initialise+0x353>
c040c573:	73 69                	jae    c040c5de <debug_initialise+0x39e>
c040c575:	7a 65                	jp     c040c5dc <debug_initialise+0x39c>
c040c577:	20 6f 66             	and    %ch,0x66(%edi)
c040c57a:	20 61 20             	and    %ah,0x20(%ecx)
c040c57d:	64                   	fs
c040c57e:	65                   	gs
c040c57f:	72 65                	jb     c040c5e6 <debug_initialise+0x3a6>
c040c581:	66                   	data16
c040c582:	65                   	gs
c040c583:	72 65                	jb     c040c5ea <debug_initialise+0x3aa>
c040c585:	6e                   	outsb  %ds:(%esi),(%dx)
c040c586:	63 65 64             	arpl   %sp,0x64(%ebp)
c040c589:	20 62 6c             	and    %ah,0x6c(%edx)
c040c58c:	6f                   	outsl  %ds:(%esi),(%dx)
c040c58d:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c590:	62 79 20             	bound  %edi,0x20(%ecx)
c040c593:	25 69 20 62 79       	and    $0x79622069,%eax
c040c598:	74 65                	je     c040c5ff <debug_initialise+0x3bf>
c040c59a:	73 0a                	jae    c040c5a6 <debug_initialise+0x366>
c040c59c:	00 00                	add    %al,(%eax)
c040c59e:	00 00                	add    %al,(%eax)
c040c5a0:	5b                   	pop    %ebx
c040c5a1:	76 6d                	jbe    c040c610 <debug_initialise+0x3d0>
c040c5a3:	6d                   	insl   (%dx),%es:(%edi)
c040c5a4:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c5aa:	4d                   	dec    %ebp
c040c5ab:	47                   	inc    %edi
c040c5ac:	57                   	push   %edi
c040c5ad:	54                   	push   %esp
c040c5ae:	46                   	inc    %esi
c040c5af:	20 74 72 69          	and    %dh,0x69(%edx,%esi,2)
c040c5b3:	65 64 20 74 6f 20    	and    %dh,%fs:%gs:0x20(%edi,%ebp,2)
c040c5b9:	73 68                	jae    c040c623 <debug_initialise+0x3e3>
c040c5bb:	72 69                	jb     c040c626 <debug_initialise+0x3e6>
c040c5bd:	6e                   	outsb  %ds:(%esi),(%dx)
c040c5be:	6b 20 61             	imul   $0x61,(%eax),%esp
c040c5c1:	20 6e 6f             	and    %ch,0x6f(%esi)
c040c5c4:	6e                   	outsb  %ds:(%esi),(%dx)
c040c5c5:	2d 65 78 69 73       	sub    $0x73697865,%eax
c040c5ca:	74 65                	je     c040c631 <debug_initialise+0x3f1>
c040c5cc:	6e                   	outsb  %ds:(%esi),(%dx)
c040c5cd:	74 20                	je     c040c5ef <debug_initialise+0x3af>
c040c5cf:	62 6c 6f 63          	bound  %ebp,0x63(%edi,%ebp,2)
c040c5d3:	6b 20 62             	imul   $0x62,(%eax),%esp
c040c5d6:	79 20                	jns    c040c5f8 <debug_initialise+0x3b8>
c040c5d8:	25 69 20 62 79       	and    $0x79622069,%eax
c040c5dd:	74 65                	je     c040c644 <debug_initialise+0x404>
c040c5df:	73 0a                	jae    c040c5eb <debug_initialise+0x3ab>
c040c5e1:	00 00                	add    %al,(%eax)
c040c5e3:	00 5b 76             	add    %bl,0x76(%ebx)
c040c5e6:	6d                   	insl   (%dx),%es:(%edi)
c040c5e7:	6d                   	insl   (%dx),%es:(%edi)
c040c5e8:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c5ee:	4d                   	dec    %ebp
c040c5ef:	47                   	inc    %edi
c040c5f0:	57                   	push   %edi
c040c5f1:	54                   	push   %esp
c040c5f2:	46                   	inc    %esi
c040c5f3:	20 74 72 69          	and    %dh,0x69(%edx,%esi,2)
c040c5f7:	65 64 20 74 6f 20    	and    %dh,%fs:%gs:0x20(%edi,%ebp,2)
c040c5fd:	73 68                	jae    c040c667 <debug_initialise+0x427>
c040c5ff:	72 69                	jb     c040c66a <debug_initialise+0x42a>
c040c601:	6e                   	outsb  %ds:(%esi),(%dx)
c040c602:	6b 20 61             	imul   $0x61,(%eax),%esp
c040c605:	20 62 6c             	and    %ah,0x6c(%edx)
c040c608:	6f                   	outsl  %ds:(%esi),(%dx)
c040c609:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c60c:	6f                   	outsl  %ds:(%esi),(%dx)
c040c60d:	66                   	data16
c040c60e:	20 73 69             	and    %dh,0x69(%ebx)
c040c611:	7a 65                	jp     c040c678 <debug_initialise+0x438>
c040c613:	20 25 69 20 62 79    	and    %ah,0x79622069
c040c619:	20 25 69 20 62 79    	and    %ah,0x79622069
c040c61f:	74 65                	je     c040c686 <debug_initialise+0x446>
c040c621:	73 0a                	jae    c040c62d <debug_initialise+0x3ed>
c040c623:	00 5b 76             	add    %bl,0x76(%ebx)
c040c626:	6d                   	insl   (%dx),%es:(%edi)
c040c627:	6d                   	insl   (%dx),%es:(%edi)
c040c628:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c62e:	4d                   	dec    %ebp
c040c62f:	47                   	inc    %edi
c040c630:	57                   	push   %edi
c040c631:	54                   	push   %esp
c040c632:	46                   	inc    %esi
c040c633:	21 20                	and    %esp,(%eax)
c040c635:	76 6d                	jbe    c040c6a4 <debug_initialise+0x464>
c040c637:	6d                   	insl   (%dx),%es:(%edi)
c040c638:	5f                   	pop    %edi
c040c639:	72 65                	jb     c040c6a0 <debug_initialise+0x460>
c040c63b:	74 75                	je     c040c6b2 <debug_initialise+0x472>
c040c63d:	72 6e                	jb     c040c6ad <debug_initialise+0x46d>
c040c63f:	5f                   	pop    %edi
c040c640:	70 68                	jo     c040c6aa <debug_initialise+0x46a>
c040c642:	79 73                	jns    c040c6b7 <debug_initialise+0x477>
c040c644:	5f                   	pop    %edi
c040c645:	70 67                	jo     c040c6ae <debug_initialise+0x46e>
c040c647:	3a 20                	cmp    (%eax),%ah
c040c649:	70 68                	jo     c040c6b3 <debug_initialise+0x473>
c040c64b:	79 73                	jns    c040c6c0 <debug_initialise+0x480>
c040c64d:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040c654:	61                   	popa   
c040c655:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c658:	66                   	data16
c040c659:	72 61                	jb     c040c6bc <debug_initialise+0x47c>
c040c65b:	6d                   	insl   (%dx),%es:(%edi)
c040c65c:	65 20 25 78 20 6e 6f 	and    %ah,%gs:0x6f6e2078
c040c663:	74 20                	je     c040c685 <debug_initialise+0x445>
c040c665:	70 61                	jo     c040c6c8 <debug_initialise+0x488>
c040c667:	67 65 20 61 6c       	addr16 and %ah,%gs:0x6c(%bx,%di)
c040c66c:	69 67 6e 65 64 21 0a 	imul   $0xa216465,0x6e(%edi),%esp
c040c673:	00 5b 76             	add    %bl,0x76(%ebx)
c040c676:	6d                   	insl   (%dx),%es:(%edi)
c040c677:	6d                   	insl   (%dx),%es:(%edi)
c040c678:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c67e:	4d                   	dec    %ebp
c040c67f:	47                   	inc    %edi
c040c680:	57                   	push   %edi
c040c681:	54                   	push   %esp
c040c682:	46                   	inc    %esi
c040c683:	21 20                	and    %esp,(%eax)
c040c685:	76 6d                	jbe    c040c6f4 <debug_initialise+0x4b4>
c040c687:	6d                   	insl   (%dx),%es:(%edi)
c040c688:	5f                   	pop    %edi
c040c689:	72 65                	jb     c040c6f0 <debug_initialise+0x4b0>
c040c68b:	74 75                	je     c040c702 <debug_initialise+0x4c2>
c040c68d:	72 6e                	jb     c040c6fd <debug_initialise+0x4bd>
c040c68f:	5f                   	pop    %edi
c040c690:	70 68                	jo     c040c6fa <debug_initialise+0x4ba>
c040c692:	79 73                	jns    c040c707 <debug_initialise+0x4c7>
c040c694:	5f                   	pop    %edi
c040c695:	70 67                	jo     c040c6fe <debug_initialise+0x4be>
c040c697:	3a 20                	cmp    (%eax),%ah
c040c699:	6c                   	insb   (%dx),%es:(%edi)
c040c69a:	6f                   	outsl  %ds:(%esi),(%dx)
c040c69b:	77 20                	ja     c040c6bd <debug_initialise+0x47d>
c040c69d:	70 68                	jo     c040c707 <debug_initialise+0x4c7>
c040c69f:	79 73                	jns    c040c714 <debug_initialise+0x4d4>
c040c6a1:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040c6a8:	61                   	popa   
c040c6a9:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c6ac:	66                   	data16
c040c6ad:	72 61                	jb     c040c710 <debug_initialise+0x4d0>
c040c6af:	6d                   	insl   (%dx),%es:(%edi)
c040c6b0:	65 20 68 61          	and    %ch,%gs:0x61(%eax)
c040c6b4:	73 20                	jae    c040c6d6 <debug_initialise+0x496>
c040c6b6:	6f                   	outsl  %ds:(%esi),(%dx)
c040c6b7:	76 65                	jbe    c040c71e <debug_initialise+0x4de>
c040c6b9:	72 66                	jb     c040c721 <debug_initialise+0x4e1>
c040c6bb:	6c                   	insb   (%dx),%es:(%edi)
c040c6bc:	6f                   	outsl  %ds:(%esi),(%dx)
c040c6bd:	77 65                	ja     c040c724 <debug_initialise+0x4e4>
c040c6bf:	64 21 0a             	and    %ecx,%fs:(%edx)
c040c6c2:	00 00                	add    %al,(%eax)
c040c6c4:	5b                   	pop    %ebx
c040c6c5:	76 6d                	jbe    c040c734 <debug_initialise+0x4f4>
c040c6c7:	6d                   	insl   (%dx),%es:(%edi)
c040c6c8:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c6ce:	4d                   	dec    %ebp
c040c6cf:	47                   	inc    %edi
c040c6d0:	57                   	push   %edi
c040c6d1:	54                   	push   %esp
c040c6d2:	46                   	inc    %esi
c040c6d3:	21 20                	and    %esp,(%eax)
c040c6d5:	76 6d                	jbe    c040c744 <debug_initialise+0x504>
c040c6d7:	6d                   	insl   (%dx),%es:(%edi)
c040c6d8:	5f                   	pop    %edi
c040c6d9:	72 65                	jb     c040c740 <debug_initialise+0x500>
c040c6db:	74 75                	je     c040c752 <debug_initialise+0x512>
c040c6dd:	72 6e                	jb     c040c74d <debug_initialise+0x50d>
c040c6df:	5f                   	pop    %edi
c040c6e0:	70 68                	jo     c040c74a <debug_initialise+0x50a>
c040c6e2:	79 73                	jns    c040c757 <debug_initialise+0x517>
c040c6e4:	5f                   	pop    %edi
c040c6e5:	70 67                	jo     c040c74e <debug_initialise+0x50e>
c040c6e7:	3a 20                	cmp    (%eax),%ah
c040c6e9:	68 69 67 68 20       	push   $0x20686769
c040c6ee:	70 68                	jo     c040c758 <debug_initialise+0x518>
c040c6f0:	79 73                	jns    c040c765 <debug_initialise+0x525>
c040c6f2:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040c6f9:	61                   	popa   
c040c6fa:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c6fd:	68 61 73 20 6f       	push   $0x6f207361
c040c702:	76 65                	jbe    c040c769 <debug_initialise+0x529>
c040c704:	72 66                	jb     c040c76c <debug_initialise+0x52c>
c040c706:	6c                   	insb   (%dx),%es:(%edi)
c040c707:	6f                   	outsl  %ds:(%esi),(%dx)
c040c708:	77 65                	ja     c040c76f <debug_initialise+0x52f>
c040c70a:	64 21 0a             	and    %ecx,%fs:(%edx)
c040c70d:	00 00                	add    %al,(%eax)
c040c70f:	00 5b 76             	add    %bl,0x76(%ebx)
c040c712:	6d                   	insl   (%dx),%es:(%edi)
c040c713:	6d                   	insl   (%dx),%es:(%edi)
c040c714:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040c71a:	65                   	gs
c040c71b:	72 6e                	jb     c040c78b <debug_initialise+0x54b>
c040c71d:	65                   	gs
c040c71e:	6c                   	insb   (%dx),%es:(%edi)
c040c71f:	3a 20                	cmp    (%eax),%ah
c040c721:	6c                   	insb   (%dx),%es:(%edi)
c040c722:	6f                   	outsl  %ds:(%esi),(%dx)
c040c723:	67 69 63 61 6c 20 73 	addr16 imul $0x7473206c,0x61(%bp,%di),%esp
c040c72a:	74 
c040c72b:	61                   	popa   
c040c72c:	72 74                	jb     c040c7a2 <debug_initialise+0x562>
c040c72e:	20 25 78 20 65 6e    	and    %ah,0x6e652078
c040c734:	64 20 25 78 20 73 69 	and    %ah,%fs:0x69732078
c040c73b:	7a 65                	jp     c040c7a2 <debug_initialise+0x562>
c040c73d:	20 25 69 20 62 79    	and    %ah,0x79622069
c040c743:	74 65                	je     c040c7aa <debug_initialise+0x56a>
c040c745:	73 0a                	jae    c040c751 <debug_initialise+0x511>
c040c747:	00 5b 76             	add    %bl,0x76(%ebx)
c040c74a:	6d                   	insl   (%dx),%es:(%edi)
c040c74b:	6d                   	insl   (%dx),%es:(%edi)
c040c74c:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040c752:	65                   	gs
c040c753:	72 6e                	jb     c040c7c3 <debug_initialise+0x583>
c040c755:	65                   	gs
c040c756:	6c                   	insb   (%dx),%es:(%edi)
c040c757:	3a 20                	cmp    (%eax),%ah
c040c759:	70 68                	jo     c040c7c3 <debug_initialise+0x583>
c040c75b:	79 73                	jns    c040c7d0 <debug_initialise+0x590>
c040c75d:	69 63 61 6c 20 73 74 	imul   $0x7473206c,0x61(%ebx),%esp
c040c764:	61                   	popa   
c040c765:	72 74                	jb     c040c7db <debug_initialise+0x59b>
c040c767:	20 25 78 20 65 6e    	and    %ah,0x6e652078
c040c76d:	64 20 25 78 20 61 6c 	and    %ah,%fs:0x6c612078
c040c774:	69 67 6e 65 64 20 65 	imul   $0x65206465,0x6e(%edi),%esp
c040c77b:	6e                   	outsb  %ds:(%esi),(%dx)
c040c77c:	64 20 25 78 0a 00 00 	and    %ah,%fs:0xa78
c040c783:	00 5b 76             	add    %bl,0x76(%ebx)
c040c786:	6d                   	insl   (%dx),%es:(%edi)
c040c787:	6d                   	insl   (%dx),%es:(%edi)
c040c788:	3a 25 69 5d 20 66    	cmp    0x66205d69,%ah
c040c78e:	6f                   	outsl  %ds:(%esi),(%dx)
c040c78f:	75 6e                	jne    c040c7ff <debug_initialise+0x5bf>
c040c791:	64 20 25 69 20 70 61 	and    %ah,%fs:0x61702069
c040c798:	67                   	addr16
c040c799:	65                   	gs
c040c79a:	73 2c                	jae    c040c7c8 <debug_initialise+0x588>
c040c79c:	20 25 69 4d 42 20    	and    %ah,0x20424d69
c040c7a2:	74 6f                	je     c040c813 <debug_initialise+0x5d3>
c040c7a4:	74 61                	je     c040c807 <debug_initialise+0x5c7>
c040c7a6:	6c                   	insb   (%dx),%es:(%edi)
c040c7a7:	2c 20                	sub    $0x20,%al
c040c7a9:	70 68                	jo     c040c813 <debug_initialise+0x5d3>
c040c7ab:	79 73                	jns    c040c820 <debug_initialise+0x5e0>
c040c7ad:	20 73 74             	and    %dh,0x74(%ebx)
c040c7b0:	61                   	popa   
c040c7b1:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c7b4:	73 69                	jae    c040c81f <debug_initialise+0x5df>
c040c7b6:	7a 65                	jp     c040c81d <debug_initialise+0x5dd>
c040c7b8:	20 25 69 20 62 79    	and    %ah,0x79622069
c040c7be:	74 65                	je     c040c825 <debug_initialise+0x5e5>
c040c7c0:	73 0a                	jae    c040c7cc <debug_initialise+0x58c>
c040c7c2:	00 00                	add    %al,(%eax)
c040c7c4:	2a 2a                	sub    (%edx),%ch
c040c7c6:	2a 20                	sub    (%eax),%ah
c040c7c8:	4e                   	dec    %esi
c040c7c9:	6f                   	outsl  %ds:(%esi),(%dx)
c040c7ca:	74 20                	je     c040c7ec <debug_initialise+0x5ac>
c040c7cc:	65 6e                	outsb  %gs:(%esi),(%dx)
c040c7ce:	6f                   	outsl  %ds:(%esi),(%dx)
c040c7cf:	75 67                	jne    c040c838 <debug_initialise+0x5f8>
c040c7d1:	68 20 6d 65 6d       	push   $0x6d656d20
c040c7d6:	6f                   	outsl  %ds:(%esi),(%dx)
c040c7d7:	72 79                	jb     c040c852 <debug_initialise+0x612>
c040c7d9:	20 70 72             	and    %dh,0x72(%eax)
c040c7dc:	65                   	gs
c040c7dd:	73 65                	jae    c040c844 <debug_initialise+0x604>
c040c7df:	6e                   	outsb  %ds:(%esi),(%dx)
c040c7e0:	74 2c                	je     c040c80e <debug_initialise+0x5ce>
c040c7e2:	20 6d 75             	and    %ch,0x75(%ebp)
c040c7e5:	73 74                	jae    c040c85b <debug_initialise+0x61b>
c040c7e7:	20 68 61             	and    %ch,0x61(%eax)
c040c7ea:	76 65                	jbe    c040c851 <debug_initialise+0x611>
c040c7ec:	20 61 74             	and    %ah,0x74(%ecx)
c040c7ef:	20 6c 65 61          	and    %ch,0x61(%ebp,%eiz,2)
c040c7f3:	73 74                	jae    c040c869 <debug_initialise+0x629>
c040c7f5:	20 25 69 20 62 79    	and    %ah,0x79622069
c040c7fb:	74 65                	je     c040c862 <debug_initialise+0x622>
c040c7fd:	73 20                	jae    c040c81f <debug_initialise+0x5df>
c040c7ff:	61                   	popa   
c040c800:	76 61                	jbe    c040c863 <debug_initialise+0x623>
c040c802:	69 6c 61 62 6c 65 2e 	imul   $0xa2e656c,0x62(%ecx,%eiz,2),%ebp
c040c809:	0a 
c040c80a:	00 00                	add    %al,(%eax)
c040c80c:	2a 2a                	sub    (%edx),%ch
c040c80e:	2a 20                	sub    (%eax),%ah
c040c810:	6c                   	insb   (%dx),%es:(%edi)
c040c811:	6f                   	outsl  %ds:(%esi),(%dx)
c040c812:	6d                   	insl   (%dx),%es:(%edi)
c040c813:	65                   	gs
c040c814:	6d                   	insl   (%dx),%es:(%edi)
c040c815:	20 70 61             	and    %dh,0x61(%eax)
c040c818:	67 65 20 73 74       	addr16 and %dh,%gs:0x74(%bp,%di)
c040c81d:	61                   	popa   
c040c81e:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040c821:	63 72 61             	arpl   %si,0x61(%edx)
c040c824:	73 68                	jae    c040c88e <debug_initialise+0x64e>
c040c826:	65 64 20 69 6e       	and    %ch,%fs:%gs:0x6e(%ecx)
c040c82b:	74 6f                	je     c040c89c <debug_initialise+0x65c>
c040c82d:	20 68 69             	and    %ch,0x69(%eax)
c040c830:	6d                   	insl   (%dx),%es:(%edi)
c040c831:	65                   	gs
c040c832:	6d                   	insl   (%dx),%es:(%edi)
c040c833:	20 73 74             	and    %dh,0x74(%ebx)
c040c836:	61                   	popa   
c040c837:	63 6b 21             	arpl   %bp,0x21(%ebx)
c040c83a:	0a 20                	or     (%eax),%ah
c040c83c:	20 20                	and    %ah,(%eax)
c040c83e:	20 70 74             	and    %dh,0x74(%eax)
c040c841:	72 20                	jb     c040c863 <debug_initialise+0x623>
c040c843:	25 70 20 61 66       	and    $0x66612070,%eax
c040c848:	74 65                	je     c040c8af <debug_initialise+0x66f>
c040c84a:	72 20                	jb     c040c86c <debug_initialise+0x62c>
c040c84c:	25 69 20 70 61       	and    $0x61702069,%eax
c040c851:	67                   	addr16
c040c852:	65                   	gs
c040c853:	73 20                	jae    c040c875 <debug_initialise+0x635>
c040c855:	28 25 78 29 20 2d    	sub    %ah,0x2d202978
c040c85b:	20 68 61             	and    %ch,0x61(%eax)
c040c85e:	6c                   	insb   (%dx),%es:(%edi)
c040c85f:	74 69                	je     c040c8ca <debug_initialise+0x68a>
c040c861:	6e                   	outsb  %ds:(%esi),(%dx)
c040c862:	67 2e 0a 00          	addr16 or %cs:(%bx,%si),%al
c040c866:	00 00                	add    %al,(%eax)
c040c868:	5b                   	pop    %ebx
c040c869:	76 6d                	jbe    c040c8d8 <debug_initialise+0x698>
c040c86b:	6d                   	insl   (%dx),%es:(%edi)
c040c86c:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040c872:	4d                   	dec    %ebp
c040c873:	47                   	inc    %edi
c040c874:	57                   	push   %edi
c040c875:	54                   	push   %esp
c040c876:	46                   	inc    %esi
c040c877:	3a 20                	cmp    (%eax),%ah
c040c879:	76 6d                	jbe    c040c8e8 <debug_initialise+0x6a8>
c040c87b:	6d                   	insl   (%dx),%es:(%edi)
c040c87c:	5f                   	pop    %edi
c040c87d:	6d                   	insl   (%dx),%es:(%edi)
c040c87e:	65                   	gs
c040c87f:	6d                   	insl   (%dx),%es:(%edi)
c040c880:	63 70 79             	arpl   %si,0x79(%eax)
c040c883:	75 73                	jne    c040c8f8 <debug_initialise+0x6b8>
c040c885:	65                   	gs
c040c886:	72 20                	jb     c040c8a8 <debug_initialise+0x668>
c040c888:	68 61 73 20 62       	push   $0x62207361
c040c88d:	61                   	popa   
c040c88e:	64 20 70 61          	and    %dh,%fs:0x61(%eax)
c040c892:	72 61                	jb     c040c8f5 <debug_initialise+0x6b5>
c040c894:	6d                   	insl   (%dx),%es:(%edi)
c040c895:	73 21                	jae    c040c8b8 <debug_initialise+0x678>
c040c897:	0a 20                	or     (%eax),%ah
c040c899:	20 20                	and    %ah,(%eax)
c040c89b:	20 20                	and    %ah,(%eax)
c040c89d:	20 20                	and    %ah,(%eax)
c040c89f:	20 20                	and    %ah,(%eax)
c040c8a1:	20 20                	and    %ah,(%eax)
c040c8a3:	20 20                	and    %ah,(%eax)
c040c8a5:	20 20                	and    %ah,(%eax)
c040c8a7:	20 74 61 72          	and    %dh,0x72(%ecx,%eiz,2)
c040c8ab:	67                   	addr16
c040c8ac:	65                   	gs
c040c8ad:	74 20                	je     c040c8cf <debug_initialise+0x68f>
c040c8af:	3d 20 25 70 20       	cmp    $0x20702520,%eax
c040c8b4:	28 70 72             	sub    %dh,0x72(%eax)
c040c8b7:	6f                   	outsl  %ds:(%esi),(%dx)
c040c8b8:	63 20                	arpl   %sp,(%eax)
c040c8ba:	25 70 29 0a 20       	and    $0x200a2970,%eax
c040c8bf:	20 20                	and    %ah,(%eax)
c040c8c1:	20 20                	and    %ah,(%eax)
c040c8c3:	20 20                	and    %ah,(%eax)
c040c8c5:	20 20                	and    %ah,(%eax)
c040c8c7:	20 20                	and    %ah,(%eax)
c040c8c9:	20 20                	and    %ah,(%eax)
c040c8cb:	20 20                	and    %ah,(%eax)
c040c8cd:	20 73 6f             	and    %dh,0x6f(%ebx)
c040c8d0:	75 72                	jne    c040c944 <debug_initialise+0x704>
c040c8d2:	63 65 20             	arpl   %sp,0x20(%ebp)
c040c8d5:	3d 20 25 70 20       	cmp    $0x20702520,%eax
c040c8da:	28 70 72             	sub    %dh,0x72(%eax)
c040c8dd:	6f                   	outsl  %ds:(%esi),(%dx)
c040c8de:	63 20                	arpl   %sp,(%eax)
c040c8e0:	25 70 29 0a 20       	and    $0x200a2970,%eax
c040c8e5:	20 20                	and    %ah,(%eax)
c040c8e7:	20 20                	and    %ah,(%eax)
c040c8e9:	20 20                	and    %ah,(%eax)
c040c8eb:	20 20                	and    %ah,(%eax)
c040c8ed:	20 20                	and    %ah,(%eax)
c040c8ef:	20 20                	and    %ah,(%eax)
c040c8f1:	20 20                	and    %ah,(%eax)
c040c8f3:	20 63 6f             	and    %ah,0x6f(%ebx)
c040c8f6:	70 79                	jo     c040c971 <debug_initialise+0x731>
c040c8f8:	69 6e 67 3a 20 25 69 	imul   $0x6925203a,0x67(%esi),%ebp
c040c8ff:	20 62 79             	and    %ah,0x79(%edx)
c040c902:	74 65                	je     c040c969 <debug_initialise+0x729>
c040c904:	73 0a                	jae    c040c910 <debug_initialise+0x6d0>
c040c906:	00 2e                	add    %ch,(%esi)
c040c908:	2e                   	cs
c040c909:	2f                   	das    
c040c90a:	2e                   	cs
c040c90b:	2e                   	cs
c040c90c:	2f                   	das    
c040c90d:	63 6f 72             	arpl   %bp,0x72(%edi)
c040c910:	65                   	gs
c040c911:	2f                   	das    
c040c912:	76 6d                	jbe    c040c981 <debug_initialise+0x741>
c040c914:	6d                   	insl   (%dx),%es:(%edi)
c040c915:	2e 63 00             	arpl   %ax,%cs:(%eax)
c040c918:	74 21                	je     c040c93b <debug_initialise+0x6fb>
c040c91a:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040c91f:	00 53 47             	add    %dl,0x47(%ebx)
c040c922:	4c                   	dec    %esp
c040c923:	49                   	dec    %ecx
c040c924:	42                   	inc    %edx
c040c925:	5f                   	pop    %edi
c040c926:	5f                   	pop    %edi
c040c927:	5f                   	pop    %edi
c040c928:	47                   	inc    %edi
c040c929:	45                   	inc    %ebp
c040c92a:	54                   	push   %esp
c040c92b:	5f                   	pop    %edi
c040c92c:	56                   	push   %esi
c040c92d:	41                   	inc    %ecx
c040c92e:	4c                   	dec    %esp
c040c92f:	55                   	push   %ebp
c040c930:	45                   	inc    %ebp
c040c931:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040c935:	63 6f 6c             	arpl   %bp,0x6c(%edi)
c040c938:	6f                   	outsl  %ds:(%esi),(%dx)
c040c939:	75 72                	jne    c040c9ad <debug_initialise+0x76d>
c040c93b:	29 3d 3d 31 00 63    	sub    %edi,0x6300313d
c040c941:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040c947:	20 26                	and    %ah,(%esi)
c040c949:	26 20 53 47          	and    %dl,%es:0x47(%ebx)
c040c94d:	4c                   	dec    %esp
c040c94e:	49                   	dec    %ecx
c040c94f:	42                   	inc    %edx
c040c950:	5f                   	pop    %edi
c040c951:	5f                   	pop    %edi
c040c952:	5f                   	pop    %edi
c040c953:	47                   	inc    %edi
c040c954:	45                   	inc    %ebp
c040c955:	54                   	push   %esp
c040c956:	5f                   	pop    %edi
c040c957:	56                   	push   %esi
c040c958:	41                   	inc    %ecx
c040c959:	4c                   	dec    %esp
c040c95a:	55                   	push   %ebp
c040c95b:	45                   	inc    %ebp
c040c95c:	28 63 2d             	sub    %ah,0x2d(%ebx)
c040c95f:	3e 63 6f 6c          	arpl   %bp,%ds:0x6c(%edi)
c040c963:	6f                   	outsl  %ds:(%esi),(%dx)
c040c964:	75 72                	jne    c040c9d8 <debug_initialise+0x798>
c040c966:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040c96c:	63 6c 3d 3d          	arpl   %bp,0x3d(%ebp,%edi,1)
c040c970:	4e                   	dec    %esi
c040c971:	55                   	push   %ebp
c040c972:	4c                   	dec    %esp
c040c973:	4c                   	dec    %esp
c040c974:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040c978:	53                   	push   %ebx
c040c979:	47                   	inc    %edi
c040c97a:	4c                   	dec    %esp
c040c97b:	49                   	dec    %ecx
c040c97c:	42                   	inc    %edx
c040c97d:	5f                   	pop    %edi
c040c97e:	5f                   	pop    %edi
c040c97f:	5f                   	pop    %edi
c040c980:	47                   	inc    %edi
c040c981:	45                   	inc    %ebp
c040c982:	54                   	push   %esp
c040c983:	5f                   	pop    %edi
c040c984:	56                   	push   %esi
c040c985:	41                   	inc    %ecx
c040c986:	4c                   	dec    %esp
c040c987:	55                   	push   %ebp
c040c988:	45                   	inc    %ebp
c040c989:	28 63 6c             	sub    %ah,0x6c(%ebx)
c040c98c:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040c991:	6f                   	outsl  %ds:(%esi),(%dx)
c040c992:	75 72                	jne    c040ca06 <debug_initialise+0x7c6>
c040c994:	29 3d 3d 30 00 30    	sub    %edi,0x3000303d
c040c99a:	00 62 6c             	add    %ah,0x6c(%edx)
c040c99d:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040c9a3:	00 62 72             	add    %ah,0x72(%edx)
c040c9a6:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040c9ac:	00 00                	add    %al,(%eax)
c040c9ae:	00 00                	add    %al,(%eax)
c040c9b0:	53                   	push   %ebx
c040c9b1:	47                   	inc    %edi
c040c9b2:	4c                   	dec    %esp
c040c9b3:	49                   	dec    %ecx
c040c9b4:	42                   	inc    %edx
c040c9b5:	5f                   	pop    %edi
c040c9b6:	5f                   	pop    %edi
c040c9b7:	5f                   	pop    %edi
c040c9b8:	47                   	inc    %edi
c040c9b9:	45                   	inc    %ebp
c040c9ba:	54                   	push   %esp
c040c9bb:	5f                   	pop    %edi
c040c9bc:	56                   	push   %esi
c040c9bd:	41                   	inc    %ecx
c040c9be:	4c                   	dec    %esp
c040c9bf:	55                   	push   %ebp
c040c9c0:	45                   	inc    %ebp
c040c9c1:	28 62 6c             	sub    %ah,0x6c(%edx)
c040c9c4:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040c9c9:	6f                   	outsl  %ds:(%esi),(%dx)
c040c9ca:	75 72                	jne    c040ca3e <debug_initialise+0x7fe>
c040c9cc:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040c9d2:	00 00                	add    %al,(%eax)
c040c9d4:	53                   	push   %ebx
c040c9d5:	47                   	inc    %edi
c040c9d6:	4c                   	dec    %esp
c040c9d7:	49                   	dec    %ecx
c040c9d8:	42                   	inc    %edx
c040c9d9:	5f                   	pop    %edi
c040c9da:	5f                   	pop    %edi
c040c9db:	5f                   	pop    %edi
c040c9dc:	47                   	inc    %edi
c040c9dd:	45                   	inc    %ebp
c040c9de:	54                   	push   %esp
c040c9df:	5f                   	pop    %edi
c040c9e0:	56                   	push   %esi
c040c9e1:	41                   	inc    %ecx
c040c9e2:	4c                   	dec    %esp
c040c9e3:	55                   	push   %ebp
c040c9e4:	45                   	inc    %ebp
c040c9e5:	28 62 72             	sub    %ah,0x72(%edx)
c040c9e8:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040c9ed:	6f                   	outsl  %ds:(%esi),(%dx)
c040c9ee:	75 72                	jne    c040ca62 <debug_initialise+0x822>
c040c9f0:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040c9f6:	00 00                	add    %al,(%eax)
c040c9f8:	62 72 21             	bound  %esi,0x21(%edx)
c040c9fb:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040ca00:	20 26                	and    %ah,(%esi)
c040ca02:	26 20 53 47          	and    %dl,%es:0x47(%ebx)
c040ca06:	4c                   	dec    %esp
c040ca07:	49                   	dec    %ecx
c040ca08:	42                   	inc    %edx
c040ca09:	5f                   	pop    %edi
c040ca0a:	5f                   	pop    %edi
c040ca0b:	5f                   	pop    %edi
c040ca0c:	47                   	inc    %edi
c040ca0d:	45                   	inc    %ebp
c040ca0e:	54                   	push   %esp
c040ca0f:	5f                   	pop    %edi
c040ca10:	56                   	push   %esi
c040ca11:	41                   	inc    %ecx
c040ca12:	4c                   	dec    %esp
c040ca13:	55                   	push   %ebp
c040ca14:	45                   	inc    %ebp
c040ca15:	28 62 72             	sub    %ah,0x72(%edx)
c040ca18:	2d 3e 63 6f 6c       	sub    $0x6c6f633e,%eax
c040ca1d:	6f                   	outsl  %ds:(%esi),(%dx)
c040ca1e:	75 72                	jne    c040ca92 <debug_initialise+0x852>
c040ca20:	29 3d 3d 31 00 00    	sub    %edi,0x313d
c040ca26:	00 00                	add    %al,(%eax)
c040ca28:	30 20                	xor    %ah,(%eax)
c040ca2a:	26 26 20 22          	and    %ah,%es:(%edx)
c040ca2e:	54                   	push   %esp
c040ca2f:	68 65 20 65 6c       	push   $0x6c652065
c040ca34:	65                   	gs
c040ca35:	6d                   	insl   (%dx),%es:(%edi)
c040ca36:	65 6e                	outsb  %gs:(%esi),(%dx)
c040ca38:	74 20                	je     c040ca5a <debug_initialise+0x81a>
c040ca3a:	74 6f                	je     c040caab <debug_initialise+0x86b>
c040ca3c:	20 64 65 6c          	and    %ah,0x6c(%ebp,%eiz,2)
c040ca40:	65                   	gs
c040ca41:	74 65                	je     c040caa8 <debug_initialise+0x868>
c040ca43:	20 6e 6f             	and    %ch,0x6f(%esi)
c040ca46:	74 20                	je     c040ca68 <debug_initialise+0x828>
c040ca48:	66 6f                	outsw  %ds:(%esi),(%dx)
c040ca4a:	75 6e                	jne    c040caba <debug_initialise+0x87a>
c040ca4c:	64 20 69 6e          	and    %ch,%fs:0x6e(%ecx)
c040ca50:	20 74 68 65          	and    %dh,0x65(%eax,%ebp,2)
c040ca54:	20 74 72 65          	and    %dh,0x65(%edx,%esi,2)
c040ca58:	65                   	gs
c040ca59:	2c 20                	sub    $0x20,%al
c040ca5b:	20 75 73             	and    %dh,0x73(%ebp)
c040ca5e:	65 20 27             	and    %ah,%gs:(%edi)
c040ca61:	64                   	fs
c040ca62:	65                   	gs
c040ca63:	6c                   	insb   (%dx),%es:(%edi)
c040ca64:	65                   	gs
c040ca65:	74 65                	je     c040cacc <debug_initialise+0x88c>
c040ca67:	5f                   	pop    %edi
c040ca68:	69 66 5f 6d 65 6d 62 	imul   $0x626d656d,0x5f(%esi),%esp
c040ca6f:	65                   	gs
c040ca70:	72 27                	jb     c040ca99 <debug_initialise+0x859>
c040ca72:	22 21                	and    (%ecx),%ah
c040ca74:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040ca79:	00 00                	add    %al,(%eax)
c040ca7b:	00 65 6c             	add    %ah,0x6c(%ebp)
c040ca7e:	65                   	gs
c040ca7f:	6d                   	insl   (%dx),%es:(%edi)
c040ca80:	3d 3d 74 20 26       	cmp    $0x2620743d,%eax
c040ca85:	26 20 22             	and    %ah,%es:(%edx)
c040ca88:	44                   	inc    %esp
c040ca89:	65                   	gs
c040ca8a:	6c                   	insb   (%dx),%es:(%edi)
c040ca8b:	65                   	gs
c040ca8c:	74 69                	je     c040caf7 <debug_initialise+0x8b7>
c040ca8e:	6e                   	outsb  %ds:(%esi),(%dx)
c040ca8f:	67 20 61 6e          	addr16 and %ah,0x6e(%bx,%di)
c040ca93:	20 65 6c             	and    %ah,0x6c(%ebp)
c040ca96:	65                   	gs
c040ca97:	6d                   	insl   (%dx),%es:(%edi)
c040ca98:	65 6e                	outsb  %gs:(%esi),(%dx)
c040ca9a:	74 20                	je     c040cabc <debug_initialise+0x87c>
c040ca9c:	77 68                	ja     c040cb06 <debug_initialise+0x8c6>
c040ca9e:	69 63 68 20 69 73 20 	imul   $0x20736920,0x68(%ebx),%esp
c040caa5:	6e                   	outsb  %ds:(%esi),(%dx)
c040caa6:	6f                   	outsl  %ds:(%esi),(%dx)
c040caa7:	6e                   	outsb  %ds:(%esi),(%dx)
c040caa8:	20 6d 65             	and    %ch,0x65(%ebp)
c040caab:	6d                   	insl   (%dx),%es:(%edi)
c040caac:	62 65 72             	bound  %esp,0x72(%ebp)
c040caaf:	20 6f 66             	and    %ch,0x66(%edi)
c040cab2:	20 74 68 65          	and    %dh,0x65(%eax,%ebp,2)
c040cab6:	20 74 72 65          	and    %dh,0x65(%edx,%esi,2)
c040caba:	65                   	gs
c040cabb:	2c 20                	sub    $0x20,%al
c040cabd:	75 73                	jne    c040cb32 <debug_initialise+0x8f2>
c040cabf:	65 20 27             	and    %ah,%gs:(%edi)
c040cac2:	64                   	fs
c040cac3:	65                   	gs
c040cac4:	6c                   	insb   (%dx),%es:(%edi)
c040cac5:	65                   	gs
c040cac6:	74 65                	je     c040cb2d <debug_initialise+0x8ed>
c040cac8:	5f                   	pop    %edi
c040cac9:	69 66 5f 6d 65 6d 62 	imul   $0x626d656d,0x5f(%esi),%esp
c040cad0:	65                   	gs
c040cad1:	72 27                	jb     c040cafa <debug_initialise+0x8ba>
c040cad3:	22 21                	and    (%ecx),%ah
c040cad5:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040cada:	00 74 20 3d          	add    %dh,0x3d(%eax,%eiz,1)
c040cade:	3d 20 65 6c 65       	cmp    $0x656c6520,%eax
c040cae3:	6d                   	insl   (%dx),%es:(%edi)
c040cae4:	00 00                	add    %al,(%eax)
c040cae6:	00 00                	add    %al,(%eax)
c040cae8:	30 20                	xor    %ah,(%eax)
c040caea:	26 26 20 22          	and    %ah,%es:(%edx)
c040caee:	74 68                	je     c040cb58 <debug_initialise+0x918>
c040caf0:	65 20 62 69          	and    %ah,%gs:0x69(%edx)
c040caf4:	6e                   	outsb  %ds:(%esi),(%dx)
c040caf5:	61                   	popa   
c040caf6:	72 79                	jb     c040cb71 <debug_initialise+0x931>
c040caf8:	5f                   	pop    %edi
c040caf9:	74 72                	je     c040cb6d <debug_initialise+0x92d>
c040cafb:	65 65 20 69 73       	and    %ch,%gs:0x73(%ecx)
c040cb00:	20 74 6f 6f          	and    %dh,0x6f(%edi,%ebp,2)
c040cb04:	20 64 65 65          	and    %ah,0x65(%ebp,%eiz,2)
c040cb08:	70 22                	jo     c040cb2c <debug_initialise+0x8ec>
c040cb0a:	00 69 74             	add    %ch,0x74(%ecx)
c040cb0d:	21 3d 4e 55 4c 4c    	and    %edi,0x4c4c554e
c040cb13:	00 2a                	add    %ch,(%edx)
c040cb15:	70 61                	jo     c040cb78 <debug_initialise+0x938>
c040cb17:	74 68                	je     c040cb81 <debug_initialise+0x941>
c040cb19:	64                   	fs
c040cb1a:	65                   	gs
c040cb1b:	65                   	gs
c040cb1c:	70 20                	jo     c040cb3e <debug_initialise+0x8fe>
c040cb1e:	3d 3d 20 63 64       	cmp    $0x6463203d,%eax
c040cb23:	65                   	gs
c040cb24:	65                   	gs
c040cb25:	70 00                	jo     c040cb27 <debug_initialise+0x8e7>
c040cb27:	76 6d                	jbe    c040cb96 <debug_initialise+0x956>
c040cb29:	6d                   	insl   (%dx),%es:(%edi)
c040cb2a:	5f                   	pop    %edi
c040cb2b:	63 6d 70             	arpl   %bp,0x70(%ebp)
c040cb2e:	5f                   	pop    %edi
c040cb2f:	76 6d                	jbe    c040cb9e <debug_initialise+0x95e>
c040cb31:	61                   	popa   
c040cb32:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040cb36:	6c                   	insb   (%dx),%es:(%edi)
c040cb37:	65                   	gs
c040cb38:	66                   	data16
c040cb39:	74 2c                	je     c040cb67 <debug_initialise+0x927>
c040cb3b:	20 74 29 20          	and    %dh,0x20(%ecx,%ebp,1)
c040cb3f:	3c 3d                	cmp    $0x3d,%al
c040cb41:	20 30                	and    %dh,(%eax)
c040cb43:	00 76 6d             	add    %dh,0x6d(%esi)
c040cb46:	6d                   	insl   (%dx),%es:(%edi)
c040cb47:	5f                   	pop    %edi
c040cb48:	63 6d 70             	arpl   %bp,0x70(%ebp)
c040cb4b:	5f                   	pop    %edi
c040cb4c:	76 6d                	jbe    c040cbbb <debug_initialise+0x97b>
c040cb4e:	61                   	popa   
c040cb4f:	28 74 2c 20          	sub    %dh,0x20(%esp,%ebp,1)
c040cb53:	74 2d                	je     c040cb82 <debug_initialise+0x942>
c040cb55:	3e 72 69             	jb,pt  c040cbc1 <debug_initialise+0x981>
c040cb58:	67 68 74 29 20 3c    	addr16 push $0x3c202974
c040cb5e:	3d 20 30 00 00       	cmp    $0x3020,%eax
c040cb63:	00 74 2d 3e          	add    %dh,0x3e(%ebp,%ebp,1)
c040cb67:	6c                   	insb   (%dx),%es:(%edi)
c040cb68:	65                   	gs
c040cb69:	66                   	data16
c040cb6a:	74 20                	je     c040cb8c <debug_initialise+0x94c>
c040cb6c:	3d 3d 20 4e 55       	cmp    $0x554e203d,%eax
c040cb71:	4c                   	dec    %esp
c040cb72:	4c                   	dec    %esp
c040cb73:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040cb77:	53                   	push   %ebx
c040cb78:	47                   	inc    %edi
c040cb79:	4c                   	dec    %esp
c040cb7a:	49                   	dec    %ecx
c040cb7b:	42                   	inc    %edx
c040cb7c:	5f                   	pop    %edi
c040cb7d:	5f                   	pop    %edi
c040cb7e:	5f                   	pop    %edi
c040cb7f:	47                   	inc    %edi
c040cb80:	45                   	inc    %ebp
c040cb81:	54                   	push   %esp
c040cb82:	5f                   	pop    %edi
c040cb83:	56                   	push   %esi
c040cb84:	41                   	inc    %ecx
c040cb85:	4c                   	dec    %esp
c040cb86:	55                   	push   %ebp
c040cb87:	45                   	inc    %ebp
c040cb88:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040cb8c:	6c                   	insb   (%dx),%es:(%edi)
c040cb8d:	65                   	gs
c040cb8e:	66                   	data16
c040cb8f:	74 2d                	je     c040cbbe <debug_initialise+0x97e>
c040cb91:	3e 63 6f 6c          	arpl   %bp,%ds:0x6c(%edi)
c040cb95:	6f                   	outsl  %ds:(%esi),(%dx)
c040cb96:	75 72                	jne    c040cc0a <debug_initialise+0x9ca>
c040cb98:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040cb9e:	00 00                	add    %al,(%eax)
c040cba0:	74 2d                	je     c040cbcf <debug_initialise+0x98f>
c040cba2:	3e 72 69             	jb,pt  c040cc0e <debug_initialise+0x9ce>
c040cba5:	67 68 74 20 3d 3d    	addr16 push $0x3d3d2074
c040cbab:	20 4e 55             	and    %cl,0x55(%esi)
c040cbae:	4c                   	dec    %esp
c040cbaf:	4c                   	dec    %esp
c040cbb0:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040cbb4:	53                   	push   %ebx
c040cbb5:	47                   	inc    %edi
c040cbb6:	4c                   	dec    %esp
c040cbb7:	49                   	dec    %ecx
c040cbb8:	42                   	inc    %edx
c040cbb9:	5f                   	pop    %edi
c040cbba:	5f                   	pop    %edi
c040cbbb:	5f                   	pop    %edi
c040cbbc:	47                   	inc    %edi
c040cbbd:	45                   	inc    %ebp
c040cbbe:	54                   	push   %esp
c040cbbf:	5f                   	pop    %edi
c040cbc0:	56                   	push   %esi
c040cbc1:	41                   	inc    %ecx
c040cbc2:	4c                   	dec    %esp
c040cbc3:	55                   	push   %ebp
c040cbc4:	45                   	inc    %ebp
c040cbc5:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040cbc9:	72 69                	jb     c040cc34 <debug_initialise+0x9f4>
c040cbcb:	67 68 74 2d 3e 63    	addr16 push $0x633e2d74
c040cbd1:	6f                   	outsl  %ds:(%esi),(%dx)
c040cbd2:	6c                   	insb   (%dx),%es:(%edi)
c040cbd3:	6f                   	outsl  %ds:(%esi),(%dx)
c040cbd4:	75 72                	jne    c040cc48 <debug_initialise+0xa08>
c040cbd6:	29 3d 3d 30 00 00    	sub    %edi,0x303d
c040cbdc:	74 3d                	je     c040cc1b <debug_initialise+0x9db>
c040cbde:	3d 4e 55 4c 4c       	cmp    $0x4c4c554e,%eax
c040cbe3:	20 7c 7c 20          	and    %bh,0x20(%esp,%edi,2)
c040cbe7:	53                   	push   %ebx
c040cbe8:	47                   	inc    %edi
c040cbe9:	4c                   	dec    %esp
c040cbea:	49                   	dec    %ecx
c040cbeb:	42                   	inc    %edx
c040cbec:	5f                   	pop    %edi
c040cbed:	5f                   	pop    %edi
c040cbee:	5f                   	pop    %edi
c040cbef:	47                   	inc    %edi
c040cbf0:	45                   	inc    %ebp
c040cbf1:	54                   	push   %esp
c040cbf2:	5f                   	pop    %edi
c040cbf3:	56                   	push   %esi
c040cbf4:	41                   	inc    %ecx
c040cbf5:	4c                   	dec    %esp
c040cbf6:	55                   	push   %ebp
c040cbf7:	45                   	inc    %ebp
c040cbf8:	28 74 2d 3e          	sub    %dh,0x3e(%ebp,%ebp,1)
c040cbfc:	63 6f 6c             	arpl   %bp,0x6c(%edi)
c040cbff:	6f                   	outsl  %ds:(%esi),(%dx)
c040cc00:	75 72                	jne    c040cc74 <debug_initialise+0xa34>
c040cc02:	29 20                	sub    %esp,(%eax)
c040cc04:	3d 3d 20 30 00       	cmp    $0x30203d,%eax
c040cc09:	00 00                	add    %al,(%eax)
c040cc0b:	00 5b 76             	add    %bl,0x76(%ebx)
c040cc0e:	6d                   	insl   (%dx),%es:(%edi)
c040cc0f:	6d                   	insl   (%dx),%es:(%edi)
c040cc10:	3a 25 69 5d 20 4f    	cmp    0x4f205d69,%ah
c040cc16:	4d                   	dec    %ebp
c040cc17:	47                   	inc    %edi
c040cc18:	57                   	push   %edi
c040cc19:	54                   	push   %esp
c040cc1a:	46                   	inc    %esi
c040cc1b:	20 70 61             	and    %dh,0x61(%eax)
c040cc1e:	67 65 20 63 6c       	addr16 and %ah,%gs:0x6c(%bp,%di)
c040cc23:	61                   	popa   
c040cc24:	69 6d 65 64 20 74 6f 	imul   $0x6f742064,0x65(%ebp),%ebp
c040cc2b:	20 68 61             	and    %ch,0x61(%eax)
c040cc2e:	76 65                	jbe    c040cc95 <debug_initialise+0xa55>
c040cc30:	20 70 68             	and    %dh,0x68(%eax)
c040cc33:	79 73                	jns    c040cca8 <debug_initialise+0xa68>
c040cc35:	69 63 61 6c 20 6d 65 	imul   $0x656d206c,0x61(%ebx),%esp
c040cc3c:	6d                   	insl   (%dx),%es:(%edi)
c040cc3d:	6f                   	outsl  %ds:(%esi),(%dx)
c040cc3e:	72 79                	jb     c040ccb9 <debug_initialise+0xa79>
c040cc40:	20 2d 20 62 75 74    	and    %ch,0x74756220
c040cc46:	20 64 6f 65          	and    %ah,0x65(%edi,%ebp,2)
c040cc4a:	73 6e                	jae    c040ccba <debug_initialise+0xa7a>
c040cc4c:	27                   	daa    
c040cc4d:	74 0a                	je     c040cc59 <debug_initialise+0xa19>
c040cc4f:	00 6a 75             	add    %ch,0x75(%edx)
c040cc52:	40                   	inc    %eax
c040cc53:	c0 09 76             	rorb   $0x76,(%ecx)
c040cc56:	40                   	inc    %eax
c040cc57:	c0 04 75 40 c0 5a 76 	rolb   $0x40,0x765ac040(,%esi,2)
c040cc5e:	40 
c040cc5f:	c0 54 76 40 c0       	rclb   $0xc0,0x40(%esi,%esi,2)
c040cc64:	5b                   	pop    %ebx
c040cc65:	70 61                	jo     c040ccc8 <debug_initialise+0xa88>
c040cc67:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040cc6b:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040cc72:	54                   	push   %esp
c040cc73:	46                   	inc    %esi
c040cc74:	20 75 73             	and    %dh,0x73(%ebp)
c040cc77:	65                   	gs
c040cc78:	72 73                	jb     c040cced <debug_initialise+0xaad>
c040cc7a:	70 61                	jo     c040ccdd <debug_initialise+0xa9d>
c040cc7c:	63 65 20             	arpl   %sp,0x20(%ebp)
c040cc7f:	70 61                	jo     c040cce2 <debug_initialise+0xaa2>
c040cc81:	67 65 20 6d 61       	addr16 and %ch,%gs:0x61(%di)
c040cc86:	6e                   	outsb  %ds:(%esi),(%dx)
c040cc87:	61                   	popa   
c040cc88:	67                   	addr16
c040cc89:	65                   	gs
c040cc8a:	72 20                	jb     c040ccac <debug_initialise+0xa6c>
c040cc8c:	68 61 73 20 67       	push   $0x67207361
c040cc91:	6f                   	outsl  %ds:(%esi),(%dx)
c040cc92:	6e                   	outsb  %ds:(%esi),(%dx)
c040cc93:	65 20 41 57          	and    %al,%gs:0x57(%ecx)
c040cc97:	4f                   	dec    %edi
c040cc98:	4c                   	dec    %esp
c040cc99:	0a 20                	or     (%eax),%ah
c040cc9b:	20 20                	and    %ah,(%eax)
c040cc9d:	20 20                	and    %ah,(%eax)
c040cc9f:	20 20                	and    %ah,(%eax)
c040cca1:	20 20                	and    %ah,(%eax)
c040cca3:	20 74 72 69          	and    %dh,0x69(%edx,%esi,2)
c040cca7:	65 64 20 74 61 6c    	and    %dh,%fs:%gs:0x6c(%ecx,%eiz,2)
c040ccad:	6b 69 6e 67          	imul   $0x67,0x6e(%ecx),%ebp
c040ccb1:	20 74 6f 20          	and    %dh,0x20(%edi,%ebp,2)
c040ccb5:	70 72                	jo     c040cd29 <debug_initialise+0xae9>
c040ccb7:	6f                   	outsl  %ds:(%esi),(%dx)
c040ccb8:	63 20                	arpl   %sp,(%eax)
c040ccba:	25 69 20 28 25       	and    $0x25282069,%eax
c040ccbf:	70 29                	jo     c040ccea <debug_initialise+0xaaa>
c040ccc1:	20 77 68             	and    %dh,0x68(%edi)
c040ccc4:	69 6c 65 20 63 6c 6f 	imul   $0x6e6f6c63,0x20(%ebp,%eiz,2),%ebp
c040cccb:	6e 
c040cccc:	69 6e 67 20 25 69 20 	imul   $0x20692520,0x67(%esi),%ebp
c040ccd3:	28 25 70 29 0a 00    	sub    %ah,0xa2970
c040ccd9:	00 00                	add    %al,(%eax)
c040ccdb:	00 5b 70             	add    %bl,0x70(%ebx)
c040ccde:	61                   	popa   
c040ccdf:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040cce3:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040ccea:	54                   	push   %esp
c040cceb:	46                   	inc    %esi
c040ccec:	20 75 73             	and    %dh,0x73(%ebp)
c040ccef:	65                   	gs
c040ccf0:	72 73                	jb     c040cd65 <debug_initialise+0xb25>
c040ccf2:	70 61                	jo     c040cd55 <debug_initialise+0xb15>
c040ccf4:	63 65 20             	arpl   %sp,0x20(%ebp)
c040ccf7:	70 61                	jo     c040cd5a <debug_initialise+0xb1a>
c040ccf9:	67 65 20 6d 61       	addr16 and %ch,%gs:0x61(%di)
c040ccfe:	6e                   	outsb  %ds:(%esi),(%dx)
c040ccff:	61                   	popa   
c040cd00:	67                   	addr16
c040cd01:	65                   	gs
c040cd02:	72 20                	jb     c040cd24 <debug_initialise+0xae4>
c040cd04:	68 61 73 20 67       	push   $0x67207361
c040cd09:	6f                   	outsl  %ds:(%esi),(%dx)
c040cd0a:	6e                   	outsb  %ds:(%esi),(%dx)
c040cd0b:	65 20 41 57          	and    %al,%gs:0x57(%ecx)
c040cd0f:	4f                   	dec    %edi
c040cd10:	4c                   	dec    %esp
c040cd11:	0a 20                	or     (%eax),%ah
c040cd13:	20 20                	and    %ah,(%eax)
c040cd15:	20 20                	and    %ah,(%eax)
c040cd17:	20 20                	and    %ah,(%eax)
c040cd19:	74 72                	je     c040cd8d <debug_initialise+0xb4d>
c040cd1b:	69 65 64 20 73 69 67 	imul   $0x67697320,0x64(%ebp),%esp
c040cd22:	6e                   	outsb  %ds:(%esi),(%dx)
c040cd23:	61                   	popa   
c040cd24:	6c                   	insb   (%dx),%es:(%edi)
c040cd25:	6c                   	insb   (%dx),%es:(%edi)
c040cd26:	69 6e 67 20 70 72 6f 	imul   $0x6f727020,0x67(%esi),%ebp
c040cd2d:	63 20                	arpl   %sp,(%eax)
c040cd2f:	25 69 20 28 25       	and    $0x25282069,%eax
c040cd34:	70 29                	jo     c040cd5f <debug_initialise+0xb1f>
c040cd36:	20 77 68             	and    %dh,0x68(%edi)
c040cd39:	69 6c 65 20 74 65 61 	imul   $0x72616574,0x20(%ebp,%eiz,2),%ebp
c040cd40:	72 
c040cd41:	69 6e 67 20 64 6f 77 	imul   $0x776f6420,0x67(%esi),%ebp
c040cd48:	6e                   	outsb  %ds:(%esi),(%dx)
c040cd49:	20 25 69 20 28 25    	and    %ah,0x25282069
c040cd4f:	70 29                	jo     c040cd7a <debug_initialise+0xb3a>
c040cd51:	0a 00                	or     (%eax),%al
c040cd53:	00 5b 70             	add    %bl,0x70(%ebx)
c040cd56:	61                   	popa   
c040cd57:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040cd5b:	69 5d 20 4f 4d 47 57 	imul   $0x57474d4f,0x20(%ebp),%ebx
c040cd62:	54                   	push   %esp
c040cd63:	46                   	inc    %esi
c040cd64:	20 62 61             	and    %ah,0x61(%edx)
c040cd67:	64 20 70 61          	and    %dh,%fs:0x61(%eax)
c040cd6b:	67 65 20 64 69       	addr16 and %ah,%gs:0x69(%si)
c040cd70:	72 65                	jb     c040cdd7 <debug_initialise+0xb97>
c040cd72:	63 74 6f 72          	arpl   %si,0x72(%edi,%ebp,2)
c040cd76:	79 20                	jns    c040cd98 <debug_initialise+0xb58>
c040cd78:	70 6f                	jo     c040cde9 <debug_initialise+0xba9>
c040cd7a:	69 6e 74 65 72 20 74 	imul   $0x74207265,0x74(%esi),%ebp
c040cd81:	6f                   	outsl  %ds:(%esi),(%dx)
c040cd82:	20 70 67             	and    %dh,0x67(%eax)
c040cd85:	5f                   	pop    %edi
c040cd86:	61                   	popa   
c040cd87:	64                   	fs
c040cd88:	64                   	fs
c040cd89:	5f                   	pop    %edi
c040cd8a:	34 4b                	xor    $0x4b,%al
c040cd8c:	5f                   	pop    %edi
c040cd8d:	6d                   	insl   (%dx),%es:(%edi)
c040cd8e:	61                   	popa   
c040cd8f:	70 70                	jo     c040ce01 <debug_initialise+0xbc1>
c040cd91:	69 6e 67 21 0a 20 20 	imul   $0x20200a21,0x67(%esi),%ebp
c040cd98:	20 20                	and    %ah,(%eax)
c040cd9a:	20 20                	and    %ah,(%eax)
c040cd9c:	20 20                	and    %ah,(%eax)
c040cd9e:	20 20                	and    %ah,(%eax)
c040cda0:	20 20                	and    %ah,(%eax)
c040cda2:	20 20                	and    %ah,(%eax)
c040cda4:	70 67                	jo     c040ce0d <debug_initialise+0xbcd>
c040cda6:	64 69 72 20 25 70 20 	imul   $0x76207025,%fs:0x20(%edx),%esi
c040cdad:	76 
c040cdae:	69 72 74 75 61 6c 20 	imul   $0x206c6175,0x74(%edx),%esi
c040cdb5:	25 78 20 70 68       	and    $0x68702078,%eax
c040cdba:	79 73                	jns    c040ce2f <debug_initialise+0xbef>
c040cdbc:	69 63 61 6c 20 25 78 	imul   $0x7825206c,0x61(%ebx),%esp
c040cdc3:	20 66 6c             	and    %ah,0x6c(%esi)
c040cdc6:	61                   	popa   
c040cdc7:	67 73 20             	addr16 jae c040cdea <debug_initialise+0xbaa>
c040cdca:	25 69 0a 20 20       	and    $0x20200a69,%eax
c040cdcf:	20 20                	and    %ah,(%eax)
c040cdd1:	20 20                	and    %ah,(%eax)
c040cdd3:	20 20                	and    %ah,(%eax)
c040cdd5:	20 20                	and    %ah,(%eax)
c040cdd7:	20 20                	and    %ah,(%eax)
c040cdd9:	20 20                	and    %ah,(%eax)
c040cddb:	70 67                	jo     c040ce44 <debug_initialise+0xc04>
c040cddd:	64 69 72 5f 69 6e 64 	imul   $0x65646e69,%fs:0x5f(%edx),%esi
c040cde4:	65 
c040cde5:	78 20                	js     c040ce07 <debug_initialise+0xbc7>
c040cde7:	25 69 20 70 67       	and    $0x67702069,%eax
c040cdec:	74 61                	je     c040ce4f <debug_initialise+0xc0f>
c040cdee:	62 6c 65 5f          	bound  %ebp,0x5f(%ebp,%eiz,2)
c040cdf2:	69 6e 64 65 78 20 25 	imul   $0x25207865,0x64(%esi),%ebp
c040cdf9:	69 0a 00 5b 70 61    	imul   $0x61705b00,(%edx),%ecx
c040cdff:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040ce03:	69 5d 20 76 6d 6d 20 	imul   $0x206d6d76,0x20(%ebp),%ebx
c040ce0a:	69 6e 69 74 69 61 6c 	imul   $0x6c616974,0x69(%esi),%ebp
c040ce11:	69 73 65 64 0a 00 00 	imul   $0xa64,0x65(%ebx),%esi
c040ce18:	5b                   	pop    %ebx
c040ce19:	70 61                	jo     c040ce7c <debug_initialise+0xc3c>
c040ce1b:	67 65 3a 25          	addr16 cmp %gs:(%di),%ah
c040ce1f:	69 5d 20 66 61 75 6c 	imul   $0x6c756166,0x20(%ebp),%ebx
c040ce26:	74 3a                	je     c040ce62 <debug_initialise+0xc22>
c040ce28:	20 63 6f             	and    %ah,0x6f(%ebx)
c040ce2b:	64 65 20 25 69 20 65 	and    %ah,%fs:%gs:0x69652069
c040ce32:	69 
c040ce33:	70 20                	jo     c040ce55 <debug_initialise+0xc15>
c040ce35:	25 78 20 28 25       	and    $0x25282078,%eax
c040ce3a:	78 3a                	js     c040ce76 <debug_initialise+0xc36>
c040ce3c:	25 73 29 20 66       	and    $0x66202973,%eax
c040ce41:	61                   	popa   
c040ce42:	75 6c                	jne    c040ceb0 <debug_initialise+0xc70>
c040ce44:	74 20                	je     c040ce66 <debug_initialise+0xc26>
c040ce46:	61                   	popa   
c040ce47:	74 20                	je     c040ce69 <debug_initialise+0xc29>
c040ce49:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040ce4e:	20 20                	and    %ah,(%eax)
c040ce50:	20 20                	and    %ah,(%eax)
c040ce52:	64                   	fs
c040ce53:	73 20                	jae    c040ce75 <debug_initialise+0xc35>
c040ce55:	25 78 20 65 64       	and    $0x64652078,%eax
c040ce5a:	69 20 25 78 20 65    	imul   $0x65207825,(%eax),%esp
c040ce60:	62 70 20             	bound  %esi,0x20(%eax)
c040ce63:	25 78 20 65 73       	and    $0x73652078,%eax
c040ce68:	70 20                	jo     c040ce8a <debug_initialise+0xc4a>
c040ce6a:	25 78 0a 20 20       	and    $0x20200a78,%eax
c040ce6f:	20 20                	and    %ah,(%eax)
c040ce71:	20 20                	and    %ah,(%eax)
c040ce73:	65                   	gs
c040ce74:	61                   	popa   
c040ce75:	78 20                	js     c040ce97 <debug_initialise+0xc57>
c040ce77:	25 78 20 63 73       	and    $0x73632078,%eax
c040ce7c:	20 25 78 20 65 66    	and    %ah,0x66652078
c040ce82:	6c                   	insb   (%dx),%es:(%edi)
c040ce83:	61                   	popa   
c040ce84:	67 73 20             	addr16 jae c040cea7 <debug_initialise+0xc67>
c040ce87:	25 78 20 75 73       	and    $0x73752078,%eax
c040ce8c:	65                   	gs
c040ce8d:	72 65                	jb     c040cef4 <debug_initialise+0xcb4>
c040ce8f:	73 70                	jae    c040cf01 <debug_initialise+0xcc1>
c040ce91:	20 25 78 20 73 73    	and    %ah,0x73732078
c040ce97:	20 25 78 0a 00 20    	and    %ah,0x20000a78
c040ce9d:	20 20                	and    %ah,(%eax)
c040ce9f:	20 20                	and    %ah,(%eax)
c040cea1:	20 52 65             	and    %dl,0x65(%edx)
c040cea4:	61                   	popa   
c040cea5:	73 6f                	jae    c040cf16 <debug_initialise+0xcd6>
c040cea7:	6e                   	outsb  %ds:(%esi),(%dx)
c040cea8:	3a 20                	cmp    (%eax),%ah
c040ceaa:	00 41 63             	add    %al,0x63(%ecx)
c040cead:	63 65 73             	arpl   %sp,0x73(%ebp)
c040ceb0:	73 56                	jae    c040cf08 <debug_initialise+0xcc8>
c040ceb2:	69 6f 6c 61 74 69 6f 	imul   $0x6f697461,0x6c(%edi),%ebp
c040ceb9:	6e                   	outsb  %ds:(%esi),(%dx)
c040ceba:	20 00                	and    %al,(%eax)
c040cebc:	4e                   	dec    %esi
c040cebd:	6f                   	outsl  %ds:(%esi),(%dx)
c040cebe:	74 50                	je     c040cf10 <debug_initialise+0xcd0>
c040cec0:	72 65                	jb     c040cf27 <debug_initialise+0xce7>
c040cec2:	73 65                	jae    c040cf29 <debug_initialise+0xce9>
c040cec4:	6e                   	outsb  %ds:(%esi),(%dx)
c040cec5:	74 20                	je     c040cee7 <debug_initialise+0xca7>
c040cec7:	00 57 72             	add    %dl,0x72(%edi)
c040ceca:	69 74 65 20 00 52 65 	imul   $0x61655200,0x20(%ebp,%eiz,2),%esi
c040ced1:	61 
c040ced2:	64 20 00             	and    %al,%fs:(%eax)
c040ced5:	55                   	push   %ebp
c040ced6:	73 65                	jae    c040cf3d <debug_initialise+0xcfd>
c040ced8:	72 20                	jb     c040cefa <debug_initialise+0xcba>
c040ceda:	00 4b 65             	add    %cl,0x65(%ebx)
c040cedd:	72 6e                	jb     c040cf4d <debug_initialise+0xd0d>
c040cedf:	65                   	gs
c040cee0:	6c                   	insb   (%dx),%es:(%edi)
c040cee1:	20 00                	and    %al,(%eax)
c040cee3:	52                   	push   %edx
c040cee4:	65                   	gs
c040cee5:	73 65                	jae    c040cf4c <debug_initialise+0xd0c>
c040cee7:	72 76                	jb     c040cf5f <debug_initialise+0xd1f>
c040cee9:	65 64 20 00          	and    %al,%fs:%gs:(%eax)
c040ceed:	4e                   	dec    %esi
c040ceee:	6f                   	outsl  %ds:(%esi),(%dx)
c040ceef:	45                   	inc    %ebp
c040cef0:	78 65                	js     c040cf57 <debug_initialise+0xd17>
c040cef2:	63 75 74             	arpl   %si,0x74(%ebp)
c040cef5:	65 20 00             	and    %al,%gs:(%eax)
c040cef8:	0a 00                	or     (%eax),%al
c040cefa:	00 00                	add    %al,(%eax)
c040cefc:	20 20                	and    %ah,(%eax)
c040cefe:	20 20                	and    %ah,(%eax)
c040cf00:	20 20                	and    %ah,(%eax)
c040cf02:	46                   	inc    %esi
c040cf03:	61                   	popa   
c040cf04:	75 6c                	jne    c040cf72 <debug_initialise+0xd32>
c040cf06:	74 69                	je     c040cf71 <debug_initialise+0xd31>
c040cf08:	6e                   	outsb  %ds:(%esi),(%dx)
c040cf09:	67 20 74 68          	addr16 and %dh,0x68(%si)
c040cf0d:	72 65                	jb     c040cf74 <debug_initialise+0xd34>
c040cf0f:	61                   	popa   
c040cf10:	64 3a 20             	cmp    %fs:(%eax),%ah
c040cf13:	25 69 20 28 25       	and    $0x25282069,%eax
c040cf18:	70 29                	jo     c040cf43 <debug_initialise+0xd03>
c040cf1a:	20 69 6e             	and    %ch,0x6e(%ecx)
c040cf1d:	20 70 72             	and    %dh,0x72(%eax)
c040cf20:	6f                   	outsl  %ds:(%esi),(%dx)
c040cf21:	63 65 73             	arpl   %sp,0x73(%ebp)
c040cf24:	73 20                	jae    c040cf46 <debug_initialise+0xd06>
c040cf26:	25 69 20 28 25       	and    $0x25282069,%eax
c040cf2b:	70 29                	jo     c040cf56 <debug_initialise+0xd16>
c040cf2d:	20 77 69             	and    %dh,0x69(%edi)
c040cf30:	74 68                	je     c040cf9a <debug_initialise+0xd5a>
c040cf32:	20 70 67             	and    %dh,0x67(%eax)
c040cf35:	20 64 69 72          	and    %ah,0x72(%ecx,%ebp,2)
c040cf39:	20 25 70 0a 00 00    	and    %ah,0xa70
c040cf3f:	00 20                	add    %ah,(%eax)
c040cf41:	20 20                	and    %ah,(%eax)
c040cf43:	20 20                	and    %ah,(%eax)
c040cf45:	20 50 61             	and    %dl,0x61(%eax)
c040cf48:	67 65 20 64 69       	addr16 and %ah,%gs:0x69(%si)
c040cf4d:	72 65                	jb     c040cfb4 <debug_initialise+0xd74>
c040cf4f:	63 74 6f 72          	arpl   %si,0x72(%edi,%ebp,2)
c040cf53:	79 20                	jns    c040cf75 <debug_initialise+0xd35>
c040cf55:	65 6e                	outsb  %gs:(%esi),(%dx)
c040cf57:	74 72                	je     c040cfcb <debug_initialise+0xd8b>
c040cf59:	79 20                	jns    c040cf7b <debug_initialise+0xd3b>
c040cf5b:	25 78 20 3d 20       	and    $0x203d2078,%eax
c040cf60:	25 78 0a 00 20       	and    $0x20000a78,%eax
c040cf65:	20 20                	and    %ah,(%eax)
c040cf67:	20 20                	and    %ah,(%eax)
c040cf69:	20 50 61             	and    %dl,0x61(%eax)
c040cf6c:	67 65 20 74 61       	addr16 and %dh,%gs:0x61(%si)
c040cf71:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040cf75:	65 6e                	outsb  %gs:(%esi),(%dx)
c040cf77:	74 72                	je     c040cfeb <debug_initialise+0xdab>
c040cf79:	79 20                	jns    c040cf9b <debug_initialise+0xd5b>
c040cf7b:	25 78 20 3d 20       	and    $0x203d2078,%eax
c040cf80:	25 78 0a 00 5b       	and    $0x5b000a78,%eax
c040cf85:	74 68                	je     c040cfef <debug_initialise+0xdaf>
c040cf87:	72 65                	jb     c040cfee <debug_initialise+0xdae>
c040cf89:	61                   	popa   
c040cf8a:	64 3a 25 69 5d 20 4f 	cmp    %fs:0x4f205d69,%ah
c040cf91:	4d                   	dec    %ebp
c040cf92:	47                   	inc    %edi
c040cf93:	57                   	push   %edi
c040cf94:	54                   	push   %esp
c040cf95:	46                   	inc    %esi
c040cf96:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040cf9a:	65                   	gs
c040cf9b:	61                   	popa   
c040cf9c:	64                   	fs
c040cf9d:	5f                   	pop    %edi
c040cf9e:	66 69 6e 64 5f 74    	imul   $0x745f,0x64(%esi),%bp
c040cfa4:	68 72 65 61 64       	push   $0x64616572
c040cfa9:	20 66 61             	and    %ah,0x61(%esi)
c040cfac:	69 6c 65 64 20 6f 6e 	imul   $0x206e6f20,0x64(%ebp,%eiz,2),%ebp
c040cfb3:	20 
c040cfb4:	73 61                	jae    c040d017 <debug_initialise+0xdd7>
c040cfb6:	6e                   	outsb  %ds:(%esi),(%dx)
c040cfb7:	69 74 79 20 63 68 65 	imul   $0x63656863,0x20(%ecx,%edi,2),%esi
c040cfbe:	63 
c040cfbf:	6b 2e 0a             	imul   $0xa,(%esi),%ebp
c040cfc2:	20 20                	and    %ah,(%eax)
c040cfc4:	20 20                	and    %ah,(%eax)
c040cfc6:	20 20                	and    %ah,(%eax)
c040cfc8:	20 20                	and    %ah,(%eax)
c040cfca:	20 20                	and    %ah,(%eax)
c040cfcc:	20 20                	and    %ah,(%eax)
c040cfce:	70 72                	jo     c040d042 <debug_initialise+0xe02>
c040cfd0:	6f                   	outsl  %ds:(%esi),(%dx)
c040cfd1:	63 65 73             	arpl   %sp,0x73(%ebp)
c040cfd4:	73 20                	jae    c040cff6 <debug_initialise+0xdb6>
c040cfd6:	25 70 20 74 69       	and    $0x69742070,%eax
c040cfdb:	64 20 25 69 0a 00 00 	and    %ah,%fs:0xa69
c040cfe2:	00 00                	add    %al,(%eax)
c040cfe4:	5b                   	pop    %ebx
c040cfe5:	74 68                	je     c040d04f <debug_initialise+0xe0f>
c040cfe7:	72 65                	jb     c040d04e <debug_initialise+0xe0e>
c040cfe9:	61                   	popa   
c040cfea:	64 3a 25 69 5d 20 4f 	cmp    %fs:0x4f205d69,%ah
c040cff1:	4d                   	dec    %ebp
c040cff2:	47                   	inc    %edi
c040cff3:	57                   	push   %edi
c040cff4:	54                   	push   %esp
c040cff5:	46                   	inc    %esi
c040cff6:	20 72 65             	and    %dh,0x65(%edx)
c040cff9:	74 75                	je     c040d070 <debug_initialise+0xe30>
c040cffb:	72 6e                	jb     c040d06b <debug_initialise+0xe2b>
c040cffd:	69 6e 67 20 70 68 79 	imul   $0x79687020,0x67(%esi),%ebp
c040d004:	73 69                	jae    c040d06f <debug_initialise+0xe2f>
c040d006:	63 61 6c             	arpl   %sp,0x6c(%ecx)
c040d009:	20 70 61             	and    %dh,0x61(%eax)
c040d00c:	67 65 20 66 72       	addr16 and %ah,%gs:0x72(%bp)
c040d011:	6f                   	outsl  %ds:(%esi),(%dx)
c040d012:	6d                   	insl   (%dx),%es:(%edi)
c040d013:	20 64 79 69          	and    %ah,0x69(%ecx,%edi,2)
c040d017:	6e                   	outsb  %ds:(%esi),(%dx)
c040d018:	67 20 74 68          	addr16 and %dh,0x68(%si)
c040d01c:	72 65                	jb     c040d083 <debug_initialise+0xe43>
c040d01e:	61                   	popa   
c040d01f:	64                   	fs
c040d020:	27                   	daa    
c040d021:	73 20                	jae    c040d043 <debug_initialise+0xe03>
c040d023:	73 74                	jae    c040d099 <debug_initialise+0xe59>
c040d025:	61                   	popa   
c040d026:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040d029:	66 61                	popaw  
c040d02b:	69 6c 65 64 0a 20 20 	imul   $0x2020200a,0x64(%ebp,%eiz,2),%ebp
c040d032:	20 
c040d033:	20 20                	and    %ah,(%eax)
c040d035:	20 20                	and    %ah,(%eax)
c040d037:	20 20                	and    %ah,(%eax)
c040d039:	20 20                	and    %ah,(%eax)
c040d03b:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040d03f:	65                   	gs
c040d040:	61                   	popa   
c040d041:	64 20 25 69 20 28 25 	and    %ah,%fs:0x25282069
c040d048:	70 29                	jo     c040d073 <debug_initialise+0xe33>
c040d04a:	20 70 72             	and    %dh,0x72(%eax)
c040d04d:	6f                   	outsl  %ds:(%esi),(%dx)
c040d04e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d051:	73 20                	jae    c040d073 <debug_initialise+0xe33>
c040d053:	25 69 20 28 25       	and    $0x25282069,%eax
c040d058:	70 29                	jo     c040d083 <debug_initialise+0xe43>
c040d05a:	20 75 73             	and    %dh,0x73(%ebp)
c040d05d:	72 20                	jb     c040d07f <debug_initialise+0xe3f>
c040d05f:	25 78 20 70 68       	and    $0x68702078,%eax
c040d064:	79 73                	jns    c040d0d9 <debug_initialise+0xe99>
c040d066:	20 25 78 0a 00 00    	and    %ah,0xa78
c040d06c:	5b                   	pop    %ebx
c040d06d:	70 72                	jo     c040d0e1 <debug_initialise+0xea1>
c040d06f:	6f                   	outsl  %ds:(%esi),(%dx)
c040d070:	63 3a                	arpl   %di,(%edx)
c040d072:	25 69 5d 20 69       	and    $0x69205d69,%eax
c040d077:	6e                   	outsb  %ds:(%esi),(%dx)
c040d078:	69 74 69 61 6c 69 73 	imul   $0x6573696c,0x61(%ecx,%ebp,2),%esi
c040d07f:	65 
c040d080:	64 20 70 72          	and    %dh,%fs:0x72(%eax)
c040d084:	6f                   	outsl  %ds:(%esi),(%dx)
c040d085:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d088:	73 20                	jae    c040d0aa <debug_initialise+0xe6a>
c040d08a:	68 61 73 68 20       	push   $0x20687361
c040d08f:	74 61                	je     c040d0f2 <debug_initialise+0xeb2>
c040d091:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040d095:	25 70 2e 2e 2e       	and    $0x2e2e2e70,%eax
c040d09a:	20 25 69 20 62 75    	and    %ah,0x75622069
c040d0a0:	63 6b 65             	arpl   %bp,0x65(%ebx)
c040d0a3:	74 73                	je     c040d118 <debug_initialise+0xed8>
c040d0a5:	20 25 69 20 6d 61    	and    %ah,0x616d2069
c040d0ab:	78 20                	js     c040d0cd <debug_initialise+0xe8d>
c040d0ad:	70 72                	jo     c040d121 <debug_initialise+0xee1>
c040d0af:	6f                   	outsl  %ds:(%esi),(%dx)
c040d0b0:	63 73 0a             	arpl   %si,0xa(%ebx)
c040d0b3:	00 5b 70             	add    %bl,0x70(%ebx)
c040d0b6:	72 6f                	jb     c040d127 <debug_initialise+0xee7>
c040d0b8:	63 3a                	arpl   %di,(%edx)
c040d0ba:	25 69 5d 20 66       	and    $0x66205d69,%eax
c040d0bf:	61                   	popa   
c040d0c0:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040d0c7:	20 
c040d0c8:	70 61                	jo     c040d12b <debug_initialise+0xeeb>
c040d0ca:	72 73                	jb     c040d13f <debug_initialise+0xeff>
c040d0cc:	65 20 70 61          	and    %dh,%gs:0x61(%eax)
c040d0d0:	79 6c                	jns    c040d13e <debug_initialise+0xefe>
c040d0d2:	6f                   	outsl  %ds:(%esi),(%dx)
c040d0d3:	61                   	popa   
c040d0d4:	64 20 6d 6f          	and    %ch,%fs:0x6f(%ebp)
c040d0d8:	64                   	fs
c040d0d9:	75 6c                	jne    c040d147 <debug_initialise+0xf07>
c040d0db:	65 20 61 74          	and    %ah,%gs:0x74(%ecx)
c040d0df:	20 25 78 20 21 0a    	and    %ah,0xa212078
c040d0e5:	00 00                	add    %al,(%eax)
c040d0e7:	00 5b 70             	add    %bl,0x70(%ebx)
c040d0ea:	72 6f                	jb     c040d15b <debug_initialise+0xf1b>
c040d0ec:	63 3a                	arpl   %di,(%edx)
c040d0ee:	25 69 5d 20 70       	and    $0x70205d69,%eax
c040d0f3:	72 65                	jb     c040d15a <debug_initialise+0xf1a>
c040d0f5:	70 61                	jo     c040d158 <debug_initialise+0xf18>
c040d0f7:	72 69                	jb     c040d162 <debug_initialise+0xf22>
c040d0f9:	6e                   	outsb  %ds:(%esi),(%dx)
c040d0fa:	67 20 73 79          	addr16 and %dh,0x79(%bp,%di)
c040d0fe:	73 74                	jae    c040d174 <debug_initialise+0xf34>
c040d100:	65                   	gs
c040d101:	6d                   	insl   (%dx),%es:(%edi)
c040d102:	20 70 72             	and    %dh,0x72(%eax)
c040d105:	6f                   	outsl  %ds:(%esi),(%dx)
c040d106:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d109:	73 20                	jae    c040d12b <debug_initialise+0xeeb>
c040d10b:	27                   	daa    
c040d10c:	25 73 27 2e 2e       	and    $0x2e2e2773,%eax
c040d111:	2e 0a 00             	or     %cs:(%eax),%al
c040d114:	20 20                	and    %ah,(%eax)
c040d116:	20 20                	and    %ah,(%eax)
c040d118:	20 20                	and    %ah,(%eax)
c040d11a:	20 63 6f             	and    %ah,0x6f(%ebx)
c040d11d:	64 65 3a 20          	cmp    %fs:%gs:(%eax),%ah
c040d121:	65 6e                	outsb  %gs:(%esi),(%dx)
c040d123:	74 72                	je     c040d197 <debug_initialise+0xf57>
c040d125:	79 20                	jns    c040d147 <debug_initialise+0xf07>
c040d127:	25 70 20 76 69       	and    $0x69762070,%eax
c040d12c:	72 74                	jb     c040d1a2 <debug_initialise+0xf62>
c040d12e:	20 25 70 20 70 68    	and    %ah,0x68702070
c040d134:	79 73                	jns    c040d1a9 <debug_initialise+0xf69>
c040d136:	20 25 70 20 73 69    	and    %ah,0x69732070
c040d13c:	7a 65                	jp     c040d1a3 <debug_initialise+0xf63>
c040d13e:	20 25 75 20 6d 65    	and    %ah,0x656d2075
c040d144:	6d                   	insl   (%dx),%es:(%edi)
c040d145:	73 69                	jae    c040d1b0 <debug_initialise+0xf70>
c040d147:	7a 65                	jp     c040d1ae <debug_initialise+0xf6e>
c040d149:	20 25 75 20 66 6c    	and    %ah,0x6c662075
c040d14f:	61                   	popa   
c040d150:	67 73 20             	addr16 jae c040d173 <debug_initialise+0xf33>
c040d153:	25 75 0a 00 00       	and    $0xa75,%eax
c040d158:	20 20                	and    %ah,(%eax)
c040d15a:	20 20                	and    %ah,(%eax)
c040d15c:	20 20                	and    %ah,(%eax)
c040d15e:	20 64 61 74          	and    %ah,0x74(%ecx,%eiz,2)
c040d162:	61                   	popa   
c040d163:	3a 20                	cmp    (%eax),%ah
c040d165:	20 20                	and    %ah,(%eax)
c040d167:	20 20                	and    %ah,(%eax)
c040d169:	20 20                	and    %ah,(%eax)
c040d16b:	20 20                	and    %ah,(%eax)
c040d16d:	20 76 69             	and    %dh,0x69(%esi)
c040d170:	72 74                	jb     c040d1e6 <debug_initialise+0xfa6>
c040d172:	20 25 70 20 70 68    	and    %ah,0x68702070
c040d178:	79 73                	jns    c040d1ed <debug_initialise+0xfad>
c040d17a:	20 25 70 20 73 69    	and    %ah,0x69732070
c040d180:	7a 65                	jp     c040d1e7 <debug_initialise+0xfa7>
c040d182:	20 25 75 20 6d 65    	and    %ah,0x656d2075
c040d188:	6d                   	insl   (%dx),%es:(%edi)
c040d189:	73 69                	jae    c040d1f4 <debug_initialise+0xfb4>
c040d18b:	7a 65                	jp     c040d1f2 <debug_initialise+0xfb2>
c040d18d:	20 25 75 20 66 6c    	and    %ah,0x6c662075
c040d193:	61                   	popa   
c040d194:	67 73 20             	addr16 jae c040d1b7 <debug_initialise+0xf77>
c040d197:	25 75 0a 00 00       	and    $0xa75,%eax
c040d19c:	5b                   	pop    %ebx
c040d19d:	70 72                	jo     c040d211 <debug_initialise+0xfd1>
c040d19f:	6f                   	outsl  %ds:(%esi),(%dx)
c040d1a0:	63 3a                	arpl   %di,(%edx)
c040d1a2:	25 69 5d 20 4f       	and    $0x4f205d69,%eax
c040d1a7:	4d                   	dec    %ebp
c040d1a8:	47                   	inc    %edi
c040d1a9:	57                   	push   %edi
c040d1aa:	54                   	push   %esp
c040d1ab:	46                   	inc    %esi
c040d1ac:	20 73 79             	and    %dh,0x79(%ebx)
c040d1af:	73 74                	jae    c040d225 <debug_initialise+0xfe5>
c040d1b1:	65                   	gs
c040d1b2:	6d                   	insl   (%dx),%es:(%edi)
c040d1b3:	20 70 72             	and    %dh,0x72(%eax)
c040d1b6:	6f                   	outsl  %ds:(%esi),(%dx)
c040d1b7:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d1ba:	73 20                	jae    c040d1dc <debug_initialise+0xf9c>
c040d1bc:	25 69 20 28 25       	and    $0x25282069,%eax
c040d1c1:	70 29                	jo     c040d1ec <debug_initialise+0xfac>
c040d1c3:	20 74 68 72          	and    %dh,0x72(%eax,%ebp,2)
c040d1c7:	65                   	gs
c040d1c8:	61                   	popa   
c040d1c9:	64 20 63 72          	and    %ah,%fs:0x72(%ebx)
c040d1cd:	65                   	gs
c040d1ce:	61                   	popa   
c040d1cf:	74 69                	je     c040d23a <debug_initialise+0xffa>
c040d1d1:	6f                   	outsl  %ds:(%esi),(%dx)
c040d1d2:	6e                   	outsb  %ds:(%esi),(%dx)
c040d1d3:	20 66 61             	and    %ah,0x61(%esi)
c040d1d6:	69 6c 65 64 21 0a 00 	imul   $0xa21,0x64(%ebp,%eiz,2),%ebp
c040d1dd:	00 
c040d1de:	00 00                	add    %al,(%eax)
c040d1e0:	66 61                	popaw  
c040d1e2:	69 6c 65 64 20 74 6f 	imul   $0x206f7420,0x64(%ebp,%eiz,2),%ebp
c040d1e9:	20 
c040d1ea:	63 72 65             	arpl   %si,0x65(%edx)
c040d1ed:	61                   	popa   
c040d1ee:	74 65                	je     c040d255 <debug_initialise+0x1015>
c040d1f0:	20 66 69             	and    %ah,0x69(%esi)
c040d1f3:	72 73                	jb     c040d268 <debug_initialise+0x1028>
c040d1f5:	74 20                	je     c040d217 <debug_initialise+0xfd7>
c040d1f7:	75 73                	jne    c040d26c <debug_initialise+0x102c>
c040d1f9:	65                   	gs
c040d1fa:	72 6c                	jb     c040d268 <debug_initialise+0x1028>
c040d1fc:	61                   	popa   
c040d1fd:	6e                   	outsb  %ds:(%esi),(%dx)
c040d1fe:	64 20 74 68 72       	and    %dh,%fs:0x72(%eax,%ebp,2)
c040d203:	65                   	gs
c040d204:	61                   	popa   
c040d205:	64 00 00             	add    %al,%fs:(%eax)
c040d208:	49                   	dec    %ecx
c040d209:	53                   	push   %ebx
c040d20a:	41                   	inc    %ecx
c040d20b:	00 63 61             	add    %ah,0x61(%ebx)
c040d20e:	6e                   	outsb  %ds:(%esi),(%dx)
c040d20f:	6e                   	outsb  %ds:(%esi),(%dx)
c040d210:	6f                   	outsl  %ds:(%esi),(%dx)
c040d211:	74 20                	je     c040d233 <debug_initialise+0xff3>
c040d213:	66 69 6e 64 20 61    	imul   $0x6120,0x64(%esi),%bp
c040d219:	20 6d 6f             	and    %ch,0x6f(%ebp)
c040d21c:	74 68                	je     c040d286 <debug_initialise+0x1046>
c040d21e:	65                   	gs
c040d21f:	72 62                	jb     c040d283 <debug_initialise+0x1043>
c040d221:	6f                   	outsl  %ds:(%esi),(%dx)
c040d222:	61                   	popa   
c040d223:	72 64                	jb     c040d289 <debug_initialise+0x1049>
c040d225:	20 74 69 6d          	and    %dh,0x6d(%ecx,%ebp,2)
c040d229:	65                   	gs
c040d22a:	72 20                	jb     c040d24c <debug_initialise+0x100c>
c040d22c:	74 6f                	je     c040d29d <debug_initialise+0x105d>
c040d22e:	20 63 61             	and    %ah,0x61(%ebx)
c040d231:	6c                   	insb   (%dx),%es:(%edi)
c040d232:	69 62 72 61 74 65 20 	imul   $0x20657461,0x72(%edx),%esp
c040d239:	6c                   	insb   (%dx),%es:(%edi)
c040d23a:	41                   	inc    %ecx
c040d23b:	50                   	push   %eax
c040d23c:	49                   	dec    %ecx
c040d23d:	43                   	inc    %ebx
c040d23e:	20 74 69 6d          	and    %dh,0x6d(%ecx,%ebp,2)
c040d242:	65                   	gs
c040d243:	72 00                	jb     c040d245 <debug_initialise+0x1005>
c040d245:	00 00                	add    %al,(%eax)
c040d247:	00 5b 6d             	add    %bl,0x6d(%ebx)
c040d24a:	70 3a                	jo     c040d286 <debug_initialise+0x1046>
c040d24c:	25 69 5d 20 77       	and    $0x77205d69,%eax
c040d251:	6f                   	outsl  %ds:(%esi),(%dx)
c040d252:	6b 65 20 75          	imul   $0x75,0x20(%ebp),%esp
c040d256:	70 20                	jo     c040d278 <debug_initialise+0x1038>
c040d258:	25 69 20 61 70       	and    $0x70612069,%eax
c040d25d:	70 6c                	jo     c040d2cb <debug_initialise+0x108b>
c040d25f:	69 63 61 74 69 6f 6e 	imul   $0x6e6f6974,0x61(%ebx),%esp
c040d266:	20 70 72             	and    %dh,0x72(%eax)
c040d269:	6f                   	outsl  %ds:(%esi),(%dx)
c040d26a:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d26d:	73 6f                	jae    c040d2de <debug_initialise+0x109e>
c040d26f:	72 28                	jb     c040d299 <debug_initialise+0x1059>
c040d271:	73 29                	jae    c040d29c <debug_initialise+0x105c>
c040d273:	20 6f 75             	and    %ch,0x75(%edi)
c040d276:	74 20                	je     c040d298 <debug_initialise+0x1058>
c040d278:	6f                   	outsl  %ds:(%esi),(%dx)
c040d279:	66                   	data16
c040d27a:	20 25 69 0a 00 00    	and    %ah,0xa69
c040d280:	5b                   	pop    %ebx
c040d281:	6d                   	insl   (%dx),%es:(%edi)
c040d282:	70 5d                	jo     c040d2e1 <debug_initialise+0x10a1>
c040d284:	20 61 73             	and    %ah,0x73(%ecx)
c040d287:	73 75                	jae    c040d2fe <debug_initialise+0x10be>
c040d289:	6d                   	insl   (%dx),%es:(%edi)
c040d28a:	69 6e 67 20 75 6e 69 	imul   $0x696e7520,0x67(%esi),%ebp
c040d291:	70 72                	jo     c040d305 <debug_initialise+0x10c5>
c040d293:	6f                   	outsl  %ds:(%esi),(%dx)
c040d294:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d297:	73 6f                	jae    c040d308 <debug_initialise+0x10c8>
c040d299:	72 20                	jb     c040d2bb <debug_initialise+0x107b>
c040d29b:	6d                   	insl   (%dx),%es:(%edi)
c040d29c:	61                   	popa   
c040d29d:	63 68 69             	arpl   %bp,0x69(%eax)
c040d2a0:	6e                   	outsb  %ds:(%esi),(%dx)
c040d2a1:	65 0a 00             	or     %gs:(%eax),%al
c040d2a4:	5b                   	pop    %ebx
c040d2a5:	6d                   	insl   (%dx),%es:(%edi)
c040d2a6:	70 5d                	jo     c040d305 <debug_initialise+0x10c5>
c040d2a8:	20 6d 75             	and    %ch,0x75(%ebp)
c040d2ab:	6c                   	insb   (%dx),%es:(%edi)
c040d2ac:	74 69                	je     c040d317 <debug_initialise+0x10d7>
c040d2ae:	70 72                	jo     c040d322 <debug_initialise+0x10e2>
c040d2b0:	6f                   	outsl  %ds:(%esi),(%dx)
c040d2b1:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d2b4:	73 6f                	jae    c040d325 <debug_initialise+0x10e5>
c040d2b6:	72 20                	jb     c040d2d8 <debug_initialise+0x1098>
c040d2b8:	6d                   	insl   (%dx),%es:(%edi)
c040d2b9:	61                   	popa   
c040d2ba:	63 68 69             	arpl   %bp,0x69(%eax)
c040d2bd:	6e                   	outsb  %ds:(%esi),(%dx)
c040d2be:	65 20 64 65 74       	and    %ah,%gs:0x74(%ebp,%eiz,2)
c040d2c3:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040d2c8:	0a 00                	or     (%eax),%al
c040d2ca:	5b                   	pop    %ebx
c040d2cb:	6d                   	insl   (%dx),%es:(%edi)
c040d2cc:	70 5d                	jo     c040d32b <debug_initialise+0x10eb>
c040d2ce:	20 73 79             	and    %dh,0x79(%ebx)
c040d2d1:	73 74                	jae    c040d347 <debug_initialise+0x1107>
c040d2d3:	65                   	gs
c040d2d4:	6d                   	insl   (%dx),%es:(%edi)
c040d2d5:	3a 20                	cmp    (%eax),%ah
c040d2d7:	00 25 63 00 20 00    	add    %ah,0x200063
c040d2dd:	0a 00                	or     (%eax),%al
c040d2df:	5b                   	pop    %ebx
c040d2e0:	6d                   	insl   (%dx),%es:(%edi)
c040d2e1:	70 5d                	jo     c040d340 <debug_initialise+0x1100>
c040d2e3:	20 66 6f             	and    %ah,0x6f(%esi)
c040d2e6:	75 6e                	jne    c040d356 <debug_initialise+0x1116>
c040d2e8:	64 20 63 70          	and    %ah,%fs:0x70(%ebx)
c040d2ec:	75 20                	jne    c040d30e <debug_initialise+0x10ce>
c040d2ee:	25 69 20 28 66       	and    $0x66282069,%eax
c040d2f3:	6c                   	insb   (%dx),%es:(%edi)
c040d2f4:	61                   	popa   
c040d2f5:	67 73 20             	addr16 jae c040d318 <debug_initialise+0x10d8>
c040d2f8:	25 78 29 20 00       	and    $0x202978,%eax
c040d2fd:	5b                   	pop    %ebx
c040d2fe:	62 6f 6f             	bound  %ebp,0x6f(%edi)
c040d301:	74 20                	je     c040d323 <debug_initialise+0x10e3>
c040d303:	70 72                	jo     c040d377 <debug_initialise+0x1137>
c040d305:	6f                   	outsl  %ds:(%esi),(%dx)
c040d306:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d309:	73 6f                	jae    c040d37a <debug_initialise+0x113a>
c040d30b:	72 5d                	jb     c040d36a <debug_initialise+0x112a>
c040d30d:	00 5b 61             	add    %bl,0x61(%ebx)
c040d310:	70 70                	jo     c040d382 <debug_initialise+0x1142>
c040d312:	6c                   	insb   (%dx),%es:(%edi)
c040d313:	69 63 61 74 69 6f 6e 	imul   $0x6e6f6974,0x61(%ebx),%esp
c040d31a:	20 70 72             	and    %dh,0x72(%eax)
c040d31d:	6f                   	outsl  %ds:(%esi),(%dx)
c040d31e:	63 65 73             	arpl   %sp,0x73(%ebp)
c040d321:	73 6f                	jae    c040d392 <debug_initialise+0x1152>
c040d323:	72 5d                	jb     c040d382 <debug_initialise+0x1142>
c040d325:	00 00                	add    %al,(%eax)
c040d327:	00 5b 6d             	add    %bl,0x6d(%ebx)
c040d32a:	70 5d                	jo     c040d389 <debug_initialise+0x1149>
c040d32c:	20 66 6f             	and    %ah,0x6f(%esi)
c040d32f:	75 6e                	jne    c040d39f <debug_initialise+0x115f>
c040d331:	64 20 69 6f          	and    %ch,%fs:0x6f(%ecx)
c040d335:	61                   	popa   
c040d336:	70 69                	jo     c040d3a1 <debug_initialise+0x1161>
c040d338:	63 20                	arpl   %sp,(%eax)
c040d33a:	25 69 20 28 69       	and    $0x69282069,%eax
c040d33f:	64 20 25 69 20 66 6c 	and    %ah,%fs:0x6c662069
c040d346:	61                   	popa   
c040d347:	67 73 20             	addr16 jae c040d36a <debug_initialise+0x112a>
c040d34a:	25 78 20 61 64       	and    $0x64612078,%eax
c040d34f:	64                   	fs
c040d350:	72 20                	jb     c040d372 <debug_initialise+0x1132>
c040d352:	25 70 29 0a 00       	and    $0xa2970,%eax
c040d357:	00 32                	add    %dh,(%edx)
c040d359:	3a 33                	cmp    (%ebx),%dh
c040d35b:	38 4d 00             	cmp    %cl,0x0(%ebp)
c040d35e:	00 00                	add    %al,(%eax)
c040d360:	5b                   	pop    %ebx
c040d361:	63 6f 72             	arpl   %bp,0x72(%edi)
c040d364:	65                   	gs
c040d365:	5d                   	pop    %ebp
c040d366:	20 64 69 6f          	and    %ah,0x6f(%ecx,%ebp,2)
c040d36a:	73 69                	jae    c040d3d5 <debug_initialise+0x1195>
c040d36c:	78 2d                	js     c040d39b <debug_initialise+0x115b>
c040d36e:	68 79 61 74 74       	push   $0x74746179
c040d373:	20 72 65             	and    %dh,0x65(%edx)
c040d376:	76 20                	jbe    c040d398 <debug_initialise+0x1158>
c040d378:	25 73 20 30 30       	and    $0x30302073,%eax
c040d37d:	3a 33                	cmp    (%ebx),%dh
c040d37f:	33 3a                	xor    (%edx),%edi
c040d381:	31 35 20 53 65 70    	xor    %esi,0x70655320
c040d387:	20 20                	and    %ah,(%eax)
c040d389:	36 20 32             	and    %dh,%ss:(%edx)
c040d38c:	30 31                	xor    %dh,(%ecx)
c040d38e:	30 20                	xor    %ah,(%eax)
c040d390:	28 62 75             	sub    %ah,0x75(%edx)
c040d393:	69 6c 74 20 77 69 74 	imul   $0x68746977,0x20(%esp,%esi,2),%ebp
c040d39a:	68 
c040d39b:	20 47 43             	and    %al,0x43(%edi)
c040d39e:	43                   	inc    %ebx
c040d39f:	20 34 2e             	and    %dh,(%esi,%ebp,1)
c040d3a2:	34 2e                	xor    $0x2e,%al
c040d3a4:	31 29                	xor    %ebp,(%ecx)
c040d3a6:	0a 00                	or     (%eax),%al
c040d3a8:	2a 2a                	sub    (%edx),%ch
c040d3aa:	2a 20                	sub    (%eax),%ah
c040d3ac:	77 61                	ja     c040d40f <debug_initialise+0x11cf>
c040d3ae:	72 6e                	jb     c040d41e <debug_initialise+0x11de>
c040d3b0:	69 6e 67 3a 20 62 6f 	imul   $0x6f62203a,0x67(%esi),%ebp
c040d3b7:	6f                   	outsl  %ds:(%esi),(%dx)
c040d3b8:	74 6c                	je     c040d426 <debug_initialise+0x11e6>
c040d3ba:	6f                   	outsl  %ds:(%esi),(%dx)
c040d3bb:	61                   	popa   
c040d3bc:	64                   	fs
c040d3bd:	65                   	gs
c040d3be:	72 20                	jb     c040d3e0 <debug_initialise+0x11a0>
c040d3c0:	6d                   	insl   (%dx),%es:(%edi)
c040d3c1:	61                   	popa   
c040d3c2:	67 69 63 20 77 61 73 	addr16 imul $0x20736177,0x20(%bp,%di),%esp
c040d3c9:	20 
c040d3ca:	25 78 20 28 65       	and    $0x65282078,%eax
c040d3cf:	78 70                	js     c040d441 <debug_initialise+0x1201>
c040d3d1:	65 63 74 69 6e       	arpl   %si,%gs:0x6e(%ecx,%ebp,2)
c040d3d6:	67 20 25             	addr16 and %ah,(%di)
c040d3d9:	78 29                	js     c040d404 <debug_initialise+0x11c4>
c040d3db:	2e 0a 00             	or     %cs:(%eax),%al
c040d3de:	75 6e                	jne    c040d44e <debug_initialise+0x120e>
c040d3e0:	65                   	gs
c040d3e1:	78 70                	js     c040d453 <debug_initialise+0x1213>
c040d3e3:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040d3e8:	20 65 6e             	and    %ah,0x6e(%ebp)
c040d3eb:	64                   	fs
c040d3ec:	2d 6f 66 2d 62       	sub    $0x622d666f,%eax
c040d3f1:	6f                   	outsl  %ds:(%esi),(%dx)
c040d3f2:	6f                   	outsl  %ds:(%esi),(%dx)
c040d3f3:	74 00                	je     c040d3f5 <debug_initialise+0x11b5>
c040d3f5:	00 00                	add    %al,(%eax)
c040d3f7:	00 74 72 79          	add    %dh,0x79(%edx,%esi,2)
c040d3fb:	69 6e 67 20 74 6f 20 	imul   $0x206f7420,0x67(%esi),%ebp
c040d402:	70 72                	jo     c040d476 <debug_initialise+0x1236>
c040d404:	6f                   	outsl  %ds:(%esi),(%dx)
c040d405:	62 65 20             	bound  %esp,0x20(%ebp)
c040d408:	70 61                	jo     c040d46b <debug_initialise+0x122b>
c040d40a:	79 6c                	jns    c040d478 <debug_initialise+0x1238>
c040d40c:	6f                   	outsl  %ds:(%esi),(%dx)
c040d40d:	61                   	popa   
c040d40e:	64                   	fs
c040d40f:	73 20                	jae    c040d431 <debug_initialise+0x11f1>
c040d411:	62 65 66             	bound  %esp,0x66(%ebp)
c040d414:	6f                   	outsl  %ds:(%esi),(%dx)
c040d415:	72 65                	jb     c040d47c <debug_initialise+0x123c>
c040d417:	20 70 72             	and    %dh,0x72(%eax)
c040d41a:	65 69 6e 69 74 00 5b 	imul   $0x705b0074,%gs:0x69(%esi),%ebp
c040d421:	70 
c040d422:	61                   	popa   
c040d423:	79 6c                	jns    c040d491 <debug_initialise+0x1251>
c040d425:	6f                   	outsl  %ds:(%esi),(%dx)
c040d426:	61                   	popa   
c040d427:	64 3a 25 69 5d 20 66 	cmp    %fs:0x66205d69,%ah
c040d42e:	6f                   	outsl  %ds:(%esi),(%dx)
c040d42f:	75 6e                	jne    c040d49f <debug_initialise+0x125f>
c040d431:	64 20 61 20          	and    %ah,%fs:0x20(%ecx)
c040d435:	6b 65 72 6e          	imul   $0x6e,0x72(%ebp),%esp
c040d439:	65                   	gs
c040d43a:	6c                   	insb   (%dx),%es:(%edi)
c040d43b:	20 73 79             	and    %dh,0x79(%ebx)
c040d43e:	6d                   	insl   (%dx),%es:(%edi)
c040d43f:	62 6f 6c             	bound  %ebp,0x6c(%edi)
c040d442:	20 74 61 62          	and    %dh,0x62(%ecx,%eiz,2)
c040d446:	6c                   	insb   (%dx),%es:(%edi)
c040d447:	65 20 28             	and    %ch,%gs:(%eax)
c040d44a:	25 78 20 2d 20       	and    $0x202d2078,%eax
c040d44f:	25 78 29 0a 00       	and    $0xa2978,%eax
c040d454:	5b                   	pop    %ebx
c040d455:	70 61                	jo     c040d4b8 <debug_initialise+0x1278>
c040d457:	79 6c                	jns    c040d4c5 <debug_initialise+0x1285>
c040d459:	6f                   	outsl  %ds:(%esi),(%dx)
c040d45a:	61                   	popa   
c040d45b:	64 3a 25 69 5d 20 70 	cmp    %fs:0x70205d69,%ah
c040d462:	61                   	popa   
c040d463:	72 73                	jb     c040d4d8 <debug_initialise+0x1298>
c040d465:	69 6e 67 20 62 69 6e 	imul   $0x6e696220,0x67(%esi),%ebp
c040d46c:	61                   	popa   
c040d46d:	72 79                	jb     c040d4e8 <debug_initialise+0x12a8>
c040d46f:	3a 20                	cmp    (%eax),%ah
c040d471:	25 73 20 28 25       	and    $0x25282073,%eax
c040d476:	78 29                	js     c040d4a1 <debug_initialise+0x1261>
c040d478:	00 20                	add    %ah,(%eax)
c040d47a:	2e 2e 2e 20 69 73    	and    %ch,%cs:0x73(%ecx)
c040d480:	20 6e 6f             	and    %ch,0x6f(%esi)
c040d483:	74 20                	je     c040d4a5 <debug_initialise+0x1265>
c040d485:	61                   	popa   
c040d486:	20 76 61             	and    %dh,0x61(%esi)
c040d489:	6c                   	insb   (%dx),%es:(%edi)
c040d48a:	69 64 20 45 4c 46 0a 	imul   $0xa464c,0x45(%eax,%eiz,1),%esp
c040d491:	00 
c040d492:	00 00                	add    %al,(%eax)
c040d494:	20 2e                	and    %ch,(%esi)
c040d496:	2e 2e 20 69 73       	and    %ch,%cs:0x73(%ecx)
c040d49b:	20 69 6e             	and    %ch,0x6e(%ecx)
c040d49e:	63 6f 6d             	arpl   %bp,0x6d(%edi)
c040d4a1:	70 61                	jo     c040d504 <debug_initialise+0x12c4>
c040d4a3:	74 69                	je     c040d50e <debug_initialise+0x12ce>
c040d4a5:	62 6c 65 20          	bound  %ebp,0x20(%ebp,%eiz,2)
c040d4a9:	77 69                	ja     c040d514 <debug_initialise+0x12d4>
c040d4ab:	74 68                	je     c040d515 <debug_initialise+0x12d5>
c040d4ad:	20 74 68 69          	and    %dh,0x69(%eax,%ebp,2)
c040d4b1:	73 20                	jae    c040d4d3 <debug_initialise+0x1293>
c040d4b3:	6d                   	insl   (%dx),%es:(%edi)
c040d4b4:	61                   	popa   
c040d4b5:	63 68 69             	arpl   %bp,0x69(%eax)
c040d4b8:	6e                   	outsb  %ds:(%esi),(%dx)
c040d4b9:	65 20 28             	and    %ch,%gs:(%eax)
c040d4bc:	25 78 29 0a 00       	and    $0xa2978,%eax
c040d4c1:	20 2e                	and    %ch,(%esi)
c040d4c3:	2e 2e 20 68 61       	and    %ch,%cs:0x61(%eax)
c040d4c8:	73 20                	jae    c040d4ea <debug_initialise+0x12aa>
c040d4ca:	75 6e                	jne    c040d53a <debug_initialise+0x12fa>
c040d4cc:	65                   	gs
c040d4cd:	78 70                	js     c040d53f <debug_initialise+0x12ff>
c040d4cf:	65 63 74 65 64       	arpl   %si,%gs:0x64(%ebp,%eiz,2)
c040d4d4:	20 61 72             	and    %ah,0x72(%ecx)
c040d4d7:	65                   	gs
c040d4d8:	61                   	popa   
c040d4d9:	73 21                	jae    c040d4fc <debug_initialise+0x12bc>
c040d4db:	0a 00                	or     (%eax),%al
c040d4dd:	20 2e                	and    %ch,(%esi)
c040d4df:	2e 2e 20 64 6f 6e    	and    %ah,%cs:0x6e(%edi,%ebp,2)
c040d4e5:	65 0a 00             	or     %gs:(%eax),%al
c040d4e8:	5b                   	pop    %ebx
c040d4e9:	70 61                	jo     c040d54c <debug_initialise+0x130c>
c040d4eb:	79 6c                	jns    c040d559 <debug_initialise+0x1319>
c040d4ed:	6f                   	outsl  %ds:(%esi),(%dx)
c040d4ee:	61                   	popa   
c040d4ef:	64 3a 25 69 5d 20 4e 	cmp    %fs:0x4e205d69,%ah
c040d4f6:	6f                   	outsl  %ds:(%esi),(%dx)
c040d4f7:	20 6d 6f             	and    %ch,0x6f(%ebp)
c040d4fa:	64                   	fs
c040d4fb:	75 6c                	jne    c040d569 <debug_initialise+0x1329>
c040d4fd:	65                   	gs
c040d4fe:	73 20                	jae    c040d520 <debug_initialise+0x12e0>
c040d500:	6c                   	insb   (%dx),%es:(%edi)
c040d501:	6f                   	outsl  %ds:(%esi),(%dx)
c040d502:	61                   	popa   
c040d503:	64 65 64 20 77 69    	and    %dh,%fs:%gs:0x69(%edi)
c040d509:	74 68                	je     c040d573 <debug_initialise+0x1333>
c040d50b:	20 6b 65             	and    %ch,0x65(%ebx)
c040d50e:	72 6e                	jb     c040d57e <debug_initialise+0x133e>
c040d510:	65                   	gs
c040d511:	6c                   	insb   (%dx),%es:(%edi)
c040d512:	2e 0a 00             	or     %cs:(%eax),%al
c040d515:	00 00                	add    %al,(%eax)
c040d517:	00 5b 70             	add    %bl,0x70(%ebx)
c040d51a:	61                   	popa   
c040d51b:	79 6c                	jns    c040d589 <debug_initialise+0x1349>
c040d51d:	6f                   	outsl  %ds:(%esi),(%dx)
c040d51e:	61                   	popa   
c040d51f:	64 3a 25 69 5d 20 25 	cmp    %fs:0x25205d69,%ah
c040d526:	69 20 6d 6f 64 75    	imul   $0x75646f6d,(%eax),%esp
c040d52c:	6c                   	insb   (%dx),%es:(%edi)
c040d52d:	65 28 73 29          	sub    %dh,%gs:0x29(%ebx)
c040d531:	20 69 6e             	and    %ch,0x6e(%ecx)
c040d534:	20 70 61             	and    %dh,0x61(%eax)
c040d537:	79 6c                	jns    c040d5a5 <debug_initialise+0x1365>
c040d539:	6f                   	outsl  %ds:(%esi),(%dx)
c040d53a:	61                   	popa   
c040d53b:	64 0a 00             	or     %fs:(%eax),%al
c040d53e:	00 00                	add    %al,(%eax)
c040d540:	5b                   	pop    %ebx
c040d541:	64 65 62 75 67       	bound  %esi,%fs:%gs:0x67(%ebp)
c040d546:	3a 25 69 5d 20 6b    	cmp    0x6b205d69,%ah
c040d54c:	65                   	gs
c040d54d:	72 6e                	jb     c040d5bd <debug_initialise+0x137d>
c040d54f:	65                   	gs
c040d550:	6c                   	insb   (%dx),%es:(%edi)
c040d551:	20 73 74             	and    %dh,0x74(%ebx)
c040d554:	61                   	popa   
c040d555:	63 6b 20             	arpl   %bp,0x20(%ebx)
c040d558:	62 61 63             	bound  %esp,0x63(%ecx)
c040d55b:	6b 74 72 61 63       	imul   $0x63,0x61(%edx,%esi,2),%esi
c040d560:	65 20 72 65          	and    %dh,%gs:0x65(%edx)
c040d564:	71 75                	jno    c040d5db <debug_initialise+0x139b>
c040d566:	65                   	gs
c040d567:	73 74                	jae    c040d5dd <debug_initialise+0x139d>
c040d569:	65 64 3a 20          	cmp    %fs:%gs:(%eax),%ah
c040d56d:	62 61 73             	bound  %esp,0x73(%ecx)
c040d570:	65 20 25 70 20 73 74 	and    %ah,%gs:0x74732070
c040d577:	61                   	popa   
c040d578:	63 6b 70             	arpl   %bp,0x70(%ebx)
c040d57b:	74 72                	je     c040d5ef <debug_initialise+0x13af>
c040d57d:	20 25 70 20 73 69    	and    %ah,0x69732070
c040d583:	7a 65                	jp     c040d5ea <debug_initialise+0x13aa>
c040d585:	20 25 69 20 28 74    	and    %ah,0x74282069
c040d58b:	69 64 20 25 69 20 70 	imul   $0x69702069,0x25(%eax,%eiz,1),%esp
c040d592:	69 
c040d593:	64 20 25 69 29 0a 00 	and    %ah,%fs:0xa2969
c040d59a:	00 00                	add    %al,(%eax)
c040d59c:	20 20                	and    %ah,(%eax)
c040d59e:	20 20                	and    %ah,(%eax)
c040d5a0:	20 20                	and    %ah,(%eax)
c040d5a2:	20 20                	and    %ah,(%eax)
c040d5a4:	5b                   	pop    %ebx
c040d5a5:	30 78 25             	xor    %bh,0x25(%eax)
c040d5a8:	70 5d                	jo     c040d607 <debug_initialise+0x13c7>
c040d5aa:	20 20                	and    %ah,(%eax)
c040d5ac:	30 78 25             	xor    %bh,0x25(%eax)
c040d5af:	78 20                	js     c040d5d1 <debug_initialise+0x1391>
c040d5b1:	5b                   	pop    %ebx
c040d5b2:	66                   	data16
c040d5b3:	75 6e                	jne    c040d623 <debug_initialise+0x13e3>
c040d5b5:	63 20                	arpl   %sp,(%eax)
c040d5b7:	25 73 20 2b 20       	and    $0x202b2073,%eax
c040d5bc:	30 78 25             	xor    %bh,0x25(%eax)
c040d5bf:	78 5d                	js     c040d61e <debug_initialise+0x13de>
c040d5c1:	0a 00                	or     (%eax),%al
c040d5c3:	0a 00                	or     (%eax),%al
c040d5c5:	00 00                	add    %al,(%eax)
c040d5c7:	00 5b 64             	add    %bl,0x64(%ebx)
c040d5ca:	65 62 75 67          	bound  %esi,%gs:0x67(%ebp)
c040d5ce:	5d                   	pop    %ebp
c040d5cf:	20 61 73             	and    %ah,0x73(%ecx)
c040d5d2:	73 65                	jae    c040d639 <debug_initialise+0x13f9>
c040d5d4:	72 74                	jb     c040d64a <debug_initialise+0x140a>
c040d5d6:	28 25 73 29 20 66    	sub    %ah,0x66202973
c040d5dc:	61                   	popa   
c040d5dd:	69 6c 65 64 20 69 6e 	imul   $0x206e6920,0x64(%ebp,%eiz,2),%ebp
c040d5e4:	20 
c040d5e5:	66 69 6c 65 20 25 73 	imul   $0x7325,0x20(%ebp,%eiz,2),%bp
c040d5ec:	20 28                	and    %ch,(%eax)
c040d5ee:	69 6e 63 6c 75 64 65 	imul   $0x6564756c,0x63(%esi),%ebp
c040d5f5:	64 20 66 72          	and    %ah,%fs:0x72(%esi)
c040d5f9:	6f                   	outsl  %ds:(%esi),(%dx)
c040d5fa:	6d                   	insl   (%dx),%es:(%edi)
c040d5fb:	20 25 73 29 2c 20    	and    %ah,0x202c2973
c040d601:	6c                   	insb   (%dx),%es:(%edi)
c040d602:	69 6e 65 20 25 64 0a 	imul   $0xa642520,0x65(%esi),%ebp
c040d609:	00 61 73             	add    %ah,0x73(%ecx)
c040d60c:	73 65                	jae    c040d673 <debug_initialise+0x1433>
c040d60e:	72 74                	jb     c040d684 <debug_initialise+0x1444>
c040d610:	28 29                	sub    %ch,(%ecx)
c040d612:	20 66 61             	and    %ah,0x61(%esi)
c040d615:	69 6c 65 64 00 2a 2a 	imul   $0x2a2a2a00,0x64(%ebp,%eiz,2),%ebp
c040d61c:	2a 
c040d61d:	20 50 41             	and    %dl,0x41(%eax)
c040d620:	4e                   	dec    %esi
c040d621:	49                   	dec    %ecx
c040d622:	43                   	inc    %ebx
c040d623:	3a 20                	cmp    (%eax),%ah
c040d625:	25 73 20 2d 2d       	and    $0x2d2d2073,%eax
c040d62a:	20 68 61             	and    %ch,0x61(%eax)
c040d62d:	6c                   	insb   (%dx),%es:(%edi)
c040d62e:	74 69                	je     c040d699 <debug_initialise+0x1459>
c040d630:	6e                   	outsb  %ds:(%esi),(%dx)
c040d631:	67 0a 00             	addr16 or (%bx,%si),%al
c040d634:	1d ba 40 c0 53       	sbb    $0x53c040ba,%eax
c040d639:	ba 40 c0 ec ba       	mov    $0xbaecc040,%edx
c040d63e:	40                   	inc    %eax
c040d63f:	c0 2b bb             	shrb   $0xbb,(%ebx)
c040d642:	40                   	inc    %eax
c040d643:	c0 7c bb 40 c0       	sarb   $0xc0,0x40(%ebx,%edi,4)
c040d648:	ac                   	lods   %ds:(%esi),%al
c040d649:	bb 40 c0 4d be       	mov    $0xbe4dc040,%ebx
c040d64e:	40                   	inc    %eax
c040d64f:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d653:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d657:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d65b:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d65f:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d663:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d667:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d66b:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d66f:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d673:	c0 ed bc             	shr    $0xbc,%ch
c040d676:	40                   	inc    %eax
c040d677:	c0 bb bb 40 c0 4d be 	sarb   $0xbe,0x4dc040bb(%ebx)
c040d67e:	40                   	inc    %eax
c040d67f:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d683:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d687:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d68b:	c0 bb bb 40 c0 4d be 	sarb   $0xbe,0x4dc040bb(%ebx)
c040d692:	40                   	inc    %eax
c040d693:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d697:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d69b:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d69f:	c0                   	(bad)  
c040d6a0:	b1 bb                	mov    $0xbb,%cl
c040d6a2:	40                   	inc    %eax
c040d6a3:	c0 ca bb             	ror    $0xbb,%dl
c040d6a6:	40                   	inc    %eax
c040d6a7:	c0                   	(bad)  
c040d6a8:	b1 bb                	mov    $0xbb,%cl
c040d6aa:	40                   	inc    %eax
c040d6ab:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d6af:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d6b3:	c0 14 bd 40 c0 4d be 	rclb   $0x40,-0x41b23fc0(,%edi,4)
c040d6ba:	40 
c040d6bb:	c0 c0 bb             	rol    $0xbb,%al
c040d6be:	40                   	inc    %eax
c040d6bf:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d6c3:	c0 4d be 40          	rorb   $0x40,-0x42(%ebp)
c040d6c7:	c0                   	(bad)  
c040d6c8:	b1 bb                	mov    $0xbb,%cl
c040d6ca:	40                   	inc    %eax
c040d6cb:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d6ce:	40                   	inc    %eax
c040d6cf:	c0 53 bf 40          	rclb   $0x40,-0x41(%ebx)
c040d6d3:	c0 60 bf 40          	shlb   $0x40,-0x41(%eax)
c040d6d7:	c0 6f bf 40          	shrb   $0x40,-0x41(%edi)
c040d6db:	c0 82 bf 40 c0 92 bf 	rolb   $0xbf,-0x6d3fbf41(%edx)
c040d6e2:	40                   	inc    %eax
c040d6e3:	c0 a6 bf 40 c0 bb bf 	shlb   $0xbf,-0x443fbf41(%esi)
c040d6ea:	40                   	inc    %eax
c040d6eb:	c0 d3 bf             	rcl    $0xbf,%bl
c040d6ee:	40                   	inc    %eax
c040d6ef:	c0 e3 bf             	shl    $0xbf,%bl
c040d6f2:	40                   	inc    %eax
c040d6f3:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d6f6:	40                   	inc    %eax
c040d6f7:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d6fa:	40                   	inc    %eax
c040d6fb:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d6fe:	40                   	inc    %eax
c040d6ff:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d702:	40                   	inc    %eax
c040d703:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d706:	40                   	inc    %eax
c040d707:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d70a:	40                   	inc    %eax
c040d70b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d70e:	40                   	inc    %eax
c040d70f:	c0                   	(bad)  
c040d710:	f7 bf 40 c0 0d c0    	idivl  -0x3ff23fc0(%edi)
c040d716:	40                   	inc    %eax
c040d717:	c0 25 c0 40 c0 3b c0 	shlb   $0xc0,0x3bc040c0
c040d71e:	40                   	inc    %eax
c040d71f:	c0 53 c0 40          	rclb   $0x40,-0x40(%ebx)
c040d723:	c0 6f c0 40          	shrb   $0x40,-0x40(%edi)
c040d727:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d72a:	40                   	inc    %eax
c040d72b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d72e:	40                   	inc    %eax
c040d72f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d732:	40                   	inc    %eax
c040d733:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d736:	40                   	inc    %eax
c040d737:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d73a:	40                   	inc    %eax
c040d73b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d73e:	40                   	inc    %eax
c040d73f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d742:	40                   	inc    %eax
c040d743:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d746:	40                   	inc    %eax
c040d747:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d74a:	40                   	inc    %eax
c040d74b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d74e:	40                   	inc    %eax
c040d74f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d752:	40                   	inc    %eax
c040d753:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d756:	40                   	inc    %eax
c040d757:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d75a:	40                   	inc    %eax
c040d75b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d75e:	40                   	inc    %eax
c040d75f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d762:	40                   	inc    %eax
c040d763:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d766:	40                   	inc    %eax
c040d767:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d76a:	40                   	inc    %eax
c040d76b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d76e:	40                   	inc    %eax
c040d76f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d772:	40                   	inc    %eax
c040d773:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d776:	40                   	inc    %eax
c040d777:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d77a:	40                   	inc    %eax
c040d77b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d77e:	40                   	inc    %eax
c040d77f:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d782:	40                   	inc    %eax
c040d783:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d786:	40                   	inc    %eax
c040d787:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d78a:	40                   	inc    %eax
c040d78b:	c0 0b c1             	rorb   $0xc1,(%ebx)
c040d78e:	40                   	inc    %eax
c040d78f:	c0 8b c0 40 c0 9e c0 	rorb   $0xc0,-0x613fbf40(%ebx)
c040d796:	40                   	inc    %eax
c040d797:	c0                   	(bad)  
c040d798:	b3 c0                	mov    $0xc0,%bl
c040d79a:	40                   	inc    %eax
c040d79b:	c0 c6 c0             	rol    $0xc0,%dh
c040d79e:	40                   	inc    %eax
c040d79f:	c0 db c0             	rcr    $0xc0,%bl
c040d7a2:	40                   	inc    %eax
c040d7a3:	c0                   	(bad)  
c040d7a4:	f4                   	hlt    
c040d7a5:	c0 40 c0 5b          	rolb   $0x5b,-0x40(%eax)
c040d7a9:	63 6f 72             	arpl   %bp,0x72(%edi)
c040d7ac:	65                   	gs
c040d7ad:	5d                   	pop    %ebp
c040d7ae:	20 4e 6f             	and    %cl,0x6f(%esi)
c040d7b1:	77 20                	ja     c040d7d3 <debug_initialise+0x1593>
c040d7b3:	64 65 62 75 67       	bound  %esi,%fs:%gs:0x67(%ebp)
c040d7b8:	67 69 6e 67 20 74 6f 	addr16 imul $0x206f7420,0x67(%bp),%ebp
c040d7bf:	20 
c040d7c0:	73 65                	jae    c040d827 <debug_initialise+0x15e7>
c040d7c2:	72 69                	jb     c040d82d <debug_initialise+0x15ed>
c040d7c4:	61                   	popa   
c040d7c5:	6c                   	insb   (%dx),%es:(%edi)
c040d7c6:	20 70 6f             	and    %dh,0x6f(%eax)
c040d7c9:	72 74                	jb     c040d83f <debug_initialise+0x15ff>
c040d7cb:	2e 0a 00             	or     %cs:(%eax),%al
