/* kernel/ports/i386/include/mmu.h
 * prototypes and structures for the i386 port of the kernel 
 * Author : Chris Williams
 * Date   : Mon,26 Mar 2007.23:09:39

Copyright (c) Chris Williams and individual contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contact: chris@diodesign.co.uk / http://www.diodesign.co.uk/

*/

#ifndef _MMU_H
#define   _MMU_H

/* assumed to be generated by linker script, used by KERNEL_ macros */
extern unsigned int _knlstart, _ebss;

/* defined in start.s */
extern unsigned int KernelPageDirectoryVirtStart;
extern unsigned int KernelPageDirectory;
extern unsigned int KernelGDT, KernelGDTEnd, KernelGDTPtr, TSS_Selector;
extern unsigned int KernelBootStackBase, APStack;

/* the start of our virtual memory at the top 1GB. note: we map as much of
   physical memory into our kernel's virtual space */
#define KERNEL_START         (&_knlstart)
#define KERNEL_END           (&_ebss)
#define KERNEL_SIZE          (KERNEL_END - KERNEL_START)
#define KERNEL_SPACE_BASE    (0xC0000000)
#define KERNEL_PHYSICAL_BASE (0x00400000)
#define KERNEL_PHYSICAL_TOP  (0xffffffff)
#define KERNEL_VIRTUAL_BASE  (KERNEL_SPACE_BASE + KERNEL_PHYSICAL_BASE)
#define KERNEL_VIRTUAL_END   (KERNEL_VIRTUAL_BASE + KERNEL_SIZE)
#define KERNEL_PHYSICAL_END  (KERNEL_PHYSICAL_BASE + KERNEL_SIZE)
#define KERNEL_PHYSICAL_END_ALIGNED (MEM_PGALIGN(KERNEL_PHYSICAL_END + MEM_PGSIZE))
#define KERNEL_LOG2PHYS(a)   ((void *)((unsigned int)(a) - KERNEL_SPACE_BASE))
#define KERNEL_PHYS2LOG(a)   ((void *)((unsigned int)(a) + KERNEL_SPACE_BASE))

/* the ideal location of the initrd image in physical memory */
#define INITRD_LOAD_ADDR      (0x00100000)

/* the kernel is loaded at the 4M mark and the physical page stack
   descends from the 12M mark. these are critical kernel areas */
#define KERNEL_CRITICAL_BASE KERNEL_PHYSICAL_BASE
#define KERNEL_CRITICAL_END  MEM_PHYS_STACK_BASE

#define MEM_PGSIZE           (4 * 1024)
#define MEM_4M_PGSIZE        (4 * 1024 * 1024)
#define MEM_PGSHIFT          (12)
#define MEM_PGMASK           ((1 << MEM_PGSHIFT) - 1)
#define MEM_PGALIGN(a)       ((void *)((unsigned int)(a) & ~MEM_PGMASK))
#define MEM_PHYS_STACK_BASE  (12 * 1024 * 1024)
#define MEM_DMA_REGION_MARK  (16 * 1024 * 1024)
#define MEM_HIGH_PG          (2)
#define MEM_ANY_PG           (1)
#define MEM_LOW_PG           (0)

/* MEM_CLIP(base, size) - return size clipped to base+size =< KERNEL_PHYSICAL_TOP */
#define MEM_CLIP(a, b)       ( (unsigned int)(b) > (KERNEL_PHYSICAL_TOP - (unsigned int)(a)) ? (KERNEL_PHYSICAL_TOP - (unsigned int)(a)) : (b) )
/* MEM_IS_PG_ALIGNED(a) - return 1 for a page-aligned address or 0 for not */
#define MEM_IS_PG_ALIGNED(a) ( ((unsigned int)(a) & PG_4K_MASK) == (unsigned int)(a) ? 1 : 0 )
/* MEM_PG_ROUND_UP - round up to the nearest page-aligned address */
#define MEM_PG_ROUND_UP(a)   ( ((unsigned int)(a) + MEM_PGSIZE) & ~(MEM_PGMASK) )

/* paging */
/* page fault codes */
#define PG_FAULT_P    (1<<0)  /* 0 = not present,   1 = access violation */
#define PG_FAULT_W    (1<<1)  /* 0 = tried to read, 1 = tried to write */
#define PG_FAULT_U    (1<<2)  /* 0 = in svc mode,   1 = in usr mode */
#define PG_FAULT_R    (1<<3)  /* 1 = reserved bits set in dir entry */
#define PG_FAULT_I    (1<<4)  /* 0 = not instruction fetch, 1 = instr fetch */

/* intel-specific page flags (see 3-25 pg 87) */
#define PG_PRESENT    (1<<0)  /* page present in memory */
#define PG_RW         (1<<1)  /* set for read+write, clear for read only */
#define PG_PRIVLVL    (1<<2)  /* set for usr, clear for knl */
#define PG_WRITETHRU  (1<<3)  /* enable write-through caching when set */
#define PG_CACHEDIS   (1<<4)  /* don't cache when set */
#define PG_ACCESSED   (1<<5)  /* page has been read from or written to */
#define PG_DIRTY      (1<<6)  /* page has been written to */
#define PG_SIZE       (1<<7)  /* set for 4MB page dir entries, 4KB otherwise */
#define PG_GLOBAL     (1<<8)  /* set to map in globally */

#define PG_EXTERNAL   (1<<9)  /* set to bump the page manager on fault, unset to use the vma's setting */
#define PG_PRIVATE    (1<<10) /* set to indicate this page is private to the process and can be released */

#define PG_DIR_BASE   (22)    /* physical addr in bits 22-31 */
#define PG_TBL_BASE   (12)    /* table index in bits 12-21 */
#define PG_TBL_MASK   (~((4 * 1024) - 1))
#define PG_INDEX_MASK (1023)  /* 10 bits set */

#define PG_4M_MASK    (~((4 * 1024 * 1024) - 1))
#define PG_4K_MASK    (~((4 * 1024       ) - 1))

/* define the default page bit settings for the payload */
#define PG_PAYLOAD_DEFAULT_FLAGS (PG_PRESENT | PG_PRIVLVL)

void pg_init(void);
void pg_dump_pagedir(unsigned int *pgdir);
kresult pg_new_process(process *new, process *current);
kresult pg_destroy_process(process *victim);
kresult pg_add_4K_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, unsigned int flags);
kresult pg_add_4M_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int physical, unsigned int flags);
kresult pg_fault(int_registers_block *regs);
kresult pg_preempt_fault(thread *test, unsigned int virtualaddr, unsigned int size, unsigned int flags);
kresult pg_do_fault(thread *target, unsigned int addr, unsigned int cpuflags);
void pg_postmortem(int_registers_block *regs);
kresult pg_user2phys(unsigned int *paddr, unsigned int **pgdir, unsigned int vaddr);
kresult pg_user2kernel(unsigned int *kaddr, unsigned int uaddr, process *proc);
kresult pg_remove_4K_mapping(unsigned int **pgdir, unsigned int virtual, unsigned int release_flag);

#endif
