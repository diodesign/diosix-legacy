/* user/lib/newlib/libgloss/libnosys/vfs.c
 * library functions to send and receive generic data via the vfs
 * Author : Chris Williams
 * Date   : Thurs,09 Dec 2009.04:45:00

Copyright (c) Chris Williams and individual contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Contact: chris@diodesign.co.uk / http://www.diodesign.co.uk/

*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "diosix.h"
#include "functions.h"
#include "roles.h"
#include "io.h"

/* store open files in a hash table of fs associations */
#define DIOSIX_OPEN_FILES_HASH_MAX  (10)
#define DIOSIX_OPEN_FILES_HASH(a)   ((unsigned int)(a) % DIOSIX_OPEN_FILES_HASH_MAX)

/* hash table of a process's open file handles */
diosix_vfs_handle_assoc *diosix_open_files[DIOSIX_OPEN_FILES_HASH_MAX];
unsigned int diosix_open_files_lock;


/* ----------------------------------------------------
   send a request to the vfs / fs system
   ------------------------------------------------- */

/* diosix_vfs_new_req
   Craft a new request to the vfs or one of its fses
   => array = pointer to multipart array that the vfs
              message will be constructed out of.
              The first element is the request header,
              the second the request information. Further
              elements will be relevant to the specific
              request type.
      type = vfs request type
      head = pointer to structure holding the request's header
      request = pointer to the request description structure.
                if the pointer is null, then no description
                structure set up occurs.
      size = size of the request description structure
   <= returns 0 for success, or an error code
*/
kresult diosix_vfs_new_req(diosix_msg_multipart *array,
                           diosix_vfs_req_type type,
                           diosix_vfs_request_head *head,
                           void *request, unsigned int size)
{
   /* sanity checks */
   if(!array || !head) return e_bad_params;

   head->type = type;
   head->magic = VFS_MSG_MAGIC;
   DIOSIX_WRITE_MULTIPART(array, VFS_REQ_HEADER, head, sizeof(diosix_vfs_request_head));
   
   if(request)
   {
      /* check the size is sane */
      if(!size) return e_bad_params;
      
      DIOSIX_WRITE_MULTIPART(array, VFS_REQ_REQUEST, request, size);
   }
   
   return success;
}

/* diosix_vfs_send_req
   Fill out all the details to send a vfs/fs request message
   and perform the send to the vfs process. This function
   will block until the vfs or an fs completes the action or wants
   to return an error.
   => target_pid = PID of the process to send the request to.
                   Set to 0 to send to the vfs, required if the request
                   involves a pathname. If the request involves a file handle
                   generated by the vfs then set the target_pid to the FS's 
                   PID so that the FS process can handle the request directly.
                   If this is set to the VFS's PID then the VFS will fwd on the request. 
      msg = message structure to send
      parts = pointer to multiparts array of request's contents
      parts_count = number of parts in the array
      reply = pointer to structure in which the reply will be stored
      reply_size = size of the reply-holding structure
   <= 0 for success, or an error code
*/
kresult diosix_vfs_send_req(unsigned int target_pid, diosix_msg_info *msg,
                            diosix_msg_multipart *parts,
                            unsigned int parts_count,
                            void *reply, unsigned int reply_size)
{
   /* sanity check */
   if(!msg || !parts || !parts_count || !reply || !reply_size)
      return e_bad_params;

   /* determine the target of the message */
   if(target_pid)
   {
      /* create a message for a FS process */
      msg->pid   = target_pid;
      msg->role  = DIOSIX_ROLE_NONE;
   }
   else
   {
      /* fill out all the details to send a message to the vfs */
      msg->pid   = DIOSIX_MSG_ANY_PROCESS;
      msg->role  = DIOSIX_ROLE_VFS;
   }
    
   /* fill out the rest of the message structure */
   msg->tid   = DIOSIX_MSG_ANY_THREAD;
   msg->flags = DIOSIX_MSG_GENERIC | DIOSIX_MSG_QUEUEME | DIOSIX_MSG_MULTIPART | DIOSIX_MSG_SENDASUSR;
   msg->send  = parts;
   msg->send_size = parts_count;
   msg->recv  = reply;
   msg->recv_max_size = reply_size;
   
   /* send the message */
   return diosix_msg_send(msg);
}


/* ----------------------------------------------------
   register a process as a filesystem/device
   ------------------------------------------------- */

/* diosix_vfs_register
   Register a process as one capable of providing a
   filesystem or a device within the vfs's namespace.
   => path = filesystem or device's root path
   <= 0 for success, or an error code
*/
kresult diosix_vfs_register(char *path)
{
   /* structures to hold the message for the vfs */
   diosix_msg_info msg;
   diosix_msg_multipart req[VFS_REGISTER_PARTS];
   diosix_vfs_request_head head;
   diosix_vfs_request_register descr;
   diosix_vfs_reply reply;
   kresult err;
   
   /* sanity check */
   if(!path) return e_bad_params;
   
   /* craft a request to the vfs to register as a filesystem or device */
   descr.length = strlen(path) + sizeof(unsigned char);
   diosix_vfs_new_req(req, register_req, &head, &descr,
                      sizeof(diosix_vfs_request_register));
   
   /* add an entry into the multipart array to point to
      the root path to register */
   DIOSIX_WRITE_MULTIPART(req, VFS_MSG_REGISTER_PATH, path,
                          descr.length);
   
   /* create the rest of the message and send */
   err = diosix_vfs_send_req(0, &msg, req, VFS_REGISTER_PARTS,
                             &reply, sizeof(diosix_vfs_reply));
   
   if(err) return err;
   return reply.result;
}

/* diosix_vfs_deregister
   Deregister a process previously registered to handle
   part of the vfs's filespace.
   => path = filesystem or device's root path
   <= 0 for success, or an error code
*/
kresult diosix_vfs_deregister(char *path)
{
   /* structures to hold the message for the vfs.
      this code is the same as registering except it
      sends a deregister_req message */
   diosix_msg_info msg;
   diosix_msg_multipart req[VFS_REGISTER_PARTS];
   diosix_vfs_request_head head;
   diosix_vfs_request_register descr;
   diosix_vfs_reply reply;
   kresult err;
   
   /* sanity check */
   if(!path) return e_bad_params;
   
   /* craft a request to the vfs to register as a filesystem or device */
   descr.length = strlen(path) + sizeof(unsigned char);
   diosix_vfs_new_req(req, deregister_req, &head, &descr,
                      sizeof(diosix_vfs_request_register));
   
   /* add an entry into the multipart array to point to
    the root path to deregister */
   DIOSIX_WRITE_MULTIPART(req, VFS_MSG_REGISTER_PATH, path,
                          descr.length);
   
   /* create the rest of the message and send */
   err = diosix_vfs_send_req(0, &msg, req, VFS_REGISTER_PARTS,
                             &reply, sizeof(diosix_vfs_reply));
   
   if(err) return err;
   return reply.result;
}


/* ----------------------------------------------------
   associate a file handle with a fs process
   ------------------------------------------------- */

/* diosix_vfs_associate_handle
   Associate a filehandle with a given fs process PID
   so that messages can be directly routed at the fs
   process managing the file.
   => filehandle = handle to associate with the fs pid
      pid = pid of the fs process
*/
void diosix_vfs_associate_handle(int filehandle, unsigned int pid)
{
   diosix_vfs_handle_assoc *new_assoc, *hash_head;
   unsigned int hash_slot = DIOSIX_OPEN_FILES_HASH(filehandle);
   
   /* sanity check */
   if(!pid || filehandle < 0) return;

   /* create a new association */
   new_assoc = malloc(sizeof(diosix_vfs_handle_assoc));
   if(!new_assoc) return;
   memset(new_assoc, 0, sizeof(diosix_vfs_handle_assoc));
   
   new_assoc->filedesc = filehandle;
   new_assoc->pid = pid;
   
   /* critical section - make thread safe */
   DIOSIX_SPINLOCK_ACQUIRE(&diosix_open_files_lock);
   
   /* add to the head of the hash table slot */
   hash_head = diosix_open_files[hash_slot];
   
   if(hash_head)
   {
      hash_head->prev = new_assoc;
      new_assoc->next = hash_head;
   }
   
   diosix_open_files[hash_slot] = new_assoc;
   
   /* end critical section */
   DIOSIX_SPINLOCK_RELEASE(&diosix_open_files_lock);
}

/* diosix_vfs_disassociate_handle
   Remove an association between a file handle and a fs pid
   => filehandle = handle to disassociate
*/
void diosix_vfs_disassociate_handle(int filehandle)
{
   diosix_vfs_handle_assoc *victim;
   unsigned int hash_slot = DIOSIX_OPEN_FILES_HASH(filehandle);
   
   /* sanity check */
   if(filehandle < 0) return;
   
   /* critical section - make thread safe */
   DIOSIX_SPINLOCK_ACQUIRE(&diosix_open_files_lock);
   
   victim = diosix_open_files[hash_slot];
   while(victim)
   {
      if(victim->filedesc == filehandle) break;
      victim = victim->next;
   }

   /* if victim is set then we've got correct association structure */
   if(victim)
   {
      /* remove from the hash table */
      if(victim->next)
         victim->next->prev = victim->prev;
      if(victim->prev)
         victim->prev->next = victim->next;
      else
         /* we were the hash table entry head, so fixup table */
         diosix_open_files[hash_slot] = victim->next;
      
      /* return the memory it held */
      free(victim);
   }
   
   /* end critical section */
   DIOSIX_SPINLOCK_RELEASE(&diosix_open_files_lock);
}

/* diosix_vfs_get_fs
   Look up filesystem process PID from an associated
   file handle.
   => filehandle = handle to find the association for
   <= pid of the fs or 0 if the handle is invalid */
unsigned int diosix_vfs_get_fs(int filehandle)
{
   unsigned int pid;
   diosix_vfs_handle_assoc *search;
   unsigned int hash_slot = DIOSIX_OPEN_FILES_HASH(filehandle);
 
   /* sanity check */
   if(filehandle < 0) return 0;
   
   /* critical section - make thread safe */
   DIOSIX_SPINLOCK_ACQUIRE(&diosix_open_files_lock);
   
   search = diosix_open_files[hash_slot];
   while(search)
   {
      if(search->filedesc == filehandle) break;
      search = search->next;
   }
   
   if(search)
      pid = search->pid;
   else
      pid = 0;
   
   /* end critical section */
   DIOSIX_SPINLOCK_RELEASE(&diosix_open_files_lock);
   return pid;
}
